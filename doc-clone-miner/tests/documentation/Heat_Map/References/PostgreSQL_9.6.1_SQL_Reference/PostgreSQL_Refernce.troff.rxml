<?xml version="1.0" encoding="utf-8" ?>
<plainxml>'\" t
.\"     Title: ABORT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ABORT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ABORT \- abort the current transaction
.SH "SYNOPSIS"
.sp
.nf
ABORT [ WORK | TRANSACTION ]
.fi
.SH "DESCRIPTION"
.PP
\fBABORT\fR
rolls back the current transaction and causes all the updates made by the transaction to be discarded\&amp;. This command is identical in behavior to the standard
SQL
command
\fBROLLBACK\fR(7), and is present only for historical reasons\&amp;.
.SH "PARAMETERS"
.PP
WORK
.br
TRANSACTION
.RS 4
Optional key words\&amp;. They have no effect\&amp;.
.RE
.SH "NOTES"
.PP
Use
\fBCOMMIT\fR(7)
to successfully terminate a transaction\&amp;.
.PP
Issuing
\fBABORT\fR
outside of a transaction block emits a warning and otherwise has no effect\&amp;.
.SH "EXAMPLES"
.PP
To abort all changes:
.sp
.if n \{\
.RS 4
.\}
.nf
ABORT;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command is a
PostgreSQL
extension present for historical reasons\&amp;.
\fBROLLBACK\fR
is the equivalent standard SQL command\&amp;.
.SH "SEE ALSO"
\fBBEGIN\fR(7), \fBCOMMIT\fR(7), \fBROLLBACK\fR(7)
'\" t
.\"     Title: ALTER AGGREGATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER AGGREGATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_AGGREGATE \- change the definition of an aggregate function
.SH "SYNOPSIS"
.sp
.nf
ALTER AGGREGATE \fIname\fR ( \fIaggregate_signature\fR ) RENAME TO \fInew_name\fR
ALTER AGGREGATE \fIname\fR ( \fIaggregate_signature\fR )
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER AGGREGATE \fIname\fR ( \fIaggregate_signature\fR ) SET SCHEMA \fInew_schema\fR

where \fIaggregate_signature\fR is:

* |
[ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] |
[ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] ] ORDER BY [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ]
.fi
.SH "DESCRIPTION"
.PP
\fBALTER AGGREGATE\fR
changes the definition of an aggregate function\&amp;.
.PP
You must own the aggregate function to use
\fBALTER AGGREGATE\fR\&amp;. To change the schema of an aggregate function, you must also have
CREATE
privilege on the new schema\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the aggregate function\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the aggregate function\&amp;. However, a superuser can alter ownership of any aggregate function anyway\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing aggregate function\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of an argument:
IN
or
VARIADIC\&amp;. If omitted, the default is
IN\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of an argument\&amp;. Note that
\fBALTER AGGREGATE\fR
does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function\*(Aqs identity\&amp;.
.RE
.PP
\fIargtype\fR
.RS 4
An input data type on which the aggregate function operates\&amp;. To reference a zero\-argument aggregate function, write
*
in place of the list of argument specifications\&amp;. To reference an ordered\-set aggregate function, write
ORDER BY
between the direct and aggregated argument specifications\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the aggregate function\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the aggregate function\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the aggregate function\&amp;.
.RE
.SH "NOTES"
.PP
The recommended syntax for referencing an ordered\-set aggregate is to write
ORDER BY
between the direct and aggregated argument specifications, in the same style as in
CREATE AGGREGATE (\fBCREATE_AGGREGATE\fR(7))\&amp;. However, it will also work to omit
ORDER BY
and just run the direct and aggregated argument specifications into a single list\&amp;. In this abbreviated form, if
VARIADIC "any"
was used in both the direct and aggregated argument lists, write
VARIADIC "any"
only once\&amp;.
.SH "EXAMPLES"
.PP
To rename the aggregate function
myavg
for type
integer
to
my_average:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER AGGREGATE myavg(integer) RENAME TO my_average;
.fi
.if n \{\
.RE
.\}
.PP
To change the owner of the aggregate function
myavg
for type
integer
to
joe:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER AGGREGATE myavg(integer) OWNER TO joe;
.fi
.if n \{\
.RE
.\}
.PP
To move the ordered\-set aggregate
mypercentile
with direct argument of type
float8
and aggregated argument of type
integer
into schema
myschema:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER AGGREGATE mypercentile(float8 ORDER BY integer) SET SCHEMA myschema;
.fi
.if n \{\
.RE
.\}
.sp
This will work too:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER AGGREGATE mypercentile(float8, integer) SET SCHEMA myschema;
.fi
.if n \{\
.RE
.\}
.sp
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER AGGREGATE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE AGGREGATE (\fBCREATE_AGGREGATE\fR(7)), DROP AGGREGATE (\fBDROP_AGGREGATE\fR(7))
'\" t
.\"     Title: ALTER COLLATION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER COLLATION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_COLLATION \- change the definition of a collation
.SH "SYNOPSIS"
.sp
.nf
ALTER COLLATION \fIname\fR RENAME TO \fInew_name\fR
ALTER COLLATION \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER COLLATION \fIname\fR SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER COLLATION\fR
changes the definition of a collation\&amp;.
.PP
You must own the collation to use
\fBALTER COLLATION\fR\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the collation\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the collation\&amp;. However, a superuser can alter ownership of any collation anyway\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing collation\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the collation\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the collation\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the collation\&amp;.
.RE
.SH "EXAMPLES"
.PP
To rename the collation
de_DE
to
german:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER COLLATION "de_DE" RENAME TO german;
.fi
.if n \{\
.RE
.\}
.PP
To change the owner of the collation
en_US
to
joe:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER COLLATION "en_US" OWNER TO joe;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER COLLATION\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE COLLATION (\fBCREATE_COLLATION\fR(7)), DROP COLLATION (\fBDROP_COLLATION\fR(7))
'\" t
.\"     Title: ALTER CONVERSION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER CONVERSION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_CONVERSION \- change the definition of a conversion
.SH "SYNOPSIS"
.sp
.nf
ALTER CONVERSION \fIname\fR RENAME TO \fInew_name\fR
ALTER CONVERSION \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER CONVERSION \fIname\fR SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER CONVERSION\fR
changes the definition of a conversion\&amp;.
.PP
You must own the conversion to use
\fBALTER CONVERSION\fR\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the conversion\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the conversion\&amp;. However, a superuser can alter ownership of any conversion anyway\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing conversion\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the conversion\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the conversion\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the conversion\&amp;.
.RE
.SH "EXAMPLES"
.PP
To rename the conversion
iso_8859_1_to_utf8
to
latin1_to_unicode:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER CONVERSION iso_8859_1_to_utf8 RENAME TO latin1_to_unicode;
.fi
.if n \{\
.RE
.\}
.PP
To change the owner of the conversion
iso_8859_1_to_utf8
to
joe:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER CONVERSION iso_8859_1_to_utf8 OWNER TO joe;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER CONVERSION\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE CONVERSION (\fBCREATE_CONVERSION\fR(7)), DROP CONVERSION (\fBDROP_CONVERSION\fR(7))
'\" t
.\"     Title: ALTER DATABASE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER DATABASE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_DATABASE \- change a database
.SH "SYNOPSIS"
.sp
.nf
ALTER DATABASE \fIname\fR [ [ WITH ] \fIoption\fR [ \&amp;.\&amp;.\&amp;. ] ]

where \fIoption\fR can be:

ALLOW_CONNECTIONS \fIallowconn\fR
CONNECTION LIMIT \fIconnlimit\fR
IS_TEMPLATE \fIistemplate\fR

ALTER DATABASE \fIname\fR RENAME TO \fInew_name\fR

ALTER DATABASE \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }

ALTER DATABASE \fIname\fR SET TABLESPACE \fInew_tablespace\fR

ALTER DATABASE \fIname\fR SET \fIconfiguration_parameter\fR { TO | = } { \fIvalue\fR | DEFAULT }
ALTER DATABASE \fIname\fR SET \fIconfiguration_parameter\fR FROM CURRENT
ALTER DATABASE \fIname\fR RESET \fIconfiguration_parameter\fR
ALTER DATABASE \fIname\fR RESET ALL
.fi
.SH "DESCRIPTION"
.PP
\fBALTER DATABASE\fR
changes the attributes of a database\&amp;.
.PP
The first form changes certain per\-database settings\&amp;. (See below for details\&amp;.) Only the database owner or a superuser can change these settings\&amp;.
.PP
The second form changes the name of the database\&amp;. Only the database owner or a superuser can rename a database; non\-superuser owners must also have the
CREATEDB
privilege\&amp;. The current database cannot be renamed\&amp;. (Connect to a different database if you need to do that\&amp;.)
.PP
The third form changes the owner of the database\&amp;. To alter the owner, you must own the database and also be a direct or indirect member of the new owning role, and you must have the
CREATEDB
privilege\&amp;. (Note that superusers have all these privileges automatically\&amp;.)
.PP
The fourth form changes the default tablespace of the database\&amp;. Only the database owner or a superuser can do this; you must also have create privilege for the new tablespace\&amp;. This command physically moves any tables or indexes in the database\*(Aqs old default tablespace to the new tablespace\&amp;. The new default tablespace must be empty for this database, and no one can be connected to the database\&amp;. Tables and indexes in non\-default tablespaces are unaffected\&amp;.
.PP
The remaining forms change the session default for a run\-time configuration variable for a
PostgreSQL
database\&amp;. Whenever a new session is subsequently started in that database, the specified value becomes the session default value\&amp;. The database\-specific default overrides whatever setting is present in
postgresql\&amp;.conf
or has been received from the
\fBpostgres\fR
command line\&amp;. Only the database owner or a superuser can change the session defaults for a database\&amp;. Certain variables cannot be set this way, or can only be set by a superuser\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the database whose attributes are to be altered\&amp;.
.RE
.PP
\fIallowconn\fR
.RS 4
If false then no one can connect to this database\&amp;.
.RE
.PP
\fIconnlimit\fR
.RS 4
How many concurrent connections can be made to this database\&amp;. \-1 means no limit\&amp;.
.RE
.PP
\fIistemplate\fR
.RS 4
If true, then this database can be cloned by any user with
CREATEDB
privileges; if false, then only superusers or the owner of the database can clone it\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the database\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the database\&amp;.
.RE
.PP
\fInew_tablespace\fR
.RS 4
The new default tablespace of the database\&amp;.
.RE
.PP
\fIconfiguration_parameter\fR
.br
\fIvalue\fR
.RS 4
Set this database\*(Aqs session default for the specified configuration parameter to the given value\&amp;. If
\fIvalue\fR
is
DEFAULT
or, equivalently,
RESET
is used, the database\-specific setting is removed, so the system\-wide default setting will be inherited in new sessions\&amp;. Use
RESET ALL
to clear all database\-specific settings\&amp;.
SET FROM CURRENT
saves the session\*(Aqs current value of the parameter as the database\-specific value\&amp;.
.sp
See
\fBSET\fR(7)
and
Chapter 19, Server Configuration, in the documentation
for more information about allowed parameter names and values\&amp;.
.RE
.SH "NOTES"
.PP
It is also possible to tie a session default to a specific role rather than to a database; see
ALTER ROLE (\fBALTER_ROLE\fR(7))\&amp;. Role\-specific settings override database\-specific ones if there is a conflict\&amp;.
.SH "EXAMPLES"
.PP
To disable index scans by default in the database
test:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DATABASE test SET enable_indexscan TO off;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBALTER DATABASE\fR
statement is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE DATABASE (\fBCREATE_DATABASE\fR(7)), DROP DATABASE (\fBDROP_DATABASE\fR(7)), \fBSET\fR(7), CREATE TABLESPACE (\fBCREATE_TABLESPACE\fR(7))
'\" t
.\"     Title: ALTER DEFAULT PRIVILEGES
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER DEFAULT PRIVILEGES" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_DEFAULT_PRIVILEGES \- define default access privileges
.SH "SYNOPSIS"
.sp
.nf
ALTER DEFAULT PRIVILEGES
[ FOR { ROLE | USER } \fItarget_role\fR [, \&amp;.\&amp;.\&amp;.] ]
[ IN SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.] ]
\fIabbreviated_grant_or_revoke\fR

where \fIabbreviated_grant_or_revoke\fR is one of:

GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON TABLES
TO { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { { USAGE | SELECT | UPDATE }
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON SEQUENCES
TO { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { EXECUTE | ALL [ PRIVILEGES ] }
ON FUNCTIONS
TO { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
ON TYPES
TO { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

REVOKE [ GRANT OPTION FOR ]
{ { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON TABLES
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ { USAGE | SELECT | UPDATE }
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON SEQUENCES
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ EXECUTE | ALL [ PRIVILEGES ] }
ON FUNCTIONS
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ USAGE | ALL [ PRIVILEGES ] }
ON TYPES
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBALTER DEFAULT PRIVILEGES\fR
allows you to set the privileges that will be applied to objects created in the future\&amp;. (It does not affect privileges assigned to already\-existing objects\&amp;.) Currently, only the privileges for tables (including views and foreign tables), sequences, functions, and types (including domains) can be altered\&amp;.
.PP
You can change default privileges only for objects that will be created by yourself or by roles that you are a member of\&amp;. The privileges can be set globally (i\&amp;.e\&amp;., for all objects created in the current database), or just for objects created in specified schemas\&amp;. Default privileges that are specified per\-schema are added to whatever the global default privileges are for the particular object type\&amp;.
.PP
As explained under
\fBGRANT\fR(7), the default privileges for any object type normally grant all grantable permissions to the object owner, and may grant some privileges to
PUBLIC
as well\&amp;. However, this behavior can be changed by altering the global default privileges with
\fBALTER DEFAULT PRIVILEGES\fR\&amp;.
.SS "Parameters"
.PP
\fItarget_role\fR
.RS 4
The name of an existing role of which the current role is a member\&amp;. If
FOR ROLE
is omitted, the current role is assumed\&amp;.
.RE
.PP
\fIschema_name\fR
.RS 4
The name of an existing schema\&amp;. If specified, the default privileges are altered for objects later created in that schema\&amp;. If
IN SCHEMA
is omitted, the global default privileges are altered\&amp;.
.RE
.PP
\fIrole_name\fR
.RS 4
The name of an existing role to grant or revoke privileges for\&amp;. This parameter, and all the other parameters in
\fIabbreviated_grant_or_revoke\fR, act as described under
\fBGRANT\fR(7)
or
\fBREVOKE\fR(7), except that one is setting permissions for a whole class of objects rather than specific named objects\&amp;.
.RE
.SH "NOTES"
.PP
Use
\fBpsql\fR(1)\*(Aqs
\fB\eddp\fR
command to obtain information about existing assignments of default privileges\&amp;. The meaning of the privilege values is the same as explained for
\fB\edp\fR
under
\fBGRANT\fR(7)\&amp;.
.PP
If you wish to drop a role for which the default privileges have been altered, it is necessary to reverse the changes in its default privileges or use
\fBDROP OWNED BY\fR
to get rid of the default privileges entry for the role\&amp;.
.SH "EXAMPLES"
.PP
Grant SELECT privilege to everyone for all tables (and views) you subsequently create in schema
myschema, and allow role
webuser
to INSERT into them too:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT ON TABLES TO PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT INSERT ON TABLES TO webuser;
.fi
.if n \{\
.RE
.\}
.PP
Undo the above, so that subsequently\-created tables won\*(Aqt have any more permissions than normal:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema REVOKE SELECT ON TABLES FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema REVOKE INSERT ON TABLES FROM webuser;
.fi
.if n \{\
.RE
.\}
.PP
Remove the public EXECUTE permission that is normally granted on functions, for all functions subsequently created by role
admin:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DEFAULT PRIVILEGES FOR ROLE admin REVOKE EXECUTE ON FUNCTIONS FROM PUBLIC;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER DEFAULT PRIVILEGES\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBGRANT\fR(7), \fBREVOKE\fR(7)
'\" t
.\"     Title: ALTER DOMAIN
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER DOMAIN" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_DOMAIN \- change the definition of a domain
.SH "SYNOPSIS"
.sp
.nf
ALTER DOMAIN \fIname\fR
{ SET DEFAULT \fIexpression\fR | DROP DEFAULT }
ALTER DOMAIN \fIname\fR
{ SET | DROP } NOT NULL
ALTER DOMAIN \fIname\fR
ADD \fIdomain_constraint\fR [ NOT VALID ]
ALTER DOMAIN \fIname\fR
DROP CONSTRAINT [ IF EXISTS ] \fIconstraint_name\fR [ RESTRICT | CASCADE ]
ALTER DOMAIN \fIname\fR
RENAME CONSTRAINT \fIconstraint_name\fR TO \fInew_constraint_name\fR
ALTER DOMAIN \fIname\fR
VALIDATE CONSTRAINT \fIconstraint_name\fR
ALTER DOMAIN \fIname\fR
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER DOMAIN \fIname\fR
RENAME TO \fInew_name\fR
ALTER DOMAIN \fIname\fR
SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER DOMAIN\fR
changes the definition of an existing domain\&amp;. There are several sub\-forms:
.PP
SET/DROP DEFAULT
.RS 4
These forms set or remove the default value for a domain\&amp;. Note that defaults only apply to subsequent
\fBINSERT\fR
commands; they do not affect rows already in a table using the domain\&amp;.
.RE
.PP
SET/DROP NOT NULL
.RS 4
These forms change whether a domain is marked to allow NULL values or to reject NULL values\&amp;. You can only
SET NOT NULL
when the columns using the domain contain no null values\&amp;.
.RE
.PP
ADD \fIdomain_constraint\fR [ NOT VALID ]
.RS 4
This form adds a new constraint to a domain using the same syntax as
CREATE DOMAIN (\fBCREATE_DOMAIN\fR(7))\&amp;. When a new constraint is added to a domain, all columns using that domain will be checked against the newly added constraint\&amp;. These checks can be suppressed by adding the new constraint using the
NOT VALID
option; the constraint can later be made valid using
\fBALTER DOMAIN \&amp;.\&amp;.\&amp;. VALIDATE CONSTRAINT\fR\&amp;. Newly inserted or updated rows are always checked against all constraints, even those marked
NOT VALID\&amp;.
NOT VALID
is only accepted for
CHECK
constraints\&amp;.
.RE
.PP
DROP CONSTRAINT [ IF EXISTS ]
.RS 4
This form drops constraints on a domain\&amp;. If
IF EXISTS
is specified and the constraint does not exist, no error is thrown\&amp;. In this case a notice is issued instead\&amp;.
.RE
.PP
RENAME CONSTRAINT
.RS 4
This form changes the name of a constraint on a domain\&amp;.
.RE
.PP
VALIDATE CONSTRAINT
.RS 4
This form validates a constraint previously added as
NOT VALID, that is, verify that all data in columns using the domain satisfy the specified constraint\&amp;.
.RE
.PP
OWNER
.RS 4
This form changes the owner of the domain to the specified user\&amp;.
.RE
.PP
RENAME
.RS 4
This form changes the name of the domain\&amp;.
.RE
.PP
SET SCHEMA
.RS 4
This form changes the schema of the domain\&amp;. Any constraints associated with the domain are moved into the new schema as well\&amp;.
.RE
.PP
You must own the domain to use
\fBALTER DOMAIN\fR\&amp;. To change the schema of a domain, you must also have
CREATE
privilege on the new schema\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the domain\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the domain\&amp;. However, a superuser can alter ownership of any domain anyway\&amp;.)
.SH "PARAMETERS"
.PP
.PP
\fIname\fR
.RS 4
The name (possibly schema\-qualified) of an existing domain to alter\&amp;.
.RE
.PP
\fIdomain_constraint\fR
.RS 4
New domain constraint for the domain\&amp;.
.RE
.PP
\fIconstraint_name\fR
.RS 4
Name of an existing constraint to drop or rename\&amp;.
.RE
.PP
\fINOT VALID\fR
.RS 4
Do not verify existing column data for constraint validity\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the constraint, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the constraint if there are any dependent objects\&amp;. This is the default behavior\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the domain\&amp;.
.RE
.PP
\fInew_constraint_name\fR
.RS 4
The new name for the constraint\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the domain\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the domain\&amp;.
.RE
.SH "NOTES"
.PP
Currently,
\fBALTER DOMAIN ADD CONSTRAINT\fR,
\fBALTER DOMAIN VALIDATE CONSTRAINT\fR, and
\fBALTER DOMAIN SET NOT NULL\fR
will fail if the validated named domain or any derived domain is used within a composite\-type column of any table in the database\&amp;. They should eventually be improved to be able to verify the new constraint for such nested columns\&amp;.
.SH "EXAMPLES"
.PP
To add a
NOT NULL
constraint to a domain:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DOMAIN zipcode SET NOT NULL;
.fi
.if n \{\
.RE
.\}
.sp
To remove a
NOT NULL
constraint from a domain:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DOMAIN zipcode DROP NOT NULL;
.fi
.if n \{\
.RE
.\}
.PP
To add a check constraint to a domain:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DOMAIN zipcode ADD CONSTRAINT zipchk CHECK (char_length(VALUE) = 5);
.fi
.if n \{\
.RE
.\}
.PP
To remove a check constraint from a domain:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DOMAIN zipcode DROP CONSTRAINT zipchk;
.fi
.if n \{\
.RE
.\}
.PP
To rename a check constraint on a domain:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DOMAIN zipcode RENAME CONSTRAINT zipchk TO zip_check;
.fi
.if n \{\
.RE
.\}
.PP
To move the domain into a different schema:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER DOMAIN zipcode SET SCHEMA customers;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER DOMAIN\fR
conforms to the
SQL
standard, except for the
OWNER,
RENAME,
SET SCHEMA, and
VALIDATE CONSTRAINT
variants, which are
PostgreSQL
extensions\&amp;. The
NOT VALID
clause of the
ADD CONSTRAINT
variant is also a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE DOMAIN (\fBCREATE_DOMAIN\fR(7)), DROP DOMAIN (\fBDROP_DOMAIN\fR(7))
'\" t
.\"     Title: ALTER EVENT TRIGGER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER EVENT TRIGGER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_EVENT_TRIGGER \- change the definition of an event trigger
.SH "SYNOPSIS"
.sp
.nf
ALTER EVENT TRIGGER \fIname\fR DISABLE
ALTER EVENT TRIGGER \fIname\fR ENABLE [ REPLICA | ALWAYS ]
ALTER EVENT TRIGGER \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER EVENT TRIGGER \fIname\fR RENAME TO \fInew_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER EVENT TRIGGER\fR
changes properties of an existing event trigger\&amp;.
.PP
You must be superuser to alter an event trigger\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an existing trigger to alter\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the event trigger\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the event trigger\&amp;.
.RE
.PP
DISABLE/ENABLE [ REPLICA | ALWAYS ] TRIGGER
.RS 4
These forms configure the firing of event triggers\&amp;. A disabled trigger is still known to the system, but is not executed when its triggering event occurs\&amp;. See also
session_replication_role\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER EVENT TRIGGER\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE EVENT TRIGGER (\fBCREATE_EVENT_TRIGGER\fR(7)), DROP EVENT TRIGGER (\fBDROP_EVENT_TRIGGER\fR(7))
'\" t
.\"     Title: ALTER EXTENSION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER EXTENSION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_EXTENSION \- change the definition of an extension
.SH "SYNOPSIS"
.sp
.nf
ALTER EXTENSION \fIname\fR UPDATE [ TO \fInew_version\fR ]
ALTER EXTENSION \fIname\fR SET SCHEMA \fInew_schema\fR
ALTER EXTENSION \fIname\fR ADD \fImember_object\fR
ALTER EXTENSION \fIname\fR DROP \fImember_object\fR

where \fImember_object\fR is:

ACCESS METHOD \fIobject_name\fR |
AGGREGATE \fIaggregate_name\fR ( \fIaggregate_signature\fR ) |
CAST (\fIsource_type\fR AS \fItarget_type\fR) |
COLLATION \fIobject_name\fR |
CONVERSION \fIobject_name\fR |
DOMAIN \fIobject_name\fR |
EVENT TRIGGER \fIobject_name\fR |
FOREIGN DATA WRAPPER \fIobject_name\fR |
FOREIGN TABLE \fIobject_name\fR |
FUNCTION \fIfunction_name\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] ) |
MATERIALIZED VIEW \fIobject_name\fR |
OPERATOR \fIoperator_name\fR (\fIleft_type\fR, \fIright_type\fR) |
OPERATOR CLASS \fIobject_name\fR USING \fIindex_method\fR |
OPERATOR FAMILY \fIobject_name\fR USING \fIindex_method\fR |
[ PROCEDURAL ] LANGUAGE \fIobject_name\fR |
SCHEMA \fIobject_name\fR |
SEQUENCE \fIobject_name\fR |
SERVER \fIobject_name\fR |
TABLE \fIobject_name\fR |
TEXT SEARCH CONFIGURATION \fIobject_name\fR |
TEXT SEARCH DICTIONARY \fIobject_name\fR |
TEXT SEARCH PARSER \fIobject_name\fR |
TEXT SEARCH TEMPLATE \fIobject_name\fR |
TRANSFORM FOR \fItype_name\fR LANGUAGE \fIlang_name\fR |
TYPE \fIobject_name\fR |
VIEW \fIobject_name\fR

and \fIaggregate_signature\fR is:

* |
[ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] |
[ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] ] ORDER BY [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ]
.fi
.SH "DESCRIPTION"
.PP
\fBALTER EXTENSION\fR
changes the definition of an installed extension\&amp;. There are several subforms:
.PP
UPDATE
.RS 4
This form updates the extension to a newer version\&amp;. The extension must supply a suitable update script (or series of scripts) that can modify the currently\-installed version into the requested version\&amp;.
.RE
.PP
SET SCHEMA
.RS 4
This form moves the extension\*(Aqs objects into another schema\&amp;. The extension has to be
relocatable
for this command to succeed\&amp;.
.RE
.PP
ADD \fImember_object\fR
.RS 4
This form adds an existing object to the extension\&amp;. This is mainly useful in extension update scripts\&amp;. The object will subsequently be treated as a member of the extension; notably, it can only be dropped by dropping the extension\&amp;.
.RE
.PP
DROP \fImember_object\fR
.RS 4
This form removes a member object from the extension\&amp;. This is mainly useful in extension update scripts\&amp;. The object is not dropped, only disassociated from the extension\&amp;.
.RE
See
Section 36.15, \(lqPackaging Related Objects into an Extension\(rq, in the documentation
for more information about these operations\&amp;.
.PP
You must own the extension to use
\fBALTER EXTENSION\fR\&amp;. The
ADD/DROP
forms require ownership of the added/dropped object as well\&amp;.
.SH "PARAMETERS"
.PP
.PP
\fIname\fR
.RS 4
The name of an installed extension\&amp;.
.RE
.PP
\fInew_version\fR
.RS 4
The desired new version of the extension\&amp;. This can be written as either an identifier or a string literal\&amp;. If not specified,
\fBALTER EXTENSION UPDATE\fR
attempts to update to whatever is shown as the default version in the extension\*(Aqs control file\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the extension\&amp;.
.RE
.PP
\fIobject_name\fR
.br
\fIaggregate_name\fR
.br
\fIfunction_name\fR
.br
\fIoperator_name\fR
.RS 4
The name of an object to be added to or removed from the extension\&amp;. Names of tables, aggregates, domains, foreign tables, functions, operators, operator classes, operator families, sequences, text search objects, types, and views can be schema\-qualified\&amp;.
.RE
.PP
\fIsource_type\fR
.RS 4
The name of the source data type of the cast\&amp;.
.RE
.PP
\fItarget_type\fR
.RS 4
The name of the target data type of the cast\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of a function or aggregate argument:
IN,
OUT,
INOUT, or
VARIADIC\&amp;. If omitted, the default is
IN\&amp;. Note that
\fBALTER EXTENSION\fR
does not actually pay any attention to
OUT
arguments, since only the input arguments are needed to determine the function\*(Aqs identity\&amp;. So it is sufficient to list the
IN,
INOUT, and
VARIADIC
arguments\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of a function or aggregate argument\&amp;. Note that
\fBALTER EXTENSION\fR
does not actually pay any attention to argument names, since only the argument data types are needed to determine the function\*(Aqs identity\&amp;.
.RE
.PP
\fIargtype\fR
.RS 4
The data type of a function or aggregate argument\&amp;.
.RE
.PP
\fIleft_type\fR
.br
\fIright_type\fR
.RS 4
The data type(s) of the operator\*(Aqs arguments (optionally schema\-qualified)\&amp;. Write
NONE
for the missing argument of a prefix or postfix operator\&amp;.
.RE
.PP
PROCEDURAL
.RS 4
This is a noise word\&amp;.
.RE
.PP
\fItype_name\fR
.RS 4
The name of the data type of the transform\&amp;.
.RE
.PP
\fIlang_name\fR
.RS 4
The name of the language of the transform\&amp;.
.RE
.SH "EXAMPLES"
.PP
To update the
hstore
extension to version 2\&amp;.0:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER EXTENSION hstore UPDATE TO \*(Aq2\&amp;.0\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
To change the schema of the
hstore
extension to
utils:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER EXTENSION hstore SET SCHEMA utils;
.fi
.if n \{\
.RE
.\}
.PP
To add an existing function to the
hstore
extension:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER EXTENSION hstore ADD FUNCTION populate_record(anyelement, hstore);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER EXTENSION\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE EXTENSION (\fBCREATE_EXTENSION\fR(7)), DROP EXTENSION (\fBDROP_EXTENSION\fR(7))
'\" t
.\"     Title: ALTER FOREIGN DATA WRAPPER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER FOREIGN DATA WRAPPER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_FOREIGN_DATA_WRAPPER \- change the definition of a foreign\-data wrapper
.SH "SYNOPSIS"
.sp
.nf
ALTER FOREIGN DATA WRAPPER \fIname\fR
[ HANDLER \fIhandler_function\fR | NO HANDLER ]
[ VALIDATOR \fIvalidator_function\fR | NO VALIDATOR ]
[ OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ]) ]
ALTER FOREIGN DATA WRAPPER \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER FOREIGN DATA WRAPPER \fIname\fR RENAME TO \fInew_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER FOREIGN DATA WRAPPER\fR
changes the definition of a foreign\-data wrapper\&amp;. The first form of the command changes the support functions or the generic options of the foreign\-data wrapper (at least one clause is required)\&amp;. The second form changes the owner of the foreign\-data wrapper\&amp;.
.PP
Only superusers can alter foreign\-data wrappers\&amp;. Additionally, only superusers can own foreign\-data wrappers\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an existing foreign\-data wrapper\&amp;.
.RE
.PP
HANDLER \fIhandler_function\fR
.RS 4
Specifies a new handler function for the foreign\-data wrapper\&amp;.
.RE
.PP
NO HANDLER
.RS 4
This is used to specify that the foreign\-data wrapper should no longer have a handler function\&amp;.
.sp
Note that foreign tables that use a foreign\-data wrapper with no handler cannot be accessed\&amp;.
.RE
.PP
VALIDATOR \fIvalidator_function\fR
.RS 4
Specifies a new validator function for the foreign\-data wrapper\&amp;.
.sp
Note that it is possible that pre\-existing options of the foreign\-data wrapper, or of dependent servers, user mappings, or foreign tables, are invalid according to the new validator\&amp;.
PostgreSQL
does not check for this\&amp;. It is up to the user to make sure that these options are correct before using the modified foreign\-data wrapper\&amp;. However, any options specified in this
\fBALTER FOREIGN DATA WRAPPER\fR
command will be checked using the new validator\&amp;.
.RE
.PP
NO VALIDATOR
.RS 4
This is used to specify that the foreign\-data wrapper should no longer have a validator function\&amp;.
.RE
.PP
OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
Change options for the foreign\-data wrapper\&amp;.
ADD,
SET, and
DROP
specify the action to be performed\&amp;.
ADD
is assumed if no operation is explicitly specified\&amp;. Option names must be unique; names and values are also validated using the foreign data wrapper\*(Aqs validator function, if any\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the foreign\-data wrapper\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the foreign\-data wrapper\&amp;.
.RE
.SH "EXAMPLES"
.PP
Change a foreign\-data wrapper
dbi, add option
foo, drop
bar:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FOREIGN DATA WRAPPER dbi OPTIONS (ADD foo \*(Aq1\*(Aq, DROP \*(Aqbar\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
Change the foreign\-data wrapper
dbi
validator to
bob\&amp;.myvalidator:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FOREIGN DATA WRAPPER dbi VALIDATOR bob\&amp;.myvalidator;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER FOREIGN DATA WRAPPER\fR
conforms to ISO/IEC 9075\-9 (SQL/MED), except that the
HANDLER,
VALIDATOR,
OWNER TO, and
RENAME
clauses are extensions\&amp;.
.SH "SEE ALSO"
CREATE FOREIGN DATA WRAPPER (\fBCREATE_FOREIGN_DATA_WRAPPER\fR(7)), DROP FOREIGN DATA WRAPPER (\fBDROP_FOREIGN_DATA_WRAPPER\fR(7))
'\" t
.\"     Title: ALTER FOREIGN TABLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER FOREIGN TABLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_FOREIGN_TABLE \- change the definition of a foreign table
.SH "SYNOPSIS"
.sp
.nf
ALTER FOREIGN TABLE [ IF EXISTS ] [ ONLY ] \fIname\fR [ * ]
\fIaction\fR [, \&amp;.\&amp;.\&amp;. ]
ALTER FOREIGN TABLE [ IF EXISTS ] [ ONLY ] \fIname\fR [ * ]
RENAME [ COLUMN ] \fIcolumn_name\fR TO \fInew_column_name\fR
ALTER FOREIGN TABLE [ IF EXISTS ] \fIname\fR
RENAME TO \fInew_name\fR
ALTER FOREIGN TABLE [ IF EXISTS ] \fIname\fR
SET SCHEMA \fInew_schema\fR

where \fIaction\fR is one of:

ADD [ COLUMN ] \fIcolumn_name\fR \fIdata_type\fR [ COLLATE \fIcollation\fR ] [ \fIcolumn_constraint\fR [ \&amp;.\&amp;.\&amp;. ] ]
DROP [ COLUMN ] [ IF EXISTS ] \fIcolumn_name\fR [ RESTRICT | CASCADE ]
ALTER [ COLUMN ] \fIcolumn_name\fR [ SET DATA ] TYPE \fIdata_type\fR [ COLLATE \fIcollation\fR ]
ALTER [ COLUMN ] \fIcolumn_name\fR SET DEFAULT \fIexpression\fR
ALTER [ COLUMN ] \fIcolumn_name\fR DROP DEFAULT
ALTER [ COLUMN ] \fIcolumn_name\fR { SET | DROP } NOT NULL
ALTER [ COLUMN ] \fIcolumn_name\fR SET STATISTICS \fIinteger\fR
ALTER [ COLUMN ] \fIcolumn_name\fR SET ( \fIattribute_option\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER [ COLUMN ] \fIcolumn_name\fR RESET ( \fIattribute_option\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER [ COLUMN ] \fIcolumn_name\fR SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
ALTER [ COLUMN ] \fIcolumn_name\fR OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ])
ADD \fItable_constraint\fR [ NOT VALID ]
VALIDATE CONSTRAINT \fIconstraint_name\fR
DROP CONSTRAINT [ IF EXISTS ]  \fIconstraint_name\fR [ RESTRICT | CASCADE ]
DISABLE TRIGGER [ \fItrigger_name\fR | ALL | USER ]
ENABLE TRIGGER [ \fItrigger_name\fR | ALL | USER ]
ENABLE REPLICA TRIGGER \fItrigger_name\fR
ENABLE ALWAYS TRIGGER \fItrigger_name\fR
SET WITH OIDS
SET WITHOUT OIDS
INHERIT \fIparent_table\fR
NO INHERIT \fIparent_table\fR
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ])
.fi
.SH "DESCRIPTION"
.PP
\fBALTER FOREIGN TABLE\fR
changes the definition of an existing foreign table\&amp;. There are several subforms:
.PP
ADD COLUMN
.RS 4
This form adds a new column to the foreign table, using the same syntax as
CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7))\&amp;. Unlike the case when adding a column to a regular table, nothing happens to the underlying storage: this action simply declares that some new column is now accessible through the foreign table\&amp;.
.RE
.PP
DROP COLUMN [ IF EXISTS ]
.RS 4
This form drops a column from a foreign table\&amp;. You will need to say
CASCADE
if anything outside the table depends on the column; for example, views\&amp;. If
IF EXISTS
is specified and the column does not exist, no error is thrown\&amp;. In this case a notice is issued instead\&amp;.
.RE
.PP
SET DATA TYPE
.RS 4
This form changes the type of a column of a foreign table\&amp;. Again, this has no effect on any underlying storage: this action simply changes the type that
PostgreSQL
believes the column to have\&amp;.
.RE
.PP
SET/DROP DEFAULT
.RS 4
These forms set or remove the default value for a column\&amp;. Default values only apply in subsequent
\fBINSERT\fR
or
\fBUPDATE\fR
commands; they do not cause rows already in the table to change\&amp;.
.RE
.PP
SET/DROP NOT NULL
.RS 4
Mark a column as allowing, or not allowing, null values\&amp;.
.RE
.PP
SET STATISTICS
.RS 4
This form sets the per\-column statistics\-gathering target for subsequent
\fBANALYZE\fR(7)
operations\&amp;. See the similar form of
ALTER TABLE (\fBALTER_TABLE\fR(7))
for more details\&amp;.
.RE
.PP
SET ( \fIattribute_option\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
.br
RESET ( \fIattribute_option\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This form sets or resets per\-attribute options\&amp;. See the similar form of
ALTER TABLE (\fBALTER_TABLE\fR(7))
for more details\&amp;.
.RE
.PP
SET STORAGE
.RS 4
This form sets the storage mode for a column\&amp;. See the similar form of
ALTER TABLE (\fBALTER_TABLE\fR(7))
for more details\&amp;. Note that the storage mode has no effect unless the table\*(Aqs foreign\-data wrapper chooses to pay attention to it\&amp;.
.RE
.PP
ADD \fItable_constraint\fR [ NOT VALID ]
.RS 4
This form adds a new constraint to a foreign table, using the same syntax as
CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7))\&amp;. Currently only
CHECK
constraints are supported\&amp;.
.sp
Unlike the case when adding a constraint to a regular table, nothing is done to verify the constraint is correct; rather, this action simply declares that some new condition should be assumed to hold for all rows in the foreign table\&amp;. (See the discussion in
CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7))\&amp;.) If the constraint is marked
NOT VALID, then it isn\*(Aqt assumed to hold, but is only recorded for possible future use\&amp;.
.RE
.PP
VALIDATE CONSTRAINT
.RS 4
This form marks as valid a constraint that was previously marked as
NOT VALID\&amp;. No action is taken to verify the constraint, but future queries will assume that it holds\&amp;.
.RE
.PP
DROP CONSTRAINT [ IF EXISTS ]
.RS 4
This form drops the specified constraint on a foreign table\&amp;. If
IF EXISTS
is specified and the constraint does not exist, no error is thrown\&amp;. In this case a notice is issued instead\&amp;.
.RE
.PP
DISABLE/ENABLE [ REPLICA | ALWAYS ] TRIGGER
.RS 4
These forms configure the firing of trigger(s) belonging to the foreign table\&amp;. See the similar form of
ALTER TABLE (\fBALTER_TABLE\fR(7))
for more details\&amp;.
.RE
.PP
SET WITH OIDS
.RS 4
This form adds an
oid
system column to the table (see
Section 5.4, \(lqSystem Columns\(rq, in the documentation)\&amp;. It does nothing if the table already has OIDs\&amp;. Unless the table\*(Aqs foreign\-data wrapper supports OIDs, this column will simply read as zeroes\&amp;.
.sp
Note that this is not equivalent to
ADD COLUMN oid oid; that would add a normal column that happened to be named
oid, not a system column\&amp;.
.RE
.PP
SET WITHOUT OIDS
.RS 4
This form removes the
oid
system column from the table\&amp;. This is exactly equivalent to
DROP COLUMN oid RESTRICT, except that it will not complain if there is already no
oid
column\&amp;.
.RE
.PP
INHERIT \fIparent_table\fR
.RS 4
This form adds the target foreign table as a new child of the specified parent table\&amp;. See the similar form of
ALTER TABLE (\fBALTER_TABLE\fR(7))
for more details\&amp;.
.RE
.PP
NO INHERIT \fIparent_table\fR
.RS 4
This form removes the target foreign table from the list of children of the specified parent table\&amp;.
.RE
.PP
OWNER
.RS 4
This form changes the owner of the foreign table to the specified user\&amp;.
.RE
.PP
OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
Change options for the foreign table or one of its columns\&amp;.
ADD,
SET, and
DROP
specify the action to be performed\&amp;.
ADD
is assumed if no operation is explicitly specified\&amp;. Duplicate option names are not allowed (although it\*(Aqs OK for a table option and a column option to have the same name)\&amp;. Option names and values are also validated using the foreign data wrapper library\&amp;.
.RE
.PP
RENAME
.RS 4
The
RENAME
forms change the name of a foreign table or the name of an individual column in a foreign table\&amp;.
.RE
.PP
SET SCHEMA
.RS 4
This form moves the foreign table into another schema\&amp;.
.RE
.PP
All the actions except
RENAME
and
SET SCHEMA
can be combined into a list of multiple alterations to apply in parallel\&amp;. For example, it is possible to add several columns and/or alter the type of several columns in a single command\&amp;.
.PP
If the command is written as
ALTER FOREIGN TABLE IF EXISTS \&amp;.\&amp;.\&amp;.
and the foreign table does not exist, no error is thrown\&amp;. A notice is issued in this case\&amp;.
.PP
You must own the table to use
\fBALTER FOREIGN TABLE\fR\&amp;. To change the schema of a foreign table, you must also have
CREATE
privilege on the new schema\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the table\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the table\&amp;. However, a superuser can alter ownership of any table anyway\&amp;.) To add a column or alter a column type, you must also have
USAGE
privilege on the data type\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (possibly schema\-qualified) of an existing foreign table to alter\&amp;. If
ONLY
is specified before the table name, only that table is altered\&amp;. If
ONLY
is not specified, the table and all its descendant tables (if any) are altered\&amp;. Optionally,
*
can be specified after the table name to explicitly indicate that descendant tables are included\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
Name of a new or existing column\&amp;.
.RE
.PP
\fInew_column_name\fR
.RS 4
New name for an existing column\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
New name for the table\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
Data type of the new column, or new data type for an existing column\&amp;.
.RE
.PP
\fItable_constraint\fR
.RS 4
New table constraint for the foreign table\&amp;.
.RE
.PP
\fIconstraint_name\fR
.RS 4
Name of an existing constraint to drop\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the column or constraint if there are any dependent objects\&amp;. This is the default behavior\&amp;.
.RE
.PP
\fItrigger_name\fR
.RS 4
Name of a single trigger to disable or enable\&amp;.
.RE
.PP
ALL
.RS 4
Disable or enable all triggers belonging to the foreign table\&amp;. (This requires superuser privilege if any of the triggers are internally generated triggers\&amp;. The core system does not add such triggers to foreign tables, but add\-on code could do so\&amp;.)
.RE
.PP
USER
.RS 4
Disable or enable all triggers belonging to the foreign table except for internally generated triggers\&amp;.
.RE
.PP
\fIparent_table\fR
.RS 4
A parent table to associate or de\-associate with this foreign table\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the table\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The name of the schema to which the table will be moved\&amp;.
.RE
.SH "NOTES"
.PP
The key word
COLUMN
is noise and can be omitted\&amp;.
.PP
Consistency with the foreign server is not checked when a column is added or removed with
ADD COLUMN
or
DROP COLUMN, a
NOT NULL
or
CHECK
constraint is added, or a column type is changed with
SET DATA TYPE\&amp;. It is the user\*(Aqs responsibility to ensure that the table definition matches the remote side\&amp;.
.PP
Refer to
CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7))
for a further description of valid parameters\&amp;.
.SH "EXAMPLES"
.PP
To mark a column as not\-null:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FOREIGN TABLE distributors ALTER COLUMN street SET NOT NULL;
.fi
.if n \{\
.RE
.\}
.PP
To change options of a foreign table:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FOREIGN TABLE myschema\&amp;.distributors OPTIONS (ADD opt1 \*(Aqvalue\*(Aq, SET opt2 \*(Aqvalue2\*(Aq, DROP opt3 \*(Aqvalue3\*(Aq);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The forms
ADD,
DROP, and
SET DATA TYPE
conform with the SQL standard\&amp;. The other forms are
PostgreSQL
extensions of the SQL standard\&amp;. Also, the ability to specify more than one manipulation in a single
\fBALTER FOREIGN TABLE\fR
command is an extension\&amp;.
.PP
\fBALTER FOREIGN TABLE DROP COLUMN\fR
can be used to drop the only column of a foreign table, leaving a zero\-column table\&amp;. This is an extension of SQL, which disallows zero\-column foreign tables\&amp;.
.SH "SEE ALSO"
CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7)), DROP FOREIGN TABLE (\fBDROP_FOREIGN_TABLE\fR(7))
'\" t
.\"     Title: ALTER FUNCTION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER FUNCTION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_FUNCTION \- change the definition of a function
.SH "SYNOPSIS"
.sp
.nf
ALTER FUNCTION \fIname\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] )
\fIaction\fR [ \&amp;.\&amp;.\&amp;. ] [ RESTRICT ]
ALTER FUNCTION \fIname\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] )
RENAME TO \fInew_name\fR
ALTER FUNCTION \fIname\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] )
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER FUNCTION \fIname\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] )
SET SCHEMA \fInew_schema\fR
ALTER FUNCTION \fIname\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] )
DEPENDS ON EXTENSION \fIextension_name\fR

where \fIaction\fR is one of:

CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
[ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
PARALLEL { UNSAFE | RESTRICTED | SAFE }
COST \fIexecution_cost\fR
ROWS \fIresult_rows\fR
SET \fIconfiguration_parameter\fR { TO | = } { \fIvalue\fR | DEFAULT }
SET \fIconfiguration_parameter\fR FROM CURRENT
RESET \fIconfiguration_parameter\fR
RESET ALL
.fi
.SH "DESCRIPTION"
.PP
\fBALTER FUNCTION\fR
changes the definition of a function\&amp;.
.PP
You must own the function to use
\fBALTER FUNCTION\fR\&amp;. To change a function\*(Aqs schema, you must also have
CREATE
privilege on the new schema\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the function\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the function\&amp;. However, a superuser can alter ownership of any function anyway\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing function\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of an argument:
IN,
OUT,
INOUT, or
VARIADIC\&amp;. If omitted, the default is
IN\&amp;. Note that
\fBALTER FUNCTION\fR
does not actually pay any attention to
OUT
arguments, since only the input arguments are needed to determine the function\*(Aqs identity\&amp;. So it is sufficient to list the
IN,
INOUT, and
VARIADIC
arguments\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of an argument\&amp;. Note that
\fBALTER FUNCTION\fR
does not actually pay any attention to argument names, since only the argument data types are needed to determine the function\*(Aqs identity\&amp;.
.RE
.PP
\fIargtype\fR
.RS 4
The data type(s) of the function\*(Aqs arguments (optionally schema\-qualified), if any\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the function\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the function\&amp;. Note that if the function is marked
SECURITY DEFINER, it will subsequently execute as the new owner\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the function\&amp;.
.RE
.PP
\fIextension_name\fR
.RS 4
The name of the extension that the function is to depend on\&amp;.
.RE
.PP
CALLED ON NULL INPUT
.br
RETURNS NULL ON NULL INPUT
.br
STRICT
.RS 4
CALLED ON NULL INPUT
changes the function so that it will be invoked when some or all of its arguments are null\&amp;.
RETURNS NULL ON NULL INPUT
or
STRICT
changes the function so that it is not invoked if any of its arguments are null; instead, a null result is assumed automatically\&amp;. See
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
for more information\&amp;.
.RE
.PP
IMMUTABLE
.br
STABLE
.br
VOLATILE
.RS 4
Change the volatility of the function to the specified setting\&amp;. See
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
for details\&amp;.
.RE
.PP
[ EXTERNAL ] SECURITY INVOKER
.br
[ EXTERNAL ] SECURITY DEFINER
.RS 4
Change whether the function is a security definer or not\&amp;. The key word
EXTERNAL
is ignored for SQL conformance\&amp;. See
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
for more information about this capability\&amp;.
.RE
.PP
PARALLEL
.RS 4
Change whether the function is deemed safe for parallelism\&amp;. See
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
for details\&amp;.
.RE
.PP
LEAKPROOF
.RS 4
Change whether the function is considered leakproof or not\&amp;. See
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
for more information about this capability\&amp;.
.RE
.PP
COST \fIexecution_cost\fR
.RS 4
Change the estimated execution cost of the function\&amp;. See
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
for more information\&amp;.
.RE
.PP
ROWS \fIresult_rows\fR
.RS 4
Change the estimated number of rows returned by a set\-returning function\&amp;. See
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
for more information\&amp;.
.RE
.PP
\fIconfiguration_parameter\fR
.br
\fIvalue\fR
.RS 4
Add or change the assignment to be made to a configuration parameter when the function is called\&amp;. If
\fIvalue\fR
is
DEFAULT
or, equivalently,
RESET
is used, the function\-local setting is removed, so that the function executes with the value present in its environment\&amp;. Use
RESET ALL
to clear all function\-local settings\&amp;.
SET FROM CURRENT
saves the value of the parameter that is current when
\fBALTER FUNCTION\fR
is executed as the value to be applied when the function is entered\&amp;.
.sp
See
\fBSET\fR(7)
and
Chapter 19, Server Configuration, in the documentation
for more information about allowed parameter names and values\&amp;.
.RE
.PP
RESTRICT
.RS 4
Ignored for conformance with the SQL standard\&amp;.
.RE
.SH "EXAMPLES"
.PP
To rename the function
sqrt
for type
integer
to
square_root:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FUNCTION sqrt(integer) RENAME TO square_root;
.fi
.if n \{\
.RE
.\}
.PP
To change the owner of the function
sqrt
for type
integer
to
joe:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FUNCTION sqrt(integer) OWNER TO joe;
.fi
.if n \{\
.RE
.\}
.PP
To change the schema of the function
sqrt
for type
integer
to
maths:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FUNCTION sqrt(integer) SET SCHEMA maths;
.fi
.if n \{\
.RE
.\}
.PP
To mark the function
sqrt
for type
integer
as being dependent on the extension
mathlib:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FUNCTION sqrt(integer) DEPENDS ON EXTENSION mathlib;
.fi
.if n \{\
.RE
.\}
.PP
To adjust the search path that is automatically set for a function:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FUNCTION check_password(text) SET search_path = admin, pg_temp;
.fi
.if n \{\
.RE
.\}
.PP
To disable automatic setting of
\fIsearch_path\fR
for a function:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER FUNCTION check_password(text) RESET search_path;
.fi
.if n \{\
.RE
.\}
.sp
The function will now execute with whatever search path is used by its caller\&amp;.
.SH "COMPATIBILITY"
.PP
This statement is partially compatible with the
\fBALTER FUNCTION\fR
statement in the SQL standard\&amp;. The standard allows more properties of a function to be modified, but does not provide the ability to rename a function, make a function a security definer, attach configuration parameter values to a function, or change the owner, schema, or volatility of a function\&amp;. The standard also requires the
RESTRICT
key word, which is optional in
PostgreSQL\&amp;.
.SH "SEE ALSO"
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)), DROP FUNCTION (\fBDROP_FUNCTION\fR(7))
'\" t
.\"     Title: ALTER GROUP
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER GROUP" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_GROUP \- change role name or membership
.SH "SYNOPSIS"
.sp
.nf
ALTER GROUP \fIrole_specification\fR ADD USER \fIuser_name\fR [, \&amp;.\&amp;.\&amp;. ]
ALTER GROUP \fIrole_specification\fR DROP USER \fIuser_name\fR [, \&amp;.\&amp;.\&amp;. ]

where \fIrole_specification\fR can be:

\fIrole_name\fR
| CURRENT_USER
| SESSION_USER

ALTER GROUP \fIgroup_name\fR RENAME TO \fInew_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER GROUP\fR
changes the attributes of a user group\&amp;. This is an obsolete command, though still accepted for backwards compatibility, because groups (and users too) have been superseded by the more general concept of roles\&amp;.
.PP
The first two variants add users to a group or remove them from a group\&amp;. (Any role can play the part of either a
\(lquser\(rq
or a
\(lqgroup\(rq
for this purpose\&amp;.) These variants are effectively equivalent to granting or revoking membership in the role named as the
\(lqgroup\(rq; so the preferred way to do this is to use
\fBGRANT\fR(7)
or
\fBREVOKE\fR(7)\&amp;.
.PP
The third variant changes the name of the group\&amp;. This is exactly equivalent to renaming the role with
ALTER ROLE (\fBALTER_ROLE\fR(7))\&amp;.
.SH "PARAMETERS"
.PP
\fIgroup_name\fR
.RS 4
The name of the group (role) to modify\&amp;.
.RE
.PP
\fIuser_name\fR
.RS 4
Users (roles) that are to be added to or removed from the group\&amp;. The users must already exist;
\fBALTER GROUP\fR
does not create or drop users\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the group\&amp;.
.RE
.SH "EXAMPLES"
.PP
Add users to a group:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER GROUP staff ADD USER karl, john;
.fi
.if n \{\
.RE
.\}
.sp
Remove a user from a group:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER GROUP workers DROP USER beth;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER GROUP\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBGRANT\fR(7), \fBREVOKE\fR(7), ALTER ROLE (\fBALTER_ROLE\fR(7))
'\" t
.\"     Title: ALTER INDEX
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER INDEX" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_INDEX \- change the definition of an index
.SH "SYNOPSIS"
.sp
.nf
ALTER INDEX [ IF EXISTS ] \fIname\fR RENAME TO \fInew_name\fR
ALTER INDEX [ IF EXISTS ] \fIname\fR SET TABLESPACE \fItablespace_name\fR
ALTER INDEX \fIname\fR DEPENDS ON EXTENSION \fIextension_name\fR
ALTER INDEX [ IF EXISTS ] \fIname\fR SET ( \fIstorage_parameter\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER INDEX [ IF EXISTS ] \fIname\fR RESET ( \fIstorage_parameter\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER INDEX ALL IN TABLESPACE \fIname\fR [ OWNED BY \fIrole_name\fR [, \&amp;.\&amp;.\&amp;. ] ]
SET TABLESPACE \fInew_tablespace\fR [ NOWAIT ]
.fi
.SH "DESCRIPTION"
.PP
\fBALTER INDEX\fR
changes the definition of an existing index\&amp;. There are several subforms:
.PP
RENAME
.RS 4
The
RENAME
form changes the name of the index\&amp;. There is no effect on the stored data\&amp;.
.RE
.PP
SET TABLESPACE
.RS 4
This form changes the index\*(Aqs tablespace to the specified tablespace and moves the data file(s) associated with the index to the new tablespace\&amp;. To change the tablespace of an index, you must own the index and have
CREATE
privilege on the new tablespace\&amp;. All indexes in the current database in a tablespace can be moved by using the
ALL IN TABLESPACE
form, which will lock all indexes to be moved and then move each one\&amp;. This form also supports
OWNED BY, which will only move indexes owned by the roles specified\&amp;. If the
NOWAIT
option is specified then the command will fail if it is unable to acquire all of the locks required immediately\&amp;. Note that system catalogs will not be moved by this command, use
\fBALTER DATABASE\fR
or explicit
\fBALTER INDEX\fR
invocations instead if desired\&amp;. See also
CREATE TABLESPACE (\fBCREATE_TABLESPACE\fR(7))\&amp;.
.RE
.PP
DEPENDS ON EXTENSION
.RS 4
This form marks the index as dependent on the extension, such that if the extension is dropped, the index will automatically be dropped as well\&amp;.
.RE
.PP
SET ( \fIstorage_parameter\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This form changes one or more index\-method\-specific storage parameters for the index\&amp;. See
CREATE INDEX (\fBCREATE_INDEX\fR(7))
for details on the available parameters\&amp;. Note that the index contents will not be modified immediately by this command; depending on the parameter you might need to rebuild the index with
\fBREINDEX\fR(7)
to get the desired effects\&amp;.
.RE
.PP
RESET ( \fIstorage_parameter\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This form resets one or more index\-method\-specific storage parameters to their defaults\&amp;. As with
SET, a
REINDEX
might be needed to update the index entirely\&amp;.
.RE
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the index does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (possibly schema\-qualified) of an existing index to alter\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the index\&amp;.
.RE
.PP
\fItablespace_name\fR
.RS 4
The tablespace to which the index will be moved\&amp;.
.RE
.PP
\fIextension_name\fR
.RS 4
The name of the extension that the index is to depend on\&amp;.
.RE
.PP
\fIstorage_parameter\fR
.RS 4
The name of an index\-method\-specific storage parameter\&amp;.
.RE
.PP
\fIvalue\fR
.RS 4
The new value for an index\-method\-specific storage parameter\&amp;. This might be a number or a word depending on the parameter\&amp;.
.RE
.SH "NOTES"
.PP
These operations are also possible using
ALTER TABLE (\fBALTER_TABLE\fR(7))\&amp;.
\fBALTER INDEX\fR
is in fact just an alias for the forms of
\fBALTER TABLE\fR
that apply to indexes\&amp;.
.PP
There was formerly an
\fBALTER INDEX OWNER\fR
variant, but this is now ignored (with a warning)\&amp;. An index cannot have an owner different from its table\*(Aqs owner\&amp;. Changing the table\*(Aqs owner automatically changes the index as well\&amp;.
.PP
Changing any part of a system catalog index is not permitted\&amp;.
.SH "EXAMPLES"
.PP
To rename an existing index:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER INDEX distributors RENAME TO suppliers;
.fi
.if n \{\
.RE
.\}
.PP
To move an index to a different tablespace:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER INDEX distributors SET TABLESPACE fasttablespace;
.fi
.if n \{\
.RE
.\}
.PP
To change an index\*(Aqs fill factor (assuming that the index method supports it):
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER INDEX distributors SET (fillfactor = 75);
REINDEX INDEX distributors;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER INDEX\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE INDEX (\fBCREATE_INDEX\fR(7)), \fBREINDEX\fR(7)
'\" t
.\"     Title: ALTER LANGUAGE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER LANGUAGE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_LANGUAGE \- change the definition of a procedural language
.SH "SYNOPSIS"
.sp
.nf
ALTER [ PROCEDURAL ] LANGUAGE \fIname\fR RENAME TO \fInew_name\fR
ALTER [ PROCEDURAL ] LANGUAGE \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
.fi
.SH "DESCRIPTION"
.PP
\fBALTER LANGUAGE\fR
changes the definition of a procedural language\&amp;. The only functionality is to rename the language or assign a new owner\&amp;. You must be superuser or owner of the language to use
\fBALTER LANGUAGE\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
Name of a language
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the language
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the language
.RE
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER LANGUAGE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE LANGUAGE (\fBCREATE_LANGUAGE\fR(7)), DROP LANGUAGE (\fBDROP_LANGUAGE\fR(7))
'\" t
.\"     Title: ALTER LARGE OBJECT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER LARGE OBJECT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_LARGE_OBJECT \- change the definition of a large object
.SH "SYNOPSIS"
.sp
.nf
ALTER LARGE OBJECT \fIlarge_object_oid\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
.fi
.SH "DESCRIPTION"
.PP
\fBALTER LARGE OBJECT\fR
changes the definition of a large object\&amp;. The only functionality is to assign a new owner\&amp;. You must be superuser or owner of the large object to use
\fBALTER LARGE OBJECT\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIlarge_object_oid\fR
.RS 4
OID of the large object to be altered
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the large object
.RE
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER LARGE OBJECT\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
Chapter 33, Large Objects, in the documentation
'\" t
.\"     Title: ALTER MATERIALIZED VIEW
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER MATERIALIZED VIEW" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_MATERIALIZED_VIEW \- change the definition of a materialized view
.SH "SYNOPSIS"
.sp
.nf
ALTER MATERIALIZED VIEW [ IF EXISTS ] \fIname\fR
\fIaction\fR [, \&amp;.\&amp;.\&amp;. ]
ALTER MATERIALIZED VIEW \fIname\fR
DEPENDS ON EXTENSION \fIextension_name\fR
ALTER MATERIALIZED VIEW [ IF EXISTS ] \fIname\fR
RENAME [ COLUMN ] \fIcolumn_name\fR TO \fInew_column_name\fR
ALTER MATERIALIZED VIEW [ IF EXISTS ] \fIname\fR
RENAME TO \fInew_name\fR
ALTER MATERIALIZED VIEW [ IF EXISTS ] \fIname\fR
SET SCHEMA \fInew_schema\fR
ALTER MATERIALIZED VIEW ALL IN TABLESPACE \fIname\fR [ OWNED BY \fIrole_name\fR [, \&amp;.\&amp;.\&amp;. ] ]
SET TABLESPACE \fInew_tablespace\fR [ NOWAIT ]

where \fIaction\fR is one of:

ALTER [ COLUMN ] \fIcolumn_name\fR SET STATISTICS \fIinteger\fR
ALTER [ COLUMN ] \fIcolumn_name\fR SET ( \fIattribute_option\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER [ COLUMN ] \fIcolumn_name\fR RESET ( \fIattribute_option\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER [ COLUMN ] \fIcolumn_name\fR SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
CLUSTER ON \fIindex_name\fR
SET WITHOUT CLUSTER
SET ( \fIstorage_parameter\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
RESET ( \fIstorage_parameter\fR [, \&amp;.\&amp;.\&amp;. ] )
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
SET TABLESPACE \fInew_tablespace\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER MATERIALIZED VIEW\fR
changes various auxiliary properties of an existing materialized view\&amp;.
.PP
You must own the materialized view to use
\fBALTER MATERIALIZED VIEW\fR\&amp;. To change a materialized view\*(Aqs schema, you must also have
CREATE
privilege on the new schema\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the materialized view\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the materialized view\&amp;. However, a superuser can alter ownership of any view anyway\&amp;.)
.PP
The
DEPENDS ON EXTENSION
form marks the materialized view as dependent on an extension, such that the materialized view will automatically be dropped if the extension is dropped\&amp;.
.PP
The statement subforms and actions available for
\fBALTER MATERIALIZED VIEW\fR
are a subset of those available for
\fBALTER TABLE\fR, and have the same meaning when used for materialized views\&amp;. See the descriptions for
ALTER TABLE (\fBALTER_TABLE\fR(7))
for details\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing materialized view\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
Name of a new or existing column\&amp;.
.RE
.PP
\fIextension_name\fR
.RS 4
The name of the extension that the materialized view is to depend on\&amp;.
.RE
.PP
\fInew_column_name\fR
.RS 4
New name for an existing column\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the materialized view\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the materialized view\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the materialized view\&amp;.
.RE
.SH "EXAMPLES"
.PP
To rename the materialized view
foo
to
bar:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER MATERIALIZED VIEW foo RENAME TO bar;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER MATERIALIZED VIEW\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE MATERIALIZED VIEW (\fBCREATE_MATERIALIZED_VIEW\fR(7)), DROP MATERIALIZED VIEW (\fBDROP_MATERIALIZED_VIEW\fR(7)), REFRESH MATERIALIZED VIEW (\fBREFRESH_MATERIALIZED_VIEW\fR(7))
'\" t
.\"     Title: ALTER OPERATOR
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER OPERATOR" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_OPERATOR \- change the definition of an operator
.SH "SYNOPSIS"
.sp
.nf
ALTER OPERATOR \fIname\fR ( { \fIleft_type\fR | NONE } , { \fIright_type\fR | NONE } )
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }

ALTER OPERATOR \fIname\fR ( { \fIleft_type\fR | NONE } , { \fIright_type\fR | NONE } )
SET SCHEMA \fInew_schema\fR

ALTER OPERATOR \fIname\fR ( { \fIleft_type\fR | NONE } , { \fIright_type\fR | NONE } )
SET ( {  RESTRICT = { \fIres_proc\fR | NONE }
| JOIN = { \fIjoin_proc\fR | NONE }
} [, \&amp;.\&amp;.\&amp;. ] )
.fi
.SH "DESCRIPTION"
.PP
\fBALTER OPERATOR\fR
changes the definition of an operator\&amp;.
.PP
You must own the operator to use
\fBALTER OPERATOR\fR\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the operator\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the operator\&amp;. However, a superuser can alter ownership of any operator anyway\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing operator\&amp;.
.RE
.PP
\fIleft_type\fR
.RS 4
The data type of the operator\*(Aqs left operand; write
NONE
if the operator has no left operand\&amp;.
.RE
.PP
\fIright_type\fR
.RS 4
The data type of the operator\*(Aqs right operand; write
NONE
if the operator has no right operand\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the operator\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the operator\&amp;.
.RE
.PP
\fIres_proc\fR
.RS 4
The restriction selectivity estimator function for this operator; write NONE to remove existing selectivity estimator\&amp;.
.RE
.PP
\fIjoin_proc\fR
.RS 4
The join selectivity estimator function for this operator; write NONE to remove existing selectivity estimator\&amp;.
.RE
.SH "EXAMPLES"
.PP
Change the owner of a custom operator
a @@ b
for type
text:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER OPERATOR @@ (text, text) OWNER TO joe;
.fi
.if n \{\
.RE
.\}
.PP
Change the restriction and join selectivity estimator functions of a custom operator
a &amp;&amp; b
for type
int[]:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER OPERATOR &amp;&amp; (_int4, _int4) SET (RESTRICT = _int_contsel, JOIN = _int_contjoinsel);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER OPERATOR\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE OPERATOR (\fBCREATE_OPERATOR\fR(7)), DROP OPERATOR (\fBDROP_OPERATOR\fR(7))
'\" t
.\"     Title: ALTER OPERATOR CLASS
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER OPERATOR CLASS" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_OPERATOR_CLASS \- change the definition of an operator class
.SH "SYNOPSIS"
.sp
.nf
ALTER OPERATOR CLASS \fIname\fR USING \fIindex_method\fR
RENAME TO \fInew_name\fR

ALTER OPERATOR CLASS \fIname\fR USING \fIindex_method\fR
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }

ALTER OPERATOR CLASS \fIname\fR USING \fIindex_method\fR
SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER OPERATOR CLASS\fR
changes the definition of an operator class\&amp;.
.PP
You must own the operator class to use
\fBALTER OPERATOR CLASS\fR\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the operator class\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the operator class\&amp;. However, a superuser can alter ownership of any operator class anyway\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing operator class\&amp;.
.RE
.PP
\fIindex_method\fR
.RS 4
The name of the index method this operator class is for\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the operator class\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the operator class\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the operator class\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER OPERATOR CLASS\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE OPERATOR CLASS (\fBCREATE_OPERATOR_CLASS\fR(7)), DROP OPERATOR CLASS (\fBDROP_OPERATOR_CLASS\fR(7)), ALTER OPERATOR FAMILY (\fBALTER_OPERATOR_FAMILY\fR(7))
'\" t
.\"     Title: ALTER OPERATOR FAMILY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER OPERATOR FAMILY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_OPERATOR_FAMILY \- change the definition of an operator family
.SH "SYNOPSIS"
.sp
.nf
ALTER OPERATOR FAMILY \fIname\fR USING \fIindex_method\fR ADD
{  OPERATOR \fIstrategy_number\fR \fIoperator_name\fR ( \fIop_type\fR, \fIop_type\fR )
[ FOR SEARCH | FOR ORDER BY \fIsort_family_name\fR ]
| FUNCTION \fIsupport_number\fR [ ( \fIop_type\fR [ , \fIop_type\fR ] ) ]
\fIfunction_name\fR ( \fIargument_type\fR [, \&amp;.\&amp;.\&amp;.] )
} [, \&amp;.\&amp;.\&amp;. ]

ALTER OPERATOR FAMILY \fIname\fR USING \fIindex_method\fR DROP
{  OPERATOR \fIstrategy_number\fR ( \fIop_type\fR [ , \fIop_type\fR ] )
| FUNCTION \fIsupport_number\fR ( \fIop_type\fR [ , \fIop_type\fR ] )
} [, \&amp;.\&amp;.\&amp;. ]

ALTER OPERATOR FAMILY \fIname\fR USING \fIindex_method\fR
RENAME TO \fInew_name\fR

ALTER OPERATOR FAMILY \fIname\fR USING \fIindex_method\fR
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }

ALTER OPERATOR FAMILY \fIname\fR USING \fIindex_method\fR
SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER OPERATOR FAMILY\fR
changes the definition of an operator family\&amp;. You can add operators and support functions to the family, remove them from the family, or change the family\*(Aqs name or owner\&amp;.
.PP
When operators and support functions are added to a family with
\fBALTER OPERATOR FAMILY\fR, they are not part of any specific operator class within the family, but are just
\(lqloose\(rq
within the family\&amp;. This indicates that these operators and functions are compatible with the family\*(Aqs semantics, but are not required for correct functioning of any specific index\&amp;. (Operators and functions that are so required should be declared as part of an operator class, instead; see
CREATE OPERATOR CLASS (\fBCREATE_OPERATOR_CLASS\fR(7))\&amp;.)
PostgreSQL
will allow loose members of a family to be dropped from the family at any time, but members of an operator class cannot be dropped without dropping the whole class and any indexes that depend on it\&amp;. Typically, single\-data\-type operators and functions are part of operator classes because they are needed to support an index on that specific data type, while cross\-data\-type operators and functions are made loose members of the family\&amp;.
.PP
You must be a superuser to use
\fBALTER OPERATOR FAMILY\fR\&amp;. (This restriction is made because an erroneous operator family definition could confuse or even crash the server\&amp;.)
.PP
\fBALTER OPERATOR FAMILY\fR
does not presently check whether the operator family definition includes all the operators and functions required by the index method, nor whether the operators and functions form a self\-consistent set\&amp;. It is the user\*(Aqs responsibility to define a valid operator family\&amp;.
.PP
Refer to
Section 36.14, \(lqInterfacing Extensions To Indexes\(rq, in the documentation
for further information\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing operator family\&amp;.
.RE
.PP
\fIindex_method\fR
.RS 4
The name of the index method this operator family is for\&amp;.
.RE
.PP
\fIstrategy_number\fR
.RS 4
The index method\*(Aqs strategy number for an operator associated with the operator family\&amp;.
.RE
.PP
\fIoperator_name\fR
.RS 4
The name (optionally schema\-qualified) of an operator associated with the operator family\&amp;.
.RE
.PP
\fIop_type\fR
.RS 4
In an
OPERATOR
clause, the operand data type(s) of the operator, or
NONE
to signify a left\-unary or right\-unary operator\&amp;. Unlike the comparable syntax in
\fBCREATE OPERATOR CLASS\fR, the operand data types must always be specified\&amp;.
.sp
In an
ADD FUNCTION
clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function\&amp;. For B\-tree comparison functions and hash functions it is not necessary to specify
\fIop_type\fR
since the function\*(Aqs input data type(s) are always the correct ones to use\&amp;. For B\-tree sort support functions and all functions in GiST, SP\-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with\&amp;.
.sp
In a
DROP FUNCTION
clause, the operand data type(s) the function is intended to support must be specified\&amp;.
.RE
.PP
\fIsort_family_name\fR
.RS 4
The name (optionally schema\-qualified) of an existing
btree
operator family that describes the sort ordering associated with an ordering operator\&amp;.
.sp
If neither
FOR SEARCH
nor
FOR ORDER BY
is specified,
FOR SEARCH
is the default\&amp;.
.RE
.PP
\fIsupport_number\fR
.RS 4
The index method\*(Aqs support procedure number for a function associated with the operator family\&amp;.
.RE
.PP
\fIfunction_name\fR
.RS 4
The name (optionally schema\-qualified) of a function that is an index method support procedure for the operator family\&amp;.
.RE
.PP
\fIargument_type\fR
.RS 4
The parameter data type(s) of the function\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the operator family\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the operator family\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the operator family\&amp;.
.RE
.PP
The
OPERATOR
and
FUNCTION
clauses can appear in any order\&amp;.
.SH "NOTES"
.PP
Notice that the
DROP
syntax only specifies the
\(lqslot\(rq
in the operator family, by strategy or support number and input data type(s)\&amp;. The name of the operator or function occupying the slot is not mentioned\&amp;. Also, for
DROP FUNCTION
the type(s) to specify are the input data type(s) the function is intended to support; for GiST, SP\-GiST and GIN indexes this might have nothing to do with the actual input argument types of the function\&amp;.
.PP
Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator family is tantamount to granting public execute permission on it\&amp;. This is usually not an issue for the sorts of functions that are useful in an operator family\&amp;.
.PP
The operators should not be defined by SQL functions\&amp;. A SQL function is likely to be inlined into the calling query, which will prevent the optimizer from recognizing that the query matches an index\&amp;.
.PP
Before
PostgreSQL
8\&amp;.4, the
OPERATOR
clause could include a
RECHECK
option\&amp;. This is no longer supported because whether an index operator is
\(lqlossy\(rq
is now determined on\-the\-fly at run time\&amp;. This allows efficient handling of cases where an operator might or might not be lossy\&amp;.
.SH "EXAMPLES"
.PP
The following example command adds cross\-data\-type operators and support functions to an operator family that already contains B\-tree operator classes for data types
int4
and
int2\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER OPERATOR FAMILY integer_ops USING btree ADD

\-\- int4 vs int2
OPERATOR 1 &lt; (int4, int2) ,
OPERATOR 2 &lt;= (int4, int2) ,
OPERATOR 3 = (int4, int2) ,
OPERATOR 4 &gt;= (int4, int2) ,
OPERATOR 5 &gt; (int4, int2) ,
FUNCTION 1 btint42cmp(int4, int2) ,

\-\- int2 vs int4
OPERATOR 1 &lt; (int2, int4) ,
OPERATOR 2 &lt;= (int2, int4) ,
OPERATOR 3 = (int2, int4) ,
OPERATOR 4 &gt;= (int2, int4) ,
OPERATOR 5 &gt; (int2, int4) ,
FUNCTION 1 btint24cmp(int2, int4) ;
.fi
.if n \{\
.RE
.\}
.PP
To remove these entries again:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER OPERATOR FAMILY integer_ops USING btree DROP

\-\- int4 vs int2
OPERATOR 1 (int4, int2) ,
OPERATOR 2 (int4, int2) ,
OPERATOR 3 (int4, int2) ,
OPERATOR 4 (int4, int2) ,
OPERATOR 5 (int4, int2) ,
FUNCTION 1 (int4, int2) ,

\-\- int2 vs int4
OPERATOR 1 (int2, int4) ,
OPERATOR 2 (int2, int4) ,
OPERATOR 3 (int2, int4) ,
OPERATOR 4 (int2, int4) ,
OPERATOR 5 (int2, int4) ,
FUNCTION 1 (int2, int4) ;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER OPERATOR FAMILY\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE OPERATOR FAMILY (\fBCREATE_OPERATOR_FAMILY\fR(7)), DROP OPERATOR FAMILY (\fBDROP_OPERATOR_FAMILY\fR(7)), CREATE OPERATOR CLASS (\fBCREATE_OPERATOR_CLASS\fR(7)), ALTER OPERATOR CLASS (\fBALTER_OPERATOR_CLASS\fR(7)), DROP OPERATOR CLASS (\fBDROP_OPERATOR_CLASS\fR(7))
'\" t
.\"     Title: ALTER POLICY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER POLICY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_POLICY \- change the definition of a row level security policy
.SH "SYNOPSIS"
.sp
.nf
ALTER POLICY \fIname\fR ON \fItable_name\fR RENAME TO \fInew_name\fR

ALTER POLICY \fIname\fR ON \fItable_name\fR
[ TO { \fIrole_name\fR | PUBLIC | CURRENT_USER | SESSION_USER } [, \&amp;.\&amp;.\&amp;.] ]
[ USING ( \fIusing_expression\fR ) ]
[ WITH CHECK ( \fIcheck_expression\fR ) ]
.fi
.SH "DESCRIPTION"
.PP
\fBALTER POLICY\fR
changes the definition of an existing row\-level security policy\&amp;.
.PP
To use
\fBALTER POLICY\fR, you must own the table that the policy applies to\&amp;.
.PP
In the second form of
\fBALTER POLICY\fR, the role list,
\fIusing_expression\fR, and
\fIcheck_expression\fR
are replaced independently if specified\&amp;. When one of those clauses is omitted, the corresponding part of the policy is unchanged\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an existing policy to alter\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table that the policy is on\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the policy\&amp;.
.RE
.PP
\fIrole_name\fR
.RS 4
The role(s) to which the policy applies\&amp;. Multiple roles can be specified at one time\&amp;. To apply the policy to all roles, use
PUBLIC\&amp;.
.RE
.PP
\fIusing_expression\fR
.RS 4
The
USING
expression for the policy\&amp;. See
CREATE POLICY (\fBCREATE_POLICY\fR(7))
for details\&amp;.
.RE
.PP
\fIcheck_expression\fR
.RS 4
The
WITH CHECK
expression for the policy\&amp;. See
CREATE POLICY (\fBCREATE_POLICY\fR(7))
for details\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
\fBALTER POLICY\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE POLICY (\fBCREATE_POLICY\fR(7)), DROP POLICY (\fBDROP_POLICY\fR(7))
'\" t
.\"     Title: ALTER ROLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER ROLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_ROLE \- change a database role
.SH "SYNOPSIS"
.sp
.nf
ALTER ROLE \fIrole_specification\fR [ WITH ] \fIoption\fR [ \&amp;.\&amp;.\&amp;. ]

where \fIoption\fR can be:

SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| REPLICATION | NOREPLICATION
| BYPASSRLS | NOBYPASSRLS
| CONNECTION LIMIT \fIconnlimit\fR
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD \*(Aq\fIpassword\fR\*(Aq
| VALID UNTIL \*(Aq\fItimestamp\fR\*(Aq

ALTER ROLE \fIname\fR RENAME TO \fInew_name\fR

ALTER ROLE { \fIrole_specification\fR | ALL } [ IN DATABASE \fIdatabase_name\fR ] SET \fIconfiguration_parameter\fR { TO | = } { \fIvalue\fR | DEFAULT }
ALTER ROLE { \fIrole_specification\fR | ALL } [ IN DATABASE \fIdatabase_name\fR ] SET \fIconfiguration_parameter\fR FROM CURRENT
ALTER ROLE { \fIrole_specification\fR | ALL } [ IN DATABASE \fIdatabase_name\fR ] RESET \fIconfiguration_parameter\fR
ALTER ROLE { \fIrole_specification\fR | ALL } [ IN DATABASE \fIdatabase_name\fR ] RESET ALL

where \fIrole_specification\fR can be:

[ GROUP ] \fIrole_name\fR
| CURRENT_USER
| SESSION_USER
.fi
.SH "DESCRIPTION"
.PP
\fBALTER ROLE\fR
changes the attributes of a
PostgreSQL
role\&amp;.
.PP
The first variant of this command listed in the synopsis can change many of the role attributes that can be specified in
CREATE ROLE (\fBCREATE_ROLE\fR(7))\&amp;. (All the possible attributes are covered, except that there are no options for adding or removing memberships; use
\fBGRANT\fR(7)
and
\fBREVOKE\fR(7)
for that\&amp;.) Attributes not mentioned in the command retain their previous settings\&amp;. Database superusers can change any of these settings for any role\&amp;. Roles having
CREATEROLE
privilege can change any of these settings, but only for non\-superuser and non\-replication roles\&amp;. Ordinary roles can only change their own password\&amp;.
.PP
The second variant changes the name of the role\&amp;. Database superusers can rename any role\&amp;. Roles having
CREATEROLE
privilege can rename non\-superuser roles\&amp;. The current session user cannot be renamed\&amp;. (Connect as a different user if you need to do that\&amp;.) Because
MD5\-encrypted passwords use the role name as cryptographic salt, renaming a role clears its password if the password is
MD5\-encrypted\&amp;.
.PP
The remaining variants change a role\*(Aqs session default for a configuration variable, either for all databases or, when the
IN DATABASE
clause is specified, only for sessions in the named database\&amp;. If
ALL
is specified instead of a role name, this changes the setting for all roles\&amp;. Using
ALL
with
IN DATABASE
is effectively the same as using the command
ALTER DATABASE \&amp;.\&amp;.\&amp;. SET \&amp;.\&amp;.\&amp;.\&amp;.
.PP
Whenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present in
postgresql\&amp;.conf
or has been received from the
\fBpostgres\fR
command line\&amp;. This only happens at login time; executing
SET ROLE (\fBSET_ROLE\fR(7))
or
SET SESSION AUTHORIZATION (\fBSET_SESSION_AUTHORIZATION\fR(7))
does not cause new configuration values to be set\&amp;. Settings set for all databases are overridden by database\-specific settings attached to a role\&amp;. Settings for specific databases or specific roles override settings for all roles\&amp;.
.PP
Superusers can change anyone\*(Aqs session defaults\&amp;. Roles having
CREATEROLE
privilege can change defaults for non\-superuser roles\&amp;. Ordinary roles can only set defaults for themselves\&amp;. Certain configuration variables cannot be set this way, or can only be set if a superuser issues the command\&amp;. Only superusers can change a setting for all roles in all databases\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the role whose attributes are to be altered\&amp;.
.RE
.PP
CURRENT_USER
.RS 4
Alter the current user instead of an explicitly identified role\&amp;.
.RE
.PP
SESSION_USER
.RS 4
Alter the current session user instead of an explicitly identified role\&amp;.
.RE
.PP
SUPERUSER
.br
NOSUPERUSER
.br
CREATEDB
.br
NOCREATEDB
.br
CREATEROLE
.br
NOCREATEROLE
.br
INHERIT
.br
NOINHERIT
.br
LOGIN
.br
NOLOGIN
.br
REPLICATION
.br
NOREPLICATION
.br
BYPASSRLS
.br
NOBYPASSRLS
.br
CONNECTION LIMIT \fIconnlimit\fR
.br
PASSWORD \fIpassword\fR
.br
ENCRYPTED
.br
UNENCRYPTED
.br
VALID UNTIL \*(Aq\fItimestamp\fR\*(Aq
.RS 4
These clauses alter attributes originally set by
CREATE ROLE (\fBCREATE_ROLE\fR(7))\&amp;. For more information, see the
\fBCREATE ROLE\fR
reference page\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the role\&amp;.
.RE
.PP
\fIdatabase_name\fR
.RS 4
The name of the database the configuration variable should be set in\&amp;.
.RE
.PP
\fIconfiguration_parameter\fR
.br
\fIvalue\fR
.RS 4
Set this role\*(Aqs session default for the specified configuration parameter to the given value\&amp;. If
\fIvalue\fR
is
DEFAULT
or, equivalently,
RESET
is used, the role\-specific variable setting is removed, so the role will inherit the system\-wide default setting in new sessions\&amp;. Use
RESET ALL
to clear all role\-specific settings\&amp;.
SET FROM CURRENT
saves the session\*(Aqs current value of the parameter as the role\-specific value\&amp;. If
IN DATABASE
is specified, the configuration parameter is set or removed for the given role and database only\&amp;.
.sp
Role\-specific variable settings take effect only at login;
SET ROLE (\fBSET_ROLE\fR(7))
and
SET SESSION AUTHORIZATION (\fBSET_SESSION_AUTHORIZATION\fR(7))
do not process role\-specific variable settings\&amp;.
.sp
See
\fBSET\fR(7)
and
Chapter 19, Server Configuration, in the documentation
for more information about allowed parameter names and values\&amp;.
.RE
.SH "NOTES"
.PP
Use
CREATE ROLE (\fBCREATE_ROLE\fR(7))
to add new roles, and
DROP ROLE (\fBDROP_ROLE\fR(7))
to remove a role\&amp;.
.PP
\fBALTER ROLE\fR
cannot change a role\*(Aqs memberships\&amp;. Use
\fBGRANT\fR(7)
and
\fBREVOKE\fR(7)
to do that\&amp;.
.PP
Caution must be exercised when specifying an unencrypted password with this command\&amp;. The password will be transmitted to the server in cleartext, and it might also be logged in the client\*(Aqs command history or the server log\&amp;.
\fBpsql\fR(1)
contains a command
\fB\epassword\fR
that can be used to change a role\*(Aqs password without exposing the cleartext password\&amp;.
.PP
It is also possible to tie a session default to a specific database rather than to a role; see
ALTER DATABASE (\fBALTER_DATABASE\fR(7))\&amp;. If there is a conflict, database\-role\-specific settings override role\-specific ones, which in turn override database\-specific ones\&amp;.
.SH "EXAMPLES"
.PP
Change a role\*(Aqs password:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER ROLE davide WITH PASSWORD \*(Aqhu8jmn3\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Remove a role\*(Aqs password:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER ROLE davide WITH PASSWORD NULL;
.fi
.if n \{\
.RE
.\}
.PP
Change a password expiration date, specifying that the password should expire at midday on 4th May 2015 using the time zone which is one hour ahead of
UTC:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER ROLE chris VALID UNTIL \*(AqMay 4 12:00:00 2015 +1\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Make a password valid forever:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER ROLE fred VALID UNTIL \*(Aqinfinity\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Give a role the ability to create other roles and new databases:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER ROLE miriam CREATEROLE CREATEDB;
.fi
.if n \{\
.RE
.\}
.PP
Give a role a non\-default setting of the
maintenance_work_mem
parameter:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER ROLE worker_bee SET maintenance_work_mem = 100000;
.fi
.if n \{\
.RE
.\}
.PP
Give a role a non\-default, database\-specific setting of the
client_min_messages
parameter:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER ROLE fred IN DATABASE devel SET client_min_messages = DEBUG;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBALTER ROLE\fR
statement is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE ROLE (\fBCREATE_ROLE\fR(7)), DROP ROLE (\fBDROP_ROLE\fR(7)), ALTER DATABASE (\fBALTER_DATABASE\fR(7)), \fBSET\fR(7)
'\" t
.\"     Title: ALTER RULE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER RULE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_RULE \- change the definition of a rule
.SH "SYNOPSIS"
.sp
.nf
ALTER RULE \fIname\fR ON \fItable_name\fR RENAME TO \fInew_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER RULE\fR
changes properties of an existing rule\&amp;. Currently, the only available action is to change the rule\*(Aqs name\&amp;.
.PP
To use
\fBALTER RULE\fR, you must own the table or view that the rule applies to\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an existing rule to alter\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table or view that the rule applies to\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the rule\&amp;.
.RE
.SH "EXAMPLES"
.PP
To rename an existing rule:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER RULE notify_all ON emp RENAME TO notify_me;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER RULE\fR
is a
PostgreSQL
language extension, as is the entire query rewrite system\&amp;.
.SH "SEE ALSO"
CREATE RULE (\fBCREATE_RULE\fR(7)), DROP RULE (\fBDROP_RULE\fR(7))
'\" t
.\"     Title: ALTER SCHEMA
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER SCHEMA" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_SCHEMA \- change the definition of a schema
.SH "SYNOPSIS"
.sp
.nf
ALTER SCHEMA \fIname\fR RENAME TO \fInew_name\fR
ALTER SCHEMA \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
.fi
.SH "DESCRIPTION"
.PP
\fBALTER SCHEMA\fR
changes the definition of a schema\&amp;.
.PP
You must own the schema to use
\fBALTER SCHEMA\fR\&amp;. To rename a schema you must also have the
CREATE
privilege for the database\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and you must have the
CREATE
privilege for the database\&amp;. (Note that superusers have all these privileges automatically\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an existing schema\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the schema\&amp;. The new name cannot begin with
pg_, as such names are reserved for system schemas\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the schema\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER SCHEMA\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE SCHEMA (\fBCREATE_SCHEMA\fR(7)), DROP SCHEMA (\fBDROP_SCHEMA\fR(7))
'\" t
.\"     Title: ALTER SEQUENCE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER SEQUENCE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_SEQUENCE \- change the definition of a sequence generator
.SH "SYNOPSIS"
.sp
.nf
ALTER SEQUENCE [ IF EXISTS ] \fIname\fR [ INCREMENT [ BY ] \fIincrement\fR ]
[ MINVALUE \fIminvalue\fR | NO MINVALUE ] [ MAXVALUE \fImaxvalue\fR | NO MAXVALUE ]
[ START [ WITH ] \fIstart\fR ]
[ RESTART [ [ WITH ] \fIrestart\fR ] ]
[ CACHE \fIcache\fR ] [ [ NO ] CYCLE ]
[ OWNED BY { \fItable_name\fR\&amp;.\fIcolumn_name\fR | NONE } ]
ALTER SEQUENCE [ IF EXISTS ] \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER SEQUENCE [ IF EXISTS ] \fIname\fR RENAME TO \fInew_name\fR
ALTER SEQUENCE [ IF EXISTS ] \fIname\fR SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER SEQUENCE\fR
changes the parameters of an existing sequence generator\&amp;. Any parameters not specifically set in the
\fBALTER SEQUENCE\fR
command retain their prior settings\&amp;.
.PP
You must own the sequence to use
\fBALTER SEQUENCE\fR\&amp;. To change a sequence\*(Aqs schema, you must also have
CREATE
privilege on the new schema\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the sequence\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the sequence\&amp;. However, a superuser can alter ownership of any sequence anyway\&amp;.)
.SH "PARAMETERS"
.PP
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of a sequence to be altered\&amp;.
.RE
.PP
IF EXISTS
.RS 4
Do not throw an error if the sequence does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIincrement\fR
.RS 4
The clause
INCREMENT BY \fIincrement\fR
is optional\&amp;. A positive value will make an ascending sequence, a negative one a descending sequence\&amp;. If unspecified, the old increment value will be maintained\&amp;.
.RE
.PP
\fIminvalue\fR
.br
NO MINVALUE
.RS 4
The optional clause
MINVALUE \fIminvalue\fR
determines the minimum value a sequence can generate\&amp;. If
NO MINVALUE
is specified, the defaults of 1 and \-2^63\-1 for ascending and descending sequences, respectively, will be used\&amp;. If neither option is specified, the current minimum value will be maintained\&amp;.
.RE
.PP
\fImaxvalue\fR
.br
NO MAXVALUE
.RS 4
The optional clause
MAXVALUE \fImaxvalue\fR
determines the maximum value for the sequence\&amp;. If
NO MAXVALUE
is specified, the defaults are 2^63\-1 and \-1 for ascending and descending sequences, respectively, will be used\&amp;. If neither option is specified, the current maximum value will be maintained\&amp;.
.RE
.PP
\fIstart\fR
.RS 4
The optional clause
START WITH \fIstart\fR
changes the recorded start value of the sequence\&amp;. This has no effect on the
\fIcurrent\fR
sequence value; it simply sets the value that future
\fBALTER SEQUENCE RESTART\fR
commands will use\&amp;.
.RE
.PP
\fIrestart\fR
.RS 4
The optional clause
RESTART [ WITH \fIrestart\fR ]
changes the current value of the sequence\&amp;. This is equivalent to calling the
\fBsetval\fR
function with
is_called
=
false: the specified value will be returned by the
\fInext\fR
call of
\fBnextval\fR\&amp;. Writing
RESTART
with no
\fIrestart\fR
value is equivalent to supplying the start value that was recorded by
\fBCREATE SEQUENCE\fR
or last set by
\fBALTER SEQUENCE START WITH\fR\&amp;.
.RE
.PP
\fIcache\fR
.RS 4
The clause
CACHE \fIcache\fR
enables sequence numbers to be preallocated and stored in memory for faster access\&amp;. The minimum value is 1 (only one value can be generated at a time, i\&amp;.e\&amp;., no cache)\&amp;. If unspecified, the old cache value will be maintained\&amp;.
.RE
.PP
CYCLE
.RS 4
The optional
CYCLE
key word can be used to enable the sequence to wrap around when the
\fImaxvalue\fR
or
\fIminvalue\fR
has been reached by an ascending or descending sequence respectively\&amp;. If the limit is reached, the next number generated will be the
\fIminvalue\fR
or
\fImaxvalue\fR, respectively\&amp;.
.RE
.PP
NO CYCLE
.RS 4
If the optional
NO CYCLE
key word is specified, any calls to
\fBnextval\fR
after the sequence has reached its maximum value will return an error\&amp;. If neither
CYCLE
or
NO CYCLE
are specified, the old cycle behavior will be maintained\&amp;.
.RE
.PP
OWNED BY \fItable_name\fR\&amp;.\fIcolumn_name\fR
.br
OWNED BY NONE
.RS 4
The
OWNED BY
option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well\&amp;. If specified, this association replaces any previously specified association for the sequence\&amp;. The specified table must have the same owner and be in the same schema as the sequence\&amp;. Specifying
OWNED BY NONE
removes any existing association, making the sequence
\(lqfree\-standing\(rq\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the sequence\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the sequence\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the sequence\&amp;.
.RE
.SH "NOTES"
.PP
To avoid blocking of concurrent transactions that obtain numbers from the same sequence,
\fBALTER SEQUENCE\fR\*(Aqs effects on the sequence generation parameters are never rolled back; those changes take effect immediately and are not reversible\&amp;. However, the
OWNED BY,
OWNER TO,
RENAME TO, and
SET SCHEMA
clauses cause ordinary catalog updates that can be rolled back\&amp;.
.PP
\fBALTER SEQUENCE\fR
will not immediately affect
\fBnextval\fR
results in backends, other than the current one, that have preallocated (cached) sequence values\&amp;. They will use up all cached values prior to noticing the changed sequence generation parameters\&amp;. The current backend will be affected immediately\&amp;.
.PP
\fBALTER SEQUENCE\fR
does not affect the
\fBcurrval\fR
status for the sequence\&amp;. (Before
PostgreSQL
8\&amp;.3, it sometimes did\&amp;.)
.PP
For historical reasons,
\fBALTER TABLE\fR
can be used with sequences too; but the only variants of
\fBALTER TABLE\fR
that are allowed with sequences are equivalent to the forms shown above\&amp;.
.SH "EXAMPLES"
.PP
Restart a sequence called
serial, at 105:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER SEQUENCE serial RESTART WITH 105;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER SEQUENCE\fR
conforms to the
SQL
standard, except for the
START WITH,
OWNED BY,
OWNER TO,
RENAME TO, and
SET SCHEMA
clauses, which are
PostgreSQL
extensions\&amp;.
.SH "SEE ALSO"
CREATE SEQUENCE (\fBCREATE_SEQUENCE\fR(7)), DROP SEQUENCE (\fBDROP_SEQUENCE\fR(7))
'\" t
.\"     Title: ALTER SERVER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER SERVER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_SERVER \- change the definition of a foreign server
.SH "SYNOPSIS"
.sp
.nf
ALTER SERVER \fIname\fR [ VERSION \*(Aq\fInew_version\fR\*(Aq ]
[ OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ] ) ]
ALTER SERVER \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER SERVER \fIname\fR RENAME TO \fInew_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER SERVER\fR
changes the definition of a foreign server\&amp;. The first form changes the server version string or the generic options of the server (at least one clause is required)\&amp;. The second form changes the owner of the server\&amp;.
.PP
To alter the server you must be the owner of the server\&amp;. Additionally to alter the owner, you must own the server and also be a direct or indirect member of the new owning role, and you must have
USAGE
privilege on the server\*(Aqs foreign\-data wrapper\&amp;. (Note that superusers satisfy all these criteria automatically\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an existing server\&amp;.
.RE
.PP
\fInew_version\fR
.RS 4
New server version\&amp;.
.RE
.PP
OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
Change options for the server\&amp;.
ADD,
SET, and
DROP
specify the action to be performed\&amp;.
ADD
is assumed if no operation is explicitly specified\&amp;. Option names must be unique; names and values are also validated using the server\*(Aqs foreign\-data wrapper library\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the foreign server\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the foreign server\&amp;.
.RE
.SH "EXAMPLES"
.PP
Alter server
foo, add connection options:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER SERVER foo OPTIONS (host \*(Aqfoo\*(Aq, dbname \*(Aqfoodb\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
Alter server
foo, change version, change
host
option:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER SERVER foo VERSION \*(Aq8\&amp;.4\*(Aq OPTIONS (SET host \*(Aqbaz\*(Aq);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER SERVER\fR
conforms to ISO/IEC 9075\-9 (SQL/MED)\&amp;. The
OWNER TO
and
RENAME
forms are PostgreSQL extensions\&amp;.
.SH "SEE ALSO"
CREATE SERVER (\fBCREATE_SERVER\fR(7)), DROP SERVER (\fBDROP_SERVER\fR(7))
'\" t
.\"     Title: ALTER SYSTEM
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER SYSTEM" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_SYSTEM \- change a server configuration parameter
.SH "SYNOPSIS"
.sp
.nf
ALTER SYSTEM SET \fIconfiguration_parameter\fR { TO | = } { \fIvalue\fR | \*(Aq\fIvalue\fR\*(Aq | DEFAULT }

ALTER SYSTEM RESET \fIconfiguration_parameter\fR
ALTER SYSTEM RESET ALL
.fi
.SH "DESCRIPTION"
.PP
\fBALTER SYSTEM\fR
is used for changing server configuration parameters across the entire database cluster\&amp;. It can be more convenient than the traditional method of manually editing the
postgresql\&amp;.conf
file\&amp;.
\fBALTER SYSTEM\fR
writes the given parameter setting to the
postgresql\&amp;.auto\&amp;.conf
file, which is read in addition to
postgresql\&amp;.conf\&amp;. Setting a parameter to
DEFAULT, or using the
\fBRESET\fR
variant, removes that configuration entry from the
postgresql\&amp;.auto\&amp;.conf
file\&amp;. Use
RESET ALL
to remove all such configuration entries\&amp;.
.PP
Values set with
\fBALTER SYSTEM\fR
will be effective after the next server configuration reload, or after the next server restart in the case of parameters that can only be changed at server start\&amp;. A server configuration reload can be commanded by calling the SQL function
\fBpg_reload_conf()\fR, running
pg_ctl reload, or sending a
SIGHUP
signal to the main server process\&amp;.
.PP
Only superusers can use
\fBALTER SYSTEM\fR\&amp;. Also, since this command acts directly on the file system and cannot be rolled back, it is not allowed inside a transaction block or function\&amp;.
.SH "PARAMETERS"
.PP
\fIconfiguration_parameter\fR
.RS 4
Name of a settable configuration parameter\&amp;. Available parameters are documented in
Chapter 19, Server Configuration, in the documentation\&amp;.
.RE
.PP
\fIvalue\fR
.RS 4
New value of the parameter\&amp;. Values can be specified as string constants, identifiers, numbers, or comma\-separated lists of these, as appropriate for the particular parameter\&amp;.
DEFAULT
can be written to specify removing the parameter and its value from
postgresql\&amp;.auto\&amp;.conf\&amp;.
.RE
.SH "NOTES"
.PP
This command can\*(Aqt be used to set
data_directory, nor parameters that are not allowed in
postgresql\&amp;.conf
(e\&amp;.g\&amp;.,
preset options)\&amp;.
.PP
See
Section 19.1, \(lqSetting Parameters\(rq, in the documentation
for other ways to set the parameters\&amp;.
.SH "EXAMPLES"
.PP
Set the
wal_level:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER SYSTEM SET wal_level = replica;
.fi
.if n \{\
.RE
.\}
.PP
Undo that, restoring whatever setting was effective in
postgresql\&amp;.conf:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER SYSTEM RESET wal_level;
.fi
.if n \{\
.RE
.\}
.sp
.SH "COMPATIBILITY"
.PP
The
\fBALTER SYSTEM\fR
statement is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
\fBSET\fR(7), \fBSHOW\fR(7)
'\" t
.\"     Title: ALTER TABLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER TABLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_TABLE \- change the definition of a table
.SH "SYNOPSIS"
.sp
.nf
ALTER TABLE [ IF EXISTS ] [ ONLY ] \fIname\fR [ * ]
\fIaction\fR [, \&amp;.\&amp;.\&amp;. ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] \fIname\fR [ * ]
RENAME [ COLUMN ] \fIcolumn_name\fR TO \fInew_column_name\fR
ALTER TABLE [ IF EXISTS ] [ ONLY ] \fIname\fR [ * ]
RENAME CONSTRAINT \fIconstraint_name\fR TO \fInew_constraint_name\fR
ALTER TABLE [ IF EXISTS ] \fIname\fR
RENAME TO \fInew_name\fR
ALTER TABLE [ IF EXISTS ] \fIname\fR
SET SCHEMA \fInew_schema\fR
ALTER TABLE ALL IN TABLESPACE \fIname\fR [ OWNED BY \fIrole_name\fR [, \&amp;.\&amp;.\&amp;. ] ]
SET TABLESPACE \fInew_tablespace\fR [ NOWAIT ]

where \fIaction\fR is one of:

ADD [ COLUMN ] [ IF NOT EXISTS ] \fIcolumn_name\fR \fIdata_type\fR [ COLLATE \fIcollation\fR ] [ \fIcolumn_constraint\fR [ \&amp;.\&amp;.\&amp;. ] ]
DROP [ COLUMN ] [ IF EXISTS ] \fIcolumn_name\fR [ RESTRICT | CASCADE ]
ALTER [ COLUMN ] \fIcolumn_name\fR [ SET DATA ] TYPE \fIdata_type\fR [ COLLATE \fIcollation\fR ] [ USING \fIexpression\fR ]
ALTER [ COLUMN ] \fIcolumn_name\fR SET DEFAULT \fIexpression\fR
ALTER [ COLUMN ] \fIcolumn_name\fR DROP DEFAULT
ALTER [ COLUMN ] \fIcolumn_name\fR { SET | DROP } NOT NULL
ALTER [ COLUMN ] \fIcolumn_name\fR SET STATISTICS \fIinteger\fR
ALTER [ COLUMN ] \fIcolumn_name\fR SET ( \fIattribute_option\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER [ COLUMN ] \fIcolumn_name\fR RESET ( \fIattribute_option\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER [ COLUMN ] \fIcolumn_name\fR SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
ADD \fItable_constraint\fR [ NOT VALID ]
ADD \fItable_constraint_using_index\fR
ALTER CONSTRAINT \fIconstraint_name\fR [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
VALIDATE CONSTRAINT \fIconstraint_name\fR
DROP CONSTRAINT [ IF EXISTS ]  \fIconstraint_name\fR [ RESTRICT | CASCADE ]
DISABLE TRIGGER [ \fItrigger_name\fR | ALL | USER ]
ENABLE TRIGGER [ \fItrigger_name\fR | ALL | USER ]
ENABLE REPLICA TRIGGER \fItrigger_name\fR
ENABLE ALWAYS TRIGGER \fItrigger_name\fR
DISABLE RULE \fIrewrite_rule_name\fR
ENABLE RULE \fIrewrite_rule_name\fR
ENABLE REPLICA RULE \fIrewrite_rule_name\fR
ENABLE ALWAYS RULE \fIrewrite_rule_name\fR
DISABLE ROW LEVEL SECURITY
ENABLE ROW LEVEL SECURITY
FORCE ROW LEVEL SECURITY
NO FORCE ROW LEVEL SECURITY
CLUSTER ON \fIindex_name\fR
SET WITHOUT CLUSTER
SET WITH OIDS
SET WITHOUT OIDS
SET TABLESPACE \fInew_tablespace\fR
SET { LOGGED | UNLOGGED }
SET ( \fIstorage_parameter\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
RESET ( \fIstorage_parameter\fR [, \&amp;.\&amp;.\&amp;. ] )
INHERIT \fIparent_table\fR
NO INHERIT \fIparent_table\fR
OF \fItype_name\fR
NOT OF
OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
REPLICA IDENTITY { DEFAULT | USING INDEX \fIindex_name\fR | FULL | NOTHING }

and \fItable_constraint_using_index\fR is:

[ CONSTRAINT \fIconstraint_name\fR ]
{ UNIQUE | PRIMARY KEY } USING INDEX \fIindex_name\fR
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
.fi
.SH "DESCRIPTION"
.PP
\fBALTER TABLE\fR
changes the definition of an existing table\&amp;. There are several subforms described below\&amp;. Note that the lock level required may differ for each subform\&amp;. An
ACCESS EXCLUSIVE
lock is held unless explicitly noted\&amp;. When multiple subcommands are listed, the lock held will be the strictest one required from any subcommand\&amp;.
.PP
ADD COLUMN [ IF NOT EXISTS ]
.RS 4
This form adds a new column to the table, using the same syntax as
CREATE TABLE (\fBCREATE_TABLE\fR(7))\&amp;. If
IF NOT EXISTS
is specified and a column already exists with this name, no error is thrown\&amp;.
.RE
.PP
DROP COLUMN [ IF EXISTS ]
.RS 4
This form drops a column from a table\&amp;. Indexes and table constraints involving the column will be automatically dropped as well\&amp;. You will need to say
CASCADE
if anything outside the table depends on the column, for example, foreign key references or views\&amp;. If
IF EXISTS
is specified and the column does not exist, no error is thrown\&amp;. In this case a notice is issued instead\&amp;.
.RE
.PP
SET DATA TYPE
.RS 4
This form changes the type of a column of a table\&amp;. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression\&amp;. The optional
COLLATE
clause specifies a collation for the new column; if omitted, the collation is the default for the new column type\&amp;. The optional
USING
clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new\&amp;. A
USING
clause must be provided if there is no implicit or assignment cast from old to new type\&amp;.
.RE
.PP
SET/DROP DEFAULT
.RS 4
These forms set or remove the default value for a column\&amp;. Default values only apply in subsequent
\fBINSERT\fR
or
\fBUPDATE\fR
commands; they do not cause rows already in the table to change\&amp;.
.RE
.PP
SET/DROP NOT NULL
.RS 4
These forms change whether a column is marked to allow null values or to reject null values\&amp;. You can only use
SET NOT NULL
when the column contains no null values\&amp;.
.RE
.PP
SET STATISTICS
.RS 4
This form sets the per\-column statistics\-gathering target for subsequent
\fBANALYZE\fR(7)
operations\&amp;. The target can be set in the range 0 to 10000; alternatively, set it to \-1 to revert to using the system default statistics target (default_statistics_target)\&amp;. For more information on the use of statistics by the
PostgreSQL
query planner, refer to
Section 14.2, \(lqStatistics Used by the Planner\(rq, in the documentation\&amp;.
.sp
SET STATISTICS
acquires a
SHARE UPDATE EXCLUSIVE
lock\&amp;.
.RE
.PP
SET ( \fIattribute_option\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
.br
RESET ( \fIattribute_option\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This form sets or resets per\-attribute options\&amp;. Currently, the only defined per\-attribute options are
n_distinct
and
n_distinct_inherited, which override the number\-of\-distinct\-values estimates made by subsequent
\fBANALYZE\fR(7)
operations\&amp;.
n_distinct
affects the statistics for the table itself, while
n_distinct_inherited
affects the statistics gathered for the table plus its inheritance children\&amp;. When set to a positive value,
\fBANALYZE\fR
will assume that the column contains exactly the specified number of distinct nonnull values\&amp;. When set to a negative value, which must be greater than or equal to \-1,
\fBANALYZE\fR
will assume that the number of distinct nonnull values in the column is linear in the size of the table; the exact count is to be computed by multiplying the estimated table size by the absolute value of the given number\&amp;. For example, a value of \-1 implies that all values in the column are distinct, while a value of \-0\&amp;.5 implies that each value appears twice on the average\&amp;. This can be useful when the size of the table changes over time, since the multiplication by the number of rows in the table is not performed until query planning time\&amp;. Specify a value of 0 to revert to estimating the number of distinct values normally\&amp;. For more information on the use of statistics by the
PostgreSQL
query planner, refer to
Section 14.2, \(lqStatistics Used by the Planner\(rq, in the documentation\&amp;.
.sp
Changing per\-attribute options acquires a
SHARE UPDATE EXCLUSIVE
lock\&amp;.
.RE
.PP
SET STORAGE
.RS 4
This form sets the storage mode for a column\&amp;. This controls whether this column is held inline or in a secondary
TOAST
table, and whether the data should be compressed or not\&amp;.
PLAIN
must be used for fixed\-length values such as
integer
and is inline, uncompressed\&amp;.
MAIN
is for inline, compressible data\&amp;.
EXTERNAL
is for external, uncompressed data, and
EXTENDED
is for external, compressed data\&amp;.
EXTENDED
is the default for most data types that support non\-PLAIN
storage\&amp;. Use of
EXTERNAL
will make substring operations on very large
text
and
bytea
values run faster, at the penalty of increased storage space\&amp;. Note that
SET STORAGE
doesn\*(Aqt itself change anything in the table, it just sets the strategy to be pursued during future table updates\&amp;. See
Section 65.2, \(lqTOAST\(rq, in the documentation
for more information\&amp;.
.RE
.PP
ADD \fItable_constraint\fR [ NOT VALID ]
.RS 4
This form adds a new constraint to a table using the same syntax as
CREATE TABLE (\fBCREATE_TABLE\fR(7)), plus the option
NOT VALID, which is currently only allowed for foreign key and CHECK constraints\&amp;. If the constraint is marked
NOT VALID, the potentially\-lengthy initial check to verify that all rows in the table satisfy the constraint is skipped\&amp;. The constraint will still be enforced against subsequent inserts or updates (that is, they\*(Aqll fail unless there is a matching row in the referenced table, in the case of foreign keys; and they\*(Aqll fail unless the new row matches the specified check constraints)\&amp;. But the database will not assume that the constraint holds for all rows in the table, until it is validated by using the
VALIDATE CONSTRAINT
option\&amp;.
.RE
.PP
ADD \fItable_constraint_using_index\fR
.RS 4
This form adds a new
PRIMARY KEY
or
UNIQUE
constraint to a table based on an existing unique index\&amp;. All the columns of the index will be included in the constraint\&amp;.
.sp
The index cannot have expression columns nor be a partial index\&amp;. Also, it must be a b\-tree index with default sort ordering\&amp;. These restrictions ensure that the index is equivalent to one that would be built by a regular
ADD PRIMARY KEY
or
ADD UNIQUE
command\&amp;.
.sp
If
PRIMARY KEY
is specified, and the index\*(Aqs columns are not already marked
NOT NULL, then this command will attempt to do
ALTER COLUMN SET NOT NULL
against each such column\&amp;. That requires a full table scan to verify the column(s) contain no nulls\&amp;. In all other cases, this is a fast operation\&amp;.
.sp
If a constraint name is provided then the index will be renamed to match the constraint name\&amp;. Otherwise the constraint will be named the same as the index\&amp;.
.sp
After this command is executed, the index is
\(lqowned\(rq
by the constraint, in the same way as if the index had been built by a regular
ADD PRIMARY KEY
or
ADD UNIQUE
command\&amp;. In particular, dropping the constraint will make the index disappear too\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time\&amp;. To do that, create the index using
\fBCREATE INDEX CONCURRENTLY\fR, and then install it as an official constraint using this syntax\&amp;. See the example below\&amp;.
.sp .5v
.RE
.RE
.PP
ALTER CONSTRAINT
.RS 4
This form alters the attributes of a constraint that was previously created\&amp;. Currently only foreign key constraints may be altered\&amp;.
.RE
.PP
VALIDATE CONSTRAINT
.RS 4
This form validates a foreign key or check constraint that was previously created as
NOT VALID, by scanning the table to ensure there are no rows for which the constraint is not satisfied\&amp;. Nothing happens if the constraint is already marked valid\&amp;.
.sp
Validation can be a long process on larger tables\&amp;. The value of separating validation from initial creation is that you can defer validation to less busy times, or can be used to give additional time to correct pre\-existing errors while preventing new errors\&amp;. Note also that validation on its own does not prevent normal write commands against the table while it runs\&amp;.
.sp
Validation acquires only a
SHARE UPDATE EXCLUSIVE
lock on the table being altered\&amp;. If the constraint is a foreign key then a
ROW SHARE
lock is also required on the table referenced by the constraint\&amp;.
.RE
.PP
DROP CONSTRAINT [ IF EXISTS ]
.RS 4
This form drops the specified constraint on a table\&amp;. If
IF EXISTS
is specified and the constraint does not exist, no error is thrown\&amp;. In this case a notice is issued instead\&amp;.
.RE
.PP
DISABLE/ENABLE [ REPLICA | ALWAYS ] TRIGGER
.RS 4
These forms configure the firing of trigger(s) belonging to the table\&amp;. A disabled trigger is still known to the system, but is not executed when its triggering event occurs\&amp;. For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed\&amp;. One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints)\&amp;. Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed\&amp;. The trigger firing mechanism is also affected by the configuration variable
session_replication_role\&amp;. Simply enabled triggers will fire when the replication role is
\(lqorigin\(rq
(the default) or
\(lqlocal\(rq\&amp;. Triggers configured as
ENABLE REPLICA
will only fire if the session is in
\(lqreplica\(rq
mode, and triggers configured as
ENABLE ALWAYS
will fire regardless of the current replication mode\&amp;.
.sp
This command acquires a
SHARE ROW EXCLUSIVE
lock\&amp;.
.RE
.PP
DISABLE/ENABLE [ REPLICA | ALWAYS ] RULE
.RS 4
These forms configure the firing of rewrite rules belonging to the table\&amp;. A disabled rule is still known to the system, but is not applied during query rewriting\&amp;. The semantics are as for disabled/enabled triggers\&amp;. This configuration is ignored for
ON SELECT
rules, which are always applied in order to keep views working even if the current session is in a non\-default replication role\&amp;.
.RE
.PP
DISABLE/ENABLE ROW LEVEL SECURITY
.RS 4
These forms control the application of row security policies belonging to the table\&amp;. If enabled and no policies exist for the table, then a default\-deny policy is applied\&amp;. Note that policies can exist for a table even if row level security is disabled \- in this case, the policies will NOT be applied and the policies will be ignored\&amp;. See also
CREATE POLICY (\fBCREATE_POLICY\fR(7))\&amp;.
.RE
.PP
NO FORCE/FORCE ROW LEVEL SECURITY
.RS 4
These forms control the application of row security policies belonging to the table when the user is the table owner\&amp;. If enabled, row level security policies will be applied when the user is the table owner\&amp;. If disabled (the default) then row level security will not be applied when the user is the table owner\&amp;. See also
CREATE POLICY (\fBCREATE_POLICY\fR(7))\&amp;.
.RE
.PP
CLUSTER ON
.RS 4
This form selects the default index for future
\fBCLUSTER\fR(7)
operations\&amp;. It does not actually re\-cluster the table\&amp;.
.sp
Changing cluster options acquires a
SHARE UPDATE EXCLUSIVE
lock\&amp;.
.RE
.PP
SET WITHOUT CLUSTER
.RS 4
This form removes the most recently used
\fBCLUSTER\fR(7)
index specification from the table\&amp;. This affects future cluster operations that don\*(Aqt specify an index\&amp;.
.sp
Changing cluster options acquires a
SHARE UPDATE EXCLUSIVE
lock\&amp;.
.RE
.PP
SET WITH OIDS
.RS 4
This form adds an
oid
system column to the table (see
Section 5.4, \(lqSystem Columns\(rq, in the documentation)\&amp;. It does nothing if the table already has OIDs\&amp;.
.sp
Note that this is not equivalent to
ADD COLUMN oid oid; that would add a normal column that happened to be named
oid, not a system column\&amp;.
.RE
.PP
SET WITHOUT OIDS
.RS 4
This form removes the
oid
system column from the table\&amp;. This is exactly equivalent to
DROP COLUMN oid RESTRICT, except that it will not complain if there is already no
oid
column\&amp;.
.RE
.PP
SET TABLESPACE
.RS 4
This form changes the table\*(Aqs tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace\&amp;. Indexes on the table, if any, are not moved; but they can be moved separately with additional
SET TABLESPACE
commands\&amp;. All tables in the current database in a tablespace can be moved by using the
ALL IN TABLESPACE
form, which will lock all tables to be moved first and then move each one\&amp;. This form also supports
OWNED BY, which will only move tables owned by the roles specified\&amp;. If the
NOWAIT
option is specified then the command will fail if it is unable to acquire all of the locks required immediately\&amp;. Note that system catalogs are not moved by this command, use
\fBALTER DATABASE\fR
or explicit
\fBALTER TABLE\fR
invocations instead if desired\&amp;. The
information_schema
relations are not considered part of the system catalogs and will be moved\&amp;. See also
CREATE TABLESPACE (\fBCREATE_TABLESPACE\fR(7))\&amp;.
.RE
.PP
SET { LOGGED | UNLOGGED }
.RS 4
This form changes the table from unlogged to logged or vice\-versa (see
UNLOGGED)\&amp;. It cannot be applied to a temporary table\&amp;.
.RE
.PP
SET ( \fIstorage_parameter\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This form changes one or more storage parameters for the table\&amp;. See
Storage Parameters
for details on the available parameters\&amp;. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects\&amp;. That can be done with
VACUUM FULL,
\fBCLUSTER\fR(7)
or one of the forms of
\fBALTER TABLE\fR
that forces a table rewrite\&amp;.
.sp
Changing fillfactor and autovacuum storage parameters acquires a
SHARE UPDATE EXCLUSIVE
lock\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
While
\fBCREATE TABLE\fR
allows
OIDS
to be specified in the
WITH (\fIstorage_parameter\fR)
syntax,
\fBALTER TABLE\fR
does not treat
OIDS
as a storage parameter\&amp;. Instead use the
SET WITH OIDS
and
SET WITHOUT OIDS
forms to change OID status\&amp;.
.sp .5v
.RE
.RE
.PP
RESET ( \fIstorage_parameter\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This form resets one or more storage parameters to their defaults\&amp;. As with
SET, a table rewrite might be needed to update the table entirely\&amp;.
.RE
.PP
INHERIT \fIparent_table\fR
.RS 4
This form adds the target table as a new child of the specified parent table\&amp;. Subsequently, queries against the parent will include records of the target table\&amp;. To be added as a child, the target table must already contain all the same columns as the parent (it could have additional columns, too)\&amp;. The columns must have matching data types, and if they have
NOT NULL
constraints in the parent then they must also have
NOT NULL
constraints in the child\&amp;.
.sp
There must also be matching child\-table constraints for all
CHECK
constraints of the parent, except those marked non\-inheritable (that is, created with
ALTER TABLE \&amp;.\&amp;.\&amp;. ADD CONSTRAINT \&amp;.\&amp;.\&amp;. NO INHERIT) in the parent, which are ignored; all child\-table constraints matched must not be marked non\-inheritable\&amp;. Currently
UNIQUE,
PRIMARY KEY, and
FOREIGN KEY
constraints are not considered, but this might change in the future\&amp;.
.RE
.PP
NO INHERIT \fIparent_table\fR
.RS 4
This form removes the target table from the list of children of the specified parent table\&amp;. Queries against the parent table will no longer include records drawn from the target table\&amp;.
.RE
.PP
OF \fItype_name\fR
.RS 4
This form links the table to a composite type as though
\fBCREATE TABLE OF\fR
had formed it\&amp;. The table\*(Aqs list of column names and types must precisely match that of the composite type; the presence of an
oid
system column is permitted to differ\&amp;. The table must not inherit from any other table\&amp;. These restrictions ensure that
\fBCREATE TABLE OF\fR
would permit an equivalent table definition\&amp;.
.RE
.PP
NOT OF
.RS 4
This form dissociates a typed table from its type\&amp;.
.RE
.PP
OWNER
.RS 4
This form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user\&amp;.
.RE
.PP
REPLICA IDENTITY
.RS 4
This form changes the information which is written to the write\-ahead log to identify rows which are updated or deleted\&amp;. This option has no effect except when logical replication is in use\&amp;.
DEFAULT
(the default for non\-system tables) records the old values of the columns of the primary key, if any\&amp;.
USING INDEX
records the old values of the columns covered by the named index, which must be unique, not partial, not deferrable, and include only columns marked
NOT NULL\&amp;.
FULL
records the old values of all columns in the row\&amp;.
NOTHING
records no information about the old row\&amp;. (This is the default for system tables\&amp;.) In all cases, no old values are logged unless at least one of the columns that would be logged differs between the old and new versions of the row\&amp;.
.RE
.PP
RENAME
.RS 4
The
RENAME
forms change the name of a table (or an index, sequence, view, materialized view, or foreign table), the name of an individual column in a table, or the name of a constraint of the table\&amp;. There is no effect on the stored data\&amp;.
.RE
.PP
SET SCHEMA
.RS 4
This form moves the table into another schema\&amp;. Associated indexes, constraints, and sequences owned by table columns are moved as well\&amp;.
.RE
.PP
All the actions except
RENAME,
SET TABLESPACE
and
SET SCHEMA
can be combined into a list of multiple alterations to apply in parallel\&amp;. For example, it is possible to add several columns and/or alter the type of several columns in a single command\&amp;. This is particularly useful with large tables, since only one pass over the table need be made\&amp;.
.PP
You must own the table to use
\fBALTER TABLE\fR\&amp;. To change the schema or tablespace of a table, you must also have
CREATE
privilege on the new schema or tablespace\&amp;. To add the table as a new child of a parent table, you must own the parent table as well\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the table\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the table\&amp;. However, a superuser can alter ownership of any table anyway\&amp;.) To add a column or alter a column type or use the
OF
clause, you must also have
USAGE
privilege on the data type\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the table does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing table to alter\&amp;. If
ONLY
is specified before the table name, only that table is altered\&amp;. If
ONLY
is not specified, the table and all its descendant tables (if any) are altered\&amp;. Optionally,
*
can be specified after the table name to explicitly indicate that descendant tables are included\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
Name of a new or existing column\&amp;.
.RE
.PP
\fInew_column_name\fR
.RS 4
New name for an existing column\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
New name for the table\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
Data type of the new column, or new data type for an existing column\&amp;.
.RE
.PP
\fItable_constraint\fR
.RS 4
New table constraint for the table\&amp;.
.RE
.PP
\fIconstraint_name\fR
.RS 4
Name of a new or existing constraint\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the column or constraint if there are any dependent objects\&amp;. This is the default behavior\&amp;.
.RE
.PP
\fItrigger_name\fR
.RS 4
Name of a single trigger to disable or enable\&amp;.
.RE
.PP
ALL
.RS 4
Disable or enable all triggers belonging to the table\&amp;. (This requires superuser privilege if any of the triggers are internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints\&amp;.)
.RE
.PP
USER
.RS 4
Disable or enable all triggers belonging to the table except for internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints\&amp;.
.RE
.PP
\fIindex_name\fR
.RS 4
The name of an existing index\&amp;.
.RE
.PP
\fIstorage_parameter\fR
.RS 4
The name of a table storage parameter\&amp;.
.RE
.PP
\fIvalue\fR
.RS 4
The new value for a table storage parameter\&amp;. This might be a number or a word depending on the parameter\&amp;.
.RE
.PP
\fIparent_table\fR
.RS 4
A parent table to associate or de\-associate with this table\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the table\&amp;.
.RE
.PP
\fInew_tablespace\fR
.RS 4
The name of the tablespace to which the table will be moved\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The name of the schema to which the table will be moved\&amp;.
.RE
.SH "NOTES"
.PP
The key word
COLUMN
is noise and can be omitted\&amp;.
.PP
When a column is added with
ADD COLUMN, all existing rows in the table are initialized with the column\*(Aqs default value (NULL if no
DEFAULT
clause is specified)\&amp;. If there is no
DEFAULT
clause, this is merely a metadata change and does not require any immediate update of the table\*(Aqs data; the added NULL values are supplied on readout, instead\&amp;.
.PP
Adding a column with a
DEFAULT
clause or changing the type of an existing column will require the entire table and its indexes to be rewritten\&amp;. As an exception when changing the type of an existing column, if the
USING
clause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed; but any indexes on the affected columns must still be rebuilt\&amp;. Adding or removing a system
oid
column also requires rewriting the entire table\&amp;. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space\&amp;.
.PP
Adding a
CHECK
or
NOT NULL
constraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite\&amp;.
.PP
The main reason for providing the option to specify multiple changes in a single
\fBALTER TABLE\fR
is that multiple table scans or rewrites can thereby be combined into a single pass over the table\&amp;.
.PP
The
DROP COLUMN
form does not physically remove the column, but simply makes it invisible to SQL operations\&amp;. Subsequent insert and update operations in the table will store a null value for the column\&amp;. Thus, dropping a column is quick but it will not immediately reduce the on\-disk size of your table, as the space occupied by the dropped column is not reclaimed\&amp;. The space will be reclaimed over time as existing rows are updated\&amp;. (These statements do not apply when dropping the system
oid
column; that is done with an immediate rewrite\&amp;.)
.PP
To force immediate reclamation of space occupied by a dropped column, you can execute one of the forms of
\fBALTER TABLE\fR
that performs a rewrite of the whole table\&amp;. This results in reconstructing each row with the dropped column replaced by a null value\&amp;.
.PP
The rewriting forms of
\fBALTER TABLE\fR
are not MVCC\-safe\&amp;. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred\&amp;. See
Section 13.5, \(lqCaveats\(rq, in the documentation
for more details\&amp;.
.PP
The
USING
option of
SET DATA TYPE
can actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted\&amp;. This allows very general conversions to be done with the
SET DATA TYPE
syntax\&amp;. Because of this flexibility, the
USING
expression is not applied to the column\*(Aqs default value (if any); the result might not be a constant expression as required for a default\&amp;. This means that when there is no implicit or assignment cast from old to new type,
SET DATA TYPE
might fail to convert the default even though a
USING
clause is supplied\&amp;. In such cases, drop the default with
DROP DEFAULT, perform the
ALTER TYPE, and then use
SET DEFAULT
to add a suitable new default\&amp;. Similar considerations apply to indexes and constraints involving the column\&amp;.
.PP
If a table has any descendant tables, it is not permitted to add, rename, or change the type of a column, or rename an inherited constraint in the parent table without doing the same to the descendants\&amp;. That is,
\fBALTER TABLE ONLY\fR
will be rejected\&amp;. This ensures that the descendants always have columns matching the parent\&amp;.
.PP
A recursive
DROP COLUMN
operation will remove a descendant table\*(Aqs column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column\&amp;. A nonrecursive
DROP COLUMN
(i\&amp;.e\&amp;.,
\fBALTER TABLE ONLY \&amp;.\&amp;.\&amp;. DROP COLUMN\fR) never removes any descendant columns, but instead marks them as independently defined rather than inherited\&amp;.
.PP
The
TRIGGER,
CLUSTER,
OWNER, and
TABLESPACE
actions never recurse to descendant tables; that is, they always act as though
ONLY
were specified\&amp;. Adding a constraint recurses only for
CHECK
constraints that are not marked
NO INHERIT\&amp;.
.PP
Changing any part of a system catalog table is not permitted\&amp;.
.PP
Refer to
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for a further description of valid parameters\&amp;.
Chapter 5, Data Definition, in the documentation
has further information on inheritance\&amp;.
.SH "EXAMPLES"
.PP
To add a column of type
varchar
to a table:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ADD COLUMN address varchar(30);
.fi
.if n \{\
.RE
.\}
.PP
To drop a column from a table:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors DROP COLUMN address RESTRICT;
.fi
.if n \{\
.RE
.\}
.PP
To change the types of two existing columns in one operation:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors
ALTER COLUMN address TYPE varchar(80),
ALTER COLUMN name TYPE varchar(100);
.fi
.if n \{\
.RE
.\}
.PP
To change an integer column containing Unix timestamps to
timestamp with time zone
via a
USING
clause:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE foo
ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
USING
timestamp with time zone \*(Aqepoch\*(Aq + foo_timestamp * interval \*(Aq1 second\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
The same, when the column has a default expression that won\*(Aqt automatically cast to the new data type:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE foo
ALTER COLUMN foo_timestamp DROP DEFAULT,
ALTER COLUMN foo_timestamp TYPE timestamp with time zone
USING
timestamp with time zone \*(Aqepoch\*(Aq + foo_timestamp * interval \*(Aq1 second\*(Aq,
ALTER COLUMN foo_timestamp SET DEFAULT now();
.fi
.if n \{\
.RE
.\}
.PP
To rename an existing column:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors RENAME COLUMN address TO city;
.fi
.if n \{\
.RE
.\}
.PP
To rename an existing table:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors RENAME TO suppliers;
.fi
.if n \{\
.RE
.\}
.PP
To rename an existing constraint:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
.fi
.if n \{\
.RE
.\}
.PP
To add a not\-null constraint to a column:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
.fi
.if n \{\
.RE
.\}
.sp
To remove a not\-null constraint from a column:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
.fi
.if n \{\
.RE
.\}
.PP
To add a check constraint to a table and all its children:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
.fi
.if n \{\
.RE
.\}
.PP
To add a check constraint only to a table and not to its children:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
.fi
.if n \{\
.RE
.\}
.sp
(The check constraint will not be inherited by future children, either\&amp;.)
.PP
To remove a check constraint from a table and all its children:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors DROP CONSTRAINT zipchk;
.fi
.if n \{\
.RE
.\}
.PP
To remove a check constraint from one table only:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
.fi
.if n \{\
.RE
.\}
.sp
(The check constraint remains in place for any child tables\&amp;.)
.PP
To add a foreign key constraint to a table:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
.fi
.if n \{\
.RE
.\}
.PP
To add a foreign key constraint to a table with the least impact on other work:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
.fi
.if n \{\
.RE
.\}
.PP
To add a (multicolumn) unique constraint to a table:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
.fi
.if n \{\
.RE
.\}
.PP
To add an automatically named primary key constraint to a table, noting that a table can only ever have one primary key:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
.fi
.if n \{\
.RE
.\}
.PP
To move a table to a different tablespace:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE distributors SET TABLESPACE fasttablespace;
.fi
.if n \{\
.RE
.\}
.PP
To move a table to a different schema:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLE myschema\&amp;.distributors SET SCHEMA yourschema;
.fi
.if n \{\
.RE
.\}
.PP
To recreate a primary key constraint, without blocking updates while the index is rebuilt:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The forms
ADD
(without
USING INDEX),
DROP,
SET DEFAULT, and
SET DATA TYPE
(without
USING) conform with the SQL standard\&amp;. The other forms are
PostgreSQL
extensions of the SQL standard\&amp;. Also, the ability to specify more than one manipulation in a single
\fBALTER TABLE\fR
command is an extension\&amp;.
.PP
\fBALTER TABLE DROP COLUMN\fR
can be used to drop the only column of a table, leaving a zero\-column table\&amp;. This is an extension of SQL, which disallows zero\-column tables\&amp;.
.SH "SEE ALSO"
CREATE TABLE (\fBCREATE_TABLE\fR(7))
'\" t
.\"     Title: ALTER TABLESPACE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER TABLESPACE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_TABLESPACE \- change the definition of a tablespace
.SH "SYNOPSIS"
.sp
.nf
ALTER TABLESPACE \fIname\fR RENAME TO \fInew_name\fR
ALTER TABLESPACE \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER TABLESPACE \fIname\fR SET ( \fItablespace_option\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] )
ALTER TABLESPACE \fIname\fR RESET ( \fItablespace_option\fR [, \&amp;.\&amp;.\&amp;. ] )
.fi
.SH "DESCRIPTION"
.PP
\fBALTER TABLESPACE\fR
can be used to change the definition of a tablespace\&amp;.
.PP
You must own the tablespace to change the definition of a tablespace\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role\&amp;. (Note that superusers have these privileges automatically\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an existing tablespace\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the tablespace\&amp;. The new name cannot begin with
pg_, as such names are reserved for system tablespaces\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the tablespace\&amp;.
.RE
.PP
\fItablespace_option\fR
.RS 4
A tablespace parameter to be set or reset\&amp;. Currently, the only available parameters are
\fIseq_page_cost\fR
and
\fIrandom_page_cost\fR\&amp;. Setting either value for a particular tablespace will override the planner\*(Aqs usual estimate of the cost of reading pages from tables in that tablespace, as established by the configuration parameters of the same name (see
seq_page_cost,
random_page_cost)\&amp;. This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem\&amp;.
.RE
.SH "EXAMPLES"
.PP
Rename tablespace
index_space
to
fast_raid:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLESPACE index_space RENAME TO fast_raid;
.fi
.if n \{\
.RE
.\}
.PP
Change the owner of tablespace
index_space:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TABLESPACE index_space OWNER TO mary;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER TABLESPACE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE TABLESPACE (\fBCREATE_TABLESPACE\fR(7)), DROP TABLESPACE (\fBDROP_TABLESPACE\fR(7))
'\" t
.\"     Title: ALTER TEXT SEARCH CONFIGURATION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER TEXT SEARCH CONFIGURATION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_TEXT_SEARCH_CONFIGURATION \- change the definition of a text search configuration
.SH "SYNOPSIS"
.sp
.nf
ALTER TEXT SEARCH CONFIGURATION \fIname\fR
ADD MAPPING FOR \fItoken_type\fR [, \&amp;.\&amp;.\&amp;. ] WITH \fIdictionary_name\fR [, \&amp;.\&amp;.\&amp;. ]
ALTER TEXT SEARCH CONFIGURATION \fIname\fR
ALTER MAPPING FOR \fItoken_type\fR [, \&amp;.\&amp;.\&amp;. ] WITH \fIdictionary_name\fR [, \&amp;.\&amp;.\&amp;. ]
ALTER TEXT SEARCH CONFIGURATION \fIname\fR
ALTER MAPPING REPLACE \fIold_dictionary\fR WITH \fInew_dictionary\fR
ALTER TEXT SEARCH CONFIGURATION \fIname\fR
ALTER MAPPING FOR \fItoken_type\fR [, \&amp;.\&amp;.\&amp;. ] REPLACE \fIold_dictionary\fR WITH \fInew_dictionary\fR
ALTER TEXT SEARCH CONFIGURATION \fIname\fR
DROP MAPPING [ IF EXISTS ] FOR \fItoken_type\fR [, \&amp;.\&amp;.\&amp;. ]
ALTER TEXT SEARCH CONFIGURATION \fIname\fR RENAME TO \fInew_name\fR
ALTER TEXT SEARCH CONFIGURATION \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER TEXT SEARCH CONFIGURATION \fIname\fR SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER TEXT SEARCH CONFIGURATION\fR
changes the definition of a text search configuration\&amp;. You can modify its mappings from token types to dictionaries, or change the configuration\*(Aqs name or owner\&amp;.
.PP
You must be the owner of the configuration to use
\fBALTER TEXT SEARCH CONFIGURATION\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing text search configuration\&amp;.
.RE
.PP
\fItoken_type\fR
.RS 4
The name of a token type that is emitted by the configuration\*(Aqs parser\&amp;.
.RE
.PP
\fIdictionary_name\fR
.RS 4
The name of a text search dictionary to be consulted for the specified token type(s)\&amp;. If multiple dictionaries are listed, they are consulted in the specified order\&amp;.
.RE
.PP
\fIold_dictionary\fR
.RS 4
The name of a text search dictionary to be replaced in the mapping\&amp;.
.RE
.PP
\fInew_dictionary\fR
.RS 4
The name of a text search dictionary to be substituted for
\fIold_dictionary\fR\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the text search configuration\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the text search configuration\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the text search configuration\&amp;.
.RE
.PP
The
ADD MAPPING FOR
form installs a list of dictionaries to be consulted for the specified token type(s); it is an error if there is already a mapping for any of the token types\&amp;. The
ALTER MAPPING FOR
form does the same, but first removing any existing mapping for those token types\&amp;. The
ALTER MAPPING REPLACE
forms substitute
\fInew_dictionary\fR
for
\fIold_dictionary\fR
anywhere the latter appears\&amp;. This is done for only the specified token types when
FOR
appears, or for all mappings of the configuration when it doesn\*(Aqt\&amp;. The
DROP MAPPING
form removes all dictionaries for the specified token type(s), causing tokens of those types to be ignored by the text search configuration\&amp;. It is an error if there is no mapping for the token types, unless
IF EXISTS
appears\&amp;.
.SH "EXAMPLES"
.PP
The following example replaces the
english
dictionary with the
swedish
dictionary anywhere that
english
is used within
my_config\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TEXT SEARCH CONFIGURATION my_config
ALTER MAPPING REPLACE english WITH swedish;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER TEXT SEARCH CONFIGURATION\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE TEXT SEARCH CONFIGURATION (\fBCREATE_TEXT_SEARCH_CONFIGURATION\fR(7)), DROP TEXT SEARCH CONFIGURATION (\fBDROP_TEXT_SEARCH_CONFIGURATION\fR(7))
'\" t
.\"     Title: ALTER TEXT SEARCH DICTIONARY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER TEXT SEARCH DICTIONARY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_TEXT_SEARCH_DICTIONARY \- change the definition of a text search dictionary
.SH "SYNOPSIS"
.sp
.nf
ALTER TEXT SEARCH DICTIONARY \fIname\fR (
\fIoption\fR [ = \fIvalue\fR ] [, \&amp;.\&amp;.\&amp;. ]
)
ALTER TEXT SEARCH DICTIONARY \fIname\fR RENAME TO \fInew_name\fR
ALTER TEXT SEARCH DICTIONARY \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER TEXT SEARCH DICTIONARY \fIname\fR SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER TEXT SEARCH DICTIONARY\fR
changes the definition of a text search dictionary\&amp;. You can change the dictionary\*(Aqs template\-specific options, or change the dictionary\*(Aqs name or owner\&amp;.
.PP
You must be the owner of the dictionary to use
\fBALTER TEXT SEARCH DICTIONARY\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing text search dictionary\&amp;.
.RE
.PP
\fIoption\fR
.RS 4
The name of a template\-specific option to be set for this dictionary\&amp;.
.RE
.PP
\fIvalue\fR
.RS 4
The new value to use for a template\-specific option\&amp;. If the equal sign and value are omitted, then any previous setting for the option is removed from the dictionary, allowing the default to be used\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the text search dictionary\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The new owner of the text search dictionary\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the text search dictionary\&amp;.
.RE
.PP
Template\-specific options can appear in any order\&amp;.
.SH "EXAMPLES"
.PP
The following example command changes the stopword list for a Snowball\-based dictionary\&amp;. Other parameters remain unchanged\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TEXT SEARCH DICTIONARY my_dict ( StopWords = newrussian );
.fi
.if n \{\
.RE
.\}
.PP
The following example command changes the language option to
dutch, and removes the stopword option entirely\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TEXT SEARCH DICTIONARY my_dict ( language = dutch, StopWords );
.fi
.if n \{\
.RE
.\}
.PP
The following example command
\(lqupdates\(rq
the dictionary\*(Aqs definition without actually changing anything\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TEXT SEARCH DICTIONARY my_dict ( dummy );
.fi
.if n \{\
.RE
.\}
.sp
(The reason this works is that the option removal code doesn\*(Aqt complain if there is no such option\&amp;.) This trick is useful when changing configuration files for the dictionary: the
\fBALTER\fR
will force existing database sessions to re\-read the configuration files, which otherwise they would never do if they had read them earlier\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER TEXT SEARCH DICTIONARY\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE TEXT SEARCH DICTIONARY (\fBCREATE_TEXT_SEARCH_DICTIONARY\fR(7)), DROP TEXT SEARCH DICTIONARY (\fBDROP_TEXT_SEARCH_DICTIONARY\fR(7))
'\" t
.\"     Title: ALTER TEXT SEARCH PARSER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER TEXT SEARCH PARSER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_TEXT_SEARCH_PARSER \- change the definition of a text search parser
.SH "SYNOPSIS"
.sp
.nf
ALTER TEXT SEARCH PARSER \fIname\fR RENAME TO \fInew_name\fR
ALTER TEXT SEARCH PARSER \fIname\fR SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER TEXT SEARCH PARSER\fR
changes the definition of a text search parser\&amp;. Currently, the only supported functionality is to change the parser\*(Aqs name\&amp;.
.PP
You must be a superuser to use
\fBALTER TEXT SEARCH PARSER\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing text search parser\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the text search parser\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the text search parser\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER TEXT SEARCH PARSER\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE TEXT SEARCH PARSER (\fBCREATE_TEXT_SEARCH_PARSER\fR(7)), DROP TEXT SEARCH PARSER (\fBDROP_TEXT_SEARCH_PARSER\fR(7))
'\" t
.\"     Title: ALTER TEXT SEARCH TEMPLATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER TEXT SEARCH TEMPLATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_TEXT_SEARCH_TEMPLATE \- change the definition of a text search template
.SH "SYNOPSIS"
.sp
.nf
ALTER TEXT SEARCH TEMPLATE \fIname\fR RENAME TO \fInew_name\fR
ALTER TEXT SEARCH TEMPLATE \fIname\fR SET SCHEMA \fInew_schema\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER TEXT SEARCH TEMPLATE\fR
changes the definition of a text search template\&amp;. Currently, the only supported functionality is to change the template\*(Aqs name\&amp;.
.PP
You must be a superuser to use
\fBALTER TEXT SEARCH TEMPLATE\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing text search template\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name of the text search template\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the text search template\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
There is no
\fBALTER TEXT SEARCH TEMPLATE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE TEXT SEARCH TEMPLATE (\fBCREATE_TEXT_SEARCH_TEMPLATE\fR(7)), DROP TEXT SEARCH TEMPLATE (\fBDROP_TEXT_SEARCH_TEMPLATE\fR(7))
'\" t
.\"     Title: ALTER TRIGGER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER TRIGGER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_TRIGGER \- change the definition of a trigger
.SH "SYNOPSIS"
.sp
.nf
ALTER TRIGGER \fIname\fR ON \fItable_name\fR RENAME TO \fInew_name\fR
ALTER TRIGGER \fIname\fR ON \fItable_name\fR DEPENDS ON EXTENSION \fIextension_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBALTER TRIGGER\fR
changes properties of an existing trigger\&amp;. The
RENAME
clause changes the name of the given trigger without otherwise changing the trigger definition\&amp;. The
DEPENDS ON EXTENSION
clause marks the trigger as dependent on an extension, such that if the extension is dropped, the trigger will automatically be dropped as well\&amp;.
.PP
You must own the table on which the trigger acts to be allowed to change its properties\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an existing trigger to alter\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name of the table on which this trigger acts\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the trigger\&amp;.
.RE
.PP
\fIextension_name\fR
.RS 4
The name of the extension that the trigger is to depend on\&amp;.
.RE
.SH "NOTES"
.PP
The ability to temporarily enable or disable a trigger is provided by
ALTER TABLE (\fBALTER_TABLE\fR(7)), not by
\fBALTER TRIGGER\fR, because
\fBALTER TRIGGER\fR
has no convenient way to express the option of enabling or disabling all of a table\*(Aqs triggers at once\&amp;.
.SH "EXAMPLES"
.PP
To rename an existing trigger:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TRIGGER emp_stamp ON emp RENAME TO emp_track_chgs;
.fi
.if n \{\
.RE
.\}
.PP
To mark a trigger as being dependent on an extension:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TRIGGER emp_stamp ON emp DEPENDS ON EXTENSION emplib;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER TRIGGER\fR
is a
PostgreSQL
extension of the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TABLE (\fBALTER_TABLE\fR(7))
'\" t
.\"     Title: ALTER TYPE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER TYPE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_TYPE \- change the definition of a type
.SH "SYNOPSIS"
.sp
.nf
ALTER TYPE \fIname\fR \fIaction\fR [, \&amp;.\&amp;.\&amp;. ]
ALTER TYPE \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER TYPE \fIname\fR RENAME ATTRIBUTE \fIattribute_name\fR TO \fInew_attribute_name\fR [ CASCADE | RESTRICT ]
ALTER TYPE \fIname\fR RENAME TO \fInew_name\fR
ALTER TYPE \fIname\fR SET SCHEMA \fInew_schema\fR
ALTER TYPE \fIname\fR ADD VALUE [ IF NOT EXISTS ] \fInew_enum_value\fR [ { BEFORE | AFTER } \fIexisting_enum_value\fR ]

where \fIaction\fR is one of:

ADD ATTRIBUTE \fIattribute_name\fR \fIdata_type\fR [ COLLATE \fIcollation\fR ] [ CASCADE | RESTRICT ]
DROP ATTRIBUTE [ IF EXISTS ] \fIattribute_name\fR [ CASCADE | RESTRICT ]
ALTER ATTRIBUTE \fIattribute_name\fR [ SET DATA ] TYPE \fIdata_type\fR [ COLLATE \fIcollation\fR ] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBALTER TYPE\fR
changes the definition of an existing type\&amp;. There are several subforms:
.PP
ADD ATTRIBUTE
.RS 4
This form adds a new attribute to a composite type, using the same syntax as
CREATE TYPE (\fBCREATE_TYPE\fR(7))\&amp;.
.RE
.PP
DROP ATTRIBUTE [ IF EXISTS ]
.RS 4
This form drops an attribute from a composite type\&amp;. If
IF EXISTS
is specified and the attribute does not exist, no error is thrown\&amp;. In this case a notice is issued instead\&amp;.
.RE
.PP
SET DATA TYPE
.RS 4
This form changes the type of an attribute of a composite type\&amp;.
.RE
.PP
OWNER
.RS 4
This form changes the owner of the type\&amp;.
.RE
.PP
RENAME
.RS 4
This form changes the name of the type or the name of an individual attribute of a composite type\&amp;.
.RE
.PP
SET SCHEMA
.RS 4
This form moves the type into another schema\&amp;.
.RE
.PP
ADD VALUE [ IF NOT EXISTS ] [ BEFORE | AFTER ]
.RS 4
This form adds a new value to an enum type\&amp;. The new value\*(Aqs place in the enum\*(Aqs ordering can be specified as being
BEFORE
or
AFTER
one of the existing values\&amp;. Otherwise, the new item is added at the end of the list of values\&amp;.
.sp
If
IF NOT EXISTS
is specified, it is not an error if the type already contains the new value: a notice is issued but no other action is taken\&amp;. Otherwise, an error will occur if the new value is already present\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically propagate the operation to typed tables of the type being altered, and their descendants\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse the operation if the type being altered is the type of a typed table\&amp;. This is the default\&amp;.
.RE
.PP
The
ADD ATTRIBUTE,
DROP ATTRIBUTE, and
ALTER ATTRIBUTE
actions can be combined into a list of multiple alterations to apply in parallel\&amp;. For example, it is possible to add several attributes and/or alter the type of several attributes in a single command\&amp;.
.PP
You must own the type to use
\fBALTER TYPE\fR\&amp;. To change the schema of a type, you must also have
CREATE
privilege on the new schema\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the type\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the type\&amp;. However, a superuser can alter ownership of any type anyway\&amp;.) To add an attribute or alter an attribute type, you must also have
USAGE
privilege on the data type\&amp;.
.SH "PARAMETERS"
.PP
.PP
\fIname\fR
.RS 4
The name (possibly schema\-qualified) of an existing type to alter\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the type\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the type\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the type\&amp;.
.RE
.PP
\fIattribute_name\fR
.RS 4
The name of the attribute to add, alter, or drop\&amp;.
.RE
.PP
\fInew_attribute_name\fR
.RS 4
The new name of the attribute to be renamed\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
The data type of the attribute to add, or the new type of the attribute to alter\&amp;.
.RE
.PP
\fInew_enum_value\fR
.RS 4
The new value to be added to an enum type\*(Aqs list of values\&amp;. Like all enum literals, it needs to be quoted\&amp;.
.RE
.PP
\fIexisting_enum_value\fR
.RS 4
The existing enum value that the new value should be added immediately before or after in the enum type\*(Aqs sort ordering\&amp;. Like all enum literals, it needs to be quoted\&amp;.
.RE
.SH "NOTES"
.PP
\fBALTER TYPE \&amp;.\&amp;.\&amp;. ADD VALUE\fR
(the form that adds a new value to an enum type) cannot be executed inside a transaction block\&amp;.
.PP
Comparisons involving an added enum value will sometimes be slower than comparisons involving only original members of the enum type\&amp;. This will usually only occur if
BEFORE
or
AFTER
is used to set the new value\*(Aqs sort position somewhere other than at the end of the list\&amp;. However, sometimes it will happen even though the new value is added at the end (this occurs if the OID counter
\(lqwrapped around\(rq
since the original creation of the enum type)\&amp;. The slowdown is usually insignificant; but if it matters, optimal performance can be regained by dropping and recreating the enum type, or by dumping and reloading the database\&amp;.
.SH "EXAMPLES"
.PP
To rename a data type:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TYPE electronic_mail RENAME TO email;
.fi
.if n \{\
.RE
.\}
.PP
To change the owner of the type
email
to
joe:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TYPE email OWNER TO joe;
.fi
.if n \{\
.RE
.\}
.PP
To change the schema of the type
email
to
customers:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TYPE email SET SCHEMA customers;
.fi
.if n \{\
.RE
.\}
.PP
To add a new attribute to a type:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TYPE compfoo ADD ATTRIBUTE f3 int;
.fi
.if n \{\
.RE
.\}
.PP
To add a new value to an enum type in a particular sort position:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER TYPE colors ADD VALUE \*(Aqorange\*(Aq AFTER \*(Aqred\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The variants to add and drop attributes are part of the SQL standard; the other variants are PostgreSQL extensions\&amp;.
.SH "SEE ALSO"
CREATE TYPE (\fBCREATE_TYPE\fR(7)), DROP TYPE (\fBDROP_TYPE\fR(7))
'\" t
.\"     Title: ALTER USER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER USER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_USER \- change a database role
.SH "SYNOPSIS"
.sp
.nf
ALTER USER \fIrole_specification\fR [ WITH ] \fIoption\fR [ \&amp;.\&amp;.\&amp;. ]

where \fIoption\fR can be:

SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| REPLICATION | NOREPLICATION
| BYPASSRLS | NOBYPASSRLS
| CONNECTION LIMIT \fIconnlimit\fR
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD \*(Aq\fIpassword\fR\*(Aq
| VALID UNTIL \*(Aq\fItimestamp\fR\*(Aq

ALTER USER \fIname\fR RENAME TO \fInew_name\fR

ALTER USER \fIrole_specification\fR SET \fIconfiguration_parameter\fR { TO | = } { \fIvalue\fR | DEFAULT }
ALTER USER \fIrole_specification\fR SET \fIconfiguration_parameter\fR FROM CURRENT
ALTER USER \fIrole_specification\fR RESET \fIconfiguration_parameter\fR
ALTER USER \fIrole_specification\fR RESET ALL

where \fIrole_specification\fR can be:

[ GROUP ] \fIrole_name\fR
| CURRENT_USER
| SESSION_USER
.fi
.SH "DESCRIPTION"
.PP
\fBALTER USER\fR
is now an alias for
ALTER ROLE (\fBALTER_ROLE\fR(7))\&amp;.
.SH "COMPATIBILITY"
.PP
The
\fBALTER USER\fR
statement is a
PostgreSQL
extension\&amp;. The SQL standard leaves the definition of users to the implementation\&amp;.
.SH "SEE ALSO"
ALTER ROLE (\fBALTER_ROLE\fR(7))
'\" t
.\"     Title: ALTER USER MAPPING
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER USER MAPPING" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_USER_MAPPING \- change the definition of a user mapping
.SH "SYNOPSIS"
.sp
.nf
ALTER USER MAPPING FOR { \fIuser_name\fR | USER | CURRENT_USER | SESSION_USER | PUBLIC }
SERVER \fIserver_name\fR
OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ] )
.fi
.SH "DESCRIPTION"
.PP
\fBALTER USER MAPPING\fR
changes the definition of a user mapping\&amp;.
.PP
The owner of a foreign server can alter user mappings for that server for any user\&amp;. Also, a user can alter a user mapping for their own user name if
USAGE
privilege on the server has been granted to the user\&amp;.
.SH "PARAMETERS"
.PP
\fIuser_name\fR
.RS 4
User name of the mapping\&amp;.
CURRENT_USER
and
USER
match the name of the current user\&amp;.
PUBLIC
is used to match all present and future user names in the system\&amp;.
.RE
.PP
\fIserver_name\fR
.RS 4
Server name of the user mapping\&amp;.
.RE
.PP
OPTIONS ( [ ADD | SET | DROP ] \fIoption\fR [\*(Aq\fIvalue\fR\*(Aq] [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
Change options for the user mapping\&amp;. The new options override any previously specified options\&amp;.
ADD,
SET, and
DROP
specify the action to be performed\&amp;.
ADD
is assumed if no operation is explicitly specified\&amp;. Option names must be unique; options are also validated by the server\*(Aqs foreign\-data wrapper\&amp;.
.RE
.SH "EXAMPLES"
.PP
Change the password for user mapping
bob, server
foo:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER USER MAPPING FOR bob SERVER foo OPTIONS (SET password \*(Aqpublic\*(Aq);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER USER MAPPING\fR
conforms to ISO/IEC 9075\-9 (SQL/MED)\&amp;. There is a subtle syntax issue: The standard omits the
FOR
key word\&amp;. Since both
CREATE USER MAPPING
and
DROP USER MAPPING
use
FOR
in analogous positions, and IBM DB2 (being the other major SQL/MED implementation) also requires it for
ALTER USER MAPPING, PostgreSQL diverges from the standard here in the interest of consistency and interoperability\&amp;.
.SH "SEE ALSO"
CREATE USER MAPPING (\fBCREATE_USER_MAPPING\fR(7)), DROP USER MAPPING (\fBDROP_USER_MAPPING\fR(7))
'\" t
.\"     Title: ALTER VIEW
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ALTER VIEW" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ALTER_VIEW \- change the definition of a view
.SH "SYNOPSIS"
.sp
.nf
ALTER VIEW [ IF EXISTS ] \fIname\fR ALTER [ COLUMN ] \fIcolumn_name\fR SET DEFAULT \fIexpression\fR
ALTER VIEW [ IF EXISTS ] \fIname\fR ALTER [ COLUMN ] \fIcolumn_name\fR DROP DEFAULT
ALTER VIEW [ IF EXISTS ] \fIname\fR OWNER TO { \fInew_owner\fR | CURRENT_USER | SESSION_USER }
ALTER VIEW [ IF EXISTS ] \fIname\fR RENAME TO \fInew_name\fR
ALTER VIEW [ IF EXISTS ] \fIname\fR SET SCHEMA \fInew_schema\fR
ALTER VIEW [ IF EXISTS ] \fIname\fR SET ( \fIview_option_name\fR [= \fIview_option_value\fR] [, \&amp;.\&amp;.\&amp;. ] )
ALTER VIEW [ IF EXISTS ] \fIname\fR RESET ( \fIview_option_name\fR [, \&amp;.\&amp;.\&amp;. ] )
.fi
.SH "DESCRIPTION"
.PP
\fBALTER VIEW\fR
changes various auxiliary properties of a view\&amp;. (If you want to modify the view\*(Aqs defining query, use
\fBCREATE OR REPLACE VIEW\fR\&amp;.)
.PP
You must own the view to use
\fBALTER VIEW\fR\&amp;. To change a view\*(Aqs schema, you must also have
CREATE
privilege on the new schema\&amp;. To alter the owner, you must also be a direct or indirect member of the new owning role, and that role must have
CREATE
privilege on the view\*(Aqs schema\&amp;. (These restrictions enforce that altering the owner doesn\*(Aqt do anything you couldn\*(Aqt do by dropping and recreating the view\&amp;. However, a superuser can alter ownership of any view anyway\&amp;.)
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing view\&amp;.
.RE
.PP
IF EXISTS
.RS 4
Do not throw an error if the view does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
SET/DROP DEFAULT
.RS 4
These forms set or remove the default value for a column\&amp;. A view column\*(Aqs default value is substituted into any
\fBINSERT\fR
or
\fBUPDATE\fR
command whose target is the view, before applying any rules or triggers for the view\&amp;. The view\*(Aqs default will therefore take precedence over any default values from underlying relations\&amp;.
.RE
.PP
\fInew_owner\fR
.RS 4
The user name of the new owner of the view\&amp;.
.RE
.PP
\fInew_name\fR
.RS 4
The new name for the view\&amp;.
.RE
.PP
\fInew_schema\fR
.RS 4
The new schema for the view\&amp;.
.RE
.PP
SET ( \fIview_option_name\fR [= \fIview_option_value\fR] [, \&amp;.\&amp;.\&amp;. ] )
.br
RESET ( \fIview_option_name\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
Sets or resets a view option\&amp;. Currently supported options are:
.PP
check_option (string)
.RS 4
Changes the check option of the view\&amp;. The value must be
local
or
cascaded\&amp;.
.RE
.PP
security_barrier (boolean)
.RS 4
Changes the security\-barrier property of the view\&amp;. The value must be Boolean value, such as
true
or
false\&amp;.
.RE
.sp
.RE
.SH "NOTES"
.PP
For historical reasons,
\fBALTER TABLE\fR
can be used with views too; but the only variants of
\fBALTER TABLE\fR
that are allowed with views are equivalent to the ones shown above\&amp;.
.SH "EXAMPLES"
.PP
To rename the view
foo
to
bar:
.sp
.if n \{\
.RS 4
.\}
.nf
ALTER VIEW foo RENAME TO bar;
.fi
.if n \{\
.RE
.\}
.PP
To attach a default column value to an updatable view:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE base_table (id int, ts timestamptz);
CREATE VIEW a_view AS SELECT * FROM base_table;
ALTER VIEW a_view ALTER COLUMN ts SET DEFAULT now();
INSERT INTO base_table(id) VALUES(1);  \-\- ts will receive a NULL
INSERT INTO a_view(id) VALUES(2);  \-\- ts will receive the current time
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBALTER VIEW\fR
is a
PostgreSQL
extension of the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE VIEW (\fBCREATE_VIEW\fR(7)), DROP VIEW (\fBDROP_VIEW\fR(7))
'\" t
.\"     Title: ANALYZE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ANALYZE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ANALYZE \- collect statistics about a database
.SH "SYNOPSIS"
.sp
.nf
ANALYZE [ VERBOSE ] [ \fItable_name\fR [ ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
.fi
.SH "DESCRIPTION"
.PP
\fBANALYZE\fR
collects statistics about the contents of tables in the database, and stores the results in the
pg_statistic
system catalog\&amp;. Subsequently, the query planner uses these statistics to help determine the most efficient execution plans for queries\&amp;.
.PP
With no parameter,
\fBANALYZE\fR
examines every table in the current database\&amp;. With a parameter,
\fBANALYZE\fR
examines only that table\&amp;. It is further possible to give a list of column names, in which case only the statistics for those columns are collected\&amp;.
.SH "PARAMETERS"
.PP
VERBOSE
.RS 4
Enables display of progress messages\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (possibly schema\-qualified) of a specific table to analyze\&amp;. If omitted, all regular tables (but not foreign tables) in the current database are analyzed\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a specific column to analyze\&amp;. Defaults to all columns\&amp;.
.RE
.SH "OUTPUTS"
.PP
When
VERBOSE
is specified,
\fBANALYZE\fR
emits progress messages to indicate which table is currently being processed\&amp;. Various statistics about the tables are printed as well\&amp;.
.SH "NOTES"
.PP
Foreign tables are analyzed only when explicitly selected\&amp;. Not all foreign data wrappers support
\fBANALYZE\fR\&amp;. If the table\*(Aqs wrapper does not support
\fBANALYZE\fR, the command prints a warning and does nothing\&amp;.
.PP
In the default
PostgreSQL
configuration, the autovacuum daemon (see
Section 24.1.6, \(lqThe Autovacuum Daemon\(rq, in the documentation) takes care of automatic analyzing of tables when they are first loaded with data, and as they change throughout regular operation\&amp;. When autovacuum is disabled, it is a good idea to run
\fBANALYZE\fR
periodically, or just after making major changes in the contents of a table\&amp;. Accurate statistics will help the planner to choose the most appropriate query plan, and thereby improve the speed of query processing\&amp;. A common strategy for read\-mostly databases is to run
\fBVACUUM\fR(7)
and
\fBANALYZE\fR
once a day during a low\-usage time of day\&amp;. (This will not be sufficient if there is heavy update activity\&amp;.)
.PP
\fBANALYZE\fR
requires only a read lock on the target table, so it can run in parallel with other activity on the table\&amp;.
.PP
The statistics collected by
\fBANALYZE\fR
usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column\&amp;. One or both of these can be omitted if
\fBANALYZE\fR
deems them uninteresting (for example, in a unique\-key column, there are no common values) or if the column data type does not support the appropriate operators\&amp;. There is more information about the statistics in
Chapter 24, Routine Database Maintenance Tasks, in the documentation\&amp;.
.PP
For large tables,
\fBANALYZE\fR
takes a random sample of the table contents, rather than examining every row\&amp;. This allows even very large tables to be analyzed in a small amount of time\&amp;. Note, however, that the statistics are only approximate, and will change slightly each time
\fBANALYZE\fR
is run, even if the actual table contents did not change\&amp;. This might result in small changes in the planner\*(Aqs estimated costs shown by
\fBEXPLAIN\fR(7)\&amp;. In rare situations, this non\-determinism will cause the planner\*(Aqs choices of query plans to change after
\fBANALYZE\fR
is run\&amp;. To avoid this, raise the amount of statistics collected by
\fBANALYZE\fR, as described below\&amp;.
.PP
The extent of analysis can be controlled by adjusting the
default_statistics_target
configuration variable, or on a column\-by\-column basis by setting the per\-column statistics target with
\fBALTER TABLE \&amp;.\&amp;.\&amp;. ALTER COLUMN \&amp;.\&amp;.\&amp;. SET STATISTICS\fR
(see
ALTER TABLE (\fBALTER_TABLE\fR(7)))\&amp;. The target value sets the maximum number of entries in the most\-common\-value list and the maximum number of bins in the histogram\&amp;. The default target value is 100, but this can be adjusted up or down to trade off accuracy of planner estimates against the time taken for
\fBANALYZE\fR
and the amount of space occupied in
pg_statistic\&amp;. In particular, setting the statistics target to zero disables collection of statistics for that column\&amp;. It might be useful to do that for columns that are never used as part of the
WHERE,
GROUP BY, or
ORDER BY
clauses of queries, since the planner will have no use for statistics on such columns\&amp;.
.PP
The largest statistics target among the columns being analyzed determines the number of table rows sampled to prepare the statistics\&amp;. Increasing the target causes a proportional increase in the time and space needed to do
\fBANALYZE\fR\&amp;.
.PP
One of the values estimated by
\fBANALYZE\fR
is the number of distinct values that appear in each column\&amp;. Because only a subset of the rows are examined, this estimate can sometimes be quite inaccurate, even with the largest possible statistics target\&amp;. If this inaccuracy leads to bad query plans, a more accurate value can be determined manually and then installed with
\fBALTER TABLE \&amp;.\&amp;.\&amp;. ALTER COLUMN \&amp;.\&amp;.\&amp;. SET (n_distinct = \&amp;.\&amp;.\&amp;.)\fR
(see
ALTER TABLE (\fBALTER_TABLE\fR(7)))\&amp;.
.PP
If the table being analyzed has one or more children,
\fBANALYZE\fR
will gather statistics twice: once on the rows of the parent table only, and a second time on the rows of the parent table with all of its children\&amp;. This second set of statistics is needed when planning queries that traverse the entire inheritance tree\&amp;. The autovacuum daemon, however, will only consider inserts or updates on the parent table itself when deciding whether to trigger an automatic analyze for that table\&amp;. If that table is rarely inserted into or updated, the inheritance statistics will not be up to date unless you run
\fBANALYZE\fR
manually\&amp;.
.PP
If any of the child tables are foreign tables whose foreign data wrappers do not support
\fBANALYZE\fR, those child tables are ignored while gathering inheritance statistics\&amp;.
.PP
If the table being analyzed is completely empty,
\fBANALYZE\fR
will not record new statistics for that table\&amp;. Any existing statistics will be retained\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBANALYZE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBVACUUM\fR(7), \fBvacuumdb\fR(1), Section 19.4.4, \(lqCost-based Vacuum Delay\(rq, in the documentation, Section 24.1.6, \(lqThe Autovacuum Daemon\(rq, in the documentation
'\" t
.\"     Title: BEGIN
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "BEGIN" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
BEGIN \- start a transaction block
.SH "SYNOPSIS"
.sp
.nf
BEGIN [ WORK | TRANSACTION ] [ \fItransaction_mode\fR [, \&amp;.\&amp;.\&amp;.] ]

where \fItransaction_mode\fR is one of:

ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }
READ WRITE | READ ONLY
[ NOT ] DEFERRABLE
.fi
.SH "DESCRIPTION"
.PP
\fBBEGIN\fR
initiates a transaction block, that is, all statements after a
\fBBEGIN\fR
command will be executed in a single transaction until an explicit
\fBCOMMIT\fR(7)
or
\fBROLLBACK\fR(7)
is given\&amp;. By default (without
\fBBEGIN\fR),
PostgreSQL
executes transactions in
\(lqautocommit\(rq
mode, that is, each statement is executed in its own transaction and a commit is implicitly performed at the end of the statement (if execution was successful, otherwise a rollback is done)\&amp;.
.PP
Statements are executed more quickly in a transaction block, because transaction start/commit requires significant CPU and disk activity\&amp;. Execution of multiple statements inside a transaction is also useful to ensure consistency when making several related changes: other sessions will be unable to see the intermediate states wherein not all the related updates have been done\&amp;.
.PP
If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if
SET TRANSACTION (\fBSET_TRANSACTION\fR(7))
was executed\&amp;.
.SH "PARAMETERS"
.PP
WORK
.br
TRANSACTION
.RS 4
Optional key words\&amp;. They have no effect\&amp;.
.RE
.PP
Refer to
SET TRANSACTION (\fBSET_TRANSACTION\fR(7))
for information on the meaning of the other parameters to this statement\&amp;.
.SH "NOTES"
.PP
START TRANSACTION (\fBSTART_TRANSACTION\fR(7))
has the same functionality as
\fBBEGIN\fR\&amp;.
.PP
Use
\fBCOMMIT\fR(7)
or
\fBROLLBACK\fR(7)
to terminate a transaction block\&amp;.
.PP
Issuing
\fBBEGIN\fR
when already inside a transaction block will provoke a warning message\&amp;. The state of the transaction is not affected\&amp;. To nest transactions within a transaction block, use savepoints (see
\fBSAVEPOINT\fR(7))\&amp;.
.PP
For reasons of backwards compatibility, the commas between successive
\fItransaction_modes\fR
can be omitted\&amp;.
.SH "EXAMPLES"
.PP
To begin a transaction block:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBBEGIN\fR
is a
PostgreSQL
language extension\&amp;. It is equivalent to the SQL\-standard command
START TRANSACTION (\fBSTART_TRANSACTION\fR(7)), whose reference page contains additional compatibility information\&amp;.
.PP
The
DEFERRABLE\fItransaction_mode\fR
is a
PostgreSQL
language extension\&amp;.
.PP
Incidentally, the
BEGIN
key word is used for a different purpose in embedded SQL\&amp;. You are advised to be careful about the transaction semantics when porting database applications\&amp;.
.SH "SEE ALSO"
\fBCOMMIT\fR(7), \fBROLLBACK\fR(7), START TRANSACTION (\fBSTART_TRANSACTION\fR(7)), \fBSAVEPOINT\fR(7)
'\" t
.\"     Title: CHECKPOINT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CHECKPOINT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CHECKPOINT \- force a transaction log checkpoint
.SH "SYNOPSIS"
.sp
.nf
CHECKPOINT
.fi
.SH "DESCRIPTION"
.PP
A checkpoint is a point in the transaction log sequence at which all data files have been updated to reflect the information in the log\&amp;. All data files will be flushed to disk\&amp;. Refer to
Section 30.4, \(lqWAL Configuration\(rq, in the documentation
for more details about what happens during a checkpoint\&amp;.
.PP
The
\fBCHECKPOINT\fR
command forces an immediate checkpoint when the command is issued, without waiting for a regular checkpoint scheduled by the system (controlled by the settings in
Section 19.5.2, \(lqCheckpoints\(rq, in the documentation)\&amp;.
\fBCHECKPOINT\fR
is not intended for use during normal operation\&amp;.
.PP
If executed during recovery, the
\fBCHECKPOINT\fR
command will force a restartpoint (see
Section 30.4, \(lqWAL Configuration\(rq, in the documentation) rather than writing a new checkpoint\&amp;.
.PP
Only superusers can call
\fBCHECKPOINT\fR\&amp;.
.SH "COMPATIBILITY"
.PP
The
\fBCHECKPOINT\fR
command is a
PostgreSQL
language extension\&amp;.
'\" t
.\"     Title: CLOSE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CLOSE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CLOSE \- close a cursor
.SH "SYNOPSIS"
.sp
.nf
CLOSE { \fIname\fR | ALL }
.fi
.SH "DESCRIPTION"
.PP
\fBCLOSE\fR
frees the resources associated with an open cursor\&amp;. After the cursor is closed, no subsequent operations are allowed on it\&amp;. A cursor should be closed when it is no longer needed\&amp;.
.PP
Every non\-holdable open cursor is implicitly closed when a transaction is terminated by
\fBCOMMIT\fR
or
\fBROLLBACK\fR\&amp;. A holdable cursor is implicitly closed if the transaction that created it aborts via
\fBROLLBACK\fR\&amp;. If the creating transaction successfully commits, the holdable cursor remains open until an explicit
\fBCLOSE\fR
is executed, or the client disconnects\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of an open cursor to close\&amp;.
.RE
.PP
ALL
.RS 4
Close all open cursors\&amp;.
.RE
.SH "NOTES"
.PP
PostgreSQL
does not have an explicit
\fBOPEN\fR
cursor statement; a cursor is considered open when it is declared\&amp;. Use the
\fBDECLARE\fR(7)
statement to declare a cursor\&amp;.
.PP
You can see all available cursors by querying the
pg_cursors
system view\&amp;.
.PP
If a cursor is closed after a savepoint which is later rolled back, the
\fBCLOSE\fR
is not rolled back; that is, the cursor remains closed\&amp;.
.SH "EXAMPLES"
.PP
Close the cursor
liahona:
.sp
.if n \{\
.RS 4
.\}
.nf
CLOSE liahona;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCLOSE\fR
is fully conforming with the SQL standard\&amp;.
\fBCLOSE ALL\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
\fBDECLARE\fR(7), \fBFETCH\fR(7), \fBMOVE\fR(7)
'\" t
.\"     Title: CLUSTER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CLUSTER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CLUSTER \- cluster a table according to an index
.SH "SYNOPSIS"
.sp
.nf
CLUSTER [VERBOSE] \fItable_name\fR [ USING \fIindex_name\fR ]
CLUSTER [VERBOSE]
.fi
.SH "DESCRIPTION"
.PP
\fBCLUSTER\fR
instructs
PostgreSQL
to cluster the table specified by
\fItable_name\fR
based on the index specified by
\fIindex_name\fR\&amp;. The index must already have been defined on
\fItable_name\fR\&amp;.
.PP
When a table is clustered, it is physically reordered based on the index information\&amp;. Clustering is a one\-time operation: when the table is subsequently updated, the changes are not clustered\&amp;. That is, no attempt is made to store new or updated rows according to their index order\&amp;. (If one wishes, one can periodically recluster by issuing the command again\&amp;. Also, setting the table\*(Aqs
fillfactor
storage parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are kept on the same page if enough space is available there\&amp;.)
.PP
When a table is clustered,
PostgreSQL
remembers which index it was clustered by\&amp;. The form
\fBCLUSTER \fR\fB\fItable_name\fR\fR
reclusters the table using the same index as before\&amp;. You can also use the
CLUSTER
or
SET WITHOUT CLUSTER
forms of
ALTER TABLE (\fBALTER_TABLE\fR(7))
to set the index to be used for future cluster operations, or to clear any previous setting\&amp;.
.PP
\fBCLUSTER\fR
without any parameter reclusters all the previously\-clustered tables in the current database that the calling user owns, or all such tables if called by a superuser\&amp;. This form of
\fBCLUSTER\fR
cannot be executed inside a transaction block\&amp;.
.PP
When a table is being clustered, an
ACCESS EXCLUSIVE
lock is acquired on it\&amp;. This prevents any other database operations (both reads and writes) from operating on the table until the
\fBCLUSTER\fR
is finished\&amp;.
.SH "PARAMETERS"
.PP
\fItable_name\fR
.RS 4
The name (possibly schema\-qualified) of a table\&amp;.
.RE
.PP
\fIindex_name\fR
.RS 4
The name of an index\&amp;.
.RE
.PP
VERBOSE
.RS 4
Prints a progress report as each table is clustered\&amp;.
.RE
.SH "NOTES"
.PP
In cases where you are accessing single rows randomly within a table, the actual order of the data in the table is unimportant\&amp;. However, if you tend to access some data more than others, and there is an index that groups them together, you will benefit from using
\fBCLUSTER\fR\&amp;. If you are requesting a range of indexed values from a table, or a single indexed value that has multiple rows that match,
\fBCLUSTER\fR
will help because once the index identifies the table page for the first row that matches, all other rows that match are probably already on the same table page, and so you save disk accesses and speed up the query\&amp;.
.PP
\fBCLUSTER\fR
can re\-sort the table using either an index scan on the specified index, or (if the index is a b\-tree) a sequential scan followed by sorting\&amp;. It will attempt to choose the method that will be faster, based on planner cost parameters and available statistical information\&amp;.
.PP
When an index scan is used, a temporary copy of the table is created that contains the table data in the index order\&amp;. Temporary copies of each index on the table are created as well\&amp;. Therefore, you need free space on disk at least equal to the sum of the table size and the index sizes\&amp;.
.PP
When a sequential scan and sort is used, a temporary sort file is also created, so that the peak temporary space requirement is as much as double the table size, plus the index sizes\&amp;. This method is often faster than the index scan method, but if the disk space requirement is intolerable, you can disable this choice by temporarily setting
enable_sort
to
off\&amp;.
.PP
It is advisable to set
maintenance_work_mem
to a reasonably large value (but not more than the amount of RAM you can dedicate to the
\fBCLUSTER\fR
operation) before clustering\&amp;.
.PP
Because the planner records statistics about the ordering of tables, it is advisable to run
\fBANALYZE\fR(7)
on the newly clustered table\&amp;. Otherwise, the planner might make poor choices of query plans\&amp;.
.PP
Because
\fBCLUSTER\fR
remembers which indexes are clustered, one can cluster the tables one wants clustered manually the first time, then set up a periodic maintenance script that executes
\fBCLUSTER\fR
without any parameters, so that the desired tables are periodically reclustered\&amp;.
.SH "EXAMPLES"
.PP
Cluster the table
employees
on the basis of its index
employees_ind:
.sp
.if n \{\
.RS 4
.\}
.nf
CLUSTER employees USING employees_ind;
.fi
.if n \{\
.RE
.\}
.PP
Cluster the
employees
table using the same index that was used before:
.sp
.if n \{\
.RS 4
.\}
.nf
CLUSTER employees;
.fi
.if n \{\
.RE
.\}
.PP
Cluster all tables in the database that have previously been clustered:
.sp
.if n \{\
.RS 4
.\}
.nf
CLUSTER;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBCLUSTER\fR
statement in the SQL standard\&amp;.
.PP
The syntax
.sp
.if n \{\
.RS 4
.\}
.nf
CLUSTER \fIindex_name\fR ON \fItable_name\fR
.fi
.if n \{\
.RE
.\}
.sp
is also supported for compatibility with pre\-8\&amp;.3
PostgreSQL
versions\&amp;.
.SH "SEE ALSO"
\fBclusterdb\fR(1)
'\" t
.\"     Title: COMMENT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "COMMENT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
COMMENT \- define or change the comment of an object
.SH "SYNOPSIS"
.sp
.nf
COMMENT ON
{
ACCESS METHOD \fIobject_name\fR |
AGGREGATE \fIaggregate_name\fR ( \fIaggregate_signature\fR ) |
CAST (\fIsource_type\fR AS \fItarget_type\fR) |
COLLATION \fIobject_name\fR |
COLUMN \fIrelation_name\fR\&amp;.\fIcolumn_name\fR |
CONSTRAINT \fIconstraint_name\fR ON \fItable_name\fR |
CONSTRAINT \fIconstraint_name\fR ON DOMAIN \fIdomain_name\fR |
CONVERSION \fIobject_name\fR |
DATABASE \fIobject_name\fR |
DOMAIN \fIobject_name\fR |
EXTENSION \fIobject_name\fR |
EVENT TRIGGER \fIobject_name\fR |
FOREIGN DATA WRAPPER \fIobject_name\fR |
FOREIGN TABLE \fIobject_name\fR |
FUNCTION \fIfunction_name\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] ) |
INDEX \fIobject_name\fR |
LARGE OBJECT \fIlarge_object_oid\fR |
MATERIALIZED VIEW \fIobject_name\fR |
OPERATOR \fIoperator_name\fR (\fIleft_type\fR, \fIright_type\fR) |
OPERATOR CLASS \fIobject_name\fR USING \fIindex_method\fR |
OPERATOR FAMILY \fIobject_name\fR USING \fIindex_method\fR |
POLICY \fIpolicy_name\fR ON \fItable_name\fR |
[ PROCEDURAL ] LANGUAGE \fIobject_name\fR |
ROLE \fIobject_name\fR |
RULE \fIrule_name\fR ON \fItable_name\fR |
SCHEMA \fIobject_name\fR |
SEQUENCE \fIobject_name\fR |
SERVER \fIobject_name\fR |
TABLE \fIobject_name\fR |
TABLESPACE \fIobject_name\fR |
TEXT SEARCH CONFIGURATION \fIobject_name\fR |
TEXT SEARCH DICTIONARY \fIobject_name\fR |
TEXT SEARCH PARSER \fIobject_name\fR |
TEXT SEARCH TEMPLATE \fIobject_name\fR |
TRANSFORM FOR \fItype_name\fR LANGUAGE \fIlang_name\fR |
TRIGGER \fItrigger_name\fR ON \fItable_name\fR |
TYPE \fIobject_name\fR |
VIEW \fIobject_name\fR
} IS \*(Aq\fItext\fR\*(Aq

where \fIaggregate_signature\fR is:

* |
[ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] |
[ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] ] ORDER BY [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ]
.fi
.SH "DESCRIPTION"
.PP
\fBCOMMENT\fR
stores a comment about a database object\&amp;.
.PP
Only one comment string is stored for each object, so to modify a comment, issue a new
\fBCOMMENT\fR
command for the same object\&amp;. To remove a comment, write
NULL
in place of the text string\&amp;. Comments are automatically dropped when their object is dropped\&amp;.
.PP
For most kinds of object, only the object\*(Aqs owner can set the comment\&amp;. Roles don\*(Aqt have owners, so the rule for
COMMENT ON ROLE
is that you must be superuser to comment on a superuser role, or have the
CREATEROLE
privilege to comment on non\-superuser roles\&amp;. Likewise, access methods don\*(Aqt have owners either; you must be superuser to comment on an access method\&amp;. Of course, a superuser can comment on anything\&amp;.
.PP
Comments can be viewed using
psql\*(Aqs
\fB\ed\fR
family of commands\&amp;. Other user interfaces to retrieve comments can be built atop the same built\-in functions that
psql
uses, namely
\fBobj_description\fR,
\fBcol_description\fR, and
\fBshobj_description\fR
(see
Table\ \&amp;9.67, \(lqComment Information Functions\(rq)\&amp;.
.SH "PARAMETERS"
.PP
\fIobject_name\fR
.br
\fIrelation_name\fR\&amp;.\fIcolumn_name\fR
.br
\fIaggregate_name\fR
.br
\fIconstraint_name\fR
.br
\fIfunction_name\fR
.br
\fIoperator_name\fR
.br
\fIpolicy_name\fR
.br
\fIrule_name\fR
.br
\fItrigger_name\fR
.RS 4
The name of the object to be commented\&amp;. Names of tables, aggregates, collations, conversions, domains, foreign tables, functions, indexes, operators, operator classes, operator families, sequences, text search objects, types, and views can be schema\-qualified\&amp;. When commenting on a column,
\fIrelation_name\fR
must refer to a table, view, composite type, or foreign table\&amp;.
.RE
.PP
\fItable_name\fR
.br
\fIdomain_name\fR
.RS 4
When creating a comment on a constraint, a trigger, a rule or a policy these parameters specify the name of the table or domain on which that object is defined\&amp;.
.RE
.PP
\fIsource_type\fR
.RS 4
The name of the source data type of the cast\&amp;.
.RE
.PP
\fItarget_type\fR
.RS 4
The name of the target data type of the cast\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of a function or aggregate argument:
IN,
OUT,
INOUT, or
VARIADIC\&amp;. If omitted, the default is
IN\&amp;. Note that
\fBCOMMENT\fR
does not actually pay any attention to
OUT
arguments, since only the input arguments are needed to determine the function\*(Aqs identity\&amp;. So it is sufficient to list the
IN,
INOUT, and
VARIADIC
arguments\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of a function or aggregate argument\&amp;. Note that
\fBCOMMENT\fR
does not actually pay any attention to argument names, since only the argument data types are needed to determine the function\*(Aqs identity\&amp;.
.RE
.PP
\fIargtype\fR
.RS 4
The data type of a function or aggregate argument\&amp;.
.RE
.PP
\fIlarge_object_oid\fR
.RS 4
The OID of the large object\&amp;.
.RE
.PP
\fIleft_type\fR
.br
\fIright_type\fR
.RS 4
The data type(s) of the operator\*(Aqs arguments (optionally schema\-qualified)\&amp;. Write
NONE
for the missing argument of a prefix or postfix operator\&amp;.
.RE
.PP
PROCEDURAL
.RS 4
This is a noise word\&amp;.
.RE
.PP
\fItype_name\fR
.RS 4
The name of the data type of the transform\&amp;.
.RE
.PP
\fIlang_name\fR
.RS 4
The name of the language of the transform\&amp;.
.RE
.PP
\fItext\fR
.RS 4
The new comment, written as a string literal; or
NULL
to drop the comment\&amp;.
.RE
.SH "NOTES"
.PP
There is presently no security mechanism for viewing comments: any user connected to a database can see all the comments for objects in that database\&amp;. For shared objects such as databases, roles, and tablespaces, comments are stored globally so any user connected to any database in the cluster can see all the comments for shared objects\&amp;. Therefore, don\*(Aqt put security\-critical information in comments\&amp;.
.SH "EXAMPLES"
.PP
Attach a comment to the table
mytable:
.sp
.if n \{\
.RS 4
.\}
.nf
COMMENT ON TABLE mytable IS \*(AqThis is my table\&amp;.\*(Aq;
.fi
.if n \{\
.RE
.\}
.sp
Remove it again:
.sp
.if n \{\
.RS 4
.\}
.nf
COMMENT ON TABLE mytable IS NULL;
.fi
.if n \{\
.RE
.\}
.PP
Some more examples:
.sp
.if n \{\
.RS 4
.\}
.nf
COMMENT ON ACCESS METHOD rtree IS \*(AqR\-Tree access method\*(Aq;
COMMENT ON AGGREGATE my_aggregate (double precision) IS \*(AqComputes sample variance\*(Aq;
COMMENT ON CAST (text AS int4) IS \*(AqAllow casts from text to int4\*(Aq;
COMMENT ON COLLATION "fr_CA" IS \*(AqCanadian French\*(Aq;
COMMENT ON COLUMN my_table\&amp;.my_column IS \*(AqEmployee ID number\*(Aq;
COMMENT ON CONVERSION my_conv IS \*(AqConversion to UTF8\*(Aq;
COMMENT ON CONSTRAINT bar_col_cons ON bar IS \*(AqConstrains column col\*(Aq;
COMMENT ON CONSTRAINT dom_col_constr ON DOMAIN dom IS \*(AqConstrains col of domain\*(Aq;
COMMENT ON DATABASE my_database IS \*(AqDevelopment Database\*(Aq;
COMMENT ON DOMAIN my_domain IS \*(AqEmail Address Domain\*(Aq;
COMMENT ON EXTENSION hstore IS \*(Aqimplements the hstore data type\*(Aq;
COMMENT ON FOREIGN DATA WRAPPER mywrapper IS \*(Aqmy foreign data wrapper\*(Aq;
COMMENT ON FOREIGN TABLE my_foreign_table IS \*(AqEmployee Information in other database\*(Aq;
COMMENT ON FUNCTION my_function (timestamp) IS \*(AqReturns Roman Numeral\*(Aq;
COMMENT ON INDEX my_index IS \*(AqEnforces uniqueness on employee ID\*(Aq;
COMMENT ON LANGUAGE plpython IS \*(AqPython support for stored procedures\*(Aq;
COMMENT ON LARGE OBJECT 346344 IS \*(AqPlanning document\*(Aq;
COMMENT ON MATERIALIZED VIEW my_matview IS \*(AqSummary of order history\*(Aq;
COMMENT ON OPERATOR ^ (text, text) IS \*(AqPerforms intersection of two texts\*(Aq;
COMMENT ON OPERATOR \- (NONE, integer) IS \*(AqUnary minus\*(Aq;
COMMENT ON OPERATOR CLASS int4ops USING btree IS \*(Aq4 byte integer operators for btrees\*(Aq;
COMMENT ON OPERATOR FAMILY integer_ops USING btree IS \*(Aqall integer operators for btrees\*(Aq;
COMMENT ON POLICY my_policy ON mytable IS \*(AqFilter rows by users\*(Aq;
COMMENT ON ROLE my_role IS \*(AqAdministration group for finance tables\*(Aq;
COMMENT ON RULE my_rule ON my_table IS \*(AqLogs updates of employee records\*(Aq;
COMMENT ON SCHEMA my_schema IS \*(AqDepartmental data\*(Aq;
COMMENT ON SEQUENCE my_sequence IS \*(AqUsed to generate primary keys\*(Aq;
COMMENT ON SERVER myserver IS \*(Aqmy foreign server\*(Aq;
COMMENT ON TABLE my_schema\&amp;.my_table IS \*(AqEmployee Information\*(Aq;
COMMENT ON TABLESPACE my_tablespace IS \*(AqTablespace for indexes\*(Aq;
COMMENT ON TEXT SEARCH CONFIGURATION my_config IS \*(AqSpecial word filtering\*(Aq;
COMMENT ON TEXT SEARCH DICTIONARY swedish IS \*(AqSnowball stemmer for Swedish language\*(Aq;
COMMENT ON TEXT SEARCH PARSER my_parser IS \*(AqSplits text into words\*(Aq;
COMMENT ON TEXT SEARCH TEMPLATE snowball IS \*(AqSnowball stemmer\*(Aq;
COMMENT ON TRANSFORM FOR hstore LANGUAGE plpythonu IS \*(AqTransform between hstore and Python dict\*(Aq;
COMMENT ON TRIGGER my_trigger ON my_table IS \*(AqUsed for RI\*(Aq;
COMMENT ON TYPE complex IS \*(AqComplex number data type\*(Aq;
COMMENT ON VIEW my_view IS \*(AqView of departmental costs\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBCOMMENT\fR
command in the SQL standard\&amp;.
'\" t
.\"     Title: COMMIT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "COMMIT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
COMMIT \- commit the current transaction
.SH "SYNOPSIS"
.sp
.nf
COMMIT [ WORK | TRANSACTION ]
.fi
.SH "DESCRIPTION"
.PP
\fBCOMMIT\fR
commits the current transaction\&amp;. All changes made by the transaction become visible to others and are guaranteed to be durable if a crash occurs\&amp;.
.SH "PARAMETERS"
.PP
WORK
.br
TRANSACTION
.RS 4
Optional key words\&amp;. They have no effect\&amp;.
.RE
.SH "NOTES"
.PP
Use
\fBROLLBACK\fR(7)
to abort a transaction\&amp;.
.PP
Issuing
\fBCOMMIT\fR
when not inside a transaction does no harm, but it will provoke a warning message\&amp;.
.SH "EXAMPLES"
.PP
To commit the current transaction and make all changes permanent:
.sp
.if n \{\
.RS 4
.\}
.nf
COMMIT;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The SQL standard only specifies the two forms
COMMIT
and
COMMIT WORK\&amp;. Otherwise, this command is fully conforming\&amp;.
.SH "SEE ALSO"
\fBBEGIN\fR(7), \fBROLLBACK\fR(7)
'\" t
.\"     Title: COMMIT PREPARED
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "COMMIT PREPARED" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
COMMIT_PREPARED \- commit a transaction that was earlier prepared for two\-phase commit
.SH "SYNOPSIS"
.sp
.nf
COMMIT PREPARED \fItransaction_id\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCOMMIT PREPARED\fR
commits a transaction that is in prepared state\&amp;.
.SH "PARAMETERS"
.PP
\fItransaction_id\fR
.RS 4
The transaction identifier of the transaction that is to be committed\&amp;.
.RE
.SH "NOTES"
.PP
To commit a prepared transaction, you must be either the same user that executed the transaction originally, or a superuser\&amp;. But you do not have to be in the same session that executed the transaction\&amp;.
.PP
This command cannot be executed inside a transaction block\&amp;. The prepared transaction is committed immediately\&amp;.
.PP
All currently available prepared transactions are listed in the
pg_prepared_xacts
system view\&amp;.
.SH "EXAMPLES"
.PP
Commit the transaction identified by the transaction identifier
foobar:
.sp
.if n \{\
.RS 4
.\}
.nf
COMMIT PREPARED \*(Aqfoobar\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCOMMIT PREPARED\fR
is a
PostgreSQL
extension\&amp;. It is intended for use by external transaction management systems, some of which are covered by standards (such as X/Open XA), but the SQL side of those systems is not standardized\&amp;.
.SH "SEE ALSO"
PREPARE TRANSACTION (\fBPREPARE_TRANSACTION\fR(7)), ROLLBACK PREPARED (\fBROLLBACK_PREPARED\fR(7))
'\" t
.\"     Title: COPY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "COPY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
COPY \- copy data between a file and a table
.SH "SYNOPSIS"
.sp
.nf
COPY \fItable_name\fR [ ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ]
FROM { \*(Aq\fIfilename\fR\*(Aq | PROGRAM \*(Aq\fIcommand\fR\*(Aq | STDIN }
[ [ WITH ] ( \fIoption\fR [, \&amp;.\&amp;.\&amp;.] ) ]

COPY { \fItable_name\fR [ ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ] | ( \fIquery\fR ) }
TO { \*(Aq\fIfilename\fR\*(Aq | PROGRAM \*(Aq\fIcommand\fR\*(Aq | STDOUT }
[ [ WITH ] ( \fIoption\fR [, \&amp;.\&amp;.\&amp;.] ) ]

where \fIoption\fR can be one of:

FORMAT \fIformat_name\fR
OIDS [ \fIboolean\fR ]
FREEZE [ \fIboolean\fR ]
DELIMITER \*(Aq\fIdelimiter_character\fR\*(Aq
NULL \*(Aq\fInull_string\fR\*(Aq
HEADER [ \fIboolean\fR ]
QUOTE \*(Aq\fIquote_character\fR\*(Aq
ESCAPE \*(Aq\fIescape_character\fR\*(Aq
FORCE_QUOTE { ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) | * }
FORCE_NOT_NULL ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] )
FORCE_NULL ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] )
ENCODING \*(Aq\fIencoding_name\fR\*(Aq
.fi
.SH "DESCRIPTION"
.PP
\fBCOPY\fR
moves data between
PostgreSQL
tables and standard file\-system files\&amp;.
\fBCOPY TO\fR
copies the contents of a table
\fIto\fR
a file, while
\fBCOPY FROM\fR
copies data
\fIfrom\fR
a file to a table (appending the data to whatever is in the table already)\&amp;.
\fBCOPY TO\fR
can also copy the results of a
\fBSELECT\fR
query\&amp;.
.PP
If a list of columns is specified,
\fBCOPY\fR
will only copy the data in the specified columns to or from the file\&amp;. If there are any columns in the table that are not in the column list,
\fBCOPY FROM\fR
will insert the default values for those columns\&amp;.
.PP
\fBCOPY\fR
with a file name instructs the
PostgreSQL
server to directly read from or write to a file\&amp;. The file must be accessible by the
PostgreSQL
user (the user ID the server runs as) and the name must be specified from the viewpoint of the server\&amp;. When
PROGRAM
is specified, the server executes the given command and reads from the standard output of the program, or writes to the standard input of the program\&amp;. The command must be specified from the viewpoint of the server, and be executable by the
PostgreSQL
user\&amp;. When
STDIN
or
STDOUT
is specified, data is transmitted via the connection between the client and the server\&amp;.
.SH "PARAMETERS"
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of an existing table\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
An optional list of columns to be copied\&amp;. If no column list is specified, all columns of the table will be copied\&amp;.
.RE
.PP
\fIquery\fR
.RS 4
A
\fBSELECT\fR(7),
\fBVALUES\fR(7),
\fBINSERT\fR(7),
\fBUPDATE\fR(7)
or
\fBDELETE\fR(7)
command whose results are to be copied\&amp;. Note that parentheses are required around the query\&amp;.
.sp
For
\fBINSERT\fR,
\fBUPDATE\fR
and
\fBDELETE\fR
queries a RETURNING clause must be provided, and the target relation must not have a conditional rule, nor an
ALSO
rule, nor an
INSTEAD
rule that expands to multiple statements\&amp;.
.RE
.PP
\fIfilename\fR
.RS 4
The path name of the input or output file\&amp;. An input file name can be an absolute or relative path, but an output file name must be an absolute path\&amp;. Windows users might need to use an
E\*(Aq\*(Aq
string and double any backslashes used in the path name\&amp;.
.RE
.PP
PROGRAM
.RS 4
A command to execute\&amp;. In
\fBCOPY FROM\fR, the input is read from standard output of the command, and in
\fBCOPY TO\fR, the output is written to the standard input of the command\&amp;.
.sp
Note that the command is invoked by the shell, so if you need to pass any arguments to shell command that come from an untrusted source, you must be careful to strip or escape any special characters that might have a special meaning for the shell\&amp;. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it\&amp;.
.RE
.PP
STDIN
.RS 4
Specifies that input comes from the client application\&amp;.
.RE
.PP
STDOUT
.RS 4
Specifies that output goes to the client application\&amp;.
.RE
.PP
\fIboolean\fR
.RS 4
Specifies whether the selected option should be turned on or off\&amp;. You can write
TRUE,
ON, or
1
to enable the option, and
FALSE,
OFF, or
0
to disable it\&amp;. The
\fIboolean\fR
value can also be omitted, in which case
TRUE
is assumed\&amp;.
.RE
.PP
FORMAT
.RS 4
Selects the data format to be read or written:
text,
csv
(Comma Separated Values), or
binary\&amp;. The default is
text\&amp;.
.RE
.PP
OIDS
.RS 4
Specifies copying the OID for each row\&amp;. (An error is raised if
OIDS
is specified for a table that does not have OIDs, or in the case of copying a
\fIquery\fR\&amp;.)
.RE
.PP
FREEZE
.RS 4
Requests copying the data with rows already frozen, just as they would be after running the
\fBVACUUM FREEZE\fR
command\&amp;. This is intended as a performance option for initial data loading\&amp;. Rows will be frozen only if the table being loaded has been created or truncated in the current subtransaction, there are no cursors open and there are no older snapshots held by this transaction\&amp;.
.sp
Note that all other sessions will immediately be able to see the data once it has been successfully loaded\&amp;. This violates the normal rules of MVCC visibility and users specifying should be aware of the potential problems this might cause\&amp;.
.RE
.PP
DELIMITER
.RS 4
Specifies the character that separates columns within each row (line) of the file\&amp;. The default is a tab character in text format, a comma in
CSV
format\&amp;. This must be a single one\-byte character\&amp;. This option is not allowed when using
binary
format\&amp;.
.RE
.PP
NULL
.RS 4
Specifies the string that represents a null value\&amp;. The default is
\eN
(backslash\-N) in text format, and an unquoted empty string in
CSV
format\&amp;. You might prefer an empty string even in text format for cases where you don\*(Aqt want to distinguish nulls from empty strings\&amp;. This option is not allowed when using
binary
format\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
When using
\fBCOPY FROM\fR, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used with
\fBCOPY TO\fR\&amp;.
.sp .5v
.RE
.RE
.PP
HEADER
.RS 4
Specifies that the file contains a header line with the names of each column in the file\&amp;. On output, the first line contains the column names from the table, and on input, the first line is ignored\&amp;. This option is allowed only when using
CSV
format\&amp;.
.RE
.PP
QUOTE
.RS 4
Specifies the quoting character to be used when a data value is quoted\&amp;. The default is double\-quote\&amp;. This must be a single one\-byte character\&amp;. This option is allowed only when using
CSV
format\&amp;.
.RE
.PP
ESCAPE
.RS 4
Specifies the character that should appear before a data character that matches the
QUOTE
value\&amp;. The default is the same as the
QUOTE
value (so that the quoting character is doubled if it appears in the data)\&amp;. This must be a single one\-byte character\&amp;. This option is allowed only when using
CSV
format\&amp;.
.RE
.PP
FORCE_QUOTE
.RS 4
Forces quoting to be used for all non\-NULL
values in each specified column\&amp;.
NULL
output is never quoted\&amp;. If
*
is specified, non\-NULL
values will be quoted in all columns\&amp;. This option is allowed only in
\fBCOPY TO\fR, and only when using
CSV
format\&amp;.
.RE
.PP
FORCE_NOT_NULL
.RS 4
Do not match the specified columns\*(Aq values against the null string\&amp;. In the default case where the null string is empty, this means that empty values will be read as zero\-length strings rather than nulls, even when they are not quoted\&amp;. This option is allowed only in
\fBCOPY FROM\fR, and only when using
CSV
format\&amp;.
.RE
.PP
FORCE_NULL
.RS 4
Match the specified columns\*(Aq values against the null string, even if it has been quoted, and if a match is found set the value to
NULL\&amp;. In the default case where the null string is empty, this converts a quoted empty string into NULL\&amp;. This option is allowed only in
\fBCOPY FROM\fR, and only when using
CSV
format\&amp;.
.RE
.PP
ENCODING
.RS 4
Specifies that the file is encoded in the
\fIencoding_name\fR\&amp;. If this option is omitted, the current client encoding is used\&amp;. See the Notes below for more details\&amp;.
.RE
.SH "OUTPUTS"
.PP
On successful completion, a
\fBCOPY\fR
command returns a command tag of the form
.sp
.if n \{\
.RS 4
.\}
.nf
COPY \fIcount\fR
.fi
.if n \{\
.RE
.\}
.sp
The
\fIcount\fR
is the number of rows copied\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
psql
will print this command tag only if the command was not
COPY \&amp;.\&amp;.\&amp;. TO STDOUT, or the equivalent
psql
meta\-command
\ecopy \&amp;.\&amp;.\&amp;. to stdout\&amp;. This is to prevent confusing the command tag with the data that was just printed\&amp;.
.sp .5v
.RE
.SH "NOTES"
.PP
\fBCOPY\fR
can only be used with plain tables, not with views\&amp;. However, you can write
COPY (SELECT * FROM \fIviewname\fR) TO \&amp;.\&amp;.\&amp;.\&amp;.
.PP
\fBCOPY\fR
only deals with the specific table named; it does not copy data to or from child tables\&amp;. Thus for example
COPY \fItable\fR TO
shows the same data as
SELECT * FROM ONLY \fItable\fR\&amp;. But
COPY (SELECT * FROM \fItable\fR) TO \&amp;.\&amp;.\&amp;.
can be used to dump all of the data in an inheritance hierarchy\&amp;.
.PP
You must have select privilege on the table whose values are read by
\fBCOPY TO\fR, and insert privilege on the table into which values are inserted by
\fBCOPY FROM\fR\&amp;. It is sufficient to have column privileges on the column(s) listed in the command\&amp;.
.PP
Files named in a
\fBCOPY\fR
command are read or written directly by the server, not by the client application\&amp;. Therefore, they must reside on or be accessible to the database server machine, not the client\&amp;. They must be accessible to and readable or writable by the
PostgreSQL
user (the user ID the server runs as), not the client\&amp;. Similarly, the command specified with
PROGRAM
is executed directly by the server, not by the client application, must be executable by the
PostgreSQL
user\&amp;.
\fBCOPY\fR
naming a file or command is only allowed to database superusers, since it allows reading or writing any file that the server has privileges to access\&amp;.
.PP
Do not confuse
\fBCOPY\fR
with the
psql
instruction
\fB\copy\fR\&amp;.
\fB\ecopy\fR
invokes
\fBCOPY FROM STDIN\fR
or
\fBCOPY TO STDOUT\fR, and then fetches/stores the data in a file accessible to the
psql
client\&amp;. Thus, file accessibility and access rights depend on the client rather than the server when
\fB\ecopy\fR
is used\&amp;.
.PP
It is recommended that the file name used in
\fBCOPY\fR
always be specified as an absolute path\&amp;. This is enforced by the server in the case of
\fBCOPY TO\fR, but for
\fBCOPY FROM\fR
you do have the option of reading from a file specified by a relative path\&amp;. The path will be interpreted relative to the working directory of the server process (normally the cluster\*(Aqs data directory), not the client\*(Aqs working directory\&amp;.
.PP
Executing a command with
PROGRAM
might be restricted by the operating system\*(Aqs access control mechanisms, such as SELinux\&amp;.
.PP
\fBCOPY FROM\fR
will invoke any triggers and check constraints on the destination table\&amp;. However, it will not invoke rules\&amp;.
.PP
\fBCOPY\fR
input and output is affected by
\fIDateStyle\fR\&amp;. To ensure portability to other
PostgreSQL
installations that might use non\-default
\fIDateStyle\fR
settings,
\fIDateStyle\fR
should be set to
ISO
before using
\fBCOPY TO\fR\&amp;. It is also a good idea to avoid dumping data with
\fIIntervalStyle\fR
set to
sql_standard, because negative interval values might be misinterpreted by a server that has a different setting for
\fIIntervalStyle\fR\&amp;.
.PP
Input data is interpreted according to
ENCODING
option or the current client encoding, and output data is encoded in
ENCODING
or the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server\&amp;.
.PP
\fBCOPY\fR
stops operation at the first error\&amp;. This should not lead to problems in the event of a
\fBCOPY TO\fR, but the target table will already have received earlier rows in a
\fBCOPY FROM\fR\&amp;. These rows will not be visible or accessible, but they still occupy disk space\&amp;. This might amount to a considerable amount of wasted disk space if the failure happened well into a large copy operation\&amp;. You might wish to invoke
\fBVACUUM\fR
to recover the wasted space\&amp;.
.PP
FORCE_NULL
and
FORCE_NOT_NULL
can be used simultaneously on the same column\&amp;. This results in converting quoted null strings to null values and unquoted null strings to empty strings\&amp;.
.SH "FILE FORMATS"
.SS "Text Format"
.PP
When the
text
format is used, the data read or written is a text file with one line per table row\&amp;. Columns in a row are separated by the delimiter character\&amp;. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute\*(Aqs data type\&amp;. The specified null string is used in place of columns that are null\&amp;.
\fBCOPY FROM\fR
will raise an error if any line of the input file contains more or fewer columns than are expected\&amp;. If
OIDS
is specified, the OID is read or written as the first column, preceding the user data columns\&amp;.
.PP
End of data can be represented by a single line containing just backslash\-period (\e\&amp;.)\&amp;. An end\-of\-data marker is not necessary when reading from a file, since the end of file serves perfectly well; it is needed only when copying data to or from client applications using pre\-3\&amp;.0 client protocol\&amp;.
.PP
Backslash characters (\e) can be used in the
\fBCOPY\fR
data to quote data characters that might otherwise be taken as row or column delimiters\&amp;. In particular, the following characters
\fImust\fR
be preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character\&amp;.
.PP
The specified null string is sent by
\fBCOPY TO\fR
without adding any backslashes; conversely,
\fBCOPY FROM\fR
matches the input against the null string before removing backslashes\&amp;. Therefore, a null string such as
\eN
cannot be confused with the actual data value
\eN
(which would be represented as
\e\eN)\&amp;.
.PP
The following special backslash sequences are recognized by
\fBCOPY FROM\fR:
.TS
allbox tab(:);
lB lB.
T{
Sequence
T}:T{
Represents
T}
.T&amp;
l l
l l
l l
l l
l l
l l
l l
l l.
T{
\eb
T}:T{
Backspace (ASCII 8)
T}
T{
\ef
T}:T{
Form feed (ASCII 12)
T}
T{
\en
T}:T{
Newline (ASCII 10)
T}
T{
\er
T}:T{
Carriage return (ASCII 13)
T}
T{
\et
T}:T{
Tab (ASCII 9)
T}
T{
\ev
T}:T{
Vertical tab (ASCII 11)
T}
T{
\e\fIdigits\fR
T}:T{
Backslash followed by one to three octal digits specifies
the character with that numeric code
T}
T{
\ex\fIdigits\fR
T}:T{
Backslash x followed by one or two hex digits specifies
the character with that numeric code
T}
.TE
.sp 1
Presently,
\fBCOPY TO\fR
will never emit an octal or hex\-digits backslash sequence, but it does use the other sequences listed above for those control characters\&amp;.
.PP
Any other backslashed character that is not mentioned in the above table will be taken to represent itself\&amp;. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end\-of\-data marker (\e\&amp;.) or the null string (\eN
by default)\&amp;. These strings will be recognized before any other backslash processing is done\&amp;.
.PP
It is strongly recommended that applications generating
\fBCOPY\fR
data convert data newlines and carriage returns to the
\en
and
\er
sequences respectively\&amp;. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline\&amp;. However, these representations might not be accepted in future releases\&amp;. They are also highly vulnerable to corruption if the
\fBCOPY\fR
file is transferred across different machines (for example, from Unix to Windows or vice versa)\&amp;.
.PP
\fBCOPY TO\fR
will terminate each row with a Unix\-style newline (\(lq\en\(rq)\&amp;. Servers running on Microsoft Windows instead output carriage return/newline (\(lq\er\en\(rq), but only for
\fBCOPY\fR
to a server file; for consistency across platforms,
\fBCOPY TO STDOUT\fR
always sends
\(lq\en\(rq
regardless of server platform\&amp;.
\fBCOPY FROM\fR
can handle lines ending with newlines, carriage returns, or carriage return/newlines\&amp;. To reduce the risk of error due to un\-backslashed newlines or carriage returns that were meant as data,
\fBCOPY FROM\fR
will complain if the line endings in the input are not all alike\&amp;.
.SS "CSV Format"
.PP
This format option is used for importing and exporting the Comma Separated Value (CSV) file format used by many other programs, such as spreadsheets\&amp;. Instead of the escaping rules used by
PostgreSQL\*(Aqs standard text format, it produces and recognizes the common CSV escaping mechanism\&amp;.
.PP
The values in each record are separated by the
DELIMITER
character\&amp;. If the value contains the delimiter character, the
QUOTE
character, the
NULL
string, a carriage return, or line feed character, then the whole value is prefixed and suffixed by the
QUOTE
character, and any occurrence within the value of a
QUOTE
character or the
ESCAPE
character is preceded by the escape character\&amp;. You can also use
FORCE_QUOTE
to force quotes when outputting non\-NULL
values in specific columns\&amp;.
.PP
The
CSV
format has no standard way to distinguish a
NULL
value from an empty string\&amp;.
PostgreSQL\*(Aqs
\fBCOPY\fR
handles this by quoting\&amp;. A
NULL
is output as the
NULL
parameter string and is not quoted, while a non\-NULL
value matching the
NULL
parameter string is quoted\&amp;. For example, with the default settings, a
NULL
is written as an unquoted empty string, while an empty string data value is written with double quotes ("")\&amp;. Reading values follows similar rules\&amp;. You can use
FORCE_NOT_NULL
to prevent
NULL
input comparisons for specific columns\&amp;. You can also use
FORCE_NULL
to convert quoted null string data values to
NULL\&amp;.
.PP
Because backslash is not a special character in the
CSV
format,
\e\&amp;., the end\-of\-data marker, could also appear as a data value\&amp;. To avoid any misinterpretation, a
\e\&amp;.
data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end\-of\-data marker\&amp;. If you are loading a file created by another application that has a single unquoted column and might have a value of
\e\&amp;., you might need to quote that value in the input file\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
In
CSV
format, all characters are significant\&amp;. A quoted value surrounded by white space, or any characters other than
DELIMITER, will include those characters\&amp;. This can cause errors if you import data from a system that pads
CSV
lines with white space out to some fixed width\&amp;. If such a situation arises you might need to preprocess the
CSV
file to remove the trailing white space, before importing the data into
PostgreSQL\&amp;.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
CSV format will both recognize and produce CSV files with quoted values containing embedded carriage returns and line feeds\&amp;. Thus the files are not strictly one line per table row like text\-format files\&amp;.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Many programs produce strange and occasionally perverse CSV files, so the file format is more a convention than a standard\&amp;. Thus you might encounter some files that cannot be imported using this mechanism, and
\fBCOPY\fR
might produce files that other programs cannot process\&amp;.
.sp .5v
.RE
.SS "Binary Format"
.PP
The
binary
format option causes all data to be stored/read as binary format rather than as text\&amp;. It is somewhat faster than the text and
CSV
formats, but a binary\-format file is less portable across machine architectures and
PostgreSQL
versions\&amp;. Also, the binary format is very data type specific; for example it will not work to output binary data from a
smallint
column and read it into an
integer
column, even though that would work fine in text format\&amp;.
.PP
The
binary
file format consists of a file header, zero or more tuples containing the row data, and a file trailer\&amp;. Headers and data are in network byte order\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
PostgreSQL
releases before 7\&amp;.4 used a different binary file format\&amp;.
.sp .5v
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBFile Header\fR
.RS 4
.PP
The file header consists of 15 bytes of fixed fields, followed by a variable\-length header extension area\&amp;. The fixed fields are:
.PP
Signature
.RS 4
11\-byte sequence
PGCOPY\en\e377\er\en\e0
\(em note that the zero byte is a required part of the signature\&amp;. (The signature is designed to allow easy identification of files that have been munged by a non\-8\-bit\-clean transfer\&amp;. This signature will be changed by end\-of\-line\-translation filters, dropped zero bytes, dropped high bits, or parity changes\&amp;.)
.RE
.PP
Flags field
.RS 4
32\-bit integer bit mask to denote important aspects of the file format\&amp;. Bits are numbered from 0 (LSB) to 31 (MSB)\&amp;. Note that this field is stored in network byte order (most significant byte first), as are all the integer fields used in the file format\&amp;. Bits 16\-31 are reserved to denote critical file format issues; a reader should abort if it finds an unexpected bit set in this range\&amp;. Bits 0\-15 are reserved to signal backwards\-compatible format issues; a reader should simply ignore any unexpected bits set in this range\&amp;. Currently only one flag bit is defined, and the rest must be zero:
.PP
Bit 16
.RS 4
if 1, OIDs are included in the data; if 0, not
.RE
.RE
.PP
Header extension area length
.RS 4
32\-bit integer, length in bytes of remainder of header, not including self\&amp;. Currently, this is zero, and the first tuple follows immediately\&amp;. Future changes to the format might allow additional data to be present in the header\&amp;. A reader should silently skip over any header extension data it does not know what to do with\&amp;.
.RE
.PP
The header extension area is envisioned to contain a sequence of self\-identifying chunks\&amp;. The flags field is not intended to tell readers what is in the extension area\&amp;. Specific design of header extension contents is left for a later release\&amp;.
.PP
This design allows for both backwards\-compatible header additions (add header extension chunks, or set low\-order flag bits) and non\-backwards\-compatible changes (set high\-order flag bits to signal such changes, and add supporting data to the extension area if needed)\&amp;.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBTuples\fR
.RS 4
.PP
Each tuple begins with a 16\-bit integer count of the number of fields in the tuple\&amp;. (Presently, all tuples in a table will have the same count, but that might not always be true\&amp;.) Then, repeated for each field in the tuple, there is a 32\-bit length word followed by that many bytes of field data\&amp;. (The length word does not include itself, and can be zero\&amp;.) As a special case, \-1 indicates a NULL field value\&amp;. No value bytes follow in the NULL case\&amp;.
.PP
There is no alignment padding or any other extra data between fields\&amp;.
.PP
Presently, all data values in a binary\-format file are assumed to be in binary format (format code one)\&amp;. It is anticipated that a future extension might add a header field that allows per\-column format codes to be specified\&amp;.
.PP
To determine the appropriate binary format for the actual tuple data you should consult the
PostgreSQL
source, in particular the
\fB*send\fR
and
\fB*recv\fR
functions for each column\*(Aqs data type (typically these functions are found in the
src/backend/utils/adt/
directory of the source distribution)\&amp;.
.PP
If OIDs are included in the file, the OID field immediately follows the field\-count word\&amp;. It is a normal field except that it\*(Aqs not included in the field\-count\&amp;. In particular it has a length word \(em this will allow handling of 4\-byte vs\&amp;. 8\-byte OIDs without too much pain, and will allow OIDs to be shown as null if that ever proves desirable\&amp;.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBFile Trailer\fR
.RS 4
.PP
The file trailer consists of a 16\-bit integer word containing \-1\&amp;. This is easily distinguished from a tuple\*(Aqs field\-count word\&amp;.
.PP
A reader should report an error if a field\-count word is neither \-1 nor the expected number of columns\&amp;. This provides an extra check against somehow getting out of sync with the data\&amp;.
.RE
.SH "EXAMPLES"
.PP
The following example copies a table to the client using the vertical bar (|) as the field delimiter:
.sp
.if n \{\
.RS 4
.\}
.nf
COPY country TO STDOUT (DELIMITER \*(Aq|\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
To copy data from a file into the
country
table:
.sp
.if n \{\
.RS 4
.\}
.nf
COPY country FROM \*(Aq/usr1/proj/bray/sql/country_data\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
To copy into a file just the countries whose names start with \*(AqA\*(Aq:
.sp
.if n \{\
.RS 4
.\}
.nf
COPY (SELECT * FROM country WHERE country_name LIKE \*(AqA%\*(Aq) TO \*(Aq/usr1/proj/bray/sql/a_list_countries\&amp;.copy\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
To copy into a compressed file, you can pipe the output through an external compression program:
.sp
.if n \{\
.RS 4
.\}
.nf
COPY country TO PROGRAM \*(Aqgzip &gt; /usr1/proj/bray/sql/country_data\&amp;.gz\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Here is a sample of data suitable for copying into a table from
STDIN:
.sp
.if n \{\
.RS 4
.\}
.nf
AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE
.fi
.if n \{\
.RE
.\}
.sp
Note that the white space on each line is actually a tab character\&amp;.
.PP
The following is the same data, output in binary format\&amp;. The data is shown after filtering through the Unix utility
\fBod \-c\fR\&amp;. The table has three columns; the first has type
char(2), the second has type
text, and the third has type
integer\&amp;. All the rows have a null value in the third column\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
0000000   P   G   C   O   P   Y  \en 377  \er  \en  \e0  \e0  \e0  \e0  \e0  \e0
0000020  \e0  \e0  \e0  \e0 003  \e0  \e0  \e0 002   A   F  \e0  \e0  \e0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \e0 003
0000060  \e0  \e0  \e0 002   A   L  \e0  \e0  \e0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \e0 003  \e0  \e0  \e0 002   D   Z  \e0  \e0  \e0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \e0 003  \e0  \e0
0000140  \e0 002   Z   M  \e0  \e0  \e0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \e0 003  \e0  \e0  \e0 002   Z   W  \e0  \e0  \e0  \eb   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBCOPY\fR
statement in the SQL standard\&amp;.
.PP
The following syntax was used before
PostgreSQL
version 9\&amp;.0 and is still supported:
.sp
.if n \{\
.RS 4
.\}
.nf
COPY \fItable_name\fR [ ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ]
FROM { \*(Aq\fIfilename\fR\*(Aq | STDIN }
[ [ WITH ]
[ BINARY ]
[ OIDS ]
[ DELIMITER [ AS ] \*(Aq\fIdelimiter\fR\*(Aq ]
[ NULL [ AS ] \*(Aq\fInull string\fR\*(Aq ]
[ CSV [ HEADER ]
[ QUOTE [ AS ] \*(Aq\fIquote\fR\*(Aq ]
[ ESCAPE [ AS ] \*(Aq\fIescape\fR\*(Aq ]
[ FORCE NOT NULL \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ] ] ]

COPY { \fItable_name\fR [ ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ] | ( \fIquery\fR ) }
TO { \*(Aq\fIfilename\fR\*(Aq | STDOUT }
[ [ WITH ]
[ BINARY ]
[ OIDS ]
[ DELIMITER [ AS ] \*(Aq\fIdelimiter\fR\*(Aq ]
[ NULL [ AS ] \*(Aq\fInull string\fR\*(Aq ]
[ CSV [ HEADER ]
[ QUOTE [ AS ] \*(Aq\fIquote\fR\*(Aq ]
[ ESCAPE [ AS ] \*(Aq\fIescape\fR\*(Aq ]
[ FORCE QUOTE { \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] | * } ] ] ]
.fi
.if n \{\
.RE
.\}
.sp
Note that in this syntax,
BINARY
and
CSV
are treated as independent keywords, not as arguments of a
FORMAT
option\&amp;.
.PP
The following syntax was used before
PostgreSQL
version 7\&amp;.3 and is still supported:
.sp
.if n \{\
.RS 4
.\}
.nf
COPY [ BINARY ] \fItable_name\fR [ WITH OIDS ]
FROM { \*(Aq\fIfilename\fR\*(Aq | STDIN }
[ [USING] DELIMITERS \*(Aq\fIdelimiter\fR\*(Aq ]
[ WITH NULL AS \*(Aq\fInull string\fR\*(Aq ]

COPY [ BINARY ] \fItable_name\fR [ WITH OIDS ]
TO { \*(Aq\fIfilename\fR\*(Aq | STDOUT }
[ [USING] DELIMITERS \*(Aq\fIdelimiter\fR\*(Aq ]
[ WITH NULL AS \*(Aq\fInull string\fR\*(Aq ]
.fi
.if n \{\
.RE
.\}

'\" t
.\"     Title: CREATE ACCESS METHOD
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE ACCESS METHOD" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_ACCESS_METHOD \- define a new access method
.SH "SYNOPSIS"
.sp
.nf
CREATE ACCESS METHOD \fIname\fR
TYPE \fIaccess_method_type\fR
HANDLER \fIhandler_function\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE ACCESS METHOD\fR
creates a new access method\&amp;.
.PP
The access method name must be unique within the database\&amp;.
.PP
Only superusers can define new access methods\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the access method to be created\&amp;.
.RE
.PP
\fIaccess_method_type\fR
.RS 4
This clause specifies the type of access method to define\&amp;. Only
INDEX
is supported at present\&amp;.
.RE
.PP
\fIhandler_function\fR
.RS 4
\fIhandler_function\fR
is the name (possibly schema\-qualified) of a previously registered function that represents the access method\&amp;. The handler function must be declared to take a single argument of type
internal, and its return type depends on the type of access method; for
INDEX
access methods, it must be
index_am_handler\&amp;. The C\-level API that the handler function must implement varies depending on the type of access method\&amp;. The index access method API is described in
Chapter 59, Index Access Method Interface Definition, in the documentation\&amp;.
.RE
.SH "EXAMPLES"
.PP
Create an index access method
heptree
with handler function
heptree_handler:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE ACCESS METHOD heptree TYPE INDEX HANDLER heptree_handler;
.fi
.if n \{\
.RE
.\}
.sp
.SH "COMPATIBILITY"
.PP
\fBCREATE ACCESS METHOD\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
DROP ACCESS METHOD (\fBDROP_ACCESS_METHOD\fR(7)), CREATE OPERATOR CLASS (\fBCREATE_OPERATOR_CLASS\fR(7)), CREATE OPERATOR FAMILY (\fBCREATE_OPERATOR_FAMILY\fR(7))
'\" t
.\"     Title: CREATE AGGREGATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE AGGREGATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_AGGREGATE \- define a new aggregate function
.SH "SYNOPSIS"
.sp
.nf
CREATE AGGREGATE \fIname\fR ( [ \fIargmode\fR ] [ \fIargname\fR ] \fIarg_data_type\fR [ , \&amp;.\&amp;.\&amp;. ] ) (
SFUNC = \fIsfunc\fR,
STYPE = \fIstate_data_type\fR
[ , SSPACE = \fIstate_data_size\fR ]
[ , FINALFUNC = \fIffunc\fR ]
[ , FINALFUNC_EXTRA ]
[ , COMBINEFUNC = \fIcombinefunc\fR ]
[ , SERIALFUNC = \fIserialfunc\fR ]
[ , DESERIALFUNC = \fIdeserialfunc\fR ]
[ , INITCOND = \fIinitial_condition\fR ]
[ , MSFUNC = \fImsfunc\fR ]
[ , MINVFUNC = \fIminvfunc\fR ]
[ , MSTYPE = \fImstate_data_type\fR ]
[ , MSSPACE = \fImstate_data_size\fR ]
[ , MFINALFUNC = \fImffunc\fR ]
[ , MFINALFUNC_EXTRA ]
[ , MINITCOND = \fIminitial_condition\fR ]
[ , SORTOP = \fIsort_operator\fR ]
[ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
)

CREATE AGGREGATE \fIname\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIarg_data_type\fR [ , \&amp;.\&amp;.\&amp;. ] ]
ORDER BY [ \fIargmode\fR ] [ \fIargname\fR ] \fIarg_data_type\fR [ , \&amp;.\&amp;.\&amp;. ] ) (
SFUNC = \fIsfunc\fR,
STYPE = \fIstate_data_type\fR
[ , SSPACE = \fIstate_data_size\fR ]
[ , FINALFUNC = \fIffunc\fR ]
[ , FINALFUNC_EXTRA ]
[ , INITCOND = \fIinitial_condition\fR ]
[ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
[ , HYPOTHETICAL ]
)

or the old syntax

CREATE AGGREGATE \fIname\fR (
BASETYPE = \fIbase_type\fR,
SFUNC = \fIsfunc\fR,
STYPE = \fIstate_data_type\fR
[ , SSPACE = \fIstate_data_size\fR ]
[ , FINALFUNC = \fIffunc\fR ]
[ , FINALFUNC_EXTRA ]
[ , COMBINEFUNC = \fIcombinefunc\fR ]
[ , SERIALFUNC = \fIserialfunc\fR ]
[ , DESERIALFUNC = \fIdeserialfunc\fR ]
[ , INITCOND = \fIinitial_condition\fR ]
[ , MSFUNC = \fImsfunc\fR ]
[ , MINVFUNC = \fIminvfunc\fR ]
[ , MSTYPE = \fImstate_data_type\fR ]
[ , MSSPACE = \fImstate_data_size\fR ]
[ , MFINALFUNC = \fImffunc\fR ]
[ , MFINALFUNC_EXTRA ]
[ , MINITCOND = \fIminitial_condition\fR ]
[ , SORTOP = \fIsort_operator\fR ]
)
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE AGGREGATE\fR
defines a new aggregate function\&amp;. Some basic and commonly\-used aggregate functions are included with the distribution; they are documented in
Section 9.20, \(lqAggregate Functions\(rq, in the documentation\&amp;. If one defines new types or needs an aggregate function not already provided, then
\fBCREATE AGGREGATE\fR
can be used to provide the desired features\&amp;.
.PP
If a schema name is given (for example,
CREATE AGGREGATE myschema\&amp;.myagg \&amp;.\&amp;.\&amp;.) then the aggregate function is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;.
.PP
An aggregate function is identified by its name and input data type(s)\&amp;. Two aggregates in the same schema can have the same name if they operate on different input types\&amp;. The name and input data type(s) of an aggregate must also be distinct from the name and input data type(s) of every ordinary function in the same schema\&amp;. This behavior is identical to overloading of ordinary function names (see
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)))\&amp;.
.PP
A simple aggregate function is made from one or two ordinary functions: a state transition function
\fIsfunc\fR, and an optional final calculation function
\fIffunc\fR\&amp;. These are used as follows:
.sp
.if n \{\
.RS 4
.\}
.nf
\fIsfunc\fR( internal\-state, next\-data\-values ) \-\-\-&gt; next\-internal\-state
\fIffunc\fR( internal\-state ) \-\-\-&gt; aggregate\-value
.fi
.if n \{\
.RE
.\}
.PP
PostgreSQL
creates a temporary variable of data type
\fIstype\fR
to hold the current internal state of the aggregate\&amp;. At each input row, the aggregate argument value(s) are calculated and the state transition function is invoked with the current state value and the new argument value(s) to calculate a new internal state value\&amp;. After all the rows have been processed, the final function is invoked once to calculate the aggregate\*(Aqs return value\&amp;. If there is no final function then the ending state value is returned as\-is\&amp;.
.PP
An aggregate function can provide an initial condition, that is, an initial value for the internal state value\&amp;. This is specified and stored in the database as a value of type
text, but it must be a valid external representation of a constant of the state value data type\&amp;. If it is not supplied then the state value starts out null\&amp;.
.PP
If the state transition function is declared
\(lqstrict\(rq, then it cannot be called with null inputs\&amp;. With such a transition function, aggregate execution behaves as follows\&amp;. Rows with any null input values are ignored (the function is not called and the previous state value is retained)\&amp;. If the initial state value is null, then at the first row with all\-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at each subsequent row with all\-nonnull input values\&amp;. This is handy for implementing aggregates like
\fBmax\fR\&amp;. Note that this behavior is only available when
\fIstate_data_type\fR
is the same as the first
\fIarg_data_type\fR\&amp;. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function\&amp;.
.PP
If the state transition function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null state values for itself\&amp;. This allows the aggregate author to have full control over the aggregate\*(Aqs handling of null values\&amp;.
.PP
If the final function is declared
\(lqstrict\(rq, then it will not be called when the ending state value is null; instead a null result will be returned automatically\&amp;. (Of course this is just the normal behavior of strict functions\&amp;.) In any case the final function has the option of returning a null value\&amp;. For example, the final function for
\fBavg\fR
returns null when it sees there were zero input rows\&amp;.
.PP
Sometimes it is useful to declare the final function as taking not just the state value, but extra parameters corresponding to the aggregate\*(Aqs input values\&amp;. The main reason for doing this is if the final function is polymorphic and the state value\*(Aqs data type would be inadequate to pin down the result type\&amp;. These extra parameters are always passed as NULL (and so the final function must not be strict when the
FINALFUNC_EXTRA
option is used), but nonetheless they are valid parameters\&amp;. The final function could for example make use of
\fBget_fn_expr_argtype\fR
to identify the actual argument type in the current call\&amp;.
.PP
An aggregate can optionally support
moving\-aggregate mode, as described in
Section 36.10.1, \(lqMoving-Aggregate Mode\(rq, in the documentation\&amp;. This requires specifying the
MSFUNC,
MINVFUNC, and
MSTYPE
parameters, and optionally the
MSPACE,
MFINALFUNC,
MFINALFUNC_EXTRA, and
MINITCOND
parameters\&amp;. Except for
MINVFUNC, these parameters work like the corresponding simple\-aggregate parameters without
M; they define a separate implementation of the aggregate that includes an inverse transition function\&amp;.
.PP
The syntax with
ORDER BY
in the parameter list creates a special type of aggregate called an
ordered\-set aggregate; or if
HYPOTHETICAL
is specified, then a
hypothetical\-set aggregate
is created\&amp;. These aggregates operate over groups of sorted values in order\-dependent ways, so that specification of an input sort order is an essential part of a call\&amp;. Also, they can have
direct
arguments, which are arguments that are evaluated only once per aggregation rather than once per input row\&amp;. Hypothetical\-set aggregates are a subclass of ordered\-set aggregates in which some of the direct arguments are required to match, in number and data types, the aggregated argument columns\&amp;. This allows the values of those direct arguments to be added to the collection of aggregate\-input rows as an additional
\(lqhypothetical\(rq
row\&amp;.
.PP
An aggregate can optionally support
partial aggregation, as described in
Section 36.10.4, \(lqPartial Aggregation\(rq, in the documentation\&amp;. This requires specifying the
COMBINEFUNC
parameter\&amp;. If the
\fIstate_data_type\fR
is
internal, it\*(Aqs usually also appropriate to provide the
SERIALFUNC
and
DESERIALFUNC
parameters so that parallel aggregation is possible\&amp;. Note that the aggregate must also be marked
PARALLEL SAFE
to enable parallel aggregation\&amp;.
.PP
Aggregates that behave like
\fBMIN\fR
or
\fBMAX\fR
can sometimes be optimized by looking into an index instead of scanning every input row\&amp;. If this aggregate can be so optimized, indicate it by specifying a
sort operator\&amp;. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT agg(col) FROM tab;
.fi
.if n \{\
.RE
.\}
.sp
must be equivalent to:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
.fi
.if n \{\
.RE
.\}
.sp
Further assumptions are that the aggregate ignores null inputs, and that it delivers a null result if and only if there were no non\-null inputs\&amp;. Ordinarily, a data type\*(Aqs
&lt;
operator is the proper sort operator for
\fBMIN\fR, and
&gt;
is the proper sort operator for
\fBMAX\fR\&amp;. Note that the optimization will never actually take effect unless the specified operator is the
\(lqless than\(rq
or
\(lqgreater than\(rq
strategy member of a B\-tree index operator class\&amp;.
.PP
To be able to create an aggregate function, you must have
USAGE
privilege on the argument types, the state type(s), and the return type, as well as
EXECUTE
privilege on the supporting functions\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the aggregate function to create\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of an argument:
IN
or
VARIADIC\&amp;. (Aggregate functions do not support
OUT
arguments\&amp;.) If omitted, the default is
IN\&amp;. Only the last argument can be marked
VARIADIC\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of an argument\&amp;. This is currently only useful for documentation purposes\&amp;. If omitted, the argument has no name\&amp;.
.RE
.PP
\fIarg_data_type\fR
.RS 4
An input data type on which this aggregate function operates\&amp;. To create a zero\-argument aggregate function, write
*
in place of the list of argument specifications\&amp;. (An example of such an aggregate is
\fBcount(*)\fR\&amp;.)
.RE
.PP
\fIbase_type\fR
.RS 4
In the old syntax for
\fBCREATE AGGREGATE\fR, the input data type is specified by a
basetype
parameter rather than being written next to the aggregate name\&amp;. Note that this syntax allows only one input parameter\&amp;. To define a zero\-argument aggregate function with this syntax, specify the
basetype
as
"ANY"
(not
*)\&amp;. Ordered\-set aggregates cannot be defined with the old syntax\&amp;.
.RE
.PP
\fIsfunc\fR
.RS 4
The name of the state transition function to be called for each input row\&amp;. For a normal
\fIN\fR\-argument aggregate function, the
\fIsfunc\fR
must take
\fIN\fR+1 arguments, the first being of type
\fIstate_data_type\fR
and the rest matching the declared input data type(s) of the aggregate\&amp;. The function must return a value of type
\fIstate_data_type\fR\&amp;. This function takes the current state value and the current input data value(s), and returns the next state value\&amp;.
.sp
For ordered\-set (including hypothetical\-set) aggregates, the state transition function receives only the current state value and the aggregated arguments, not the direct arguments\&amp;. Otherwise it is the same\&amp;.
.RE
.PP
\fIstate_data_type\fR
.RS 4
The data type for the aggregate\*(Aqs state value\&amp;.
.RE
.PP
\fIstate_data_size\fR
.RS 4
The approximate average size (in bytes) of the aggregate\*(Aqs state value\&amp;. If this parameter is omitted or is zero, a default estimate is used based on the
\fIstate_data_type\fR\&amp;. The planner uses this value to estimate the memory required for a grouped aggregate query\&amp;. The planner will consider using hash aggregation for such a query only if the hash table is estimated to fit in
work_mem; therefore, large values of this parameter discourage use of hash aggregation\&amp;.
.RE
.PP
\fIffunc\fR
.RS 4
The name of the final function called to compute the aggregate\*(Aqs result after all input rows have been traversed\&amp;. For a normal aggregate, this function must take a single argument of type
\fIstate_data_type\fR\&amp;. The return data type of the aggregate is defined as the return type of this function\&amp;. If
\fIffunc\fR
is not specified, then the ending state value is used as the aggregate\*(Aqs result, and the return type is
\fIstate_data_type\fR\&amp;.
.sp
For ordered\-set (including hypothetical\-set) aggregates, the final function receives not only the final state value, but also the values of all the direct arguments\&amp;.
.sp
If
FINALFUNC_EXTRA
is specified, then in addition to the final state value and any direct arguments, the final function receives extra NULL values corresponding to the aggregate\*(Aqs regular (aggregated) arguments\&amp;. This is mainly useful to allow correct resolution of the aggregate result type when a polymorphic aggregate is being defined\&amp;.
.RE
.PP
\fIcombinefunc\fR
.RS 4
The
\fIcombinefunc\fR
function may optionally be specified to allow the aggregate function to support partial aggregation\&amp;. If provided, the
\fIcombinefunc\fR
must combine two
\fIstate_data_type\fR
values, each containing the result of aggregation over some subset of the input values, to produce a new
\fIstate_data_type\fR
that represents the result of aggregating over both sets of inputs\&amp;. This function can be thought of as an
\fIsfunc\fR, where instead of acting upon an individual input row and adding it to the running aggregate state, it adds another aggregate state to the running state\&amp;.
.sp
The
\fIcombinefunc\fR
must be declared as taking two arguments of the
\fIstate_data_type\fR
and returning a value of the
\fIstate_data_type\fR\&amp;. Optionally this function may be
\(lqstrict\(rq\&amp;. In this case the function will not be called when either of the input states are null; the other state will be taken as the correct result\&amp;.
.sp
For aggregate functions whose
\fIstate_data_type\fR
is
internal, the
\fIcombinefunc\fR
must not be strict\&amp;. In this case the
\fIcombinefunc\fR
must ensure that null states are handled correctly and that the state being returned is properly stored in the aggregate memory context\&amp;.
.RE
.PP
\fIserialfunc\fR
.RS 4
An aggregate function whose
\fIstate_data_type\fR
is
internal
can participate in parallel aggregation only if it has a
\fIserialfunc\fR
function, which must serialize the aggregate state into a
bytea
value for transmission to another process\&amp;. This function must take a single argument of type
internal
and return type
bytea\&amp;. A corresponding
\fIdeserialfunc\fR
is also required\&amp;.
.RE
.PP
\fIdeserialfunc\fR
.RS 4
Deserialize a previously serialized aggregate state back into
\fIstate_data_type\fR\&amp;. This function must take two arguments of types
bytea
and
internal, and produce a result of type
internal\&amp;. (Note: the second,
internal
argument is unused, but is required for type safety reasons\&amp;.)
.RE
.PP
\fIinitial_condition\fR
.RS 4
The initial setting for the state value\&amp;. This must be a string constant in the form accepted for the data type
\fIstate_data_type\fR\&amp;. If not specified, the state value starts out null\&amp;.
.RE
.PP
\fImsfunc\fR
.RS 4
The name of the forward state transition function to be called for each input row in moving\-aggregate mode\&amp;. This is exactly like the regular transition function, except that its first argument and result are of type
\fImstate_data_type\fR, which might be different from
\fIstate_data_type\fR\&amp;.
.RE
.PP
\fIminvfunc\fR
.RS 4
The name of the inverse state transition function to be used in moving\-aggregate mode\&amp;. This function has the same argument and result types as
\fImsfunc\fR, but it is used to remove a value from the current aggregate state, rather than add a value to it\&amp;. The inverse transition function must have the same strictness attribute as the forward state transition function\&amp;.
.RE
.PP
\fImstate_data_type\fR
.RS 4
The data type for the aggregate\*(Aqs state value, when using moving\-aggregate mode\&amp;.
.RE
.PP
\fImstate_data_size\fR
.RS 4
The approximate average size (in bytes) of the aggregate\*(Aqs state value, when using moving\-aggregate mode\&amp;. This works the same as
\fIstate_data_size\fR\&amp;.
.RE
.PP
\fImffunc\fR
.RS 4
The name of the final function called to compute the aggregate\*(Aqs result after all input rows have been traversed, when using moving\-aggregate mode\&amp;. This works the same as
\fIffunc\fR, except that its first argument\*(Aqs type is
\fImstate_data_type\fR
and extra dummy arguments are specified by writing
MFINALFUNC_EXTRA\&amp;. The aggregate result type determined by
\fImffunc\fR
or
\fImstate_data_type\fR
must match that determined by the aggregate\*(Aqs regular implementation\&amp;.
.RE
.PP
\fIminitial_condition\fR
.RS 4
The initial setting for the state value, when using moving\-aggregate mode\&amp;. This works the same as
\fIinitial_condition\fR\&amp;.
.RE
.PP
\fIsort_operator\fR
.RS 4
The associated sort operator for a
\fBMIN\fR\- or
\fBMAX\fR\-like aggregate\&amp;. This is just an operator name (possibly schema\-qualified)\&amp;. The operator is assumed to have the same input data types as the aggregate (which must be a single\-argument normal aggregate)\&amp;.
.RE
.PP
PARALLEL
.RS 4
The meanings of
PARALLEL SAFE,
PARALLEL RESTRICTED, and
PARALLEL UNSAFE
are the same as for
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))\&amp;. An aggregate will not be considered for parallelization if it is marked
PARALLEL UNSAFE
(which is the default!) or
PARALLEL RESTRICTED\&amp;. Note that the parallel\-safety markings of the aggregate\*(Aqs support functions are not consulted by the planner, only the marking of the aggregate itself\&amp;.
.RE
.PP
HYPOTHETICAL
.RS 4
For ordered\-set aggregates only, this flag specifies that the aggregate arguments are to be processed according to the requirements for hypothetical\-set aggregates: that is, the last few direct arguments must match the data types of the aggregated (WITHIN GROUP) arguments\&amp;. The
HYPOTHETICAL
flag has no effect on run\-time behavior, only on parse\-time resolution of the data types and collations of the aggregate\*(Aqs arguments\&amp;.
.RE
.PP
The parameters of
\fBCREATE AGGREGATE\fR
can be written in any order, not just the order illustrated above\&amp;.
.SH "NOTES"
.PP
In parameters that specify support function names, you can write a schema name if needed, for example
SFUNC = public\&amp;.sum\&amp;. Do not write argument types there, however \(em the argument types of the support functions are determined from other parameters\&amp;.
.PP
If an aggregate supports moving\-aggregate mode, it will improve calculation efficiency when the aggregate is used as a window function for a window with moving frame start (that is, a frame start mode other than
UNBOUNDED PRECEDING)\&amp;. Conceptually, the forward transition function adds input values to the aggregate\*(Aqs state when they enter the window frame from the bottom, and the inverse transition function removes them again when they leave the frame at the top\&amp;. So, when values are removed, they are always removed in the same order they were added\&amp;. Whenever the inverse transition function is invoked, it will thus receive the earliest added but not yet removed argument value(s)\&amp;. The inverse transition function can assume that at least one row will remain in the current state after it removes the oldest row\&amp;. (When this would not be the case, the window function mechanism simply starts a fresh aggregation, rather than using the inverse transition function\&amp;.)
.PP
The forward transition function for moving\-aggregate mode is not allowed to return NULL as the new state value\&amp;. If the inverse transition function returns NULL, this is taken as an indication that the inverse function cannot reverse the state calculation for this particular input, and so the aggregate calculation will be redone from scratch for the current frame starting position\&amp;. This convention allows moving\-aggregate mode to be used in situations where there are some infrequent cases that are impractical to reverse out of the running state value\&amp;.
.PP
If no moving\-aggregate implementation is supplied, the aggregate can still be used with moving frames, but
PostgreSQL
will recompute the whole aggregation whenever the start of the frame moves\&amp;. Note that whether or not the aggregate supports moving\-aggregate mode,
PostgreSQL
can handle a moving frame end without recalculation; this is done by continuing to add new values to the aggregate\*(Aqs state\&amp;. It is assumed that the final function does not damage the aggregate\*(Aqs state value, so that the aggregation can be continued even after an aggregate result value has been obtained for one set of frame boundaries\&amp;.
.PP
The syntax for ordered\-set aggregates allows
VARIADIC
to be specified for both the last direct parameter and the last aggregated (WITHIN GROUP) parameter\&amp;. However, the current implementation restricts use of
VARIADIC
in two ways\&amp;. First, ordered\-set aggregates can only use
VARIADIC "any", not other variadic array types\&amp;. Second, if the last direct parameter is
VARIADIC "any", then there can be only one aggregated parameter and it must also be
VARIADIC "any"\&amp;. (In the representation used in the system catalogs, these two parameters are merged into a single
VARIADIC "any"
item, since
pg_proc
cannot represent functions with more than one
VARIADIC
parameter\&amp;.) If the aggregate is a hypothetical\-set aggregate, the direct arguments that match the
VARIADIC "any"
parameter are the hypothetical ones; any preceding parameters represent additional direct arguments that are not constrained to match the aggregated arguments\&amp;.
.PP
Currently, ordered\-set aggregates do not need to support moving\-aggregate mode, since they cannot be used as window functions\&amp;.
.PP
Partial (including parallel) aggregation is currently not supported for ordered\-set aggregates\&amp;. Also, it will never be used for aggregate calls that include
DISTINCT
or
ORDER BY
clauses, since those semantics cannot be supported during partial aggregation\&amp;.
.SH "EXAMPLES"
.PP
See
Section 36.10, \(lqUser-defined Aggregates\(rq, in the documentation\&amp;.
.SH "COMPATIBILITY"
.PP
\fBCREATE AGGREGATE\fR
is a
PostgreSQL
language extension\&amp;. The SQL standard does not provide for user\-defined aggregate functions\&amp;.
.SH "SEE ALSO"
ALTER AGGREGATE (\fBALTER_AGGREGATE\fR(7)), DROP AGGREGATE (\fBDROP_AGGREGATE\fR(7))
'\" t
.\"     Title: CREATE CAST
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE CAST" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_CAST \- define a new cast
.SH "SYNOPSIS"
.sp
.nf
CREATE CAST (\fIsource_type\fR AS \fItarget_type\fR)
WITH FUNCTION \fIfunction_name\fR (\fIargument_type\fR [, \&amp;.\&amp;.\&amp;.])
[ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (\fIsource_type\fR AS \fItarget_type\fR)
WITHOUT FUNCTION
[ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (\fIsource_type\fR AS \fItarget_type\fR)
WITH INOUT
[ AS ASSIGNMENT | AS IMPLICIT ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE CAST\fR
defines a new cast\&amp;. A cast specifies how to perform a conversion between two data types\&amp;. For example,
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT CAST(42 AS float8);
.fi
.if n \{\
.RE
.\}
.sp
converts the integer constant 42 to type
float8
by invoking a previously specified function, in this case
float8(int4)\&amp;. (If no suitable cast has been defined, the conversion fails\&amp;.)
.PP
Two types can be
binary coercible, which means that the conversion can be performed
\(lqfor free\(rq
without invoking any function\&amp;. This requires that corresponding values use the same internal representation\&amp;. For instance, the types
text
and
varchar
are binary coercible both ways\&amp;. Binary coercibility is not necessarily a symmetric relationship\&amp;. For example, the cast from
xml
to
text
can be performed for free in the present implementation, but the reverse direction requires a function that performs at least a syntax check\&amp;. (Two types that are binary coercible both ways are also referred to as binary compatible\&amp;.)
.PP
You can define a cast as an
I/O conversion cast
by using the
WITH INOUT
syntax\&amp;. An I/O conversion cast is performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type\&amp;. In many common cases, this feature avoids the need to write a separate cast function for conversion\&amp;. An I/O conversion cast acts the same as a regular function\-based cast; only the implementation is different\&amp;.
.PP
By default, a cast can be invoked only by an explicit cast request, that is an explicit
CAST(\fIx\fR AS \fItypename\fR)
or
\fIx\fR::\fItypename\fR
construct\&amp;.
.PP
If the cast is marked
AS ASSIGNMENT
then it can be invoked implicitly when assigning a value to a column of the target data type\&amp;. For example, supposing that
foo\&amp;.f1
is a column of type
text, then:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO foo (f1) VALUES (42);
.fi
.if n \{\
.RE
.\}
.sp
will be allowed if the cast from type
integer
to type
text
is marked
AS ASSIGNMENT, otherwise not\&amp;. (We generally use the term
assignment cast
to describe this kind of cast\&amp;.)
.PP
If the cast is marked
AS IMPLICIT
then it can be invoked implicitly in any context, whether assignment or internally in an expression\&amp;. (We generally use the term
implicit cast
to describe this kind of cast\&amp;.) For example, consider this query:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT 2 + 4\&amp;.0;
.fi
.if n \{\
.RE
.\}
.sp
The parser initially marks the constants as being of type
integer
and
numeric
respectively\&amp;. There is no
integer+numeric
operator in the system catalogs, but there is a
numeric+numeric
operator\&amp;. The query will therefore succeed if a cast from
integer
to
numeric
is available and is marked
AS IMPLICIT
\(em which in fact it is\&amp;. The parser will apply the implicit cast and resolve the query as if it had been written
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT CAST ( 2 AS numeric ) + 4\&amp;.0;
.fi
.if n \{\
.RE
.\}
.PP
Now, the catalogs also provide a cast from
numeric
to
integer\&amp;. If that cast were marked
AS IMPLICIT
\(em which it is not \(em then the parser would be faced with choosing between the above interpretation and the alternative of casting the
numeric
constant to
integer
and applying the
integer+integer
operator\&amp;. Lacking any knowledge of which choice to prefer, it would give up and declare the query ambiguous\&amp;. The fact that only one of the two casts is implicit is the way in which we teach the parser to prefer resolution of a mixed
numeric\-and\-integer
expression as
numeric; there is no built\-in knowledge about that\&amp;.
.PP
It is wise to be conservative about marking casts as implicit\&amp;. An overabundance of implicit casting paths can cause
PostgreSQL
to choose surprising interpretations of commands, or to be unable to resolve commands at all because there are multiple possible interpretations\&amp;. A good rule of thumb is to make a cast implicitly invokable only for information\-preserving transformations between types in the same general type category\&amp;. For example, the cast from
int2
to
int4
can reasonably be implicit, but the cast from
float8
to
int4
should probably be assignment\-only\&amp;. Cross\-type\-category casts, such as
text
to
int4, are best made explicit\-only\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Sometimes it is necessary for usability or standards\-compliance reasons to provide multiple implicit casts among a set of types, resulting in ambiguity that cannot be avoided as above\&amp;. The parser has a fallback heuristic based on
type categories
and
preferred types
that can help to provide desired behavior in such cases\&amp;. See
CREATE TYPE (\fBCREATE_TYPE\fR(7))
for more information\&amp;.
.sp .5v
.RE
.PP
To be able to create a cast, you must own the source or the target data type and have
USAGE
privilege on the other type\&amp;. To create a binary\-coercible cast, you must be superuser\&amp;. (This restriction is made because an erroneous binary\-coercible cast conversion can easily crash the server\&amp;.)
.SH "PARAMETERS"
.PP
\fIsource_type\fR
.RS 4
The name of the source data type of the cast\&amp;.
.RE
.PP
\fItarget_type\fR
.RS 4
The name of the target data type of the cast\&amp;.
.RE
.PP
\fIfunction_name\fR(\fIargument_type\fR [, \&amp;.\&amp;.\&amp;.])
.RS 4
The function used to perform the cast\&amp;. The function name can be schema\-qualified\&amp;. If it is not, the function will be looked up in the schema search path\&amp;. The function\*(Aqs result data type must match the target type of the cast\&amp;. Its arguments are discussed below\&amp;.
.RE
.PP
WITHOUT FUNCTION
.RS 4
Indicates that the source type is binary\-coercible to the target type, so no function is required to perform the cast\&amp;.
.RE
.PP
WITH INOUT
.RS 4
Indicates that the cast is an I/O conversion cast, performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type\&amp;.
.RE
.PP
AS ASSIGNMENT
.RS 4
Indicates that the cast can be invoked implicitly in assignment contexts\&amp;.
.RE
.PP
AS IMPLICIT
.RS 4
Indicates that the cast can be invoked implicitly in any context\&amp;.
.RE
.PP
Cast implementation functions can have one to three arguments\&amp;. The first argument type must be identical to or binary\-coercible from the cast\*(Aqs source type\&amp;. The second argument, if present, must be type
integer; it receives the type modifier associated with the destination type, or
\-1
if there is none\&amp;. The third argument, if present, must be type
boolean; it receives
true
if the cast is an explicit cast,
false
otherwise\&amp;. (Bizarrely, the SQL standard demands different behaviors for explicit and implicit casts in some cases\&amp;. This argument is supplied for functions that must implement such casts\&amp;. It is not recommended that you design your own data types so that this matters\&amp;.)
.PP
The return type of a cast function must be identical to or binary\-coercible to the cast\*(Aqs target type\&amp;.
.PP
Ordinarily a cast must have different source and target data types\&amp;. However, it is allowed to declare a cast with identical source and target types if it has a cast implementation function with more than one argument\&amp;. This is used to represent type\-specific length coercion functions in the system catalogs\&amp;. The named function is used to coerce a value of the type to the type modifier value given by its second argument\&amp;.
.PP
When a cast has different source and target types and a function that takes more than one argument, it supports converting from one type to another and applying a length coercion in a single step\&amp;. When no such entry is available, coercion to a type that uses a type modifier involves two cast steps, one to convert between data types and a second to apply the modifier\&amp;.
.PP
A cast to or from a domain type currently has no effect\&amp;. Casting to or from a domain uses the casts associated with its underlying type\&amp;.
.SH "NOTES"
.PP
Use
DROP CAST (\fBDROP_CAST\fR(7))
to remove user\-defined casts\&amp;.
.PP
Remember that if you want to be able to convert types both ways you need to declare casts both ways explicitly\&amp;.
.PP
It is normally not necessary to create casts between user\-defined types and the standard string types (text,
varchar, and
char(\fIn\fR), as well as user\-defined types that are defined to be in the string category)\&amp;.
PostgreSQL
provides automatic I/O conversion casts for that\&amp;. The automatic casts to string types are treated as assignment casts, while the automatic casts from string types are explicit\-only\&amp;. You can override this behavior by declaring your own cast to replace an automatic cast, but usually the only reason to do so is if you want the conversion to be more easily invokable than the standard assignment\-only or explicit\-only setting\&amp;. Another possible reason is that you want the conversion to behave differently from the type\*(Aqs I/O function; but that is sufficiently surprising that you should think twice about whether it\*(Aqs a good idea\&amp;. (A small number of the built\-in types do indeed have different behaviors for conversions, mostly because of requirements of the SQL standard\&amp;.)
.PP
While not required, it is recommended that you continue to follow this old convention of naming cast implementation functions after the target data type\&amp;. Many users are used to being able to cast data types using a function\-style notation, that is
\fItypename\fR(\fIx\fR)\&amp;. This notation is in fact nothing more nor less than a call of the cast implementation function; it is not specially treated as a cast\&amp;. If your conversion functions are not named to support this convention then you will have surprised users\&amp;. Since
PostgreSQL
allows overloading of the same function name with different argument types, there is no difficulty in having multiple conversion functions from different types that all use the target type\*(Aqs name\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Actually the preceding paragraph is an oversimplification: there are two cases in which a function\-call construct will be treated as a cast request without having matched it to an actual function\&amp;. If a function call
\fIname\fR(\fIx\fR) does not exactly match any existing function, but
\fIname\fR
is the name of a data type and
pg_cast
provides a binary\-coercible cast to this type from the type of
\fIx\fR, then the call will be construed as a binary\-coercible cast\&amp;. This exception is made so that binary\-coercible casts can be invoked using functional syntax, even though they lack any function\&amp;. Likewise, if there is no
pg_cast
entry but the cast would be to or from a string type, the call will be construed as an I/O conversion cast\&amp;. This exception allows I/O conversion casts to be invoked using functional syntax\&amp;.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
There is also an exception to the exception: I/O conversion casts from composite types to string types cannot be invoked using functional syntax, but must be written in explicit cast syntax (either
CAST
or
::
notation)\&amp;. This exception was added because after the introduction of automatically\-provided I/O conversion casts, it was found too easy to accidentally invoke such a cast when a function or column reference was intended\&amp;.
.sp .5v
.RE
.SH "EXAMPLES"
.PP
To create an assignment cast from type
bigint
to type
int4
using the function
int4(bigint):
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;
.fi
.if n \{\
.RE
.\}
.sp
(This cast is already predefined in the system\&amp;.)
.SH "COMPATIBILITY"
.PP
The
\fBCREATE CAST\fR
command conforms to the
SQL
standard, except that SQL does not make provisions for binary\-coercible types or extra arguments to implementation functions\&amp;.
AS IMPLICIT
is a
PostgreSQL
extension, too\&amp;.
.SH "SEE ALSO"
.PP
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)),
CREATE TYPE (\fBCREATE_TYPE\fR(7)),
DROP CAST (\fBDROP_CAST\fR(7))
'\" t
.\"     Title: CREATE COLLATION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE COLLATION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_COLLATION \- define a new collation
.SH "SYNOPSIS"
.sp
.nf
CREATE COLLATION \fIname\fR (
[ LOCALE = \fIlocale\fR, ]
[ LC_COLLATE = \fIlc_collate\fR, ]
[ LC_CTYPE = \fIlc_ctype\fR ]
)
CREATE COLLATION \fIname\fR FROM \fIexisting_collation\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE COLLATION\fR
defines a new collation using the specified operating system locale settings, or by copying an existing collation\&amp;.
.PP
To be able to create a collation, you must have
CREATE
privilege on the destination schema\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the collation\&amp;. The collation name can be schema\-qualified\&amp;. If it is not, the collation is defined in the current schema\&amp;. The collation name must be unique within that schema\&amp;. (The system catalogs can contain collations with the same name for other encodings, but these are ignored if the database encoding does not match\&amp;.)
.RE
.PP
\fIlocale\fR
.RS 4
This is a shortcut for setting
LC_COLLATE
and
LC_CTYPE
at once\&amp;. If you specify this, you cannot specify either of those parameters\&amp;.
.RE
.PP
\fIlc_collate\fR
.RS 4
Use the specified operating system locale for the
LC_COLLATE
locale category\&amp;. The locale must be applicable to the current database encoding\&amp;. (See
CREATE DATABASE (\fBCREATE_DATABASE\fR(7))
for the precise rules\&amp;.)
.RE
.PP
\fIlc_ctype\fR
.RS 4
Use the specified operating system locale for the
LC_CTYPE
locale category\&amp;. The locale must be applicable to the current database encoding\&amp;. (See
CREATE DATABASE (\fBCREATE_DATABASE\fR(7))
for the precise rules\&amp;.)
.RE
.PP
\fIexisting_collation\fR
.RS 4
The name of an existing collation to copy\&amp;. The new collation will have the same properties as the existing one, but it will be an independent object\&amp;.
.RE
.SH "NOTES"
.PP
Use
\fBDROP COLLATION\fR
to remove user\-defined collations\&amp;.
.PP
See
Section 23.2, \(lqCollation Support\(rq, in the documentation
for more information about collation support in PostgreSQL\&amp;.
.SH "EXAMPLES"
.PP
To create a collation from the operating system locale
fr_FR\&amp;.utf8
(assuming the current database encoding is
UTF8):
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE COLLATION french (LOCALE = \*(Aqfr_FR\&amp;.utf8\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
To create a collation from an existing collation:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE COLLATION german FROM "de_DE";
.fi
.if n \{\
.RE
.\}
.sp
This can be convenient to be able to use operating\-system\-independent collation names in applications\&amp;.
.SH "COMPATIBILITY"
.PP
There is a
\fBCREATE COLLATION\fR
statement in the SQL standard, but it is limited to copying an existing collation\&amp;. The syntax to create a new collation is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER COLLATION (\fBALTER_COLLATION\fR(7)), DROP COLLATION (\fBDROP_COLLATION\fR(7))
'\" t
.\"     Title: CREATE CONVERSION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE CONVERSION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_CONVERSION \- define a new encoding conversion
.SH "SYNOPSIS"
.sp
.nf
CREATE [ DEFAULT ] CONVERSION \fIname\fR
FOR \fIsource_encoding\fR TO \fIdest_encoding\fR FROM \fIfunction_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE CONVERSION\fR
defines a new conversion between character set encodings\&amp;. Also, conversions that are marked
DEFAULT
can be used for automatic encoding conversion between client and server\&amp;. For this purpose, two conversions, from encoding A to B
\fIand\fR
from encoding B to A, must be defined\&amp;.
.PP
To be able to create a conversion, you must have
EXECUTE
privilege on the function and
CREATE
privilege on the destination schema\&amp;.
.SH "PARAMETERS"
.PP
DEFAULT
.RS 4
The
DEFAULT
clause indicates that this conversion is the default for this particular source to destination encoding\&amp;. There should be only one default encoding in a schema for the encoding pair\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the conversion\&amp;. The conversion name can be schema\-qualified\&amp;. If it is not, the conversion is defined in the current schema\&amp;. The conversion name must be unique within a schema\&amp;.
.RE
.PP
\fIsource_encoding\fR
.RS 4
The source encoding name\&amp;.
.RE
.PP
\fIdest_encoding\fR
.RS 4
The destination encoding name\&amp;.
.RE
.PP
\fIfunction_name\fR
.RS 4
The function used to perform the conversion\&amp;. The function name can be schema\-qualified\&amp;. If it is not, the function will be looked up in the path\&amp;.
.sp
The function must have the following signature:
.sp
.if n \{\
.RS 4
.\}
.nf
conv_proc(
integer,  \-\- source encoding ID
integer,  \-\- destination encoding ID
cstring,  \-\- source string (null terminated C string)
internal, \-\- destination (fill with a null terminated C string)
integer   \-\- source string length
) RETURNS void;
.fi
.if n \{\
.RE
.\}
.RE
.SH "NOTES"
.PP
Use
\fBDROP CONVERSION\fR
to remove user\-defined conversions\&amp;.
.PP
The privileges required to create a conversion might be changed in a future release\&amp;.
.SH "EXAMPLES"
.PP
To create a conversion from encoding
UTF8
to
LATIN1
using
\fBmyfunc\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE CONVERSION myconv FOR \*(AqUTF8\*(Aq TO \*(AqLATIN1\*(Aq FROM myfunc;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE CONVERSION\fR
is a
PostgreSQL
extension\&amp;. There is no
\fBCREATE CONVERSION\fR
statement in the SQL standard, but a
\fBCREATE TRANSLATION\fR
statement that is very similar in purpose and syntax\&amp;.
.SH "SEE ALSO"
ALTER CONVERSION (\fBALTER_CONVERSION\fR(7)), CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)), DROP CONVERSION (\fBDROP_CONVERSION\fR(7))
'\" t
.\"     Title: CREATE DATABASE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE DATABASE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_DATABASE \- create a new database
.SH "SYNOPSIS"
.sp
.nf
CREATE DATABASE \fIname\fR
[ [ WITH ] [ OWNER [=] \fIuser_name\fR ]
[ TEMPLATE [=] \fItemplate\fR ]
[ ENCODING [=] \fIencoding\fR ]
[ LC_COLLATE [=] \fIlc_collate\fR ]
[ LC_CTYPE [=] \fIlc_ctype\fR ]
[ TABLESPACE [=] \fItablespace_name\fR ]
[ ALLOW_CONNECTIONS [=] \fIallowconn\fR ]
[ CONNECTION LIMIT [=] \fIconnlimit\fR ]
[ IS_TEMPLATE [=] \fIistemplate\fR ] ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE DATABASE\fR
creates a new
PostgreSQL
database\&amp;.
.PP
To create a database, you must be a superuser or have the special
CREATEDB
privilege\&amp;. See
CREATE USER (\fBCREATE_USER\fR(7))\&amp;.
.PP
By default, the new database will be created by cloning the standard system database
template1\&amp;. A different template can be specified by writing
TEMPLATE \fIname\fR\&amp;. In particular, by writing
TEMPLATE template0, you can create a virgin database containing only the standard objects predefined by your version of
PostgreSQL\&amp;. This is useful if you wish to avoid copying any installation\-local objects that might have been added to
template1\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of a database to create\&amp;.
.RE
.PP
\fIuser_name\fR
.RS 4
The role name of the user who will own the new database, or
DEFAULT
to use the default (namely, the user executing the command)\&amp;. To create a database owned by another role, you must be a direct or indirect member of that role, or be a superuser\&amp;.
.RE
.PP
\fItemplate\fR
.RS 4
The name of the template from which to create the new database, or
DEFAULT
to use the default template (template1)\&amp;.
.RE
.PP
\fIencoding\fR
.RS 4
Character set encoding to use in the new database\&amp;. Specify a string constant (e\&amp;.g\&amp;.,
\*(AqSQL_ASCII\*(Aq), or an integer encoding number, or
DEFAULT
to use the default encoding (namely, the encoding of the template database)\&amp;. The character sets supported by the
PostgreSQL
server are described in
Section 23.3.1, \(lqSupported Character Sets\(rq, in the documentation\&amp;. See below for additional restrictions\&amp;.
.RE
.PP
\fIlc_collate\fR
.RS 4
Collation order (LC_COLLATE) to use in the new database\&amp;. This affects the sort order applied to strings, e\&amp;.g\&amp;. in queries with ORDER BY, as well as the order used in indexes on text columns\&amp;. The default is to use the collation order of the template database\&amp;. See below for additional restrictions\&amp;.
.RE
.PP
\fIlc_ctype\fR
.RS 4
Character classification (LC_CTYPE) to use in the new database\&amp;. This affects the categorization of characters, e\&amp;.g\&amp;. lower, upper and digit\&amp;. The default is to use the character classification of the template database\&amp;. See below for additional restrictions\&amp;.
.RE
.PP
\fItablespace_name\fR
.RS 4
The name of the tablespace that will be associated with the new database, or
DEFAULT
to use the template database\*(Aqs tablespace\&amp;. This tablespace will be the default tablespace used for objects created in this database\&amp;. See
CREATE TABLESPACE (\fBCREATE_TABLESPACE\fR(7))
for more information\&amp;.
.RE
.PP
\fIallowconn\fR
.RS 4
If false then no one can connect to this database\&amp;. The default is true, allowing connections (except as restricted by other mechanisms, such as
GRANT/REVOKE CONNECT)\&amp;.
.RE
.PP
\fIconnlimit\fR
.RS 4
How many concurrent connections can be made to this database\&amp;. \-1 (the default) means no limit\&amp;.
.RE
.PP
\fIistemplate\fR
.RS 4
If true, then this database can be cloned by any user with
CREATEDB
privileges; if false (the default), then only superusers or the owner of the database can clone it\&amp;.
.RE
.PP
Optional parameters can be written in any order, not only the order illustrated above\&amp;.
.SH "NOTES"
.PP
\fBCREATE DATABASE\fR
cannot be executed inside a transaction block\&amp;.
.PP
Errors along the line of
\(lqcould not initialize database directory\(rq
are most likely related to insufficient permissions on the data directory, a full disk, or other file system problems\&amp;.
.PP
Use
DROP DATABASE (\fBDROP_DATABASE\fR(7))
to remove a database\&amp;.
.PP
The program
\fBcreatedb\fR(1)
is a wrapper program around this command, provided for convenience\&amp;.
.PP
Database\-level configuration parameters (set via
ALTER DATABASE (\fBALTER_DATABASE\fR(7))) are not copied from the template database\&amp;.
.PP
Although it is possible to copy a database other than
template1
by specifying its name as the template, this is not (yet) intended as a general\-purpose
\(lq\fBCOPY DATABASE\fR\(rq
facility\&amp;. The principal limitation is that no other sessions can be connected to the template database while it is being copied\&amp;.
\fBCREATE DATABASE\fR
will fail if any other connection exists when it starts; otherwise, new connections to the template database are locked out until
\fBCREATE DATABASE\fR
completes\&amp;. See
Section 22.3, \(lqTemplate Databases\(rq, in the documentation
for more information\&amp;.
.PP
The character set encoding specified for the new database must be compatible with the chosen locale settings (LC_COLLATE
and
LC_CTYPE)\&amp;. If the locale is
C
(or equivalently
POSIX), then all encodings are allowed, but for other locale settings there is only one encoding that will work properly\&amp;. (On Windows, however, UTF\-8 encoding can be used with any locale\&amp;.)
\fBCREATE DATABASE\fR
will allow superusers to specify
SQL_ASCII
encoding regardless of the locale settings, but this choice is deprecated and may result in misbehavior of character\-string functions if data that is not encoding\-compatible with the locale is stored in the database\&amp;.
.PP
The encoding and locale settings must match those of the template database, except when
template0
is used as template\&amp;. This is because other databases might contain data that does not match the specified encoding, or might contain indexes whose sort ordering is affected by
LC_COLLATE
and
LC_CTYPE\&amp;. Copying such data would result in a database that is corrupt according to the new settings\&amp;.
template0, however, is known to not contain any data or indexes that would be affected\&amp;.
.PP
The
CONNECTION LIMIT
option is only enforced approximately; if two new sessions start at about the same time when just one connection
\(lqslot\(rq
remains for the database, it is possible that both will fail\&amp;. Also, the limit is not enforced against superusers\&amp;.
.SH "EXAMPLES"
.PP
To create a new database:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE DATABASE lusiadas;
.fi
.if n \{\
.RE
.\}
.PP
To create a database
sales
owned by user
salesapp
with a default tablespace of
salesspace:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE DATABASE sales OWNER salesapp TABLESPACE salesspace;
.fi
.if n \{\
.RE
.\}
.PP
To create a database
music
which supports the ISO\-8859\-1 character set:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE DATABASE music ENCODING \*(AqLATIN1\*(Aq TEMPLATE template0;
.fi
.if n \{\
.RE
.\}
.sp
In this example, the
TEMPLATE template0
clause would only be required if
template1\*(Aqs encoding is not ISO\-8859\-1\&amp;. Note that changing encoding might require selecting new
LC_COLLATE
and
LC_CTYPE
settings as well\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBCREATE DATABASE\fR
statement in the SQL standard\&amp;. Databases are equivalent to catalogs, whose creation is implementation\-defined\&amp;.
.SH "SEE ALSO"
ALTER DATABASE (\fBALTER_DATABASE\fR(7)), DROP DATABASE (\fBDROP_DATABASE\fR(7))
'\" t
.\"     Title: CREATE DOMAIN
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE DOMAIN" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_DOMAIN \- define a new domain
.SH "SYNOPSIS"
.sp
.nf
CREATE DOMAIN \fIname\fR [ AS ] \fIdata_type\fR
[ COLLATE \fIcollation\fR ]
[ DEFAULT \fIexpression\fR ]
[ \fIconstraint\fR [ \&amp;.\&amp;.\&amp;. ] ]

where \fIconstraint\fR is:

[ CONSTRAINT \fIconstraint_name\fR ]
{ NOT NULL | NULL | CHECK (\fIexpression\fR) }
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE DOMAIN\fR
creates a new domain\&amp;. A domain is essentially a data type with optional constraints (restrictions on the allowed set of values)\&amp;. The user who defines a domain becomes its owner\&amp;.
.PP
If a schema name is given (for example,
CREATE DOMAIN myschema\&amp;.mydomain \&amp;.\&amp;.\&amp;.) then the domain is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. The domain name must be unique among the types and domains existing in its schema\&amp;.
.PP
Domains are useful for abstracting common constraints on fields into a single location for maintenance\&amp;. For example, several tables might contain email address columns, all requiring the same CHECK constraint to verify the address syntax\&amp;. Define a domain rather than setting up each table\*(Aqs constraint individually\&amp;.
.PP
To be able to create a domain, you must have
USAGE
privilege on the underlying type\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of a domain to be created\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
The underlying data type of the domain\&amp;. This can include array specifiers\&amp;.
.RE
.PP
\fIcollation\fR
.RS 4
An optional collation for the domain\&amp;. If no collation is specified, the underlying data type\*(Aqs default collation is used\&amp;. The underlying type must be collatable if
COLLATE
is specified\&amp;.
.RE
.PP
DEFAULT \fIexpression\fR
.RS 4
The
DEFAULT
clause specifies a default value for columns of the domain data type\&amp;. The value is any variable\-free expression (but subqueries are not allowed)\&amp;. The data type of the default expression must match the data type of the domain\&amp;. If no default value is specified, then the default value is the null value\&amp;.
.sp
The default expression will be used in any insert operation that does not specify a value for the column\&amp;. If a default value is defined for a particular column, it overrides any default associated with the domain\&amp;. In turn, the domain default overrides any default value associated with the underlying data type\&amp;.
.RE
.PP
CONSTRAINT \fIconstraint_name\fR
.RS 4
An optional name for a constraint\&amp;. If not specified, the system generates a name\&amp;.
.RE
.PP
NOT NULL
.RS 4
Values of this domain are prevented from being null (but see notes below)\&amp;.
.RE
.PP
NULL
.RS 4
Values of this domain are allowed to be null\&amp;. This is the default\&amp;.
.sp
This clause is only intended for compatibility with nonstandard SQL databases\&amp;. Its use is discouraged in new applications\&amp;.
.RE
.PP
CHECK (\fIexpression\fR)
.RS 4
CHECK
clauses specify integrity constraints or tests which values of the domain must satisfy\&amp;. Each constraint must be an expression producing a Boolean result\&amp;. It should use the key word
VALUE
to refer to the value being tested\&amp;. Expressions evaluating to TRUE or UNKNOWN succeed\&amp;. If the expression produces a FALSE result, an error is reported and the value is not allowed to be converted to the domain type\&amp;.
.sp
Currently,
CHECK
expressions cannot contain subqueries nor refer to variables other than
VALUE\&amp;.
.sp
When a domain has multiple
CHECK
constraints, they will be tested in alphabetical order by name\&amp;. (PostgreSQL
versions before 9\&amp;.5 did not honor any particular firing order for
CHECK
constraints\&amp;.)
.RE
.SH "NOTES"
.PP
Domain constraints, particularly
NOT NULL, are checked when converting a value to the domain type\&amp;. It is possible for a column that is nominally of the domain type to read as null despite there being such a constraint\&amp;. For example, this can happen in an outer\-join query, if the domain column is on the nullable side of the outer join\&amp;. A more subtle example is
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO tab (domcol) VALUES ((SELECT domcol FROM tab WHERE false));
.fi
.if n \{\
.RE
.\}
.sp
The empty scalar sub\-SELECT will produce a null value that is considered to be of the domain type, so no further constraint checking is applied to it, and the insertion will succeed\&amp;.
.PP
It is very difficult to avoid such problems, because of SQL\*(Aqs general assumption that a null value is a valid value of every data type\&amp;. Best practice therefore is to design a domain\*(Aqs constraints so that a null value is allowed, and then to apply column
NOT NULL
constraints to columns of the domain type as needed, rather than directly to the domain type\&amp;.
.SH "EXAMPLES"
.PP
This example creates the
us_postal_code
data type and then uses the type in a table definition\&amp;. A regular expression test is used to verify that the value looks like a valid US postal code:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE DOMAIN us_postal_code AS TEXT
CHECK(
VALUE ~ \*(Aq^\ed{5}$\*(Aq
OR VALUE ~ \*(Aq^\ed{5}\-\ed{4}$\*(Aq
);

CREATE TABLE us_snail_addy (
address_id SERIAL PRIMARY KEY,
street1 TEXT NOT NULL,
street2 TEXT,
street3 TEXT,
city TEXT NOT NULL,
postal us_postal_code NOT NULL
);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The command
\fBCREATE DOMAIN\fR
conforms to the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER DOMAIN (\fBALTER_DOMAIN\fR(7)), DROP DOMAIN (\fBDROP_DOMAIN\fR(7))
'\" t
.\"     Title: CREATE EVENT TRIGGER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE EVENT TRIGGER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_EVENT_TRIGGER \- define a new event trigger
.SH "SYNOPSIS"
.sp
.nf
CREATE EVENT TRIGGER \fIname\fR
ON \fIevent\fR
[ WHEN \fIfilter_variable\fR IN (filter_value [, \&amp;.\&amp;.\&amp;. ]) [ AND \&amp;.\&amp;.\&amp;. ] ]
EXECUTE PROCEDURE \fIfunction_name\fR()
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE EVENT TRIGGER\fR
creates a new event trigger\&amp;. Whenever the designated event occurs and the
WHEN
condition associated with the trigger, if any, is satisfied, the trigger function will be executed\&amp;. For a general introduction to event triggers, see
Chapter 38, Event Triggers, in the documentation\&amp;. The user who creates an event trigger becomes its owner\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name to give the new trigger\&amp;. This name must be unique within the database\&amp;.
.RE
.PP
\fIevent\fR
.RS 4
The name of the event that triggers a call to the given function\&amp;. See
Section 38.1, \(lqOverview of Event Trigger Behavior\(rq, in the documentation
for more information on event names\&amp;.
.RE
.PP
\fIfilter_variable\fR
.RS 4
The name of a variable used to filter events\&amp;. This makes it possible to restrict the firing of the trigger to a subset of the cases in which it is supported\&amp;. Currently the only supported
\fIfilter_variable\fR
is
TAG\&amp;.
.RE
.PP
\fIfilter_value\fR
.RS 4
A list of values for the associated
\fIfilter_variable\fR
for which the trigger should fire\&amp;. For
TAG, this means a list of command tags (e\&amp;.g\&amp;.
\*(AqDROP FUNCTION\*(Aq)\&amp;.
.RE
.PP
\fIfunction_name\fR
.RS 4
A user\-supplied function that is declared as taking no argument and returning type
event_trigger\&amp;.
.RE
.SH "NOTES"
.PP
Only superusers can create event triggers\&amp;.
.PP
Event triggers are disabled in single\-user mode (see
\fBpostgres\fR(1))\&amp;. If an erroneous event trigger disables the database so much that you can\*(Aqt even drop the trigger, restart in single\-user mode and you\*(Aqll be able to do that\&amp;.
.SH "EXAMPLES"
.PP
Forbid the execution of any
DDL
command:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE OR REPLACE FUNCTION abort_any_command()
RETURNS event_trigger
LANGUAGE plpgsql
AS $$
BEGIN
RAISE EXCEPTION \*(Aqcommand % is disabled\*(Aq, tg_tag;
END;
$$;

CREATE EVENT TRIGGER abort_ddl ON ddl_command_start
EXECUTE PROCEDURE abort_any_command();
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBCREATE EVENT TRIGGER\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER EVENT TRIGGER (\fBALTER_EVENT_TRIGGER\fR(7)), DROP EVENT TRIGGER (\fBDROP_EVENT_TRIGGER\fR(7)), CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
'\" t
.\"     Title: CREATE EXTENSION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE EXTENSION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_EXTENSION \- install an extension
.SH "SYNOPSIS"
.sp
.nf
CREATE EXTENSION [ IF NOT EXISTS ] \fIextension_name\fR
[ WITH ] [ SCHEMA \fIschema_name\fR ]
[ VERSION \fIversion\fR ]
[ FROM \fIold_version\fR ]
[ CASCADE ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE EXTENSION\fR
loads a new extension into the current database\&amp;. There must not be an extension of the same name already loaded\&amp;.
.PP
Loading an extension essentially amounts to running the extension\*(Aqs script file\&amp;. The script will typically create new
SQL
objects such as functions, data types, operators and index support methods\&amp;.
\fBCREATE EXTENSION\fR
additionally records the identities of all the created objects, so that they can be dropped again if
\fBDROP EXTENSION\fR
is issued\&amp;.
.PP
Loading an extension requires the same privileges that would be required to create its component objects\&amp;. For most extensions this means superuser or database owner privileges are needed\&amp;. The user who runs
\fBCREATE EXTENSION\fR
becomes the owner of the extension for purposes of later privilege checks, as well as the owner of any objects created by the extension\*(Aqs script\&amp;.
.SH "PARAMETERS"
.PP
IF NOT EXISTS
.RS 4
Do not throw an error if an extension with the same name already exists\&amp;. A notice is issued in this case\&amp;. Note that there is no guarantee that the existing extension is anything like the one that would have been created from the currently\-available script file\&amp;.
.RE
.PP
\fIextension_name\fR
.RS 4
The name of the extension to be installed\&amp;.
PostgreSQL
will create the extension using details from the file
SHAREDIR/extension/\fIextension_name\fR\&amp;.control\&amp;.
.RE
.PP
\fIschema_name\fR
.RS 4
The name of the schema in which to install the extension\*(Aqs objects, given that the extension allows its contents to be relocated\&amp;. The named schema must already exist\&amp;. If not specified, and the extension\*(Aqs control file does not specify a schema either, the current default object creation schema is used\&amp;.
.sp
If the extension specifies a
schema
parameter in its control file, then that schema cannot be overridden with a
SCHEMA
clause\&amp;. Normally, an error will be raised if a
SCHEMA
clause is given and it conflicts with the extension\*(Aqs
schema
parameter\&amp;. However, if the
CASCADE
clause is also given, then
\fIschema_name\fR
is ignored when it conflicts\&amp;. The given
\fIschema_name\fR
will be used for installation of any needed extensions that do not specify
schema
in their control files\&amp;.
.sp
Remember that the extension itself is not considered to be within any schema: extensions have unqualified names that must be unique database\-wide\&amp;. But objects belonging to the extension can be within schemas\&amp;.
.RE
.PP
\fIversion\fR
.RS 4
The version of the extension to install\&amp;. This can be written as either an identifier or a string literal\&amp;. The default version is whatever is specified in the extension\*(Aqs control file\&amp;.
.RE
.PP
\fIold_version\fR
.RS 4
FROM\fIold_version\fR
must be specified when, and only when, you are attempting to install an extension that replaces an
\(lqold style\(rq
module that is just a collection of objects not packaged into an extension\&amp;. This option causes
\fBCREATE EXTENSION\fR
to run an alternative installation script that absorbs the existing objects into the extension, instead of creating new objects\&amp;. Be careful that
SCHEMA
specifies the schema containing these pre\-existing objects\&amp;.
.sp
The value to use for
\fIold_version\fR
is determined by the extension\*(Aqs author, and might vary if there is more than one version of the old\-style module that can be upgraded into an extension\&amp;. For the standard additional modules supplied with pre\-9\&amp;.1
PostgreSQL, use
unpackaged
for
\fIold_version\fR
when updating a module to extension style\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically install any extensions that this extension depends on that are not already installed\&amp;. Their dependencies are likewise automatically installed, recursively\&amp;. The
SCHEMA
clause, if given, applies to all extensions that get installed this way\&amp;. Other options of the statement are not applied to automatically\-installed extensions; in particular, their default versions are always selected\&amp;.
.RE
.SH "NOTES"
.PP
Before you can use
\fBCREATE EXTENSION\fR
to load an extension into a database, the extension\*(Aqs supporting files must be installed\&amp;. Information about installing the extensions supplied with
PostgreSQL
can be found in
Additional Supplied Modules\&amp;.
.PP
The extensions currently available for loading can be identified from the
pg_available_extensions
or
pg_available_extension_versions
system views\&amp;.
.PP
For information about writing new extensions, see
Section 36.15, \(lqPackaging Related Objects into an Extension\(rq, in the documentation\&amp;.
.SH "EXAMPLES"
.PP
Install the
hstore
extension into the current database:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE EXTENSION hstore;
.fi
.if n \{\
.RE
.\}
.PP
Update a pre\-9\&amp;.1 installation of
hstore
into extension style:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE EXTENSION hstore SCHEMA public FROM unpackaged;
.fi
.if n \{\
.RE
.\}
.sp
Be careful to specify the schema in which you installed the existing
hstore
objects\&amp;.
.SH "COMPATIBILITY"
.PP
\fBCREATE EXTENSION\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER EXTENSION (\fBALTER_EXTENSION\fR(7)), DROP EXTENSION (\fBDROP_EXTENSION\fR(7))
'\" t
.\"     Title: CREATE FOREIGN DATA WRAPPER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE FOREIGN DATA WRAPPER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_FOREIGN_DATA_WRAPPER \- define a new foreign\-data wrapper
.SH "SYNOPSIS"
.sp
.nf
CREATE FOREIGN DATA WRAPPER \fIname\fR
[ HANDLER \fIhandler_function\fR | NO HANDLER ]
[ VALIDATOR \fIvalidator_function\fR | NO VALIDATOR ]
[ OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] ) ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE FOREIGN DATA WRAPPER\fR
creates a new foreign\-data wrapper\&amp;. The user who defines a foreign\-data wrapper becomes its owner\&amp;.
.PP
The foreign\-data wrapper name must be unique within the database\&amp;.
.PP
Only superusers can create foreign\-data wrappers\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the foreign\-data wrapper to be created\&amp;.
.RE
.PP
HANDLER \fIhandler_function\fR
.RS 4
\fIhandler_function\fR
is the name of a previously registered function that will be called to retrieve the execution functions for foreign tables\&amp;. The handler function must take no arguments, and its return type must be
fdw_handler\&amp;.
.sp
It is possible to create a foreign\-data wrapper with no handler function, but foreign tables using such a wrapper can only be declared, not accessed\&amp;.
.RE
.PP
VALIDATOR \fIvalidator_function\fR
.RS 4
\fIvalidator_function\fR
is the name of a previously registered function that will be called to check the generic options given to the foreign\-data wrapper, as well as options for foreign servers, user mappings and foreign tables using the foreign\-data wrapper\&amp;. If no validator function or
NO VALIDATOR
is specified, then options will not be checked at creation time\&amp;. (Foreign\-data wrappers will possibly ignore or reject invalid option specifications at run time, depending on the implementation\&amp;.) The validator function must take two arguments: one of type
text[], which will contain the array of options as stored in the system catalogs, and one of type
oid, which will be the OID of the system catalog containing the options\&amp;. The return type is ignored; the function should report invalid options using the
\fBereport(ERROR)\fR
function\&amp;.
.RE
.PP
OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This clause specifies options for the new foreign\-data wrapper\&amp;. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign\-data wrapper\*(Aqs validator function\&amp;. Option names must be unique\&amp;.
.RE
.SH "NOTES"
.PP
PostgreSQL\*(Aqs foreign\-data functionality is still under active development\&amp;. Optimization of queries is primitive (and mostly left to the wrapper, too)\&amp;. Thus, there is considerable room for future performance improvements\&amp;.
.SH "EXAMPLES"
.PP
Create a useless foreign\-data wrapper
dummy:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FOREIGN DATA WRAPPER dummy;
.fi
.if n \{\
.RE
.\}
.PP
Create a foreign\-data wrapper
file
with handler function
file_fdw_handler:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FOREIGN DATA WRAPPER file HANDLER file_fdw_handler;
.fi
.if n \{\
.RE
.\}
.PP
Create a foreign\-data wrapper
mywrapper
with some options:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FOREIGN DATA WRAPPER mywrapper
OPTIONS (debug \*(Aqtrue\*(Aq);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE FOREIGN DATA WRAPPER\fR
conforms to ISO/IEC 9075\-9 (SQL/MED), with the exception that the
HANDLER
and
VALIDATOR
clauses are extensions and the standard clauses
LIBRARY
and
LANGUAGE
are not implemented in
PostgreSQL\&amp;.
.PP
Note, however, that the SQL/MED functionality as a whole is not yet conforming\&amp;.
.SH "SEE ALSO"
ALTER FOREIGN DATA WRAPPER (\fBALTER_FOREIGN_DATA_WRAPPER\fR(7)), DROP FOREIGN DATA WRAPPER (\fBDROP_FOREIGN_DATA_WRAPPER\fR(7)), CREATE SERVER (\fBCREATE_SERVER\fR(7)), CREATE USER MAPPING (\fBCREATE_USER_MAPPING\fR(7)), CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7))
'\" t
.\"     Title: CREATE FOREIGN TABLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE FOREIGN TABLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_FOREIGN_TABLE \- define a new foreign table
.SH "SYNOPSIS"
.sp
.nf
CREATE FOREIGN TABLE [ IF NOT EXISTS ] \fItable_name\fR ( [
{ \fIcolumn_name\fR \fIdata_type\fR [ OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] ) ] [ COLLATE \fIcollation\fR ] [ \fIcolumn_constraint\fR [ \&amp;.\&amp;.\&amp;. ] ]
| \fItable_constraint\fR }
[, \&amp;.\&amp;.\&amp;. ]
] )
[ INHERITS ( \fIparent_table\fR [, \&amp;.\&amp;.\&amp;. ] ) ]
SERVER \fIserver_name\fR
[ OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] ) ]

where \fIcolumn_constraint\fR is:

[ CONSTRAINT \fIconstraint_name\fR ]
{ NOT NULL |
NULL |
CHECK ( \fIexpression\fR ) [ NO INHERIT ] |
DEFAULT \fIdefault_expr\fR }

and \fItable_constraint\fR is:

[ CONSTRAINT \fIconstraint_name\fR ]
CHECK ( \fIexpression\fR ) [ NO INHERIT ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE FOREIGN TABLE\fR
creates a new foreign table in the current database\&amp;. The table will be owned by the user issuing the command\&amp;.
.PP
If a schema name is given (for example,
CREATE FOREIGN TABLE myschema\&amp;.mytable \&amp;.\&amp;.\&amp;.) then the table is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. The name of the foreign table must be distinct from the name of any other foreign table, table, sequence, index, view, or materialized view in the same schema\&amp;.
.PP
\fBCREATE FOREIGN TABLE\fR
also automatically creates a data type that represents the composite type corresponding to one row of the foreign table\&amp;. Therefore, foreign tables cannot have the same name as any existing data type in the same schema\&amp;.
.PP
To be able to create a foreign table, you must have
USAGE
privilege on the foreign server, as well as
USAGE
privilege on all column types used in the table\&amp;.
.SH "PARAMETERS"
.PP
IF NOT EXISTS
.RS 4
Do not throw an error if a relation with the same name already exists\&amp;. A notice is issued in this case\&amp;. Note that there is no guarantee that the existing relation is anything like the one that would have been created\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table to be created\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a column to be created in the new table\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
The data type of the column\&amp;. This can include array specifiers\&amp;. For more information on the data types supported by
PostgreSQL, refer to
Chapter 8, Data Types, in the documentation\&amp;.
.RE
.PP
COLLATE \fIcollation\fR
.RS 4
The
COLLATE
clause assigns a collation to the column (which must be of a collatable data type)\&amp;. If not specified, the column data type\*(Aqs default collation is used\&amp;.
.RE
.PP
INHERITS ( \fIparent_table\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
The optional
INHERITS
clause specifies a list of tables from which the new foreign table automatically inherits all columns\&amp;. Parent tables can be plain tables or foreign tables\&amp;. See the similar form of
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for more details\&amp;.
.RE
.PP
CONSTRAINT \fIconstraint_name\fR
.RS 4
An optional name for a column or table constraint\&amp;. If the constraint is violated, the constraint name is present in error messages, so constraint names like
col must be positive
can be used to communicate helpful constraint information to client applications\&amp;. (Double\-quotes are needed to specify constraint names that contain spaces\&amp;.) If a constraint name is not specified, the system generates a name\&amp;.
.RE
.PP
NOT NULL
.RS 4
The column is not allowed to contain null values\&amp;.
.RE
.PP
NULL
.RS 4
The column is allowed to contain null values\&amp;. This is the default\&amp;.
.sp
This clause is only provided for compatibility with non\-standard SQL databases\&amp;. Its use is discouraged in new applications\&amp;.
.RE
.PP
CHECK ( \fIexpression\fR ) [ NO INHERIT ]
.RS 4
The
CHECK
clause specifies an expression producing a Boolean result which each row in the foreign table is expected to satisfy; that is, the expression should produce TRUE or UNKNOWN, never FALSE, for all rows in the foreign table\&amp;. A check constraint specified as a column constraint should reference that column\*(Aqs value only, while an expression appearing in a table constraint can reference multiple columns\&amp;.
.sp
Currently,
CHECK
expressions cannot contain subqueries nor refer to variables other than columns of the current row\&amp;. The system column
tableoid
may be referenced, but not any other system column\&amp;.
.sp
A constraint marked with
NO INHERIT
will not propagate to child tables\&amp;.
.RE
.PP
DEFAULT \fIdefault_expr\fR
.RS 4
The
DEFAULT
clause assigns a default data value for the column whose column definition it appears within\&amp;. The value is any variable\-free expression (subqueries and cross\-references to other columns in the current table are not allowed)\&amp;. The data type of the default expression must match the data type of the column\&amp;.
.sp
The default expression will be used in any insert operation that does not specify a value for the column\&amp;. If there is no default for a column, then the default is null\&amp;.
.RE
.PP
\fIserver_name\fR
.RS 4
The name of an existing foreign server to use for the foreign table\&amp;. For details on defining a server, see
CREATE SERVER (\fBCREATE_SERVER\fR(7))\&amp;.
.RE
.PP
OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;.] )
.RS 4
Options to be associated with the new foreign table or one of its columns\&amp;. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign\-data wrapper\*(Aqs validator function\&amp;. Duplicate option names are not allowed (although it\*(Aqs OK for a table option and a column option to have the same name)\&amp;.
.RE
.SH "NOTES"
.PP
Constraints on foreign tables (such as
CHECK
or
NOT NULL
clauses) are not enforced by the core
PostgreSQL
system, and most foreign data wrappers do not attempt to enforce them either; that is, the constraint is simply assumed to hold true\&amp;. There would be little point in such enforcement since it would only apply to rows inserted or updated via the foreign table, and not to rows modified by other means, such as directly on the remote server\&amp;. Instead, a constraint attached to a foreign table should represent a constraint that is being enforced by the remote server\&amp;.
.PP
Some special\-purpose foreign data wrappers might be the only access mechanism for the data they access, and in that case it might be appropriate for the foreign data wrapper itself to perform constraint enforcement\&amp;. But you should not assume that a wrapper does that unless its documentation says so\&amp;.
.PP
Although
PostgreSQL
does not attempt to enforce constraints on foreign tables, it does assume that they are correct for purposes of query optimization\&amp;. If there are rows visible in the foreign table that do not satisfy a declared constraint, queries on the table might produce incorrect answers\&amp;. It is the user\*(Aqs responsibility to ensure that the constraint definition matches reality\&amp;.
.SH "EXAMPLES"
.PP
Create foreign table
films, which will be accessed through the server
film_server:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FOREIGN TABLE films (
code        char(5) NOT NULL,
title       varchar(40) NOT NULL,
did         integer NOT NULL,
date_prod   date,
kind        varchar(10),
len         interval hour to minute
)
SERVER film_server;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBCREATE FOREIGN TABLE\fR
command largely conforms to the
SQL
standard; however, much as with
\fBCREATE TABLE\fR,
NULL
constraints and zero\-column foreign tables are permitted\&amp;. The ability to specify column default values is also a
PostgreSQL
extension\&amp;. Table inheritance, in the form defined by
PostgreSQL, is nonstandard\&amp;.
.SH "SEE ALSO"
ALTER FOREIGN TABLE (\fBALTER_FOREIGN_TABLE\fR(7)), DROP FOREIGN TABLE (\fBDROP_FOREIGN_TABLE\fR(7)), CREATE TABLE (\fBCREATE_TABLE\fR(7)), CREATE SERVER (\fBCREATE_SERVER\fR(7)), IMPORT FOREIGN SCHEMA (\fBIMPORT_FOREIGN_SCHEMA\fR(7))
'\" t
.\"     Title: CREATE FUNCTION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE FUNCTION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_FUNCTION \- define a new function
.SH "SYNOPSIS"
.sp
.nf
CREATE [ OR REPLACE ] FUNCTION
\fIname\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ { DEFAULT | = } \fIdefault_expr\fR ] [, \&amp;.\&amp;.\&amp;.] ] )
[ RETURNS \fIrettype\fR
| RETURNS TABLE ( \fIcolumn_name\fR \fIcolumn_type\fR [, \&amp;.\&amp;.\&amp;.] ) ]
{ LANGUAGE \fIlang_name\fR
| TRANSFORM { FOR TYPE \fItype_name\fR } [, \&amp;.\&amp;.\&amp;. ]
| WINDOW
| IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
| CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
| [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
| PARALLEL { UNSAFE | RESTRICTED | SAFE }
| COST \fIexecution_cost\fR
| ROWS \fIresult_rows\fR
| SET \fIconfiguration_parameter\fR { TO \fIvalue\fR | = \fIvalue\fR | FROM CURRENT }
| AS \*(Aq\fIdefinition\fR\*(Aq
| AS \*(Aq\fIobj_file\fR\*(Aq, \*(Aq\fIlink_symbol\fR\*(Aq
} \&amp;.\&amp;.\&amp;.
[ WITH ( \fIattribute\fR [, \&amp;.\&amp;.\&amp;.] ) ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE FUNCTION\fR
defines a new function\&amp;.
\fBCREATE OR REPLACE FUNCTION\fR
will either create a new function, or replace an existing definition\&amp;. To be able to define a function, the user must have the
USAGE
privilege on the language\&amp;.
.PP
If a schema name is included, then the function is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. The name of the new function must not match any existing function with the same input argument types in the same schema\&amp;. However, functions of different argument types can share a name (this is called
overloading)\&amp;.
.PP
To replace the current definition of an existing function, use
\fBCREATE OR REPLACE FUNCTION\fR\&amp;. It is not possible to change the name or argument types of a function this way (if you tried, you would actually be creating a new, distinct function)\&amp;. Also,
\fBCREATE OR REPLACE FUNCTION\fR
will not let you change the return type of an existing function\&amp;. To do that, you must drop and recreate the function\&amp;. (When using
OUT
parameters, that means you cannot change the types of any
OUT
parameters except by dropping the function\&amp;.)
.PP
When
\fBCREATE OR REPLACE FUNCTION\fR
is used to replace an existing function, the ownership and permissions of the function do not change\&amp;. All other function properties are assigned the values specified or implied in the command\&amp;. You must own the function to replace it (this includes being a member of the owning role)\&amp;.
.PP
If you drop and then recreate a function, the new function is not the same entity as the old; you will have to drop existing rules, views, triggers, etc\&amp;. that refer to the old function\&amp;. Use
\fBCREATE OR REPLACE FUNCTION\fR
to change a function definition without breaking objects that refer to the function\&amp;. Also,
\fBALTER FUNCTION\fR
can be used to change most of the auxiliary properties of an existing function\&amp;.
.PP
The user that creates the function becomes the owner of the function\&amp;.
.PP
To be able to create a function, you must have
USAGE
privilege on the argument types and the return type\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the function to create\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of an argument:
IN,
OUT,
INOUT, or
VARIADIC\&amp;. If omitted, the default is
IN\&amp;. Only
OUT
arguments can follow a
VARIADIC
one\&amp;. Also,
OUT
and
INOUT
arguments cannot be used together with the
RETURNS TABLE
notation\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of an argument\&amp;. Some languages (including SQL and PL/pgSQL) let you use the name in the function body\&amp;. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability (see
Section 4.3, \(lqCalling Functions\(rq, in the documentation)\&amp;. In any case, the name of an output argument is significant, because it defines the column name in the result row type\&amp;. (If you omit the name for an output argument, the system will choose a default column name\&amp;.)
.RE
.PP
\fIargtype\fR
.RS 4
The data type(s) of the function\*(Aqs arguments (optionally schema\-qualified), if any\&amp;. The argument types can be base, composite, or domain types, or can reference the type of a table column\&amp;.
.sp
Depending on the implementation language it might also be allowed to specify
\(lqpseudotypes\(rq
such as
cstring\&amp;. Pseudotypes indicate that the actual argument type is either incompletely specified, or outside the set of ordinary SQL data types\&amp;.
.sp
The type of a column is referenced by writing
\fItable_name\fR\&amp;.\fIcolumn_name\fR%TYPE\&amp;. Using this feature can sometimes help make a function independent of changes to the definition of a table\&amp;.
.RE
.PP
\fIdefault_expr\fR
.RS 4
An expression to be used as default value if the parameter is not specified\&amp;. The expression has to be coercible to the argument type of the parameter\&amp;. Only input (including
INOUT) parameters can have a default value\&amp;. All input parameters following a parameter with a default value must have default values as well\&amp;.
.RE
.PP
\fIrettype\fR
.RS 4
The return data type (optionally schema\-qualified)\&amp;. The return type can be a base, composite, or domain type, or can reference the type of a table column\&amp;. Depending on the implementation language it might also be allowed to specify
\(lqpseudotypes\(rq
such as
cstring\&amp;. If the function is not supposed to return a value, specify
void
as the return type\&amp;.
.sp
When there are
OUT
or
INOUT
parameters, the
RETURNS
clause can be omitted\&amp;. If present, it must agree with the result type implied by the output parameters:
RECORD
if there are multiple output parameters, or the same type as the single output parameter\&amp;.
.sp
The
SETOF
modifier indicates that the function will return a set of items, rather than a single item\&amp;.
.sp
The type of a column is referenced by writing
\fItable_name\fR\&amp;.\fIcolumn_name\fR%TYPE\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of an output column in the
RETURNS TABLE
syntax\&amp;. This is effectively another way of declaring a named
OUT
parameter, except that
RETURNS TABLE
also implies
RETURNS SETOF\&amp;.
.RE
.PP
\fIcolumn_type\fR
.RS 4
The data type of an output column in the
RETURNS TABLE
syntax\&amp;.
.RE
.PP
\fIlang_name\fR
.RS 4
The name of the language that the function is implemented in\&amp;. It can be
sql,
c,
internal, or the name of a user\-defined procedural language, e\&amp;.g\&amp;.
plpgsql\&amp;. Enclosing the name in single quotes is deprecated and requires matching case\&amp;.
.RE
.PP
TRANSFORM { FOR TYPE \fItype_name\fR } [, \&amp;.\&amp;.\&amp;. ] }
.RS 4
Lists which transforms a call to the function should apply\&amp;. Transforms convert between SQL types and language\-specific data types; see
CREATE TRANSFORM (\fBCREATE_TRANSFORM\fR(7))\&amp;. Procedural language implementations usually have hardcoded knowledge of the built\-in types, so those don\*(Aqt need to be listed here\&amp;. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation\&amp;.
.RE
.PP
WINDOW
.RS 4
WINDOW
indicates that the function is a
window function
rather than a plain function\&amp;. This is currently only useful for functions written in C\&amp;. The
WINDOW
attribute cannot be changed when replacing an existing function definition\&amp;.
.RE
.PP
IMMUTABLE
.br
STABLE
.br
VOLATILE
.RS 4
These attributes inform the query optimizer about the behavior of the function\&amp;. At most one choice can be specified\&amp;. If none of these appear,
VOLATILE
is the default assumption\&amp;.
.sp
IMMUTABLE
indicates that the function cannot modify the database and always returns the same result when given the same argument values; that is, it does not do database lookups or otherwise use information not directly present in its argument list\&amp;. If this option is given, any call of the function with all\-constant arguments can be immediately replaced with the function value\&amp;.
.sp
STABLE
indicates that the function cannot modify the database, and that within a single table scan it will consistently return the same result for the same argument values, but that its result could change across SQL statements\&amp;. This is the appropriate selection for functions whose results depend on database lookups, parameter variables (such as the current time zone), etc\&amp;. (It is inappropriate for
AFTER
triggers that wish to query rows modified by the current command\&amp;.) Also note that the
\fBcurrent_timestamp\fR
family of functions qualify as stable, since their values do not change within a transaction\&amp;.
.sp
VOLATILE
indicates that the function value can change even within a single table scan, so no optimizations can be made\&amp;. Relatively few database functions are volatile in this sense; some examples are
random(),
currval(),
timeofday()\&amp;. But note that any function that has side\-effects must be classified volatile, even if its result is quite predictable, to prevent calls from being optimized away; an example is
setval()\&amp;.
.sp
For additional details see
Section 36.6, \(lqFunction Volatility Categories\(rq, in the documentation\&amp;.
.RE
.PP
LEAKPROOF
.RS 4
LEAKPROOF
indicates that the function has no side effects\&amp;. It reveals no information about its arguments other than by its return value\&amp;. For example, a function which throws an error message for some argument values but not others, or which includes the argument values in any error message, is not leakproof\&amp;. This affects how the system executes queries against views created with the
security_barrier
option or tables with row level security enabled\&amp;. The system will enforce conditions from security policies and security barrier views before any user\-supplied conditions from the query itself that contain non\-leakproof functions, in order to prevent the inadvertent exposure of data\&amp;. Functions and operators marked as leakproof are assumed to be trustworthy, and may be executed before conditions from security policies and security barrier views\&amp;. In addition, functions which do not take arguments or which are not passed any arguments from the security barrier view or table do not have to be marked as leakproof to be executed before security conditions\&amp;. See
CREATE VIEW (\fBCREATE_VIEW\fR(7))
and
Section 39.5, \(lqRules and Privileges\(rq, in the documentation\&amp;. This option can only be set by the superuser\&amp;.
.RE
.PP
CALLED ON NULL INPUT
.br
RETURNS NULL ON NULL INPUT
.br
STRICT
.RS 4
CALLED ON NULL INPUT
(the default) indicates that the function will be called normally when some of its arguments are null\&amp;. It is then the function author\*(Aqs responsibility to check for null values if necessary and respond appropriately\&amp;.
.sp
RETURNS NULL ON NULL INPUT
or
STRICT
indicates that the function always returns null whenever any of its arguments are null\&amp;. If this parameter is specified, the function is not executed when there are null arguments; instead a null result is assumed automatically\&amp;.
.RE
.PP
[EXTERNAL] SECURITY INVOKER
.br
[EXTERNAL] SECURITY DEFINER
.RS 4
SECURITY INVOKER
indicates that the function is to be executed with the privileges of the user that calls it\&amp;. That is the default\&amp;.
SECURITY DEFINER
specifies that the function is to be executed with the privileges of the user that created it\&amp;.
.sp
The key word
EXTERNAL
is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not only external ones\&amp;.
.RE
.PP
PARALLEL
.RS 4
PARALLEL UNSAFE
indicates that the function can\*(Aqt be executed in parallel mode and the presence of such a function in an SQL statement forces a serial execution plan\&amp;. This is the default\&amp;.
PARALLEL RESTRICTED
indicates that the function can be executed in parallel mode, but the execution is restricted to parallel group leader\&amp;.
PARALLEL SAFE
indicates that the function is safe to run in parallel mode without restriction\&amp;.
.sp
Functions should be labeled parallel unsafe if they modify any database state, or if they make changes to the transaction such as using sub\-transactions, or if they access sequences or attempt to make persistent changes to settings (e\&amp;.g\&amp;.
setval)\&amp;. They should be labeled as parallel restricted if they access temporary tables, client connection state, cursors, prepared statements, or miscellaneous backend\-local state which the system cannot synchronize in parallel mode (e\&amp;.g\&amp;.
setseed
cannot be executed other than by the group leader because a change made by another process would not be reflected in the leader)\&amp;. In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query\&amp;. C\-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function\&amp;. If in doubt, functions should be labeled as
UNSAFE, which is the default\&amp;.
.RE
.PP
\fIexecution_cost\fR
.RS 4
A positive number giving the estimated execution cost for the function, in units of
cpu_operator_cost\&amp;. If the function returns a set, this is the cost per returned row\&amp;. If the cost is not specified, 1 unit is assumed for C\-language and internal functions, and 100 units for functions in all other languages\&amp;. Larger values cause the planner to try to avoid evaluating the function more often than necessary\&amp;.
.RE
.PP
\fIresult_rows\fR
.RS 4
A positive number giving the estimated number of rows that the planner should expect the function to return\&amp;. This is only allowed when the function is declared to return a set\&amp;. The default assumption is 1000 rows\&amp;.
.RE
.PP
\fIconfiguration_parameter\fR
.br
\fIvalue\fR
.RS 4
The
SET
clause causes the specified configuration parameter to be set to the specified value when the function is entered, and then restored to its prior value when the function exits\&amp;.
SET FROM CURRENT
saves the value of the parameter that is current when
\fBCREATE FUNCTION\fR
is executed as the value to be applied when the function is entered\&amp;.
.sp
If a
SET
clause is attached to a function, then the effects of a
\fBSET LOCAL\fR
command executed inside the function for the same variable are restricted to the function: the configuration parameter\*(Aqs prior value is still restored at function exit\&amp;. However, an ordinary
\fBSET\fR
command (without
LOCAL) overrides the
SET
clause, much as it would do for a previous
\fBSET LOCAL\fR
command: the effects of such a command will persist after function exit, unless the current transaction is rolled back\&amp;.
.sp
See
\fBSET\fR(7)
and
Chapter 19, Server Configuration, in the documentation
for more information about allowed parameter names and values\&amp;.
.RE
.PP
\fIdefinition\fR
.RS 4
A string constant defining the function; the meaning depends on the language\&amp;. It can be an internal function name, the path to an object file, an SQL command, or text in a procedural language\&amp;.
.sp
It is often helpful to use dollar quoting (see
Section 4.1.2.4, \(lqDollar-quoted String Constants\(rq, in the documentation) to write the function definition string, rather than the normal single quote syntax\&amp;. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them\&amp;.
.RE
.PP
\fIobj_file\fR, \fIlink_symbol\fR
.RS 4
This form of the
AS
clause is used for dynamically loadable C language functions when the function name in the C language source code is not the same as the name of the SQL function\&amp;. The string
\fIobj_file\fR
is the name of the file containing the dynamically loadable object, and
\fIlink_symbol\fR
is the function\*(Aqs link symbol, that is, the name of the function in the C language source code\&amp;. If the link symbol is omitted, it is assumed to be the same as the name of the SQL function being defined\&amp;.
.sp
When repeated
\fBCREATE FUNCTION\fR
calls refer to the same object file, the file is only loaded once per session\&amp;. To unload and reload the file (perhaps during development), start a new session\&amp;.
.RE
.PP
\fIattribute\fR
.RS 4
The historical way to specify optional pieces of information about the function\&amp;. The following attributes can appear here:
.PP
isStrict
.RS 4
Equivalent to
STRICT
or
RETURNS NULL ON NULL INPUT\&amp;.
.RE
.PP
isCachable
.RS 4
isCachable
is an obsolete equivalent of
IMMUTABLE; it\*(Aqs still accepted for backwards\-compatibility reasons\&amp;.
.RE
.sp
Attribute names are not case\-sensitive\&amp;.
.RE
.PP
Refer to
Section 36.3, \(lqUser-defined Functions\(rq, in the documentation
for further information on writing functions\&amp;.
.SH "OVERLOADING"
.PP
PostgreSQL
allows function
overloading; that is, the same name can be used for several different functions so long as they have distinct input argument types\&amp;. However, the C names of all functions must be different, so you must give overloaded C functions different C names (for example, use the argument types as part of the C names)\&amp;.
.PP
Two functions are considered the same if they have the same names and
\fIinput\fR
argument types, ignoring any
OUT
parameters\&amp;. Thus for example these declarations conflict:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION foo(int) \&amp;.\&amp;.\&amp;.
CREATE FUNCTION foo(int, out text) \&amp;.\&amp;.\&amp;.
.fi
.if n \{\
.RE
.\}
.PP
Functions that have different argument type lists will not be considered to conflict at creation time, but if defaults are provided they might conflict in use\&amp;. For example, consider
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION foo(int) \&amp;.\&amp;.\&amp;.
CREATE FUNCTION foo(int, int default 42) \&amp;.\&amp;.\&amp;.
.fi
.if n \{\
.RE
.\}
.sp
A call
foo(10)
will fail due to the ambiguity about which function should be called\&amp;.
.SH "NOTES"
.PP
The full
SQL
type syntax is allowed for declaring a function\*(Aqs arguments and return value\&amp;. However, parenthesized type modifiers (e\&amp;.g\&amp;., the precision field for type
numeric) are discarded by
\fBCREATE FUNCTION\fR\&amp;. Thus for example
CREATE FUNCTION foo (varchar(10)) \&amp;.\&amp;.\&amp;.
is exactly the same as
CREATE FUNCTION foo (varchar) \&amp;.\&amp;.\&amp;.\&amp;.
.PP
When replacing an existing function with
\fBCREATE OR REPLACE FUNCTION\fR, there are restrictions on changing parameter names\&amp;. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before)\&amp;. If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function\*(Aqs result\&amp;. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced\&amp;.
.PP
If a function is declared
STRICT
with a
VARIADIC
argument, the strictness check tests that the variadic array
\fIas a whole\fR
is non\-null\&amp;. The function will still be called if the array has null elements\&amp;.
.SH "EXAMPLES"
.PP
Here are some trivial examples to help you get started\&amp;. For more information and examples, see
Section 36.3, \(lqUser-defined Functions\(rq, in the documentation\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION add(integer, integer) RETURNS integer
AS \*(Aqselect $1 + $2;\*(Aq
LANGUAGE SQL
IMMUTABLE
RETURNS NULL ON NULL INPUT;
.fi
.if n \{\
.RE
.\}
.PP
Increment an integer, making use of an argument name, in
PL/pgSQL:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
BEGIN
RETURN i + 1;
END;
$$ LANGUAGE plpgsql;
.fi
.if n \{\
.RE
.\}
.PP
Return a record containing multiple output parameters:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION dup(in int, out f1 int, out f2 text)
AS $$ SELECT $1, CAST($1 AS text) || \*(Aq is text\*(Aq $$
LANGUAGE SQL;

SELECT * FROM dup(42);
.fi
.if n \{\
.RE
.\}
.sp
You can do the same thing more verbosely with an explicitly named composite type:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
AS $$ SELECT $1, CAST($1 AS text) || \*(Aq is text\*(Aq $$
LANGUAGE SQL;

SELECT * FROM dup(42);
.fi
.if n \{\
.RE
.\}
.sp
Another way to return multiple columns is to use a
TABLE
function:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
AS $$ SELECT $1, CAST($1 AS text) || \*(Aq is text\*(Aq $$
LANGUAGE SQL;

SELECT * FROM dup(42);
.fi
.if n \{\
.RE
.\}
.sp
However, a
TABLE
function is different from the preceding examples, because it actually returns a
\fIset\fR
of records, not just one record\&amp;.
.SH "WRITING SECURITY DEFINER FUNCTIONS SAFELY"
.PP
Because a
SECURITY DEFINER
function is executed with the privileges of the user that created it, care is needed to ensure that the function cannot be misused\&amp;. For security,
search_path
should be set to exclude any schemas writable by untrusted users\&amp;. This prevents malicious users from creating objects (e\&amp;.g\&amp;., tables, functions, and operators) that mask objects intended to be used by the function\&amp;. Particularly important in this regard is the temporary\-table schema, which is searched first by default, and is normally writable by anyone\&amp;. A secure arrangement can be obtained by forcing the temporary schema to be searched last\&amp;. To do this, write
pg_temp
as the last entry in
\fIsearch_path\fR\&amp;. This function illustrates safe usage:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
SELECT  (pwd = $2) INTO passed
FROM    pwds
WHERE   username = $1;

RETURN passed;
END;
$$  LANGUAGE plpgsql
SECURITY DEFINER
\-\- Set a secure search_path: trusted schema(s), then \*(Aqpg_temp\*(Aq\&amp;.
SET search_path = admin, pg_temp;
.fi
.if n \{\
.RE
.\}
.sp
This function\*(Aqs intention is to access a table
admin\&amp;.pwds\&amp;. But without the
SET
clause, or with a
SET
clause mentioning only
admin, the function could be subverted by creating a temporary table named
pwds\&amp;.
.PP
Before
PostgreSQL
version 8\&amp;.3, the
SET
clause was not available, and so older functions may contain rather complicated logic to save, set, and restore
\fIsearch_path\fR\&amp;. The
SET
clause is far easier to use for this purpose\&amp;.
.PP
Another point to keep in mind is that by default, execute privilege is granted to
PUBLIC
for newly created functions (see
\fBGRANT\fR(7)
for more information)\&amp;. Frequently you will wish to restrict use of a security definer function to only some users\&amp;. To do that, you must revoke the default
PUBLIC
privileges and then grant execute privilege selectively\&amp;. To avoid having a window where the new function is accessible to all, create it and set the privileges within a single transaction\&amp;. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) \&amp;.\&amp;.\&amp;. SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
A
\fBCREATE FUNCTION\fR
command is defined in SQL:1999 and later\&amp;. The
PostgreSQL
version is similar but not fully compatible\&amp;. The attributes are not portable, neither are the different available languages\&amp;.
.PP
For compatibility with some other database systems,
\fIargmode\fR
can be written either before or after
\fIargname\fR\&amp;. But only the first way is standard\-compliant\&amp;.
.PP
For parameter defaults, the SQL standard specifies only the syntax with the
DEFAULT
key word\&amp;. The syntax with
=
is used in T\-SQL and Firebird\&amp;.
.SH "SEE ALSO"
ALTER FUNCTION (\fBALTER_FUNCTION\fR(7)), DROP FUNCTION (\fBDROP_FUNCTION\fR(7)), \fBGRANT\fR(7), \fBLOAD\fR(7), \fBREVOKE\fR(7), \fBcreatelang\fR(1)
'\" t
.\"     Title: CREATE GROUP
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE GROUP" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_GROUP \- define a new database role
.SH "SYNOPSIS"
.sp
.nf
CREATE GROUP \fIname\fR [ [ WITH ] \fIoption\fR [ \&amp;.\&amp;.\&amp;. ] ]

where \fIoption\fR can be:

SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD \*(Aq\fIpassword\fR\*(Aq
| VALID UNTIL \*(Aq\fItimestamp\fR\*(Aq
| IN ROLE \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| IN GROUP \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| ROLE \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| ADMIN \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| USER \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| SYSID \fIuid\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE GROUP\fR
is now an alias for
CREATE ROLE (\fBCREATE_ROLE\fR(7))\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBCREATE GROUP\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE ROLE (\fBCREATE_ROLE\fR(7))
'\" t
.\"     Title: CREATE INDEX
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE INDEX" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_INDEX \- define a new index
.SH "SYNOPSIS"
.sp
.nf
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] \fIname\fR ] ON \fItable_name\fR [ USING \fImethod\fR ]
( { \fIcolumn_name\fR | ( \fIexpression\fR ) } [ COLLATE \fIcollation\fR ] [ \fIopclass\fR ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, \&amp;.\&amp;.\&amp;.] )
[ WITH ( \fIstorage_parameter\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] ) ]
[ TABLESPACE \fItablespace_name\fR ]
[ WHERE \fIpredicate\fR ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE INDEX\fR
constructs an index on the specified column(s) of the specified relation, which can be a table or a materialized view\&amp;. Indexes are primarily used to enhance database performance (though inappropriate use can result in slower performance)\&amp;.
.PP
The key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses\&amp;. Multiple fields can be specified if the index method supports multicolumn indexes\&amp;.
.PP
An index field can be an expression computed from the values of one or more columns of the table row\&amp;. This feature can be used to obtain fast access to data based on some transformation of the basic data\&amp;. For example, an index computed on
upper(col)
would allow the clause
WHERE upper(col) = \*(AqJIM\*(Aq
to use an index\&amp;.
.PP
PostgreSQL
provides the index methods B\-tree, hash, GiST, SP\-GiST, GIN, and BRIN\&amp;. Users can also define their own index methods, but that is fairly complicated\&amp;.
.PP
When the
WHERE
clause is present, a
partial index
is created\&amp;. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table\&amp;. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion\&amp;. Another possible application is to use
WHERE
with
UNIQUE
to enforce uniqueness over a subset of a table\&amp;. See
Section 11.8, \(lqPartial Indexes\(rq, in the documentation
for more discussion\&amp;.
.PP
The expression used in the
WHERE
clause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed\&amp;. Presently, subqueries and aggregate expressions are also forbidden in
WHERE\&amp;. The same restrictions apply to index fields that are expressions\&amp;.
.PP
All functions and operators used in an index definition must be
\(lqimmutable\(rq, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time)\&amp;. This restriction ensures that the behavior of the index is well\-defined\&amp;. To use a user\-defined function in an index expression or
WHERE
clause, remember to mark the function immutable when you create it\&amp;.
.SH "PARAMETERS"
.PP
UNIQUE
.RS 4
Causes the system to check for duplicate values in the table when the index is created (if data already exist) and each time data is added\&amp;. Attempts to insert or update data which would result in duplicate entries will generate an error\&amp;.
.RE
.PP
CONCURRENTLY
.RS 4
When this option is used,
PostgreSQL
will build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it\*(Aqs done\&amp;. There are several caveats to be aware of when using this option \(em see
Building Indexes Concurrently\&amp;.
.RE
.PP
IF NOT EXISTS
.RS 4
Do not throw an error if a relation with the same name already exists\&amp;. A notice is issued in this case\&amp;. Note that there is no guarantee that the existing index is anything like the one that would have been created\&amp;. Index name is required when
IF NOT EXISTS
is specified\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the index to be created\&amp;. No schema name can be included here; the index is always created in the same schema as its parent table\&amp;. If the name is omitted,
PostgreSQL
chooses a suitable name based on the parent table\*(Aqs name and the indexed column name(s)\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (possibly schema\-qualified) of the table to be indexed\&amp;.
.RE
.PP
\fImethod\fR
.RS 4
The name of the index method to be used\&amp;. Choices are
btree,
hash,
gist,
spgist,
gin, and
brin\&amp;. The default method is
btree\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a column of the table\&amp;.
.RE
.PP
\fIexpression\fR
.RS 4
An expression based on one or more columns of the table\&amp;. The expression usually must be written with surrounding parentheses, as shown in the syntax\&amp;. However, the parentheses can be omitted if the expression has the form of a function call\&amp;.
.RE
.PP
\fIcollation\fR
.RS 4
The name of the collation to use for the index\&amp;. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed\&amp;. Indexes with non\-default collations can be useful for queries that involve expressions using non\-default collations\&amp;.
.RE
.PP
\fIopclass\fR
.RS 4
The name of an operator class\&amp;. See below for details\&amp;.
.RE
.PP
ASC
.RS 4
Specifies ascending sort order (which is the default)\&amp;.
.RE
.PP
DESC
.RS 4
Specifies descending sort order\&amp;.
.RE
.PP
NULLS FIRST
.RS 4
Specifies that nulls sort before non\-nulls\&amp;. This is the default when
DESC
is specified\&amp;.
.RE
.PP
NULLS LAST
.RS 4
Specifies that nulls sort after non\-nulls\&amp;. This is the default when
DESC
is not specified\&amp;.
.RE
.PP
\fIstorage_parameter\fR
.RS 4
The name of an index\-method\-specific storage parameter\&amp;. See
Index Storage Parameters
for details\&amp;.
.RE
.PP
\fItablespace_name\fR
.RS 4
The tablespace in which to create the index\&amp;. If not specified,
default_tablespace
is consulted, or
temp_tablespaces
for indexes on temporary tables\&amp;.
.RE
.PP
\fIpredicate\fR
.RS 4
The constraint expression for a partial index\&amp;.
.RE
.SS "Index Storage Parameters"
.PP
The optional
WITH
clause specifies
storage parameters
for the index\&amp;. Each index method has its own set of allowed storage parameters\&amp;. The B\-tree, hash, GiST and SP\-GiST index methods all accept this parameter:
.PP
fillfactor
.RS 4
The fillfactor for an index is a percentage that determines how full the index method will try to pack index pages\&amp;. For B\-trees, leaf pages are filled to this percentage during initial index build, and also when extending the index at the right (adding new largest key values)\&amp;. If pages subsequently become completely full, they will be split, leading to gradual degradation in the index\*(Aqs efficiency\&amp;. B\-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected\&amp;. If the table is static then fillfactor 100 is best to minimize the index\*(Aqs physical size, but for heavily updated tables a smaller fillfactor is better to minimize the need for page splits\&amp;. The other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods\&amp;.
.RE
.PP
GiST indexes additionally accept this parameter:
.PP
buffering
.RS 4
Determines whether the buffering build technique described in
Section 61.4.1, \(lqGiST buffering build\(rq, in the documentation
is used to build the index\&amp;. With
OFF
it is disabled, with
ON
it is enabled, and with
AUTO
it is initially disabled, but turned on on\-the\-fly once the index size reaches
effective_cache_size\&amp;. The default is
AUTO\&amp;.
.RE
.PP
GIN indexes accept different parameters:
.PP
fastupdate
.RS 4
This setting controls usage of the fast update technique described in
Section 63.4.1, \(lqGIN Fast Update Technique\(rq, in the documentation\&amp;. It is a Boolean parameter:
ON
enables fast update,
OFF
disables it\&amp;. (Alternative spellings of
ON
and
OFF
are allowed as described in
Section 19.1, \(lqSetting Parameters\(rq, in the documentation\&amp;.) The default is
ON\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Turning
fastupdate
off via
\fBALTER INDEX\fR
prevents future insertions from going into the list of pending index entries, but does not in itself flush previous entries\&amp;. You might want to
\fBVACUUM\fR
the table or call
\fBgin_clean_pending_list\fR
function afterward to ensure the pending list is emptied\&amp;.
.sp .5v
.RE
.RE
.PP
gin_pending_list_limit
.RS 4
Custom
gin_pending_list_limit
parameter\&amp;. This value is specified in kilobytes\&amp;.
.RE
.PP
BRIN
indexes accept a different parameter:
.PP
pages_per_range
.RS 4
Defines the number of table blocks that make up one block range for each entry of a
BRIN
index (see
Section 64.1, \(lqIntroduction\(rq, in the documentation
for more details)\&amp;. The default is
128\&amp;.
.RE
.SS "Building Indexes Concurrently"
.PP
Creating an index can interfere with regular operation of a database\&amp;. Normally
PostgreSQL
locks the table to be indexed against writes and performs the entire index build with a single scan of the table\&amp;. Other transactions can still read the table, but if they try to insert, update, or delete rows in the table they will block until the index build is finished\&amp;. This could have a severe effect if the system is a live production database\&amp;. Very large tables can take many hours to be indexed, and even for smaller tables, an index build can lock out writers for periods that are unacceptably long for a production system\&amp;.
.PP
PostgreSQL
supports building indexes without locking out writes\&amp;. This method is invoked by specifying the
CONCURRENTLY
option of
\fBCREATE INDEX\fR\&amp;. When this option is used,
PostgreSQL
must perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate\&amp;. Thus this method requires more total work than a standard index build and takes significantly longer to complete\&amp;. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment\&amp;. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations\&amp;.
.PP
In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions\&amp;. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate\&amp;. After the second scan, the index build must wait for any transactions that have a snapshot (see
Chapter 13, Concurrency Control, in the documentation) predating the second scan to terminate\&amp;. Then finally the index can be marked ready for use, and the
\fBCREATE INDEX\fR
command terminates\&amp;. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build\&amp;.
.PP
If a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the
\fBCREATE INDEX\fR
command will fail but leave behind an
\(lqinvalid\(rq
index\&amp;. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead\&amp;. The
psql\fB\ed\fR
command will report such an index as
INVALID:
.sp
.if n \{\
.RS 4
.\}
.nf
postgres=# \ed tab
Table "public\&amp;.tab"
Column |  Type   | Modifiers 
\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-
col    | integer | 
Indexes:
"idx" btree (col) INVALID
.fi
.if n \{\
.RE
.\}
.sp
The recommended recovery method in such cases is to drop the index and try again to perform
\fBCREATE INDEX CONCURRENTLY\fR\&amp;. (Another possibility is to rebuild the index with
\fBREINDEX\fR\&amp;. However, since
\fBREINDEX\fR
does not support concurrent builds, this option is unlikely to seem attractive\&amp;.)
.PP
Another caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins\&amp;. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails\&amp;. Also, if a failure does occur in the second scan, the
\(lqinvalid\(rq
index continues to enforce its uniqueness constraint afterwards\&amp;.
.PP
Concurrent builds of expression indexes and partial indexes are supported\&amp;. Errors occurring in the evaluation of these expressions could cause behavior similar to that described above for unique constraint violations\&amp;.
.PP
Regular index builds permit other regular index builds on the same table to occur in parallel, but only one concurrent index build can occur on a table at a time\&amp;. In both cases, no other types of schema modification on the table are allowed meanwhile\&amp;. Another difference is that a regular
\fBCREATE INDEX\fR
command can be performed within a transaction block, but
\fBCREATE INDEX CONCURRENTLY\fR
cannot\&amp;.
.SH "NOTES"
.PP
See
Chapter 11, Indexes, in the documentation
for information about when indexes can be used, when they are not used, and in which particular situations they can be useful\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBCaution\fR
.ps -1
.br
.PP
Hash index operations are not presently WAL\-logged, so hash indexes might need to be rebuilt with
\fBREINDEX\fR
after a database crash if there were unwritten changes\&amp;. Also, changes to hash indexes are not replicated over streaming or file\-based replication after the initial base backup, so they give wrong answers to queries that subsequently use them\&amp;. Hash indexes are also not properly restored during point\-in\-time recovery\&amp;. For these reasons, hash index use is presently discouraged\&amp;.
.sp .5v
.RE
.PP
Currently, only the B\-tree, GiST, GIN, and BRIN index methods support multicolumn indexes\&amp;. Up to 32 fields can be specified by default\&amp;. (This limit can be altered when building
PostgreSQL\&amp;.) Only B\-tree currently supports unique indexes\&amp;.
.PP
An
operator class
can be specified for each column of an index\&amp;. The operator class identifies the operators to be used by the index for that column\&amp;. For example, a B\-tree index on four\-byte integers would use the
int4_ops
class; this operator class includes comparison functions for four\-byte integers\&amp;. In practice the default operator class for the column\*(Aqs data type is usually sufficient\&amp;. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering\&amp;. For example, we might want to sort a complex\-number data type either by absolute value or by real part\&amp;. We could do this by defining two operator classes for the data type and then selecting the proper class when making an index\&amp;. More information about operator classes is in
Section 11.9, \(lqOperator Classes and Operator Families\(rq, in the documentation
and in
Section 36.14, \(lqInterfacing Extensions To Indexes\(rq, in the documentation\&amp;.
.PP
For index methods that support ordered scans (currently, only B\-tree), the optional clauses
ASC,
DESC,
NULLS FIRST, and/or
NULLS LAST
can be specified to modify the sort ordering of the index\&amp;. Since an ordered index can be scanned either forward or backward, it is not normally useful to create a single\-column
DESC
index \(em that sort ordering is already available with a regular index\&amp;. The value of these options is that multicolumn indexes can be created that match the sort ordering requested by a mixed\-ordering query, such as
SELECT \&amp;.\&amp;.\&amp;. ORDER BY x ASC, y DESC\&amp;. The
NULLS
options are useful if you need to support
\(lqnulls sort low\(rq
behavior, rather than the default
\(lqnulls sort high\(rq, in queries that depend on indexes to avoid sorting steps\&amp;.
.PP
For most index methods, the speed of creating an index is dependent on the setting of
maintenance_work_mem\&amp;. Larger values will reduce the time needed for index creation, so long as you don\*(Aqt make it larger than the amount of memory really available, which would drive the machine into swapping\&amp;.
.PP
Use
DROP INDEX (\fBDROP_INDEX\fR(7))
to remove an index\&amp;.
.PP
Prior releases of
PostgreSQL
also had an R\-tree index method\&amp;. This method has been removed because it had no significant advantages over the GiST method\&amp;. If
USING rtree
is specified,
\fBCREATE INDEX\fR
will interpret it as
USING gist, to simplify conversion of old databases to GiST\&amp;.
.SH "EXAMPLES"
.PP
To create a B\-tree index on the column
title
in the table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE UNIQUE INDEX title_idx ON films (title);
.fi
.if n \{\
.RE
.\}
.PP
To create an index on the expression
lower(title), allowing efficient case\-insensitive searches:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE INDEX ON films ((lower(title)));
.fi
.if n \{\
.RE
.\}
.sp
(In this example we have chosen to omit the index name, so the system will choose a name, typically
films_lower_idx\&amp;.)
.PP
To create an index with non\-default collation:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");
.fi
.if n \{\
.RE
.\}
.PP
To create an index with non\-default sort ordering of nulls:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
.fi
.if n \{\
.RE
.\}
.PP
To create an index with non\-default fill factor:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
.fi
.if n \{\
.RE
.\}
.PP
To create a
GIN
index with fast updates disabled:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
.fi
.if n \{\
.RE
.\}
.PP
To create an index on the column
code
in the table
films
and have the index reside in the tablespace
indexspace:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
.fi
.if n \{\
.RE
.\}
.PP
To create a GiST index on a point attribute so that we can efficiently use box operators on the result of the conversion function:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE INDEX pointloc
ON points USING gist (box(location,location));
SELECT * FROM points
WHERE box(location,location) &amp;&amp; \*(Aq(0,0),(1,1)\*(Aq::box;
.fi
.if n \{\
.RE
.\}
.PP
To create an index without locking out writes to the table:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE INDEX\fR
is a
PostgreSQL
language extension\&amp;. There are no provisions for indexes in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER INDEX (\fBALTER_INDEX\fR(7)), DROP INDEX (\fBDROP_INDEX\fR(7))
'\" t
.\"     Title: CREATE LANGUAGE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE LANGUAGE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_LANGUAGE \- define a new procedural language
.SH "SYNOPSIS"
.sp
.nf
CREATE [ OR REPLACE ] [ PROCEDURAL ] LANGUAGE \fIname\fR
CREATE [ OR REPLACE ] [ TRUSTED ] [ PROCEDURAL ] LANGUAGE \fIname\fR
HANDLER \fIcall_handler\fR [ INLINE \fIinline_handler\fR ] [ VALIDATOR \fIvalfunction\fR ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE LANGUAGE\fR
registers a new procedural language with a
PostgreSQL
database\&amp;. Subsequently, functions and trigger procedures can be defined in this new language\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
As of
PostgreSQL
9\&amp;.1, most procedural languages have been made into
\(lqextensions\(rq, and should therefore be installed with
CREATE EXTENSION (\fBCREATE_EXTENSION\fR(7))
not
\fBCREATE LANGUAGE\fR\&amp;. Direct use of
\fBCREATE LANGUAGE\fR
should now be confined to extension installation scripts\&amp;. If you have a
\(lqbare\(rq
language in your database, perhaps as a result of an upgrade, you can convert it to an extension using
CREATE EXTENSION \fIlangname\fR FROM unpackaged\&amp;.
.sp .5v
.RE
.PP
\fBCREATE LANGUAGE\fR
effectively associates the language name with handler function(s) that are responsible for executing functions written in the language\&amp;. Refer to
Chapter 54, Writing A Procedural Language Handler, in the documentation
for more information about language handlers\&amp;.
.PP
There are two forms of the
\fBCREATE LANGUAGE\fR
command\&amp;. In the first form, the user supplies just the name of the desired language, and the
PostgreSQL
server consults the
pg_pltemplate
system catalog to determine the correct parameters\&amp;. In the second form, the user supplies the language parameters along with the language name\&amp;. The second form can be used to create a language that is not defined in
pg_pltemplate, but this approach is considered obsolescent\&amp;.
.PP
When the server finds an entry in the
pg_pltemplate
catalog for the given language name, it will use the catalog data even if the command includes language parameters\&amp;. This behavior simplifies loading of old dump files, which are likely to contain out\-of\-date information about language support functions\&amp;.
.PP
Ordinarily, the user must have the
PostgreSQL
superuser privilege to register a new language\&amp;. However, the owner of a database can register a new language within that database if the language is listed in the
pg_pltemplate
catalog and is marked as allowed to be created by database owners (tmpldbacreate
is true)\&amp;. The default is that trusted languages can be created by database owners, but this can be adjusted by superusers by modifying the contents of
pg_pltemplate\&amp;. The creator of a language becomes its owner and can later drop it, rename it, or assign it to a new owner\&amp;.
.PP
\fBCREATE OR REPLACE LANGUAGE\fR
will either create a new language, or replace an existing definition\&amp;. If the language already exists, its parameters are updated according to the values specified or taken from
pg_pltemplate, but the language\*(Aqs ownership and permissions settings do not change, and any existing functions written in the language are assumed to still be valid\&amp;. In addition to the normal privilege requirements for creating a language, the user must be superuser or owner of the existing language\&amp;. The
REPLACE
case is mainly meant to be used to ensure that the language exists\&amp;. If the language has a
pg_pltemplate
entry then
REPLACE
will not actually change anything about an existing definition, except in the unusual case where the
pg_pltemplate
entry has been modified since the language was created\&amp;.
.SH "PARAMETERS"
.PP
TRUSTED
.RS 4
TRUSTED
specifies that the language does not grant access to data that the user would not otherwise have\&amp;. If this key word is omitted when registering the language, only users with the
PostgreSQL
superuser privilege can use this language to create new functions\&amp;.
.RE
.PP
PROCEDURAL
.RS 4
This is a noise word\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the new procedural language\&amp;. The name must be unique among the languages in the database\&amp;.
.sp
For backward compatibility, the name can be enclosed by single quotes\&amp;.
.RE
.PP
HANDLER \fIcall_handler\fR
.RS 4
\fIcall_handler\fR
is the name of a previously registered function that will be called to execute the procedural language\*(Aqs functions\&amp;. The call handler for a procedural language must be written in a compiled language such as C with version 1 call convention and registered with
PostgreSQL
as a function taking no arguments and returning the
language_handler
type, a placeholder type that is simply used to identify the function as a call handler\&amp;.
.RE
.PP
INLINE \fIinline_handler\fR
.RS 4
\fIinline_handler\fR
is the name of a previously registered function that will be called to execute an anonymous code block (\fBDO\fR(7)
command) in this language\&amp;. If no
\fIinline_handler\fR
function is specified, the language does not support anonymous code blocks\&amp;. The handler function must take one argument of type
internal, which will be the
\fBDO\fR
command\*(Aqs internal representation, and it will typically return
void\&amp;. The return value of the handler is ignored\&amp;.
.RE
.PP
VALIDATOR \fIvalfunction\fR
.RS 4
\fIvalfunction\fR
is the name of a previously registered function that will be called when a new function in the language is created, to validate the new function\&amp;. If no validator function is specified, then a new function will not be checked when it is created\&amp;. The validator function must take one argument of type
oid, which will be the OID of the to\-be\-created function, and will typically return
void\&amp;.
.sp
A validator function would typically inspect the function body for syntactical correctness, but it can also look at other properties of the function, for example if the language cannot handle certain argument types\&amp;. To signal an error, the validator function should use the
\fBereport()\fR
function\&amp;. The return value of the function is ignored\&amp;.
.RE
.PP
The
TRUSTED
option and the support function name(s) are ignored if the server has an entry for the specified language name in
pg_pltemplate\&amp;.
.SH "NOTES"
.PP
The
\fBcreatelang\fR(1)
program is a simple wrapper around the
\fBCREATE LANGUAGE\fR
command\&amp;. It eases installation of procedural languages from the shell command line\&amp;.
.PP
Use
DROP LANGUAGE (\fBDROP_LANGUAGE\fR(7)), or better yet the
\fBdroplang\fR(1)
program, to drop procedural languages\&amp;.
.PP
The system catalog
pg_language
(see
Section 50.29, \(lqpg_language\(rq, in the documentation) records information about the currently installed languages\&amp;. Also,
\fBcreatelang\fR
has an option to list the installed languages\&amp;.
.PP
To create functions in a procedural language, a user must have the
USAGE
privilege for the language\&amp;. By default,
USAGE
is granted to
PUBLIC
(i\&amp;.e\&amp;., everyone) for trusted languages\&amp;. This can be revoked if desired\&amp;.
.PP
Procedural languages are local to individual databases\&amp;. However, a language can be installed into the
template1
database, which will cause it to be available automatically in all subsequently\-created databases\&amp;.
.PP
The call handler function, the inline handler function (if any), and the validator function (if any) must already exist if the server does not have an entry for the language in
pg_pltemplate\&amp;. But when there is an entry, the functions need not already exist; they will be automatically defined if not present in the database\&amp;. (This might result in
\fBCREATE LANGUAGE\fR
failing, if the shared library that implements the language is not available in the installation\&amp;.)
.PP
In
PostgreSQL
versions before 7\&amp;.3, it was necessary to declare handler functions as returning the placeholder type
opaque, rather than
language_handler\&amp;. To support loading of old dump files,
\fBCREATE LANGUAGE\fR
will accept a function declared as returning
opaque, but it will issue a notice and change the function\*(Aqs declared return type to
language_handler\&amp;.
.SH "EXAMPLES"
.PP
The preferred way of creating any of the standard procedural languages is just:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE LANGUAGE plperl;
.fi
.if n \{\
.RE
.\}
.PP
For a language not known in the
pg_pltemplate
catalog, a sequence such as this is needed:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION plsample_call_handler() RETURNS language_handler
AS \*(Aq$libdir/plsample\*(Aq
LANGUAGE C;
CREATE LANGUAGE plsample
HANDLER plsample_call_handler;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE LANGUAGE\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER LANGUAGE (\fBALTER_LANGUAGE\fR(7)), CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)), DROP LANGUAGE (\fBDROP_LANGUAGE\fR(7)), \fBGRANT\fR(7), \fBREVOKE\fR(7), \fBcreatelang\fR(1), \fBdroplang\fR(1)
'\" t
.\"     Title: CREATE MATERIALIZED VIEW
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE MATERIALIZED VIEW" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_MATERIALIZED_VIEW \- define a new materialized view
.SH "SYNOPSIS"
.sp
.nf
CREATE MATERIALIZED VIEW [ IF NOT EXISTS ] \fItable_name\fR
[ (\fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ]
[ WITH ( \fIstorage_parameter\fR [= \fIvalue\fR] [, \&amp;.\&amp;.\&amp;. ] ) ]
[ TABLESPACE \fItablespace_name\fR ]
AS \fIquery\fR
[ WITH [ NO ] DATA ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE MATERIALIZED VIEW\fR
defines a materialized view of a query\&amp;. The query is executed and used to populate the view at the time the command is issued (unless
\fBWITH NO DATA\fR
is used) and may be refreshed later using
\fBREFRESH MATERIALIZED VIEW\fR\&amp;.
.PP
\fBCREATE MATERIALIZED VIEW\fR
is similar to
\fBCREATE TABLE AS\fR, except that it also remembers the query used to initialize the view, so that it can be refreshed later upon demand\&amp;. A materialized view has many of the same properties as a table, but there is no support for temporary materialized views or automatic generation of OIDs\&amp;.
.SH "PARAMETERS"
.PP
IF NOT EXISTS
.RS 4
Do not throw an error if a materialized view with the same name already exists\&amp;. A notice is issued in this case\&amp;. Note that there is no guarantee that the existing materialized view is anything like the one that would have been created\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the materialized view to be created\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a column in the new materialized view\&amp;. If column names are not provided, they are taken from the output column names of the query\&amp;.
.RE
.PP
WITH ( \fIstorage_parameter\fR [= \fIvalue\fR] [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This clause specifies optional storage parameters for the new materialized view; see
Storage Parameters
for more information\&amp;. All parameters supported for
CREATE TABLE
are also supported for
CREATE MATERIALIZED VIEW
with the exception of
OIDS\&amp;. See
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for more information\&amp;.
.RE
.PP
TABLESPACE \fItablespace_name\fR
.RS 4
The
\fItablespace_name\fR
is the name of the tablespace in which the new materialized view is to be created\&amp;. If not specified,
default_tablespace
is consulted\&amp;.
.RE
.PP
\fIquery\fR
.RS 4
A
\fBSELECT\fR(7),
TABLE, or
\fBVALUES\fR(7)
command\&amp;. This query will run within a security\-restricted operation; in particular, calls to functions that themselves create temporary tables will fail\&amp;.
.RE
.PP
WITH [ NO ] DATA
.RS 4
This clause specifies whether or not the materialized view should be populated at creation time\&amp;. If not, the materialized view will be flagged as unscannable and cannot be queried until
\fBREFRESH MATERIALIZED VIEW\fR
is used\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
\fBCREATE MATERIALIZED VIEW\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER MATERIALIZED VIEW (\fBALTER_MATERIALIZED_VIEW\fR(7)), CREATE TABLE AS (\fBCREATE_TABLE_AS\fR(7)), CREATE VIEW (\fBCREATE_VIEW\fR(7)), DROP MATERIALIZED VIEW (\fBDROP_MATERIALIZED_VIEW\fR(7)), REFRESH MATERIALIZED VIEW (\fBREFRESH_MATERIALIZED_VIEW\fR(7))
'\" t
.\"     Title: CREATE OPERATOR
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE OPERATOR" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_OPERATOR \- define a new operator
.SH "SYNOPSIS"
.sp
.nf
CREATE OPERATOR \fIname\fR (
PROCEDURE = \fIfunction_name\fR
[, LEFTARG = \fIleft_type\fR ] [, RIGHTARG = \fIright_type\fR ]
[, COMMUTATOR = \fIcom_op\fR ] [, NEGATOR = \fIneg_op\fR ]
[, RESTRICT = \fIres_proc\fR ] [, JOIN = \fIjoin_proc\fR ]
[, HASHES ] [, MERGES ]
)
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE OPERATOR\fR
defines a new operator,
\fIname\fR\&amp;. The user who defines an operator becomes its owner\&amp;. If a schema name is given then the operator is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;.
.PP
The operator name is a sequence of up to
NAMEDATALEN\-1 (63 by default) characters from the following list:
.sp
.if n \{\
.RS 4
.\}
.nf
+ \- * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
.fi
.if n \{\
.RE
.\}
.sp
There are a few restrictions on your choice of name:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\-\-
and
/*
cannot appear anywhere in an operator name, since they will be taken as the start of a comment\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A multicharacter operator name cannot end in
+
or
\-, unless the name also contains at least one of these characters:
.sp
.if n \{\
.RS 4
.\}
.nf
~ ! @ # % ^ &amp; | ` ?
.fi
.if n \{\
.RE
.\}
.sp
For example,
@\-
is an allowed operator name, but
*\-
is not\&amp;. This restriction allows
PostgreSQL
to parse SQL\-compliant commands without requiring spaces between tokens\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The use of
=&gt;
as an operator name is deprecated\&amp;. It may be disallowed altogether in a future release\&amp;.
.RE
.PP
The operator
!=
is mapped to
&lt;&gt;
on input, so these two names are always equivalent\&amp;.
.PP
At least one of
LEFTARG
and
RIGHTARG
must be defined\&amp;. For binary operators, both must be defined\&amp;. For right unary operators, only
LEFTARG
should be defined, while for left unary operators only
RIGHTARG
should be defined\&amp;.
.PP
The
\fIfunction_name\fR
procedure must have been previously defined using
\fBCREATE FUNCTION\fR
and must be defined to accept the correct number of arguments (either one or two) of the indicated types\&amp;.
.PP
The other clauses specify optional operator optimization clauses\&amp;. Their meaning is detailed in
Section 36.13, \(lqOperator Optimization Information\(rq, in the documentation\&amp;.
.PP
To be able to create an operator, you must have
USAGE
privilege on the argument types and the return type, as well as
EXECUTE
privilege on the underlying function\&amp;. If a commutator or negator operator is specified, you must own these operators\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the operator to be defined\&amp;. See above for allowable characters\&amp;. The name can be schema\-qualified, for example
CREATE OPERATOR myschema\&amp;.+ (\&amp;.\&amp;.\&amp;.)\&amp;. If not, then the operator is created in the current schema\&amp;. Two operators in the same schema can have the same name if they operate on different data types\&amp;. This is called
overloading\&amp;.
.RE
.PP
\fIfunction_name\fR
.RS 4
The function used to implement this operator\&amp;.
.RE
.PP
\fIleft_type\fR
.RS 4
The data type of the operator\*(Aqs left operand, if any\&amp;. This option would be omitted for a left\-unary operator\&amp;.
.RE
.PP
\fIright_type\fR
.RS 4
The data type of the operator\*(Aqs right operand, if any\&amp;. This option would be omitted for a right\-unary operator\&amp;.
.RE
.PP
\fIcom_op\fR
.RS 4
The commutator of this operator\&amp;.
.RE
.PP
\fIneg_op\fR
.RS 4
The negator of this operator\&amp;.
.RE
.PP
\fIres_proc\fR
.RS 4
The restriction selectivity estimator function for this operator\&amp;.
.RE
.PP
\fIjoin_proc\fR
.RS 4
The join selectivity estimator function for this operator\&amp;.
.RE
.PP
HASHES
.RS 4
Indicates this operator can support a hash join\&amp;.
.RE
.PP
MERGES
.RS 4
Indicates this operator can support a merge join\&amp;.
.RE
.PP
To give a schema\-qualified operator name in
\fIcom_op\fR
or the other optional arguments, use the
OPERATOR()
syntax, for example:
.sp
.if n \{\
.RS 4
.\}
.nf
COMMUTATOR = OPERATOR(myschema\&amp;.===) ,
.fi
.if n \{\
.RE
.\}
.SH "NOTES"
.PP
Refer to
Section 36.12, \(lqUser-defined Operators\(rq, in the documentation
for further information\&amp;.
.PP
It is not possible to specify an operator\*(Aqs lexical precedence in
\fBCREATE OPERATOR\fR, because the parser\*(Aqs precedence behavior is hard\-wired\&amp;. See
Section 4.1.6, \(lqOperator Precedence\(rq, in the documentation
for precedence details\&amp;.
.PP
The obsolete options
SORT1,
SORT2,
LTCMP, and
GTCMP
were formerly used to specify the names of sort operators associated with a merge\-joinable operator\&amp;. This is no longer necessary, since information about associated operators is found by looking at B\-tree operator families instead\&amp;. If one of these options is given, it is ignored except for implicitly setting
MERGES
true\&amp;.
.PP
Use
DROP OPERATOR (\fBDROP_OPERATOR\fR(7))
to delete user\-defined operators from a database\&amp;. Use
ALTER OPERATOR (\fBALTER_OPERATOR\fR(7))
to modify operators in a database\&amp;.
.SH "EXAMPLES"
.PP
The following command defines a new operator, area\-equality, for the data type
box:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE OPERATOR === (
LEFTARG = box,
RIGHTARG = box,
PROCEDURE = area_equal_procedure,
COMMUTATOR = ===,
NEGATOR = !==,
RESTRICT = area_restriction_procedure,
JOIN = area_join_procedure,
HASHES, MERGES
);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE OPERATOR\fR
is a
PostgreSQL
extension\&amp;. There are no provisions for user\-defined operators in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER OPERATOR (\fBALTER_OPERATOR\fR(7)), CREATE OPERATOR CLASS (\fBCREATE_OPERATOR_CLASS\fR(7)), DROP OPERATOR (\fBDROP_OPERATOR\fR(7))
'\" t
.\"     Title: CREATE OPERATOR CLASS
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE OPERATOR CLASS" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_OPERATOR_CLASS \- define a new operator class
.SH "SYNOPSIS"
.sp
.nf
CREATE OPERATOR CLASS \fIname\fR [ DEFAULT ] FOR TYPE \fIdata_type\fR
USING \fIindex_method\fR [ FAMILY \fIfamily_name\fR ] AS
{  OPERATOR \fIstrategy_number\fR \fIoperator_name\fR [ ( \fIop_type\fR, \fIop_type\fR ) ] [ FOR SEARCH | FOR ORDER BY \fIsort_family_name\fR ]
| FUNCTION \fIsupport_number\fR [ ( \fIop_type\fR [ , \fIop_type\fR ] ) ] \fIfunction_name\fR ( \fIargument_type\fR [, \&amp;.\&amp;.\&amp;.] )
| STORAGE \fIstorage_type\fR
} [, \&amp;.\&amp;.\&amp;. ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE OPERATOR CLASS\fR
creates a new operator class\&amp;. An operator class defines how a particular data type can be used with an index\&amp;. The operator class specifies that certain operators will fill particular roles or
\(lqstrategies\(rq
for this data type and this index method\&amp;. The operator class also specifies the support procedures to be used by the index method when the operator class is selected for an index column\&amp;. All the operators and functions used by an operator class must be defined before the operator class can be created\&amp;.
.PP
If a schema name is given then the operator class is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. Two operator classes in the same schema can have the same name only if they are for different index methods\&amp;.
.PP
The user who defines an operator class becomes its owner\&amp;. Presently, the creating user must be a superuser\&amp;. (This restriction is made because an erroneous operator class definition could confuse or even crash the server\&amp;.)
.PP
\fBCREATE OPERATOR CLASS\fR
does not presently check whether the operator class definition includes all the operators and functions required by the index method, nor whether the operators and functions form a self\-consistent set\&amp;. It is the user\*(Aqs responsibility to define a valid operator class\&amp;.
.PP
Related operator classes can be grouped into
operator families\&amp;. To add a new operator class to an existing family, specify the
FAMILY
option in
\fBCREATE OPERATOR CLASS\fR\&amp;. Without this option, the new class is placed into a family named the same as the new class (creating that family if it doesn\*(Aqt already exist)\&amp;.
.PP
Refer to
Section 36.14, \(lqInterfacing Extensions To Indexes\(rq, in the documentation
for further information\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the operator class to be created\&amp;. The name can be schema\-qualified\&amp;.
.RE
.PP
DEFAULT
.RS 4
If present, the operator class will become the default operator class for its data type\&amp;. At most one operator class can be the default for a specific data type and index method\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
The column data type that this operator class is for\&amp;.
.RE
.PP
\fIindex_method\fR
.RS 4
The name of the index method this operator class is for\&amp;.
.RE
.PP
\fIfamily_name\fR
.RS 4
The name of the existing operator family to add this operator class to\&amp;. If not specified, a family named the same as the operator class is used (creating it, if it doesn\*(Aqt already exist)\&amp;.
.RE
.PP
\fIstrategy_number\fR
.RS 4
The index method\*(Aqs strategy number for an operator associated with the operator class\&amp;.
.RE
.PP
\fIoperator_name\fR
.RS 4
The name (optionally schema\-qualified) of an operator associated with the operator class\&amp;.
.RE
.PP
\fIop_type\fR
.RS 4
In an
OPERATOR
clause, the operand data type(s) of the operator, or
NONE
to signify a left\-unary or right\-unary operator\&amp;. The operand data types can be omitted in the normal case where they are the same as the operator class\*(Aqs data type\&amp;.
.sp
In a
FUNCTION
clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B\-tree comparison functions and hash functions) or the class\*(Aqs data type (for B\-tree sort support functions and all functions in GiST, SP\-GiST, GIN and BRIN operator classes)\&amp;. These defaults are correct, and so
\fIop_type\fR
need not be specified in
FUNCTION
clauses, except for the case of a B\-tree sort support function that is meant to support cross\-data\-type comparisons\&amp;.
.RE
.PP
\fIsort_family_name\fR
.RS 4
The name (optionally schema\-qualified) of an existing
btree
operator family that describes the sort ordering associated with an ordering operator\&amp;.
.sp
If neither
FOR SEARCH
nor
FOR ORDER BY
is specified,
FOR SEARCH
is the default\&amp;.
.RE
.PP
\fIsupport_number\fR
.RS 4
The index method\*(Aqs support procedure number for a function associated with the operator class\&amp;.
.RE
.PP
\fIfunction_name\fR
.RS 4
The name (optionally schema\-qualified) of a function that is an index method support procedure for the operator class\&amp;.
.RE
.PP
\fIargument_type\fR
.RS 4
The parameter data type(s) of the function\&amp;.
.RE
.PP
\fIstorage_type\fR
.RS 4
The data type actually stored in the index\&amp;. Normally this is the same as the column data type, but some index methods (currently GiST, GIN and BRIN) allow it to be different\&amp;. The
STORAGE
clause must be omitted unless the index method allows a different type to be used\&amp;.
.RE
.PP
The
OPERATOR,
FUNCTION, and
STORAGE
clauses can appear in any order\&amp;.
.SH "NOTES"
.PP
Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator class is tantamount to granting public execute permission on it\&amp;. This is usually not an issue for the sorts of functions that are useful in an operator class\&amp;.
.PP
The operators should not be defined by SQL functions\&amp;. A SQL function is likely to be inlined into the calling query, which will prevent the optimizer from recognizing that the query matches an index\&amp;.
.PP
Before
PostgreSQL
8\&amp;.4, the
OPERATOR
clause could include a
RECHECK
option\&amp;. This is no longer supported because whether an index operator is
\(lqlossy\(rq
is now determined on\-the\-fly at run time\&amp;. This allows efficient handling of cases where an operator might or might not be lossy\&amp;.
.SH "EXAMPLES"
.PP
The following example command defines a GiST index operator class for the data type
_int4
(array of
int4)\&amp;. See the
intarray
module for the complete example\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE OPERATOR CLASS gist__int_ops
DEFAULT FOR TYPE _int4 USING gist AS
OPERATOR        3       &amp;&amp;,
OPERATOR        6       = (anyarray, anyarray),
OPERATOR        7       @&gt;,
OPERATOR        8       &lt;@,
OPERATOR        20      @@ (_int4, query_int),
FUNCTION        1       g_int_consistent (internal, _int4, smallint, oid, internal),
FUNCTION        2       g_int_union (internal, internal),
FUNCTION        3       g_int_compress (internal),
FUNCTION        4       g_int_decompress (internal),
FUNCTION        5       g_int_penalty (internal, internal, internal),
FUNCTION        6       g_int_picksplit (internal, internal),
FUNCTION        7       g_int_same (_int4, _int4, internal);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE OPERATOR CLASS\fR
is a
PostgreSQL
extension\&amp;. There is no
\fBCREATE OPERATOR CLASS\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER OPERATOR CLASS (\fBALTER_OPERATOR_CLASS\fR(7)), DROP OPERATOR CLASS (\fBDROP_OPERATOR_CLASS\fR(7)), CREATE OPERATOR FAMILY (\fBCREATE_OPERATOR_FAMILY\fR(7)), ALTER OPERATOR FAMILY (\fBALTER_OPERATOR_FAMILY\fR(7))
'\" t
.\"     Title: CREATE OPERATOR FAMILY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE OPERATOR FAMILY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_OPERATOR_FAMILY \- define a new operator family
.SH "SYNOPSIS"
.sp
.nf
CREATE OPERATOR FAMILY \fIname\fR USING \fIindex_method\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE OPERATOR FAMILY\fR
creates a new operator family\&amp;. An operator family defines a collection of related operator classes, and perhaps some additional operators and support functions that are compatible with these operator classes but not essential for the functioning of any individual index\&amp;. (Operators and functions that are essential to indexes should be grouped within the relevant operator class, rather than being
\(lqloose\(rq
in the operator family\&amp;. Typically, single\-data\-type operators are bound to operator classes, while cross\-data\-type operators can be loose in an operator family containing operator classes for both data types\&amp;.)
.PP
The new operator family is initially empty\&amp;. It should be populated by issuing subsequent
\fBCREATE OPERATOR CLASS\fR
commands to add contained operator classes, and optionally
\fBALTER OPERATOR FAMILY\fR
commands to add
\(lqloose\(rq
operators and their corresponding support functions\&amp;.
.PP
If a schema name is given then the operator family is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. Two operator families in the same schema can have the same name only if they are for different index methods\&amp;.
.PP
The user who defines an operator family becomes its owner\&amp;. Presently, the creating user must be a superuser\&amp;. (This restriction is made because an erroneous operator family definition could confuse or even crash the server\&amp;.)
.PP
Refer to
Section 36.14, \(lqInterfacing Extensions To Indexes\(rq, in the documentation
for further information\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the operator family to be created\&amp;. The name can be schema\-qualified\&amp;.
.RE
.PP
\fIindex_method\fR
.RS 4
The name of the index method this operator family is for\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
\fBCREATE OPERATOR FAMILY\fR
is a
PostgreSQL
extension\&amp;. There is no
\fBCREATE OPERATOR FAMILY\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER OPERATOR FAMILY (\fBALTER_OPERATOR_FAMILY\fR(7)), DROP OPERATOR FAMILY (\fBDROP_OPERATOR_FAMILY\fR(7)), CREATE OPERATOR CLASS (\fBCREATE_OPERATOR_CLASS\fR(7)), ALTER OPERATOR CLASS (\fBALTER_OPERATOR_CLASS\fR(7)), DROP OPERATOR CLASS (\fBDROP_OPERATOR_CLASS\fR(7))
'\" t
.\"     Title: CREATE POLICY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE POLICY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_POLICY \- define a new row level security policy for a table
.SH "SYNOPSIS"
.sp
.nf
CREATE POLICY \fIname\fR ON \fItable_name\fR
[ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
[ TO { \fIrole_name\fR | PUBLIC | CURRENT_USER | SESSION_USER } [, \&amp;.\&amp;.\&amp;.] ]
[ USING ( \fIusing_expression\fR ) ]
[ WITH CHECK ( \fIcheck_expression\fR ) ]
.fi
.SH "DESCRIPTION"
.PP
The
\fBCREATE POLICY\fR
command defines a new row\-level security policy for a table\&amp;. Note that row\-level security must be enabled on the table (using
\fBALTER TABLE \&amp;.\&amp;.\&amp;. ENABLE ROW LEVEL SECURITY\fR) in order for created policies to be applied\&amp;.
.PP
A policy grants the permission to select, insert, update, or delete rows that match the relevant policy expression\&amp;. Existing table rows are checked against the expression specified in
USING, while new rows that would be created via
INSERT
or
UPDATE
are checked against the expression specified in
WITH CHECK\&amp;. When a
USING
expression returns true for a given row then that row is visible to the user, while if false or null is returned then the row is not visible\&amp;. When a
WITH CHECK
expression returns true for a row then that row is inserted or updated, while if false or null is returned then an error occurs\&amp;.
.PP
For
\fBINSERT\fR
and
\fBUPDATE\fR
statements,
WITH CHECK
expressions are enforced after
BEFORE
triggers are fired, and before any actual data modifications are made\&amp;. Thus a
BEFORE ROW
trigger may modify the data to be inserted, affecting the result of the security policy check\&amp;.
WITH CHECK
expressions are enforced before any other constraints\&amp;.
.PP
Policy names are per\-table\&amp;. Therefore, one policy name can be used for many different tables and have a definition for each table which is appropriate to that table\&amp;.
.PP
Policies can be applied for specific commands or for specific roles\&amp;. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified\&amp;. If multiple policies apply to a given statement, they will be combined using OR (although
ON CONFLICT DO UPDATE
and
INSERT
policies are not combined in this way, but rather enforced as noted at each stage of
ON CONFLICT
execution)\&amp;.
.PP
For commands that can have both
USING
and
WITH CHECK
policies (ALL
and
UPDATE), if no
WITH CHECK
policy is defined, then the
USING
policy will be used both for which rows are visible (normal
USING
case) and for which rows will be allowed to be added (WITH CHECK
case)\&amp;.
.PP
If row\-level security is enabled for a table, but no applicable policies exist, a
\(lqdefault deny\(rq
policy is assumed, so that no rows will be visible or updatable\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the policy to be created\&amp;. This must be distinct from the name of any other policy for the table\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table the policy applies to\&amp;.
.RE
.PP
\fIcommand\fR
.RS 4
The command to which the policy applies\&amp;. Valid options are
\fBALL\fR,
\fBSELECT\fR,
\fBINSERT\fR,
\fBUPDATE\fR, and
\fBDELETE\fR\&amp;.
\fBALL\fR
is the default\&amp;. See below for specifics regarding how these are applied\&amp;.
.RE
.PP
\fIrole_name\fR
.RS 4
The role(s) to which the policy is to be applied\&amp;. The default is
PUBLIC, which will apply the policy to all roles\&amp;.
.RE
.PP
\fIusing_expression\fR
.RS 4
Any
SQL
conditional expression (returning
boolean)\&amp;. The conditional expression cannot contain any aggregate or window functions\&amp;. This expression will be added to queries that refer to the table if row level security is enabled\&amp;. Rows for which the expression returns true will be visible\&amp;. Any rows for which the expression returns false or null will not be visible to the user (in a
\fBSELECT\fR), and will not be available for modification (in an
\fBUPDATE\fR
or
\fBDELETE\fR)\&amp;. Such rows are silently suppressed; no error is reported\&amp;.
.RE
.PP
\fIcheck_expression\fR
.RS 4
Any
SQL
conditional expression (returning
boolean)\&amp;. The conditional expression cannot contain any aggregate or window functions\&amp;. This expression will be used in
\fBINSERT\fR
and
\fBUPDATE\fR
queries against the table if row level security is enabled\&amp;. Only rows for which the expression evaluates to true will be allowed\&amp;. An error will be thrown if the expression evaluates to false or null for any of the records inserted or any of the records that result from the update\&amp;. Note that the
\fIcheck_expression\fR
is evaluated against the proposed new contents of the row, not the original contents\&amp;.
.RE
.SS "Per\-Command Policies"
.PP
ALL
.RS 4
Using
ALL
for a policy means that it will apply to all commands, regardless of the type of command\&amp;. If an
ALL
policy exists and more specific policies exist, then both the
ALL
policy and the more specific policy (or policies) will be combined using OR, as usual for overlapping policies\&amp;. Additionally,
ALL
policies will be applied to both the selection side of a query and the modification side, using the
USING
expression for both cases if only a
USING
expression has been defined\&amp;.
.sp
As an example, if an
UPDATE
is issued, then the
ALL
policy will be applicable both to what the
UPDATE
will be able to select as rows to be updated (applying the
USING
expression), and to the resulting updated rows, to check if they are permitted to be added to the table (applying the
WITH CHECK
expression, if defined, and the
USING
expression otherwise)\&amp;. If an
\fBINSERT\fR
or
\fBUPDATE\fR
command attempts to add rows to the table that do not pass the
ALL
policy\*(Aqs
WITH CHECK
expression, the entire command will be aborted\&amp;.
.RE
.PP
SELECT
.RS 4
Using
SELECT
for a policy means that it will apply to
SELECT
queries and whenever
SELECT
permissions are required on the relation the policy is defined for\&amp;. The result is that only those records from the relation that pass the
SELECT
policy will be returned during a
SELECT
query, and that queries that require
SELECT
permissions, such as
UPDATE, will also only see those records that are allowed by the
SELECT
policy\&amp;. A
SELECT
policy cannot have a
WITH CHECK
expression, as it only applies in cases where records are being retrieved from the relation\&amp;.
.RE
.PP
INSERT
.RS 4
Using
INSERT
for a policy means that it will apply to
INSERT
commands\&amp;. Rows being inserted that do not pass this policy will result in a policy violation error, and the entire
INSERT
command will be aborted\&amp;. An
INSERT
policy cannot have a
USING
expression, as it only applies in cases where records are being added to the relation\&amp;.
.sp
Note that
INSERT
with
ON CONFLICT DO UPDATE
checks
INSERT
policies\*(Aq
WITH CHECK
expressions only for rows appended to the relation by the
INSERT
path\&amp;.
.RE
.PP
UPDATE
.RS 4
Using
UPDATE
for a policy means that it will apply to
UPDATE
commands (or auxiliary
ON CONFLICT DO UPDATE
clauses of
INSERT
commands)\&amp;. Since
UPDATE
involves pulling an existing record and then making changes to some portion (but possibly not all) of the record,
UPDATE
policies accept both a
USING
expression and a
WITH CHECK
expression\&amp;. The
USING
expression determines which records the
UPDATE
command will see to operate against, while the
WITH CHECK
expression defines which modified rows are allowed to be stored back into the relation\&amp;.
.sp
When an
UPDATE
command is used with a
WHERE
clause or a
RETURNING
clause,
SELECT
rights are also required on the relation being updated and the appropriate
SELECT
and
ALL
policies will be combined (using OR for any overlapping
SELECT
related policies found) with the
USING
clause of the
UPDATE
policy using AND\&amp;. Therefore, in order for a user to be able to
UPDATE
specific rows, the user must have access to the row(s) through a
SELECT
or
ALL
policy and the row(s) must pass the
UPDATE
policy\*(Aqs
USING
expression\&amp;.
.sp
Any rows whose updated values do not pass the
WITH CHECK
expression will cause an error, and the entire command will be aborted\&amp;. If only a
USING
clause is specified, then that clause will be used for both
USING
and
WITH CHECK
cases\&amp;.
.sp
Note, however, that
INSERT
with
ON CONFLICT DO UPDATE
requires that an
UPDATE
policy
USING
expression always be enforced as a
WITH CHECK
expression\&amp;. This
UPDATE
policy must always pass when the
UPDATE
path is taken\&amp;. Any existing row that necessitates that the
UPDATE
path be taken must pass the (UPDATE
or
ALL)
USING
qualifications (combined using OR), which are always enforced as
WITH CHECK
options in this context\&amp;. (The
UPDATE
path will
\fInever\fR
be silently avoided; an error will be thrown instead\&amp;.) Finally, the final row appended to the relation must pass any
WITH CHECK
options that a conventional
UPDATE
is required to pass\&amp;.
.RE
.PP
DELETE
.RS 4
Using
DELETE
for a policy means that it will apply to
DELETE
commands\&amp;. Only rows that pass this policy will be seen by a
DELETE
command\&amp;. There can be rows that are visible through a
SELECT
that are not available for deletion, if they do not pass the
USING
expression for the
DELETE
policy\&amp;.
.sp
When a
DELETE
command is used with a
WHERE
clause or a
RETURNING
clause,
SELECT
rights are also required on the relation being updated and the appropriate
SELECT
and
ALL
policies will be combined (using OR for any overlapping
SELECT
related policies found) with the
USING
clause of the
DELETE
policy using AND\&amp;. Therefore, in order for a user to be able to
DELETE
specific rows, the user must have access to the row(s) through a
SELECT
or
ALL
policy and the row(s) must pass the
DELETE
policy\*(Aqs
USING
expression\&amp;.
.sp
A
DELETE
policy cannot have a
WITH CHECK
expression, as it only applies in cases where records are being deleted from the relation, so that there is no new row to check\&amp;.
.RE
.SH "NOTES"
.PP
You must be the owner of a table to create or change policies for it\&amp;.
.PP
While policies will be applied for explicit queries against tables in the database, they are not applied when the system is performing internal referential integrity checks or validating constraints\&amp;. This means there are indirect ways to determine that a given value exists\&amp;. An example of this is attempting to insert a duplicate value into a column that is a primary key or has a unique constraint\&amp;. If the insert fails then the user can infer that the value already exists\&amp;. (This example assumes that the user is permitted by policy to insert records which they are not allowed to see\&amp;.) Another example is where a user is allowed to insert into a table which references another, otherwise hidden table\&amp;. Existence can be determined by the user inserting values into the referencing table, where success would indicate that the value exists in the referenced table\&amp;. These issues can be addressed by carefully crafting policies to prevent users from being able to insert, delete, or update records at all which might possibly indicate a value they are not otherwise able to see, or by using generated values (e\&amp;.g\&amp;., surrogate keys) instead of keys with external meanings\&amp;.
.PP
Generally, the system will enforce filter conditions imposed using security policies prior to qualifications that appear in user queries, in order to prevent inadvertent exposure of the protected data to user\-defined functions which might not be trustworthy\&amp;. However, functions and operators marked by the system (or the system administrator) as
LEAKPROOF
may be evaluated before policy expressions, as they are assumed to be trustworthy\&amp;.
.PP
Since policy expressions are added to the user\*(Aqs query directly, they will be run with the rights of the user running the overall query\&amp;. Therefore, users who are using a given policy must be able to access any tables or functions referenced in the expression or they will simply receive a permission denied error when attempting to query the table that has row\-level security enabled\&amp;. This does not change how views work, however\&amp;. As with normal queries and views, permission checks and policies for the tables which are referenced by a view will use the view owner\*(Aqs rights and any policies which apply to the view owner\&amp;.
.PP
Additional discussion and practical examples can be found in
Section 5.7, \(lqRow Security Policies\(rq, in the documentation\&amp;.
.SH "COMPATIBILITY"
.PP
\fBCREATE POLICY\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER POLICY (\fBALTER_POLICY\fR(7)), DROP POLICY (\fBDROP_POLICY\fR(7)), ALTER TABLE (\fBALTER_TABLE\fR(7))
'\" t
.\"     Title: CREATE ROLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE ROLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_ROLE \- define a new database role
.SH "SYNOPSIS"
.sp
.nf
CREATE ROLE \fIname\fR [ [ WITH ] \fIoption\fR [ \&amp;.\&amp;.\&amp;. ] ]

where \fIoption\fR can be:

SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| REPLICATION | NOREPLICATION
| BYPASSRLS | NOBYPASSRLS
| CONNECTION LIMIT \fIconnlimit\fR
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD \*(Aq\fIpassword\fR\*(Aq
| VALID UNTIL \*(Aq\fItimestamp\fR\*(Aq
| IN ROLE \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| IN GROUP \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| ROLE \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| ADMIN \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| USER \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| SYSID \fIuid\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE ROLE\fR
adds a new role to a
PostgreSQL
database cluster\&amp;. A role is an entity that can own database objects and have database privileges; a role can be considered a
\(lquser\(rq, a
\(lqgroup\(rq, or both depending on how it is used\&amp;. Refer to
Chapter 21, Database Roles, in the documentation
and
Chapter 20, Client Authentication, in the documentation
for information about managing users and authentication\&amp;. You must have
CREATEROLE
privilege or be a database superuser to use this command\&amp;.
.PP
Note that roles are defined at the database cluster level, and so are valid in all databases in the cluster\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the new role\&amp;.
.RE
.PP
SUPERUSER
.br
NOSUPERUSER
.RS 4
These clauses determine whether the new role is a
\(lqsuperuser\(rq, who can override all access restrictions within the database\&amp;. Superuser status is dangerous and should be used only when really needed\&amp;. You must yourself be a superuser to create a new superuser\&amp;. If not specified,
NOSUPERUSER
is the default\&amp;.
.RE
.PP
CREATEDB
.br
NOCREATEDB
.RS 4
These clauses define a role\*(Aqs ability to create databases\&amp;. If
CREATEDB
is specified, the role being defined will be allowed to create new databases\&amp;. Specifying
NOCREATEDB
will deny a role the ability to create databases\&amp;. If not specified,
NOCREATEDB
is the default\&amp;.
.RE
.PP
CREATEROLE
.br
NOCREATEROLE
.RS 4
These clauses determine whether a role will be permitted to create new roles (that is, execute
\fBCREATE ROLE\fR)\&amp;. A role with
CREATEROLE
privilege can also alter and drop other roles\&amp;. If not specified,
NOCREATEROLE
is the default\&amp;.
.RE
.PP
INHERIT
.br
NOINHERIT
.RS 4
These clauses determine whether a role
\(lqinherits\(rq
the privileges of roles it is a member of\&amp;. A role with the
INHERIT
attribute can automatically use whatever database privileges have been granted to all roles it is directly or indirectly a member of\&amp;. Without
INHERIT, membership in another role only grants the ability to
\fBSET ROLE\fR
to that other role; the privileges of the other role are only available after having done so\&amp;. If not specified,
INHERIT
is the default\&amp;.
.RE
.PP
LOGIN
.br
NOLOGIN
.RS 4
These clauses determine whether a role is allowed to log in; that is, whether the role can be given as the initial session authorization name during client connection\&amp;. A role having the
LOGIN
attribute can be thought of as a user\&amp;. Roles without this attribute are useful for managing database privileges, but are not users in the usual sense of the word\&amp;. If not specified,
NOLOGIN
is the default, except when
\fBCREATE ROLE\fR
is invoked through its alternative spelling
CREATE USER (\fBCREATE_USER\fR(7))\&amp;.
.RE
.PP
REPLICATION
.br
NOREPLICATION
.RS 4
These clauses determine whether a role is allowed to initiate streaming replication or put the system in and out of backup mode\&amp;. A role having the
REPLICATION
attribute is a very highly privileged role, and should only be used on roles actually used for replication\&amp;. If not specified,
NOREPLICATION
is the default\&amp;.
.RE
.PP
BYPASSRLS
.br
NOBYPASSRLS
.RS 4
These clauses determine whether a role bypasses every row\-level security (RLS) policy\&amp;.
NOBYPASSRLS
is the default\&amp;. Note that pg_dump will set
row_security
to
OFF
by default, to ensure all contents of a table are dumped out\&amp;. If the user running pg_dump does not have appropriate permissions, an error will be returned\&amp;. The superuser and owner of the table being dumped always bypass RLS\&amp;.
.RE
.PP
CONNECTION LIMIT \fIconnlimit\fR
.RS 4
If role can log in, this specifies how many concurrent connections the role can make\&amp;. \-1 (the default) means no limit\&amp;.
.RE
.PP
PASSWORD \fIpassword\fR
.RS 4
Sets the role\*(Aqs password\&amp;. (A password is only of use for roles having the
LOGIN
attribute, but you can nonetheless define one for roles without it\&amp;.) If you do not plan to use password authentication you can omit this option\&amp;. If no password is specified, the password will be set to null and password authentication will always fail for that user\&amp;. A null password can optionally be written explicitly as
PASSWORD NULL\&amp;.
.RE
.PP
ENCRYPTED
.br
UNENCRYPTED
.RS 4
These key words control whether the password is stored encrypted in the system catalogs\&amp;. (If neither is specified, the default behavior is determined by the configuration parameter
password_encryption\&amp;.) If the presented password string is already in MD5\-encrypted format, then it is stored encrypted as\-is, regardless of whether
ENCRYPTED
or
UNENCRYPTED
is specified (since the system cannot decrypt the specified encrypted password string)\&amp;. This allows reloading of encrypted passwords during dump/restore\&amp;.
.sp
Note that older clients might lack support for the MD5 authentication mechanism that is needed to work with passwords that are stored encrypted\&amp;.
.RE
.PP
VALID UNTIL \*(Aq\fItimestamp\fR\*(Aq
.RS 4
The
VALID UNTIL
clause sets a date and time after which the role\*(Aqs password is no longer valid\&amp;. If this clause is omitted the password will be valid for all time\&amp;.
.RE
.PP
IN ROLE \fIrole_name\fR
.RS 4
The
IN ROLE
clause lists one or more existing roles to which the new role will be immediately added as a new member\&amp;. (Note that there is no option to add the new role as an administrator; use a separate
\fBGRANT\fR
command to do that\&amp;.)
.RE
.PP
IN GROUP \fIrole_name\fR
.RS 4
IN GROUP
is an obsolete spelling of
IN ROLE\&amp;.
.RE
.PP
ROLE \fIrole_name\fR
.RS 4
The
ROLE
clause lists one or more existing roles which are automatically added as members of the new role\&amp;. (This in effect makes the new role a
\(lqgroup\(rq\&amp;.)
.RE
.PP
ADMIN \fIrole_name\fR
.RS 4
The
ADMIN
clause is like
ROLE, but the named roles are added to the new role
WITH ADMIN OPTION, giving them the right to grant membership in this role to others\&amp;.
.RE
.PP
USER \fIrole_name\fR
.RS 4
The
USER
clause is an obsolete spelling of the
ROLE
clause\&amp;.
.RE
.PP
SYSID \fIuid\fR
.RS 4
The
SYSID
clause is ignored, but is accepted for backwards compatibility\&amp;.
.RE
.SH "NOTES"
.PP
Use
ALTER ROLE (\fBALTER_ROLE\fR(7))
to change the attributes of a role, and
DROP ROLE (\fBDROP_ROLE\fR(7))
to remove a role\&amp;. All the attributes specified by
\fBCREATE ROLE\fR
can be modified by later
\fBALTER ROLE\fR
commands\&amp;.
.PP
The preferred way to add and remove members of roles that are being used as groups is to use
\fBGRANT\fR(7)
and
\fBREVOKE\fR(7)\&amp;.
.PP
The
VALID UNTIL
clause defines an expiration time for a password only, not for the role
per se\&amp;. In particular, the expiration time is not enforced when logging in using a non\-password\-based authentication method\&amp;.
.PP
The
INHERIT
attribute governs inheritance of grantable privileges (that is, access privileges for database objects and role memberships)\&amp;. It does not apply to the special role attributes set by
\fBCREATE ROLE\fR
and
\fBALTER ROLE\fR\&amp;. For example, being a member of a role with
CREATEDB
privilege does not immediately grant the ability to create databases, even if
INHERIT
is set; it would be necessary to become that role via
SET ROLE (\fBSET_ROLE\fR(7))
before creating a database\&amp;.
.PP
The
INHERIT
attribute is the default for reasons of backwards compatibility: in prior releases of
PostgreSQL, users always had access to all privileges of groups they were members of\&amp;. However,
NOINHERIT
provides a closer match to the semantics specified in the SQL standard\&amp;.
.PP
Be careful with the
CREATEROLE
privilege\&amp;. There is no concept of inheritance for the privileges of a
CREATEROLE\-role\&amp;. That means that even if a role does not have a certain privilege but is allowed to create other roles, it can easily create another role with different privileges than its own (except for creating roles with superuser privileges)\&amp;. For example, if the role
\(lquser\(rq
has the
CREATEROLE
privilege but not the
CREATEDB
privilege, nonetheless it can create a new role with the
CREATEDB
privilege\&amp;. Therefore, regard roles that have the
CREATEROLE
privilege as almost\-superuser\-roles\&amp;.
.PP
PostgreSQL
includes a program
\fBcreateuser\fR(1)
that has the same functionality as
\fBCREATE ROLE\fR
(in fact, it calls this command) but can be run from the command shell\&amp;.
.PP
The
CONNECTION LIMIT
option is only enforced approximately; if two new sessions start at about the same time when just one connection
\(lqslot\(rq
remains for the role, it is possible that both will fail\&amp;. Also, the limit is never enforced for superusers\&amp;.
.PP
Caution must be exercised when specifying an unencrypted password with this command\&amp;. The password will be transmitted to the server in cleartext, and it might also be logged in the client\*(Aqs command history or the server log\&amp;. The command
\fBcreateuser\fR(1), however, transmits the password encrypted\&amp;. Also,
\fBpsql\fR(1)
contains a command
\fB\epassword\fR
that can be used to safely change the password later\&amp;.
.SH "EXAMPLES"
.PP
Create a role that can log in, but don\*(Aqt give it a password:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE ROLE jonathan LOGIN;
.fi
.if n \{\
.RE
.\}
.PP
Create a role with a password:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE USER davide WITH PASSWORD \*(Aqjw8s0F4\*(Aq;
.fi
.if n \{\
.RE
.\}
.sp
(\fBCREATE USER\fR
is the same as
\fBCREATE ROLE\fR
except that it implies
LOGIN\&amp;.)
.PP
Create a role with a password that is valid until the end of 2004\&amp;. After one second has ticked in 2005, the password is no longer valid\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE ROLE miriam WITH LOGIN PASSWORD \*(Aqjw8s0F4\*(Aq VALID UNTIL \*(Aq2005\-01\-01\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Create a role that can create databases and manage roles:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE ROLE admin WITH CREATEDB CREATEROLE;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBCREATE ROLE\fR
statement is in the SQL standard, but the standard only requires the syntax
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE ROLE \fIname\fR [ WITH ADMIN \fIrole_name\fR ]
.fi
.if n \{\
.RE
.\}
.sp
Multiple initial administrators, and all the other options of
\fBCREATE ROLE\fR, are
PostgreSQL
extensions\&amp;.
.PP
The SQL standard defines the concepts of users and roles, but it regards them as distinct concepts and leaves all commands defining users to be specified by each database implementation\&amp;. In
PostgreSQL
we have chosen to unify users and roles into a single kind of entity\&amp;. Roles therefore have many more optional attributes than they do in the standard\&amp;.
.PP
The behavior specified by the SQL standard is most closely approximated by giving users the
NOINHERIT
attribute, while roles are given the
INHERIT
attribute\&amp;.
.SH "SEE ALSO"
SET ROLE (\fBSET_ROLE\fR(7)), ALTER ROLE (\fBALTER_ROLE\fR(7)), DROP ROLE (\fBDROP_ROLE\fR(7)), \fBGRANT\fR(7), \fBREVOKE\fR(7), \fBcreateuser\fR(1)
'\" t
.\"     Title: CREATE RULE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE RULE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_RULE \- define a new rewrite rule
.SH "SYNOPSIS"
.sp
.nf
CREATE [ OR REPLACE ] RULE \fIname\fR AS ON \fIevent\fR
TO \fItable_name\fR [ WHERE \fIcondition\fR ]
DO [ ALSO | INSTEAD ] { NOTHING | \fIcommand\fR | ( \fIcommand\fR ; \fIcommand\fR \&amp;.\&amp;.\&amp;. ) }

where \fIevent\fR can be one of:

SELECT | INSERT | UPDATE | DELETE
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE RULE\fR
defines a new rule applying to a specified table or view\&amp;.
\fBCREATE OR REPLACE RULE\fR
will either create a new rule, or replace an existing rule of the same name for the same table\&amp;.
.PP
The
PostgreSQL
rule system allows one to define an alternative action to be performed on insertions, updates, or deletions in database tables\&amp;. Roughly speaking, a rule causes additional commands to be executed when a given command on a given table is executed\&amp;. Alternatively, an
INSTEAD
rule can replace a given command by another, or cause a command not to be executed at all\&amp;. Rules are used to implement SQL views as well\&amp;. It is important to realize that a rule is really a command transformation mechanism, or command macro\&amp;. The transformation happens before the execution of the command starts\&amp;. If you actually want an operation that fires independently for each physical row, you probably want to use a trigger, not a rule\&amp;. More information about the rules system is in
Chapter 39, The Rule System, in the documentation\&amp;.
.PP
Presently,
ON SELECT
rules must be unconditional
INSTEAD
rules and must have actions that consist of a single
\fBSELECT\fR
command\&amp;. Thus, an
ON SELECT
rule effectively turns the table into a view, whose visible contents are the rows returned by the rule\*(Aqs
\fBSELECT\fR
command rather than whatever had been stored in the table (if anything)\&amp;. It is considered better style to write a
\fBCREATE VIEW\fR
command than to create a real table and define an
ON SELECT
rule for it\&amp;.
.PP
You can create the illusion of an updatable view by defining
ON INSERT,
ON UPDATE, and
ON DELETE
rules (or any subset of those that\*(Aqs sufficient for your purposes) to replace update actions on the view with appropriate updates on other tables\&amp;. If you want to support
\fBINSERT RETURNING\fR
and so on, then be sure to put a suitable
RETURNING
clause into each of these rules\&amp;.
.PP
There is a catch if you try to use conditional rules for complex view updates: there
\fImust\fR
be an unconditional
INSTEAD
rule for each action you wish to allow on the view\&amp;. If the rule is conditional, or is not
INSTEAD, then the system will still reject attempts to perform the update action, because it thinks it might end up trying to perform the action on the dummy table of the view in some cases\&amp;. If you want to handle all the useful cases in conditional rules, add an unconditional
DO INSTEAD NOTHING
rule to ensure that the system understands it will never be called on to update the dummy table\&amp;. Then make the conditional rules non\-INSTEAD; in the cases where they are applied, they add to the default
INSTEAD NOTHING
action\&amp;. (This method does not currently work to support
RETURNING
queries, however\&amp;.)
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
A view that is simple enough to be automatically updatable (see
CREATE VIEW (\fBCREATE_VIEW\fR(7))) does not require a user\-created rule in order to be updatable\&amp;. While you can create an explicit rule anyway, the automatic update transformation will generally outperform an explicit rule\&amp;.
.PP
Another alternative worth considering is to use
INSTEAD OF
triggers (see
CREATE TRIGGER (\fBCREATE_TRIGGER\fR(7))) in place of rules\&amp;.
.sp .5v
.RE
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of a rule to create\&amp;. This must be distinct from the name of any other rule for the same table\&amp;. Multiple rules on the same table and same event type are applied in alphabetical name order\&amp;.
.RE
.PP
\fIevent\fR
.RS 4
The event is one of
SELECT,
INSERT,
UPDATE, or
DELETE\&amp;. Note that an
\fBINSERT\fR
containing an
ON CONFLICT
clause cannot be used on tables that have either
INSERT
or
UPDATE
rules\&amp;. Consider using an updatable view instead\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table or view the rule applies to\&amp;.
.RE
.PP
\fIcondition\fR
.RS 4
Any
SQL
conditional expression (returning
boolean)\&amp;. The condition expression cannot refer to any tables except
NEW
and
OLD, and cannot contain aggregate functions\&amp;.
.RE
.PP
\fBINSTEAD\fR
.RS 4
INSTEAD
indicates that the commands should be executed
\fIinstead of\fR
the original command\&amp;.
.RE
.PP
\fBALSO\fR
.RS 4
ALSO
indicates that the commands should be executed
\fIin addition to\fR
the original command\&amp;.
.sp
If neither
ALSO
nor
INSTEAD
is specified,
ALSO
is the default\&amp;.
.RE
.PP
\fIcommand\fR
.RS 4
The command or commands that make up the rule action\&amp;. Valid commands are
\fBSELECT\fR,
\fBINSERT\fR,
\fBUPDATE\fR,
\fBDELETE\fR, or
\fBNOTIFY\fR\&amp;.
.RE
.PP
Within
\fIcondition\fR
and
\fIcommand\fR, the special table names
NEW
and
OLD
can be used to refer to values in the referenced table\&amp;.
NEW
is valid in
ON INSERT
and
ON UPDATE
rules to refer to the new row being inserted or updated\&amp;.
OLD
is valid in
ON UPDATE
and
ON DELETE
rules to refer to the existing row being updated or deleted\&amp;.
.SH "NOTES"
.PP
You must be the owner of a table to create or change rules for it\&amp;.
.PP
In a rule for
INSERT,
UPDATE, or
DELETE
on a view, you can add a
RETURNING
clause that emits the view\*(Aqs columns\&amp;. This clause will be used to compute the outputs if the rule is triggered by an
\fBINSERT RETURNING\fR,
\fBUPDATE RETURNING\fR, or
\fBDELETE RETURNING\fR
command respectively\&amp;. When the rule is triggered by a command without
RETURNING, the rule\*(Aqs
RETURNING
clause will be ignored\&amp;. The current implementation allows only unconditional
INSTEAD
rules to contain
RETURNING; furthermore there can be at most one
RETURNING
clause among all the rules for the same event\&amp;. (This ensures that there is only one candidate
RETURNING
clause to be used to compute the results\&amp;.)
RETURNING
queries on the view will be rejected if there is no
RETURNING
clause in any available rule\&amp;.
.PP
It is very important to take care to avoid circular rules\&amp;. For example, though each of the following two rule definitions are accepted by
PostgreSQL, the
\fBSELECT\fR
command would cause
PostgreSQL
to report an error because of recursive expansion of a rule:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE RULE "_RETURN" AS
ON SELECT TO t1
DO INSTEAD
SELECT * FROM t2;

CREATE RULE "_RETURN" AS
ON SELECT TO t2
DO INSTEAD
SELECT * FROM t1;

SELECT * FROM t1;
.fi
.if n \{\
.RE
.\}
.PP
Presently, if a rule action contains a
\fBNOTIFY\fR
command, the
\fBNOTIFY\fR
command will be executed unconditionally, that is, the
\fBNOTIFY\fR
will be issued even if there are not any rows that the rule should apply to\&amp;. For example, in:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE RULE notify_me AS ON UPDATE TO mytable DO ALSO NOTIFY mytable;

UPDATE mytable SET name = \*(Aqfoo\*(Aq WHERE id = 42;
.fi
.if n \{\
.RE
.\}
.sp
one
\fBNOTIFY\fR
event will be sent during the
\fBUPDATE\fR, whether or not there are any rows that match the condition
id = 42\&amp;. This is an implementation restriction that might be fixed in future releases\&amp;.
.SH "COMPATIBILITY"
.PP
\fBCREATE RULE\fR
is a
PostgreSQL
language extension, as is the entire query rewrite system\&amp;.
.SH "SEE ALSO"
ALTER RULE (\fBALTER_RULE\fR(7)), DROP RULE (\fBDROP_RULE\fR(7))
'\" t
.\"     Title: CREATE SCHEMA
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE SCHEMA" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_SCHEMA \- define a new schema
.SH "SYNOPSIS"
.sp
.nf
CREATE SCHEMA \fIschema_name\fR [ AUTHORIZATION \fIrole_specification\fR ] [ \fIschema_element\fR [ \&amp;.\&amp;.\&amp;. ] ]
CREATE SCHEMA AUTHORIZATION \fIrole_specification\fR [ \fIschema_element\fR [ \&amp;.\&amp;.\&amp;. ] ]
CREATE SCHEMA IF NOT EXISTS \fIschema_name\fR [ AUTHORIZATION \fIrole_specification\fR ]
CREATE SCHEMA IF NOT EXISTS AUTHORIZATION \fIrole_specification\fR

where \fIrole_specification\fR can be:

[ GROUP ] \fIuser_name\fR
| CURRENT_USER
| SESSION_USER
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE SCHEMA\fR
enters a new schema into the current database\&amp;. The schema name must be distinct from the name of any existing schema in the current database\&amp;.
.PP
A schema is essentially a namespace: it contains named objects (tables, data types, functions, and operators) whose names can duplicate those of other objects existing in other schemas\&amp;. Named objects are accessed either by
\(lqqualifying\(rq
their names with the schema name as a prefix, or by setting a search path that includes the desired schema(s)\&amp;. A
CREATE
command specifying an unqualified object name creates the object in the current schema (the one at the front of the search path, which can be determined with the function
\fBcurrent_schema\fR)\&amp;.
.PP
Optionally,
\fBCREATE SCHEMA\fR
can include subcommands to create objects within the new schema\&amp;. The subcommands are treated essentially the same as separate commands issued after creating the schema, except that if the
AUTHORIZATION
clause is used, all the created objects will be owned by that user\&amp;.
.SH "PARAMETERS"
.PP
\fIschema_name\fR
.RS 4
The name of a schema to be created\&amp;. If this is omitted, the
\fIuser_name\fR
is used as the schema name\&amp;. The name cannot begin with
pg_, as such names are reserved for system schemas\&amp;.
.RE
.PP
\fIuser_name\fR
.RS 4
The role name of the user who will own the new schema\&amp;. If omitted, defaults to the user executing the command\&amp;. To create a schema owned by another role, you must be a direct or indirect member of that role, or be a superuser\&amp;.
.RE
.PP
\fIschema_element\fR
.RS 4
An SQL statement defining an object to be created within the schema\&amp;. Currently, only
\fBCREATE TABLE\fR,
\fBCREATE VIEW\fR,
\fBCREATE INDEX\fR,
\fBCREATE SEQUENCE\fR,
\fBCREATE TRIGGER\fR
and
\fBGRANT\fR
are accepted as clauses within
\fBCREATE SCHEMA\fR\&amp;. Other kinds of objects may be created in separate commands after the schema is created\&amp;.
.RE
.PP
IF NOT EXISTS
.RS 4
Do nothing (except issuing a notice) if a schema with the same name already exists\&amp;.
\fIschema_element\fR
subcommands cannot be included when this option is used\&amp;.
.RE
.SH "NOTES"
.PP
To create a schema, the invoking user must have the
CREATE
privilege for the current database\&amp;. (Of course, superusers bypass this check\&amp;.)
.SH "EXAMPLES"
.PP
Create a schema:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE SCHEMA myschema;
.fi
.if n \{\
.RE
.\}
.PP
Create a schema for user
joe; the schema will also be named
joe:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE SCHEMA AUTHORIZATION joe;
.fi
.if n \{\
.RE
.\}
.PP
Create a schema named
test
that will be owned by user
joe, unless there already is a schema named
test\&amp;. (It does not matter whether
joe
owns the pre\-existing schema\&amp;.)
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE SCHEMA IF NOT EXISTS test AUTHORIZATION joe;
.fi
.if n \{\
.RE
.\}
.PP
Create a schema and create a table and view within it:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE SCHEMA hollywood
CREATE TABLE films (title text, release date, awards text[])
CREATE VIEW winners AS
SELECT title, release FROM films WHERE awards IS NOT NULL;
.fi
.if n \{\
.RE
.\}
.sp
Notice that the individual subcommands do not end with semicolons\&amp;.
.PP
The following is an equivalent way of accomplishing the same result:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE SCHEMA hollywood;
CREATE TABLE hollywood\&amp;.films (title text, release date, awards text[]);
CREATE VIEW hollywood\&amp;.winners AS
SELECT title, release FROM hollywood\&amp;.films WHERE awards IS NOT NULL;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The SQL standard allows a
DEFAULT CHARACTER SET
clause in
\fBCREATE SCHEMA\fR, as well as more subcommand types than are presently accepted by
PostgreSQL\&amp;.
.PP
The SQL standard specifies that the subcommands in
\fBCREATE SCHEMA\fR
can appear in any order\&amp;. The present
PostgreSQL
implementation does not handle all cases of forward references in subcommands; it might sometimes be necessary to reorder the subcommands in order to avoid forward references\&amp;.
.PP
According to the SQL standard, the owner of a schema always owns all objects within it\&amp;.
PostgreSQL
allows schemas to contain objects owned by users other than the schema owner\&amp;. This can happen only if the schema owner grants the
CREATE
privilege on their schema to someone else, or a superuser chooses to create objects in it\&amp;.
.PP
The
IF NOT EXISTS
option is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER SCHEMA (\fBALTER_SCHEMA\fR(7)), DROP SCHEMA (\fBDROP_SCHEMA\fR(7))
'\" t
.\"     Title: CREATE SEQUENCE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE SEQUENCE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_SEQUENCE \- define a new sequence generator
.SH "SYNOPSIS"
.sp
.nf
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] \fIname\fR [ INCREMENT [ BY ] \fIincrement\fR ]
[ MINVALUE \fIminvalue\fR | NO MINVALUE ] [ MAXVALUE \fImaxvalue\fR | NO MAXVALUE ]
[ START [ WITH ] \fIstart\fR ] [ CACHE \fIcache\fR ] [ [ NO ] CYCLE ]
[ OWNED BY { \fItable_name\fR\&amp;.\fIcolumn_name\fR | NONE } ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE SEQUENCE\fR
creates a new sequence number generator\&amp;. This involves creating and initializing a new special single\-row table with the name
\fIname\fR\&amp;. The generator will be owned by the user issuing the command\&amp;.
.PP
If a schema name is given then the sequence is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. Temporary sequences exist in a special schema, so a schema name cannot be given when creating a temporary sequence\&amp;. The sequence name must be distinct from the name of any other sequence, table, index, view, or foreign table in the same schema\&amp;.
.PP
After a sequence is created, you use the functions
\fBnextval\fR,
\fBcurrval\fR, and
\fBsetval\fR
to operate on the sequence\&amp;. These functions are documented in
Section 9.16, \(lqSequence Manipulation Functions\(rq, in the documentation\&amp;.
.PP
Although you cannot update a sequence directly, you can use a query like:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT * FROM \fIname\fR;
.fi
.if n \{\
.RE
.\}
.sp
to examine the parameters and current state of a sequence\&amp;. In particular, the
last_value
field of the sequence shows the last value allocated by any session\&amp;. (Of course, this value might be obsolete by the time it\*(Aqs printed, if other sessions are actively doing
\fBnextval\fR
calls\&amp;.)
.SH "PARAMETERS"
.PP
TEMPORARY or TEMP
.RS 4
If specified, the sequence object is created only for this session, and is automatically dropped on session exit\&amp;. Existing permanent sequences with the same name are not visible (in this session) while the temporary sequence exists, unless they are referenced with schema\-qualified names\&amp;.
.RE
.PP
IF NOT EXISTS
.RS 4
Do not throw an error if a relation with the same name already exists\&amp;. A notice is issued in this case\&amp;. Note that there is no guarantee that the existing relation is anything like the sequence that would have been created \- it might not even be a sequence\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the sequence to be created\&amp;.
.RE
.PP
\fIincrement\fR
.RS 4
The optional clause
INCREMENT BY \fIincrement\fR
specifies which value is added to the current sequence value to create a new value\&amp;. A positive value will make an ascending sequence, a negative one a descending sequence\&amp;. The default value is 1\&amp;.
.RE
.PP
\fIminvalue\fR
.br
NO MINVALUE
.RS 4
The optional clause
MINVALUE \fIminvalue\fR
determines the minimum value a sequence can generate\&amp;. If this clause is not supplied or
\fBNO MINVALUE\fR
is specified, then defaults will be used\&amp;. The defaults are 1 and \-2^63\-1 for ascending and descending sequences, respectively\&amp;.
.RE
.PP
\fImaxvalue\fR
.br
NO MAXVALUE
.RS 4
The optional clause
MAXVALUE \fImaxvalue\fR
determines the maximum value for the sequence\&amp;. If this clause is not supplied or
\fBNO MAXVALUE\fR
is specified, then default values will be used\&amp;. The defaults are 2^63\-1 and \-1 for ascending and descending sequences, respectively\&amp;.
.RE
.PP
\fIstart\fR
.RS 4
The optional clause
START WITH \fIstart\fR
allows the sequence to begin anywhere\&amp;. The default starting value is
\fIminvalue\fR
for ascending sequences and
\fImaxvalue\fR
for descending ones\&amp;.
.RE
.PP
\fIcache\fR
.RS 4
The optional clause
CACHE \fIcache\fR
specifies how many sequence numbers are to be preallocated and stored in memory for faster access\&amp;. The minimum value is 1 (only one value can be generated at a time, i\&amp;.e\&amp;., no cache), and this is also the default\&amp;.
.RE
.PP
CYCLE
.br
NO CYCLE
.RS 4
The
CYCLE
option allows the sequence to wrap around when the
\fImaxvalue\fR
or
\fIminvalue\fR
has been reached by an ascending or descending sequence respectively\&amp;. If the limit is reached, the next number generated will be the
\fIminvalue\fR
or
\fImaxvalue\fR, respectively\&amp;.
.sp
If
NO CYCLE
is specified, any calls to
\fBnextval\fR
after the sequence has reached its maximum value will return an error\&amp;. If neither
CYCLE
or
NO CYCLE
are specified,
NO CYCLE
is the default\&amp;.
.RE
.PP
OWNED BY \fItable_name\fR\&amp;.\fIcolumn_name\fR
.br
OWNED BY NONE
.RS 4
The
OWNED BY
option causes the sequence to be associated with a specific table column, such that if that column (or its whole table) is dropped, the sequence will be automatically dropped as well\&amp;. The specified table must have the same owner and be in the same schema as the sequence\&amp;.
OWNED BY NONE, the default, specifies that there is no such association\&amp;.
.RE
.SH "NOTES"
.PP
Use
\fBDROP SEQUENCE\fR
to remove a sequence\&amp;.
.PP
Sequences are based on
bigint
arithmetic, so the range cannot exceed the range of an eight\-byte integer (\-9223372036854775808 to 9223372036854775807)\&amp;.
.PP
Because
\fBnextval\fR
and
\fBsetval\fR
calls are never rolled back, sequence objects cannot be used if
\(lqgapless\(rq
assignment of sequence numbers is needed\&amp;. It is possible to build gapless assignment by using exclusive locking of a table containing a counter; but this solution is much more expensive than sequence objects, especially if many transactions need sequence numbers concurrently\&amp;.
.PP
Unexpected results might be obtained if a
\fIcache\fR
setting greater than one is used for a sequence object that will be used concurrently by multiple sessions\&amp;. Each session will allocate and cache successive sequence values during one access to the sequence object and increase the sequence object\*(Aqs
last_value
accordingly\&amp;. Then, the next
\fIcache\fR\-1 uses of
\fBnextval\fR
within that session simply return the preallocated values without touching the sequence object\&amp;. So, any numbers allocated but not used within a session will be lost when that session ends, resulting in
\(lqholes\(rq
in the sequence\&amp;.
.PP
Furthermore, although multiple sessions are guaranteed to allocate distinct sequence values, the values might be generated out of sequence when all the sessions are considered\&amp;. For example, with a
\fIcache\fR
setting of 10, session A might reserve values 1\&amp;.\&amp;.10 and return
\fBnextval\fR=1, then session B might reserve values 11\&amp;.\&amp;.20 and return
\fBnextval\fR=11 before session A has generated
nextval=2\&amp;. Thus, with a
\fIcache\fR
setting of one it is safe to assume that
\fBnextval\fR
values are generated sequentially; with a
\fIcache\fR
setting greater than one you should only assume that the
\fBnextval\fR
values are all distinct, not that they are generated purely sequentially\&amp;. Also,
last_value
will reflect the latest value reserved by any session, whether or not it has yet been returned by
\fBnextval\fR\&amp;.
.PP
Another consideration is that a
\fBsetval\fR
executed on such a sequence will not be noticed by other sessions until they have used up any preallocated values they have cached\&amp;.
.SH "EXAMPLES"
.PP
Create an ascending sequence called
serial, starting at 101:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE SEQUENCE serial START 101;
.fi
.if n \{\
.RE
.\}
.PP
Select the next number from this sequence:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT nextval(\*(Aqserial\*(Aq);

nextval
\-\-\-\-\-\-\-\-\-
101
.fi
.if n \{\
.RE
.\}
.PP
Select the next number from this sequence:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT nextval(\*(Aqserial\*(Aq);

nextval
\-\-\-\-\-\-\-\-\-
102
.fi
.if n \{\
.RE
.\}
.PP
Use this sequence in an
\fBINSERT\fR
command:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO distributors VALUES (nextval(\*(Aqserial\*(Aq), \*(Aqnothing\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
Update the sequence value after a
\fBCOPY FROM\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
COPY distributors FROM \*(Aqinput_file\*(Aq;
SELECT setval(\*(Aqserial\*(Aq, max(id)) FROM distributors;
END;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE SEQUENCE\fR
conforms to the
SQL
standard, with the following exceptions:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The standard\*(Aqs
AS \fIdata_type\fR
expression is not supported\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Obtaining the next value is done using the
\fBnextval()\fR
function instead of the standard\*(Aqs
\fBNEXT VALUE FOR\fR
expression\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The
OWNED BY
clause is a
PostgreSQL
extension\&amp;.
.RE
.SH "SEE ALSO"
ALTER SEQUENCE (\fBALTER_SEQUENCE\fR(7)), DROP SEQUENCE (\fBDROP_SEQUENCE\fR(7))
'\" t
.\"     Title: CREATE SERVER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE SERVER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_SERVER \- define a new foreign server
.SH "SYNOPSIS"
.sp
.nf
CREATE SERVER \fIserver_name\fR [ TYPE \*(Aq\fIserver_type\fR\*(Aq ] [ VERSION \*(Aq\fIserver_version\fR\*(Aq ]
FOREIGN DATA WRAPPER \fIfdw_name\fR
[ OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] ) ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE SERVER\fR
defines a new foreign server\&amp;. The user who defines the server becomes its owner\&amp;.
.PP
A foreign server typically encapsulates connection information that a foreign\-data wrapper uses to access an external data resource\&amp;. Additional user\-specific connection information may be specified by means of user mappings\&amp;.
.PP
The server name must be unique within the database\&amp;.
.PP
Creating a server requires
USAGE
privilege on the foreign\-data wrapper being used\&amp;.
.SH "PARAMETERS"
.PP
\fIserver_name\fR
.RS 4
The name of the foreign server to be created\&amp;.
.RE
.PP
\fIserver_type\fR
.RS 4
Optional server type, potentially useful to foreign\-data wrappers\&amp;.
.RE
.PP
\fIserver_version\fR
.RS 4
Optional server version, potentially useful to foreign\-data wrappers\&amp;.
.RE
.PP
\fIfdw_name\fR
.RS 4
The name of the foreign\-data wrapper that manages the server\&amp;.
.RE
.PP
OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This clause specifies the options for the server\&amp;. The options typically define the connection details of the server, but the actual names and values are dependent on the server\*(Aqs foreign\-data wrapper\&amp;.
.RE
.SH "NOTES"
.PP
When using the
dblink
module, a foreign server\*(Aqs name can be used as an argument of the
\fBdblink_connect\fR(3)
function to indicate the connection parameters\&amp;. It is necessary to have the
USAGE
privilege on the foreign server to be able to use it in this way\&amp;.
.SH "EXAMPLES"
.PP
Create a server
myserver
that uses the foreign\-data wrapper
postgres_fdw:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE SERVER myserver FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host \*(Aqfoo\*(Aq, dbname \*(Aqfoodb\*(Aq, port \*(Aq5432\*(Aq);
.fi
.if n \{\
.RE
.\}
.sp
See
postgres_fdw
for more details\&amp;.
.SH "COMPATIBILITY"
.PP
\fBCREATE SERVER\fR
conforms to ISO/IEC 9075\-9 (SQL/MED)\&amp;.
.SH "SEE ALSO"
ALTER SERVER (\fBALTER_SERVER\fR(7)), DROP SERVER (\fBDROP_SERVER\fR(7)), CREATE FOREIGN DATA WRAPPER (\fBCREATE_FOREIGN_DATA_WRAPPER\fR(7)), CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7)), CREATE USER MAPPING (\fBCREATE_USER_MAPPING\fR(7))
'\" t
.\"     Title: CREATE TABLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TABLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TABLE \- define a new table
.SH "SYNOPSIS"
.sp
.nf
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] \fItable_name\fR ( [
{ \fIcolumn_name\fR \fIdata_type\fR [ COLLATE \fIcollation\fR ] [ \fIcolumn_constraint\fR [ \&amp;.\&amp;.\&amp;. ] ]
| \fItable_constraint\fR
| LIKE \fIsource_table\fR [ \fIlike_option\fR \&amp;.\&amp;.\&amp;. ] }
[, \&amp;.\&amp;.\&amp;. ]
] )
[ INHERITS ( \fIparent_table\fR [, \&amp;.\&amp;.\&amp;. ] ) ]
[ WITH ( \fIstorage_parameter\fR [= \fIvalue\fR] [, \&amp;.\&amp;.\&amp;. ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE \fItablespace_name\fR ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] \fItable_name\fR
OF \fItype_name\fR [ (
{ \fIcolumn_name\fR WITH OPTIONS [ \fIcolumn_constraint\fR [ \&amp;.\&amp;.\&amp;. ] ]
| \fItable_constraint\fR }
[, \&amp;.\&amp;.\&amp;. ]
) ]
[ WITH ( \fIstorage_parameter\fR [= \fIvalue\fR] [, \&amp;.\&amp;.\&amp;. ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE \fItablespace_name\fR ]

where \fIcolumn_constraint\fR is:

[ CONSTRAINT \fIconstraint_name\fR ]
{ NOT NULL |
NULL |
CHECK ( \fIexpression\fR ) [ NO INHERIT ] |
DEFAULT \fIdefault_expr\fR |
UNIQUE \fIindex_parameters\fR |
PRIMARY KEY \fIindex_parameters\fR |
REFERENCES \fIreftable\fR [ ( \fIrefcolumn\fR ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
[ ON DELETE \fIaction\fR ] [ ON UPDATE \fIaction\fR ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

and \fItable_constraint\fR is:

[ CONSTRAINT \fIconstraint_name\fR ]
{ CHECK ( \fIexpression\fR ) [ NO INHERIT ] |
UNIQUE ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;. ] ) \fIindex_parameters\fR |
PRIMARY KEY ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;. ] ) \fIindex_parameters\fR |
EXCLUDE [ USING \fIindex_method\fR ] ( \fIexclude_element\fR WITH \fIoperator\fR [, \&amp;.\&amp;.\&amp;. ] ) \fIindex_parameters\fR [ WHERE ( \fIpredicate\fR ) ] |
FOREIGN KEY ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;. ] ) REFERENCES \fIreftable\fR [ ( \fIrefcolumn\fR [, \&amp;.\&amp;.\&amp;. ] ) ]
[ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE \fIaction\fR ] [ ON UPDATE \fIaction\fR ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

and \fIlike_option\fR is:

{ INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES | STORAGE | COMMENTS | ALL }

\fIindex_parameters\fR in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:

[ WITH ( \fIstorage_parameter\fR [= \fIvalue\fR] [, \&amp;.\&amp;.\&amp;. ] ) ]
[ USING INDEX TABLESPACE \fItablespace_name\fR ]

\fIexclude_element\fR in an EXCLUDE constraint is:

{ \fIcolumn_name\fR | ( \fIexpression\fR ) } [ \fIopclass\fR ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TABLE\fR
will create a new, initially empty table in the current database\&amp;. The table will be owned by the user issuing the command\&amp;.
.PP
If a schema name is given (for example,
CREATE TABLE myschema\&amp;.mytable \&amp;.\&amp;.\&amp;.) then the table is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table\&amp;. The name of the table must be distinct from the name of any other table, sequence, index, view, or foreign table in the same schema\&amp;.
.PP
\fBCREATE TABLE\fR
also automatically creates a data type that represents the composite type corresponding to one row of the table\&amp;. Therefore, tables cannot have the same name as any existing data type in the same schema\&amp;.
.PP
The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed\&amp;. A constraint is an SQL object that helps define the set of valid values in the table in various ways\&amp;.
.PP
There are two ways to define constraints: table constraints and column constraints\&amp;. A column constraint is defined as part of a column definition\&amp;. A table constraint definition is not tied to a particular column, and it can encompass more than one column\&amp;. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column\&amp;.
.PP
To be able to create a table, you must have
USAGE
privilege on all column types or the type in the
OF
clause, respectively\&amp;.
.SH "PARAMETERS"
.PP
TEMPORARY or TEMP
.RS 4
If specified, the table is created as a temporary table\&amp;. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see
ON COMMIT
below)\&amp;. Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema\-qualified names\&amp;. Any indexes created on a temporary table are automatically temporary as well\&amp;.
.sp
The
autovacuum daemon
cannot access and therefore cannot vacuum or analyze temporary tables\&amp;. For this reason, appropriate vacuum and analyze operations should be performed via session SQL commands\&amp;. For example, if a temporary table is going to be used in complex queries, it is wise to run
\fBANALYZE\fR
on the temporary table after it is populated\&amp;.
.sp
Optionally,
GLOBAL
or
LOCAL
can be written before
TEMPORARY
or
TEMP\&amp;. This presently makes no difference in
PostgreSQL
and is deprecated; see
COMPATIBILITY\&amp;.
.RE
.PP
UNLOGGED
.RS 4
If specified, the table is created as an unlogged table\&amp;. Data written to unlogged tables is not written to the write\-ahead log (see
Chapter 30, Reliability and the Write-Ahead Log, in the documentation), which makes them considerably faster than ordinary tables\&amp;. However, they are not crash\-safe: an unlogged table is automatically truncated after a crash or unclean shutdown\&amp;. The contents of an unlogged table are also not replicated to standby servers\&amp;. Any indexes created on an unlogged table are automatically unlogged as well\&amp;.
.RE
.PP
IF NOT EXISTS
.RS 4
Do not throw an error if a relation with the same name already exists\&amp;. A notice is issued in this case\&amp;. Note that there is no guarantee that the existing relation is anything like the one that would have been created\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table to be created\&amp;.
.RE
.PP
OF \fItype_name\fR
.RS 4
Creates a
typed table, which takes its structure from the specified composite type (name optionally schema\-qualified)\&amp;. A typed table is tied to its type; for example the table will be dropped if the type is dropped (with
DROP TYPE \&amp;.\&amp;.\&amp;. CASCADE)\&amp;.
.sp
When a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by the
CREATE TABLE
command\&amp;. But the
CREATE TABLE
command can add defaults and constraints to the table and can specify storage parameters\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a column to be created in the new table\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
The data type of the column\&amp;. This can include array specifiers\&amp;. For more information on the data types supported by
PostgreSQL, refer to
Chapter 8, Data Types, in the documentation\&amp;.
.RE
.PP
COLLATE \fIcollation\fR
.RS 4
The
COLLATE
clause assigns a collation to the column (which must be of a collatable data type)\&amp;. If not specified, the column data type\*(Aqs default collation is used\&amp;.
.RE
.PP
INHERITS ( \fIparent_table\fR [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
The optional
INHERITS
clause specifies a list of tables from which the new table automatically inherits all columns\&amp;. Parent tables can be plain tables or foreign tables\&amp;.
.sp
Use of
INHERITS
creates a persistent relationship between the new child table and its parent table(s)\&amp;. Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s)\&amp;.
.sp
If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables\&amp;. If there is no conflict, then the duplicate columns are merged to form a single column in the new table\&amp;. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one\&amp;. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column\&amp;. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported\&amp;.
.sp
CHECK
constraints are merged in essentially the same way as columns: if multiple parent tables and/or the new table definition contain identically\-named
CHECK
constraints, these constraints must all have the same check expression, or an error will be reported\&amp;. Constraints having the same name and expression will be merged into one copy\&amp;. A constraint marked
NO INHERIT
in a parent will not be considered\&amp;. Notice that an unnamed
CHECK
constraint in the new table will never be merged, since a unique name will always be chosen for it\&amp;.
.sp
Column
STORAGE
settings are also copied from parent tables\&amp;.
.RE
.PP
LIKE \fIsource_table\fR [ \fIlike_option\fR \&amp;.\&amp;.\&amp;. ]
.RS 4
The
LIKE
clause specifies a table from which the new table automatically copies all column names, their data types, and their not\-null constraints\&amp;.
.sp
Unlike
INHERITS, the new table and original table are completely decoupled after creation is complete\&amp;. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table\&amp;.
.sp
Default expressions for the copied column definitions will be copied only if
INCLUDING DEFAULTS
is specified\&amp;. The default behavior is to exclude default expressions, resulting in the copied columns in the new table having null defaults\&amp;. Note that copying defaults that call database\-modification functions, such as
\fBnextval\fR, may create a functional linkage between the original and new tables\&amp;.
.sp
Not\-null constraints are always copied to the new table\&amp;.
CHECK
constraints will be copied only if
INCLUDING CONSTRAINTS
is specified\&amp;. No distinction is made between column constraints and table constraints\&amp;.
.sp
Indexes,
PRIMARY KEY,
UNIQUE, and
EXCLUDE
constraints on the original table will be created on the new table only if
INCLUDING INDEXES
is specified\&amp;. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named\&amp;. (This behavior avoids possible duplicate\-name failures for the new indexes\&amp;.)
.sp
STORAGE
settings for the copied column definitions will be copied only if
INCLUDING STORAGE
is specified\&amp;. The default behavior is to exclude
STORAGE
settings, resulting in the copied columns in the new table having type\-specific default settings\&amp;. For more on
STORAGE
settings, see
Section 65.2, \(lqTOAST\(rq, in the documentation\&amp;.
.sp
Comments for the copied columns, constraints, and indexes will be copied only if
INCLUDING COMMENTS
is specified\&amp;. The default behavior is to exclude comments, resulting in the copied columns and constraints in the new table having no comments\&amp;.
.sp
INCLUDING ALL
is an abbreviated form of
INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS\&amp;.
.sp
Note that unlike
INHERITS, columns and constraints copied by
LIKE
are not merged with similarly named columns and constraints\&amp;. If the same name is specified explicitly or in another
LIKE
clause, an error is signaled\&amp;.
.sp
The
LIKE
clause can also be used to copy column definitions from views, foreign tables, or composite types\&amp;. Inapplicable options (e\&amp;.g\&amp;.,
INCLUDING INDEXES
from a view) are ignored\&amp;.
.RE
.PP
CONSTRAINT \fIconstraint_name\fR
.RS 4
An optional name for a column or table constraint\&amp;. If the constraint is violated, the constraint name is present in error messages, so constraint names like
col must be positive
can be used to communicate helpful constraint information to client applications\&amp;. (Double\-quotes are needed to specify constraint names that contain spaces\&amp;.) If a constraint name is not specified, the system generates a name\&amp;.
.RE
.PP
NOT NULL
.RS 4
The column is not allowed to contain null values\&amp;.
.RE
.PP
NULL
.RS 4
The column is allowed to contain null values\&amp;. This is the default\&amp;.
.sp
This clause is only provided for compatibility with non\-standard SQL databases\&amp;. Its use is discouraged in new applications\&amp;.
.RE
.PP
CHECK ( \fIexpression\fR ) [ NO INHERIT ]
.RS 4
The
CHECK
clause specifies an expression producing a Boolean result which new or updated rows must satisfy for an insert or update operation to succeed\&amp;. Expressions evaluating to TRUE or UNKNOWN succeed\&amp;. Should any row of an insert or update operation produce a FALSE result, an error exception is raised and the insert or update does not alter the database\&amp;. A check constraint specified as a column constraint should reference that column\*(Aqs value only, while an expression appearing in a table constraint can reference multiple columns\&amp;.
.sp
Currently,
CHECK
expressions cannot contain subqueries nor refer to variables other than columns of the current row\&amp;. The system column
tableoid
may be referenced, but not any other system column\&amp;.
.sp
A constraint marked with
NO INHERIT
will not propagate to child tables\&amp;.
.sp
When a table has multiple
CHECK
constraints, they will be tested for each row in alphabetical order by name, after checking
NOT NULL
constraints\&amp;. (PostgreSQL
versions before 9\&amp;.5 did not honor any particular firing order for
CHECK
constraints\&amp;.)
.RE
.PP
DEFAULT \fIdefault_expr\fR
.RS 4
The
DEFAULT
clause assigns a default data value for the column whose column definition it appears within\&amp;. The value is any variable\-free expression (subqueries and cross\-references to other columns in the current table are not allowed)\&amp;. The data type of the default expression must match the data type of the column\&amp;.
.sp
The default expression will be used in any insert operation that does not specify a value for the column\&amp;. If there is no default for a column, then the default is null\&amp;.
.RE
.PP
UNIQUE (column constraint)
.br
UNIQUE ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;. ] ) (table constraint)
.RS 4
The
UNIQUE
constraint specifies that a group of one or more columns of a table can contain only unique values\&amp;. The behavior of the unique table constraint is the same as that for column constraints, with the additional capability to span multiple columns\&amp;.
.sp
For the purpose of a unique constraint, null values are not considered equal\&amp;.
.sp
Each unique table constraint must name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table\&amp;. (Otherwise it would just be the same constraint listed twice\&amp;.)
.RE
.PP
PRIMARY KEY (column constraint)
.br
PRIMARY KEY ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;. ] ) (table constraint)
.RS 4
The
PRIMARY KEY
constraint specifies that a column or columns of a table can contain only unique (non\-duplicate), nonnull values\&amp;. Only one primary key can be specified for a table, whether as a column constraint or a table constraint\&amp;.
.sp
The primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table\&amp;. (Otherwise, the unique constraint is redundant and will be discarded\&amp;.)
.sp
PRIMARY KEY
enforces the same data constraints as a combination of
UNIQUE
and
NOT NULL, but identifying a set of columns as the primary key also provides metadata about the design of the schema, since a primary key implies that other tables can rely on this set of columns as a unique identifier for rows\&amp;.
.RE
.PP
EXCLUDE [ USING \fIindex_method\fR ] ( \fIexclude_element\fR WITH \fIoperator\fR [, \&amp;.\&amp;.\&amp;. ] ) \fIindex_parameters\fR [ WHERE ( \fIpredicate\fR ) ]
.RS 4
The
EXCLUDE
clause defines an exclusion constraint, which guarantees that if any two rows are compared on the specified column(s) or expression(s) using the specified operator(s), not all of these comparisons will return
TRUE\&amp;. If all of the specified operators test for equality, this is equivalent to a
UNIQUE
constraint, although an ordinary unique constraint will be faster\&amp;. However, exclusion constraints can specify constraints that are more general than simple equality\&amp;. For example, you can specify a constraint that no two rows in the table contain overlapping circles (see
Section 8.8, \(lqGeometric Types\(rq, in the documentation) by using the
&amp;&amp;
operator\&amp;.
.sp
Exclusion constraints are implemented using an index, so each specified operator must be associated with an appropriate operator class (see
Section 11.9, \(lqOperator Classes and Operator Families\(rq, in the documentation) for the index access method
\fIindex_method\fR\&amp;. The operators are required to be commutative\&amp;. Each
\fIexclude_element\fR
can optionally specify an operator class and/or ordering options; these are described fully under
CREATE INDEX (\fBCREATE_INDEX\fR(7))\&amp;.
.sp
The access method must support
amgettuple
(see
Chapter 59, Index Access Method Interface Definition, in the documentation); at present this means
GIN
cannot be used\&amp;. Although it\*(Aqs allowed, there is little point in using B\-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn\*(Aqt do better\&amp;. So in practice the access method will always be
GiST
or
SP\-GiST\&amp;.
.sp
The
\fIpredicate\fR
allows you to specify an exclusion constraint on a subset of the table; internally this creates a partial index\&amp;. Note that parentheses are required around the predicate\&amp;.
.RE
.PP
REFERENCES \fIreftable\fR [ ( \fIrefcolumn\fR ) ] [ MATCH \fImatchtype\fR ] [ ON DELETE \fIaction\fR ] [ ON UPDATE \fIaction\fR ] (column constraint)
.br
FOREIGN KEY ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;. ] ) REFERENCES \fIreftable\fR [ ( \fIrefcolumn\fR [, \&amp;.\&amp;.\&amp;. ] ) ] [ MATCH \fImatchtype\fR ] [ ON DELETE \fIaction\fR ] [ ON UPDATE \fIaction\fR ] (table constraint)
.RS 4
These clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table\&amp;. If the
\fIrefcolumn\fR
list is omitted, the primary key of the
\fIreftable\fR
is used\&amp;. The referenced columns must be the columns of a non\-deferrable unique or primary key constraint in the referenced table\&amp;. Note that foreign key constraints cannot be defined between temporary tables and permanent tables\&amp;.
.sp
A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type\&amp;. There are three match types:
MATCH FULL,
MATCH PARTIAL, and
MATCH SIMPLE
(which is the default)\&amp;.
MATCH FULL
will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table\&amp;.
MATCH SIMPLE
allows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table\&amp;.
MATCH PARTIAL
is not yet implemented\&amp;. (Of course,
NOT NULL
constraints can be applied to the referencing column(s) to prevent these cases from arising\&amp;.)
.sp
In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table\*(Aqs columns\&amp;. The
ON DELETE
clause specifies the action to perform when a referenced row in the referenced table is being deleted\&amp;. Likewise, the
ON UPDATE
clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value\&amp;. If the row is updated, but the referenced column is not actually changed, no action is done\&amp;. Referential actions other than the
NO ACTION
check cannot be deferred, even if the constraint is declared deferrable\&amp;. There are the following possible actions for each clause:
.PP
NO ACTION
.RS 4
Produce an error indicating that the deletion or update would create a foreign key constraint violation\&amp;. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows\&amp;. This is the default action\&amp;.
.RE
.PP
RESTRICT
.RS 4
Produce an error indicating that the deletion or update would create a foreign key constraint violation\&amp;. This is the same as
NO ACTION
except that the check is not deferrable\&amp;.
.RE
.PP
CASCADE
.RS 4
Delete any rows referencing the deleted row, or update the values of the referencing column(s) to the new values of the referenced columns, respectively\&amp;.
.RE
.PP
SET NULL
.RS 4
Set the referencing column(s) to null\&amp;.
.RE
.PP
SET DEFAULT
.RS 4
Set the referencing column(s) to their default values\&amp;. (There must be a row in the referenced table matching the default values, if they are not null, or the operation will fail\&amp;.)
.RE
.sp
If the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently\&amp;.
.RE
.PP
DEFERRABLE
.br
NOT DEFERRABLE
.RS 4
This controls whether the constraint can be deferred\&amp;. A constraint that is not deferrable will be checked immediately after every command\&amp;. Checking of constraints that are deferrable can be postponed until the end of the transaction (using the
SET CONSTRAINTS (\fBSET_CONSTRAINTS\fR(7))
command)\&amp;.
NOT DEFERRABLE
is the default\&amp;. Currently, only
UNIQUE,
PRIMARY KEY,
EXCLUDE, and
REFERENCES
(foreign key) constraints accept this clause\&amp;.
NOT NULL
and
CHECK
constraints are not deferrable\&amp;. Note that deferrable constraints cannot be used as conflict arbitrators in an
\fBINSERT\fR
statement that includes an
ON CONFLICT DO UPDATE
clause\&amp;.
.RE
.PP
INITIALLY IMMEDIATE
.br
INITIALLY DEFERRED
.RS 4
If a constraint is deferrable, this clause specifies the default time to check the constraint\&amp;. If the constraint is
INITIALLY IMMEDIATE, it is checked after each statement\&amp;. This is the default\&amp;. If the constraint is
INITIALLY DEFERRED, it is checked only at the end of the transaction\&amp;. The constraint check time can be altered with the
SET CONSTRAINTS (\fBSET_CONSTRAINTS\fR(7))
command\&amp;.
.RE
.PP
WITH ( \fIstorage_parameter\fR [= \fIvalue\fR] [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This clause specifies optional storage parameters for a table or index; see
Storage Parameters
for more information\&amp;. The
WITH
clause for a table can also include
OIDS=TRUE
(or just
OIDS) to specify that rows of the new table should have OIDs (object identifiers) assigned to them, or
OIDS=FALSE
to specify that the rows should not have OIDs\&amp;. If
OIDS
is not specified, the default setting depends upon the
default_with_oids
configuration parameter\&amp;. (If the new table inherits from any tables that have OIDs, then
OIDS=TRUE
is forced even if the command says
OIDS=FALSE\&amp;.)
.sp
If
OIDS=FALSE
is specified or implied, the new table does not store OIDs and no OID will be assigned for a row inserted into it\&amp;. This is generally considered worthwhile, since it will reduce OID consumption and thereby postpone the wraparound of the 32\-bit OID counter\&amp;. Once the counter wraps around, OIDs can no longer be assumed to be unique, which makes them considerably less useful\&amp;. In addition, excluding OIDs from a table reduces the space required to store the table on disk by 4 bytes per row (on most machines), slightly improving performance\&amp;.
.sp
To remove OIDs from a table after it has been created, use
ALTER TABLE (\fBALTER_TABLE\fR(7))\&amp;.
.RE
.PP
WITH OIDS
.br
WITHOUT OIDS
.RS 4
These are obsolescent syntaxes equivalent to
WITH (OIDS)
and
WITH (OIDS=FALSE), respectively\&amp;. If you wish to give both an
OIDS
setting and storage parameters, you must use the
WITH ( \&amp;.\&amp;.\&amp;. )
syntax; see above\&amp;.
.RE
.PP
ON COMMIT
.RS 4
The behavior of temporary tables at the end of a transaction block can be controlled using
ON COMMIT\&amp;. The three options are:
.PP
PRESERVE ROWS
.RS 4
No special action is taken at the ends of transactions\&amp;. This is the default behavior\&amp;.
.RE
.PP
DELETE ROWS
.RS 4
All rows in the temporary table will be deleted at the end of each transaction block\&amp;. Essentially, an automatic
\fBTRUNCATE\fR(7)
is done at each commit\&amp;.
.RE
.PP
DROP
.RS 4
The temporary table will be dropped at the end of the current transaction block\&amp;.
.RE
.RE
.PP
TABLESPACE \fItablespace_name\fR
.RS 4
The
\fItablespace_name\fR
is the name of the tablespace in which the new table is to be created\&amp;. If not specified,
default_tablespace
is consulted, or
temp_tablespaces
if the table is temporary\&amp;.
.RE
.PP
USING INDEX TABLESPACE \fItablespace_name\fR
.RS 4
This clause allows selection of the tablespace in which the index associated with a
UNIQUE,
PRIMARY KEY, or
EXCLUDE
constraint will be created\&amp;. If not specified,
default_tablespace
is consulted, or
temp_tablespaces
if the table is temporary\&amp;.
.RE
.SS "Storage Parameters"
.PP
The
WITH
clause can specify
storage parameters
for tables, and for indexes associated with a
UNIQUE,
PRIMARY KEY, or
EXCLUDE
constraint\&amp;. Storage parameters for indexes are documented in
CREATE INDEX (\fBCREATE_INDEX\fR(7))\&amp;. The storage parameters currently available for tables are listed below\&amp;. For many of these parameters, as shown, there is an additional parameter with the same name prefixed with
toast\&amp;., which controls the behavior of the table\*(Aqs secondary
TOAST
table, if any (see
Section 65.2, \(lqTOAST\(rq, in the documentation
for more information about TOAST)\&amp;. If a table parameter value is set and the equivalent
toast\&amp;.
parameter is not, the TOAST table will use the table\*(Aqs parameter value\&amp;.
.PP
fillfactor (integer)
.RS 4
The fillfactor for a table is a percentage between 10 and 100\&amp;. 100 (complete packing) is the default\&amp;. When a smaller fillfactor is specified,
\fBINSERT\fR
operations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page\&amp;. This gives
\fBUPDATE\fR
a chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page\&amp;. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate\&amp;. This parameter cannot be set for TOAST tables\&amp;.
.RE
.PP
parallel_workers (integer)
.RS 4
This sets the number of workers that should be used to assist a parallel scan of this table\&amp;. If not set, the system will determine a value based on the relation size\&amp;. The actual number of workers chosen by the planner may be less, for example due to the setting of
max_worker_processes\&amp;.
.RE
.PP
autovacuum_enabled, toast\&amp;.autovacuum_enabled (boolean)
.RS 4
Enables or disables the autovacuum daemon for a particular table\&amp;. If true, the autovacuum daemon will perform automatic
\fBVACUUM\fR
and/or
\fBANALYZE\fR
operations on this table following the rules discussed in
Section 24.1.6, \(lqThe Autovacuum Daemon\(rq, in the documentation\&amp;. If false, this table will not be autovacuumed, except to prevent transaction ID wraparound\&amp;. See
Section 24.1.5, \(lqPreventing Transaction ID Wraparound Failures\(rq, in the documentation
for more about wraparound prevention\&amp;. Note that the autovacuum daemon does not run at all (except to prevent transaction ID wraparound) if the
autovacuum
parameter is false; setting individual tables\*(Aq storage parameters does not override that\&amp;. Therefore there is seldom much point in explicitly setting this storage parameter to
true, only to
false\&amp;.
.RE
.PP
autovacuum_vacuum_threshold, toast\&amp;.autovacuum_vacuum_threshold (integer)
.RS 4
Per\-table value for
autovacuum_vacuum_threshold
parameter\&amp;.
.RE
.PP
autovacuum_vacuum_scale_factor, toast\&amp;.autovacuum_vacuum_scale_factor (float4)
.RS 4
Per\-table value for
autovacuum_vacuum_scale_factor
parameter\&amp;.
.RE
.PP
autovacuum_analyze_threshold (integer)
.RS 4
Per\-table value for
autovacuum_analyze_threshold
parameter\&amp;.
.RE
.PP
autovacuum_analyze_scale_factor (float4)
.RS 4
Per\-table value for
autovacuum_analyze_scale_factor
parameter\&amp;.
.RE
.PP
autovacuum_vacuum_cost_delay, toast\&amp;.autovacuum_vacuum_cost_delay (integer)
.RS 4
Per\-table value for
autovacuum_vacuum_cost_delay
parameter\&amp;.
.RE
.PP
autovacuum_vacuum_cost_limit, toast\&amp;.autovacuum_vacuum_cost_limit (integer)
.RS 4
Per\-table value for
autovacuum_vacuum_cost_limit
parameter\&amp;.
.RE
.PP
autovacuum_freeze_min_age, toast\&amp;.autovacuum_freeze_min_age (integer)
.RS 4
Per\-table value for
vacuum_freeze_min_age
parameter\&amp;. Note that autovacuum will ignore per\-table
autovacuum_freeze_min_age
parameters that are larger than half the system\-wide
autovacuum_freeze_max_age
setting\&amp;.
.RE
.PP
autovacuum_freeze_max_age, toast\&amp;.autovacuum_freeze_max_age (integer)
.RS 4
Per\-table value for
autovacuum_freeze_max_age
parameter\&amp;. Note that autovacuum will ignore per\-table
autovacuum_freeze_max_age
parameters that are larger than the system\-wide setting (it can only be set smaller)\&amp;.
.RE
.PP
autovacuum_freeze_table_age, toast\&amp;.autovacuum_freeze_table_age (integer)
.RS 4
Per\-table value for
vacuum_freeze_table_age
parameter\&amp;.
.RE
.PP
autovacuum_multixact_freeze_min_age, toast\&amp;.autovacuum_multixact_freeze_min_age (integer)
.RS 4
Per\-table value for
vacuum_multixact_freeze_min_age
parameter\&amp;. Note that autovacuum will ignore per\-table
autovacuum_multixact_freeze_min_age
parameters that are larger than half the system\-wide
autovacuum_multixact_freeze_max_age
setting\&amp;.
.RE
.PP
autovacuum_multixact_freeze_max_age, toast\&amp;.autovacuum_multixact_freeze_max_age (integer)
.RS 4
Per\-table value for
autovacuum_multixact_freeze_max_age
parameter\&amp;. Note that autovacuum will ignore per\-table
autovacuum_multixact_freeze_max_age
parameters that are larger than the system\-wide setting (it can only be set smaller)\&amp;.
.RE
.PP
autovacuum_multixact_freeze_table_age, toast\&amp;.autovacuum_multixact_freeze_table_age (integer)
.RS 4
Per\-table value for
vacuum_multixact_freeze_table_age
parameter\&amp;.
.RE
.PP
log_autovacuum_min_duration, toast\&amp;.log_autovacuum_min_duration (integer)
.RS 4
Per\-table value for
log_autovacuum_min_duration
parameter\&amp;.
.RE
.PP
user_catalog_table (boolean)
.RS 4
Declare the table as an additional catalog table for purposes of logical replication\&amp;. See
Section 47.6.2, \(lqCapabilities\(rq, in the documentation
for details\&amp;. This parameter cannot be set for TOAST tables\&amp;.
.RE
.SH "NOTES"
.PP
Using OIDs in new applications is not recommended: where possible, using a
SERIAL
or other sequence generator as the table\*(Aqs primary key is preferred\&amp;. However, if your application does make use of OIDs to identify specific rows of a table, it is recommended to create a unique constraint on the
oid
column of that table, to ensure that OIDs in the table will indeed uniquely identify rows even after counter wraparound\&amp;. Avoid assuming that OIDs are unique across tables; if you need a database\-wide unique identifier, use the combination of
tableoid
and row OID for the purpose\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBTip\fR
.ps -1
.br
.PP
The use of
OIDS=FALSE
is not recommended for tables with no primary key, since without either an OID or a unique data key, it is difficult to identify specific rows\&amp;.
.sp .5v
.RE
.PP
PostgreSQL
automatically creates an index for each unique constraint and primary key constraint to enforce uniqueness\&amp;. Thus, it is not necessary to create an index explicitly for primary key columns\&amp;. (See
CREATE INDEX (\fBCREATE_INDEX\fR(7))
for more information\&amp;.)
.PP
Unique constraints and primary keys are not inherited in the current implementation\&amp;. This makes the combination of inheritance and unique constraints rather dysfunctional\&amp;.
.PP
A table cannot have more than 1600 columns\&amp;. (In practice, the effective limit is usually lower because of tuple\-length constraints\&amp;.)
.SH "EXAMPLES"
.PP
Create table
films
and table
distributors:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE films (
code        char(5) CONSTRAINT firstkey PRIMARY KEY,
title       varchar(40) NOT NULL,
did         integer NOT NULL,
date_prod   date,
kind        varchar(10),
len         interval hour to minute
);

CREATE TABLE distributors (
did    integer PRIMARY KEY DEFAULT nextval(\*(Aqserial\*(Aq),
name   varchar(40) NOT NULL CHECK (name &lt;&gt; \*(Aq\*(Aq)
);
.fi
.if n \{\
.RE
.\}
.PP
Create a table with a 2\-dimensional array:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE array_int (
vector  int[][]
);
.fi
.if n \{\
.RE
.\}
.PP
Define a unique table constraint for the table
films\&amp;. Unique table constraints can be defined on one or more columns of the table:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE films (
code        char(5),
title       varchar(40),
did         integer,
date_prod   date,
kind        varchar(10),
len         interval hour to minute,
CONSTRAINT production UNIQUE(date_prod)
);
.fi
.if n \{\
.RE
.\}
.PP
Define a check column constraint:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE distributors (
did     integer CHECK (did &gt; 100),
name    varchar(40)
);
.fi
.if n \{\
.RE
.\}
.PP
Define a check table constraint:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE distributors (
did     integer,
name    varchar(40)
CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; \*(Aq\*(Aq)
);
.fi
.if n \{\
.RE
.\}
.PP
Define a primary key table constraint for the table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE films (
code        char(5),
title       varchar(40),
did         integer,
date_prod   date,
kind        varchar(10),
len         interval hour to minute,
CONSTRAINT code_title PRIMARY KEY(code,title)
);
.fi
.if n \{\
.RE
.\}
.PP
Define a primary key constraint for table
distributors\&amp;. The following two examples are equivalent, the first using the table constraint syntax, the second the column constraint syntax:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE distributors (
did     integer,
name    varchar(40),
PRIMARY KEY(did)
);

CREATE TABLE distributors (
did     integer PRIMARY KEY,
name    varchar(40)
);
.fi
.if n \{\
.RE
.\}
.PP
Assign a literal constant default value for the column
name, arrange for the default value of column
did
to be generated by selecting the next value of a sequence object, and make the default value of
modtime
be the time at which the row is inserted:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE distributors (
name      varchar(40) DEFAULT \*(AqLuso Films\*(Aq,
did       integer DEFAULT nextval(\*(Aqdistributors_serial\*(Aq),
modtime   timestamp DEFAULT current_timestamp
);
.fi
.if n \{\
.RE
.\}
.PP
Define two
NOT NULL
column constraints on the table
distributors, one of which is explicitly given a name:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE distributors (
did     integer CONSTRAINT no_null NOT NULL,
name    varchar(40) NOT NULL
);
.fi
.if n \{\
.RE
.\}
.PP
Define a unique constraint for the
name
column:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE distributors (
did     integer,
name    varchar(40) UNIQUE
);
.fi
.if n \{\
.RE
.\}
.sp
The same, specified as a table constraint:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE distributors (
did     integer,
name    varchar(40),
UNIQUE(name)
);
.fi
.if n \{\
.RE
.\}
.PP
Create the same table, specifying 70% fill factor for both the table and its unique index:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE distributors (
did     integer,
name    varchar(40),
UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
.fi
.if n \{\
.RE
.\}
.PP
Create table
circles
with an exclusion constraint that prevents any two circles from overlapping:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE circles (
c circle,
EXCLUDE USING gist (c WITH &amp;&amp;)
);
.fi
.if n \{\
.RE
.\}
.PP
Create table
cinemas
in tablespace
diskvol1:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE cinemas (
id serial,
name text,
location text
) TABLESPACE diskvol1;
.fi
.if n \{\
.RE
.\}
.PP
Create a composite type and a typed table:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
PRIMARY KEY (name),
salary WITH OPTIONS DEFAULT 1000
);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBCREATE TABLE\fR
command conforms to the
SQL
standard, with exceptions listed below\&amp;.
.SS "Temporary Tables"
.PP
Although the syntax of
CREATE TEMPORARY TABLE
resembles that of the SQL standard, the effect is not the same\&amp;. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them\&amp;.
PostgreSQL
instead requires each session to issue its own
CREATE TEMPORARY TABLE
command for each temporary table to be used\&amp;. This allows different sessions to use the same temporary table name for different purposes, whereas the standard\*(Aqs approach constrains all instances of a given temporary table name to have the same table structure\&amp;.
.PP
The standard\*(Aqs definition of the behavior of temporary tables is widely ignored\&amp;.
PostgreSQL\*(Aqs behavior on this point is similar to that of several other SQL databases\&amp;.
.PP
The SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions\&amp;. Since
PostgreSQL
does not support SQL modules, this distinction is not relevant in
PostgreSQL\&amp;.
.PP
For compatibility\*(Aqs sake,
PostgreSQL
will accept the
GLOBAL
and
LOCAL
keywords in a temporary table declaration, but they currently have no effect\&amp;. Use of these keywords is discouraged, since future versions of
PostgreSQL
might adopt a more standard\-compliant interpretation of their meaning\&amp;.
.PP
The
ON COMMIT
clause for temporary tables also resembles the SQL standard, but has some differences\&amp;. If the
ON COMMIT
clause is omitted, SQL specifies that the default behavior is
ON COMMIT DELETE ROWS\&amp;. However, the default behavior in
PostgreSQL
is
ON COMMIT PRESERVE ROWS\&amp;. The
ON COMMIT DROP
option does not exist in SQL\&amp;.
.SS "Non\-deferred Uniqueness Constraints"
.PP
When a
UNIQUE
or
PRIMARY KEY
constraint is not deferrable,
PostgreSQL
checks for uniqueness immediately whenever a row is inserted or modified\&amp;. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values\&amp;. To obtain standard\-compliant behavior, declare the constraint as
DEFERRABLE
but not deferred (i\&amp;.e\&amp;.,
INITIALLY IMMEDIATE)\&amp;. Be aware that this can be significantly slower than immediate uniqueness checking\&amp;.
.SS "Column Check Constraints"
.PP
The SQL standard says that
CHECK
column constraints can only refer to the column they apply to; only
CHECK
table constraints can refer to multiple columns\&amp;.
PostgreSQL
does not enforce this restriction; it treats column and table check constraints alike\&amp;.
.SS "EXCLUDE Constraint"
.PP
The
EXCLUDE
constraint type is a
PostgreSQL
extension\&amp;.
.SS "NULL \(lqConstraint\(rq"
.PP
The
NULL\(lqconstraint\(rq
(actually a non\-constraint) is a
PostgreSQL
extension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with the
NOT NULL
constraint)\&amp;. Since it is the default for any column, its presence is simply noise\&amp;.
.SS "Inheritance"
.PP
Multiple inheritance via the
INHERITS
clause is a
PostgreSQL
language extension\&amp;. SQL:1999 and later define single inheritance using a different syntax and different semantics\&amp;. SQL:1999\-style inheritance is not yet supported by
PostgreSQL\&amp;.
.SS "Zero\-column Tables"
.PP
PostgreSQL
allows a table of no columns to be created (for example,
CREATE TABLE foo();)\&amp;. This is an extension from the SQL standard, which does not allow zero\-column tables\&amp;. Zero\-column tables are not in themselves very useful, but disallowing them creates odd special cases for
\fBALTER TABLE DROP COLUMN\fR, so it seems cleaner to ignore this spec restriction\&amp;.
.SS "LIKE Clause"
.PP
While a
LIKE
clause exists in the SQL standard, many of the options that
PostgreSQL
accepts for it are not in the standard, and some of the standard\*(Aqs options are not implemented by
PostgreSQL\&amp;.
.SS "WITH Clause"
.PP
The
WITH
clause is a
PostgreSQL
extension; neither storage parameters nor OIDs are in the standard\&amp;.
.SS "Tablespaces"
.PP
The
PostgreSQL
concept of tablespaces is not part of the standard\&amp;. Hence, the clauses
TABLESPACE
and
USING INDEX TABLESPACE
are extensions\&amp;.
.SS "Typed Tables"
.PP
Typed tables implement a subset of the SQL standard\&amp;. According to the standard, a typed table has columns corresponding to the underlying composite type as well as one other column that is the
\(lqself\-referencing column\(rq\&amp;. PostgreSQL does not support these self\-referencing columns explicitly, but the same effect can be had using the OID feature\&amp;.
.SH "SEE ALSO"
ALTER TABLE (\fBALTER_TABLE\fR(7)), DROP TABLE (\fBDROP_TABLE\fR(7)), CREATE TABLE AS (\fBCREATE_TABLE_AS\fR(7)), CREATE TABLESPACE (\fBCREATE_TABLESPACE\fR(7)), CREATE TYPE (\fBCREATE_TYPE\fR(7))
'\" t
.\"     Title: CREATE TABLESPACE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TABLESPACE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TABLESPACE \- define a new tablespace
.SH "SYNOPSIS"
.sp
.nf
CREATE TABLESPACE \fItablespace_name\fR
[ OWNER { \fInew_owner\fR | CURRENT_USER | SESSION_USER } ]
LOCATION \*(Aq\fIdirectory\fR\*(Aq
[ WITH ( \fItablespace_option\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ] ) ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TABLESPACE\fR
registers a new cluster\-wide tablespace\&amp;. The tablespace name must be distinct from the name of any existing tablespace in the database cluster\&amp;.
.PP
A tablespace allows superusers to define an alternative location on the file system where the data files containing database objects (such as tables and indexes) can reside\&amp;.
.PP
A user with appropriate privileges can pass
\fItablespace_name\fR
to
\fBCREATE DATABASE\fR,
\fBCREATE TABLE\fR,
\fBCREATE INDEX\fR
or
\fBADD CONSTRAINT\fR
to have the data files for these objects stored within the specified tablespace\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
.PP
A tablespace cannot be used independently of the cluster in which it is defined; see
Section 22.6, \(lqTablespaces\(rq, in the documentation\&amp;.
.sp .5v
.RE
.SH "PARAMETERS"
.PP
\fItablespace_name\fR
.RS 4
The name of a tablespace to be created\&amp;. The name cannot begin with
pg_, as such names are reserved for system tablespaces\&amp;.
.RE
.PP
\fIuser_name\fR
.RS 4
The name of the user who will own the tablespace\&amp;. If omitted, defaults to the user executing the command\&amp;. Only superusers can create tablespaces, but they can assign ownership of tablespaces to non\-superusers\&amp;.
.RE
.PP
\fIdirectory\fR
.RS 4
The directory that will be used for the tablespace\&amp;. The directory should be empty and must be owned by the
PostgreSQL
system user\&amp;. The directory must be specified by an absolute path name\&amp;.
.RE
.PP
\fItablespace_option\fR
.RS 4
A tablespace parameter to be set or reset\&amp;. Currently, the only available parameters are
\fIseq_page_cost\fR,
\fIrandom_page_cost\fR
and
\fIeffective_io_concurrency\fR\&amp;. Setting either value for a particular tablespace will override the planner\*(Aqs usual estimate of the cost of reading pages from tables in that tablespace, as established by the configuration parameters of the same name (see
seq_page_cost,
random_page_cost,
effective_io_concurrency)\&amp;. This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem\&amp;.
.RE
.SH "NOTES"
.PP
Tablespaces are only supported on systems that support symbolic links\&amp;.
.PP
\fBCREATE TABLESPACE\fR
cannot be executed inside a transaction block\&amp;.
.SH "EXAMPLES"
.PP
Create a tablespace
dbspace
at
/data/dbs:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLESPACE dbspace LOCATION \*(Aq/data/dbs\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Create a tablespace
indexspace
at
/data/indexes
owned by user
genevieve:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLESPACE indexspace OWNER genevieve LOCATION \*(Aq/data/indexes\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE TABLESPACE\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE DATABASE (\fBCREATE_DATABASE\fR(7)), CREATE TABLE (\fBCREATE_TABLE\fR(7)), CREATE INDEX (\fBCREATE_INDEX\fR(7)), DROP TABLESPACE (\fBDROP_TABLESPACE\fR(7)), ALTER TABLESPACE (\fBALTER_TABLESPACE\fR(7))
'\" t
.\"     Title: CREATE TABLE AS
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TABLE AS" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TABLE_AS \- define a new table from the results of a query
.SH "SYNOPSIS"
.sp
.nf
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] \fItable_name\fR
[ (\fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ]
[ WITH ( \fIstorage_parameter\fR [= \fIvalue\fR] [, \&amp;.\&amp;.\&amp;. ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE \fItablespace_name\fR ]
AS \fIquery\fR
[ WITH [ NO ] DATA ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TABLE AS\fR
creates a table and fills it with data computed by a
\fBSELECT\fR
command\&amp;. The table columns have the names and data types associated with the output columns of the
\fBSELECT\fR
(except that you can override the column names by giving an explicit list of new column names)\&amp;.
.PP
\fBCREATE TABLE AS\fR
bears some resemblance to creating a view, but it is really quite different: it creates a new table and evaluates the query just once to fill the new table initially\&amp;. The new table will not track subsequent changes to the source tables of the query\&amp;. In contrast, a view re\-evaluates its defining
\fBSELECT\fR
statement whenever it is queried\&amp;.
.SH "PARAMETERS"
.PP
GLOBAL or LOCAL
.RS 4
Ignored for compatibility\&amp;. Use of these keywords is deprecated; refer to
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for details\&amp;.
.RE
.PP
TEMPORARY or TEMP
.RS 4
If specified, the table is created as a temporary table\&amp;. Refer to
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for details\&amp;.
.RE
.PP
UNLOGGED
.RS 4
If specified, the table is created as an unlogged table\&amp;. Refer to
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for details\&amp;.
.RE
.PP
IF NOT EXISTS
.RS 4
Do not throw an error if a relation with the same name already exists\&amp;. A notice is issued in this case\&amp;. Refer to
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for details\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table to be created\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a column in the new table\&amp;. If column names are not provided, they are taken from the output column names of the query\&amp;.
.RE
.PP
WITH ( \fIstorage_parameter\fR [= \fIvalue\fR] [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This clause specifies optional storage parameters for the new table; see
Storage Parameters
for more information\&amp;. The
WITH
clause can also include
OIDS=TRUE
(or just
OIDS) to specify that rows of the new table should have OIDs (object identifiers) assigned to them, or
OIDS=FALSE
to specify that the rows should not have OIDs\&amp;. See
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for more information\&amp;.
.RE
.PP
WITH OIDS
.br
WITHOUT OIDS
.RS 4
These are obsolescent syntaxes equivalent to
WITH (OIDS)
and
WITH (OIDS=FALSE), respectively\&amp;. If you wish to give both an
OIDS
setting and storage parameters, you must use the
WITH ( \&amp;.\&amp;.\&amp;. )
syntax; see above\&amp;.
.RE
.PP
ON COMMIT
.RS 4
The behavior of temporary tables at the end of a transaction block can be controlled using
ON COMMIT\&amp;. The three options are:
.PP
PRESERVE ROWS
.RS 4
No special action is taken at the ends of transactions\&amp;. This is the default behavior\&amp;.
.RE
.PP
DELETE ROWS
.RS 4
All rows in the temporary table will be deleted at the end of each transaction block\&amp;. Essentially, an automatic
\fBTRUNCATE\fR(7)
is done at each commit\&amp;.
.RE
.PP
DROP
.RS 4
The temporary table will be dropped at the end of the current transaction block\&amp;.
.RE
.RE
.PP
TABLESPACE \fItablespace_name\fR
.RS 4
The
\fItablespace_name\fR
is the name of the tablespace in which the new table is to be created\&amp;. If not specified,
default_tablespace
is consulted, or
temp_tablespaces
if the table is temporary\&amp;.
.RE
.PP
\fIquery\fR
.RS 4
A
\fBSELECT\fR(7),
TABLE, or
\fBVALUES\fR(7)
command, or an
\fBEXECUTE\fR(7)
command that runs a prepared
\fBSELECT\fR,
\fBTABLE\fR, or
\fBVALUES\fR
query\&amp;.
.RE
.PP
WITH [ NO ] DATA
.RS 4
This clause specifies whether or not the data produced by the query should be copied into the new table\&amp;. If not, only the table structure is copied\&amp;. The default is to copy the data\&amp;.
.RE
.SH "NOTES"
.PP
This command is functionally similar to
SELECT INTO (\fBSELECT_INTO\fR(7)), but it is preferred since it is less likely to be confused with other uses of the
\fBSELECT INTO\fR
syntax\&amp;. Furthermore,
\fBCREATE TABLE AS\fR
offers a superset of the functionality offered by
\fBSELECT INTO\fR\&amp;.
.PP
The
\fBCREATE TABLE AS\fR
command allows the user to explicitly specify whether OIDs should be included\&amp;. If the presence of OIDs is not explicitly specified, the
default_with_oids
configuration variable is used\&amp;.
.SH "EXAMPLES"
.PP
Create a new table
films_recent
consisting of only recent entries from the table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE films_recent AS
SELECT * FROM films WHERE date_prod &gt;= \*(Aq2002\-01\-01\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
To copy a table completely, the short form using the
TABLE
command can also be used:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TABLE films2 AS
TABLE films;
.fi
.if n \{\
.RE
.\}
.PP
Create a new temporary table
films_recent, consisting of only recent entries from the table
films, using a prepared statement\&amp;. The new table has OIDs and will be dropped at commit:
.sp
.if n \{\
.RS 4
.\}
.nf
PREPARE recentfilms(date) AS
SELECT * FROM films WHERE date_prod &gt; $1;
CREATE TEMP TABLE films_recent WITH (OIDS) ON COMMIT DROP AS
EXECUTE recentfilms(\*(Aq2002\-01\-01\*(Aq);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE TABLE AS\fR
conforms to the
SQL
standard\&amp;. The following are nonstandard extensions:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The standard requires parentheses around the subquery clause; in
PostgreSQL, these parentheses are optional\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
In the standard, the
WITH [ NO ] DATA
clause is required; in PostgreSQL it is optional\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
PostgreSQL
handles temporary tables in a way rather different from the standard; see
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for details\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The
WITH
clause is a
PostgreSQL
extension; neither storage parameters nor OIDs are in the standard\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The
PostgreSQL
concept of tablespaces is not part of the standard\&amp;. Hence, the clause
TABLESPACE
is an extension\&amp;.
.RE
.SH "SEE ALSO"
CREATE MATERIALIZED VIEW (\fBCREATE_MATERIALIZED_VIEW\fR(7)), CREATE TABLE (\fBCREATE_TABLE\fR(7)), \fBEXECUTE\fR(7), \fBSELECT\fR(7), SELECT INTO (\fBSELECT_INTO\fR(7)), \fBVALUES\fR(7)
'\" t
.\"     Title: CREATE TEXT SEARCH CONFIGURATION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TEXT SEARCH CONFIGURATION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TEXT_SEARCH_CONFIGURATION \- define a new text search configuration
.SH "SYNOPSIS"
.sp
.nf
CREATE TEXT SEARCH CONFIGURATION \fIname\fR (
PARSER = \fIparser_name\fR |
COPY = \fIsource_config\fR
)
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TEXT SEARCH CONFIGURATION\fR
creates a new text search configuration\&amp;. A text search configuration specifies a text search parser that can divide a string into tokens, plus dictionaries that can be used to determine which tokens are of interest for searching\&amp;.
.PP
If only the parser is specified, then the new text search configuration initially has no mappings from token types to dictionaries, and therefore will ignore all words\&amp;. Subsequent
\fBALTER TEXT SEARCH CONFIGURATION\fR
commands must be used to create mappings to make the configuration useful\&amp;. Alternatively, an existing text search configuration can be copied\&amp;.
.PP
If a schema name is given then the text search configuration is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;.
.PP
The user who defines a text search configuration becomes its owner\&amp;.
.PP
Refer to
Chapter 12, Full Text Search, in the documentation
for further information\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the text search configuration to be created\&amp;. The name can be schema\-qualified\&amp;.
.RE
.PP
\fIparser_name\fR
.RS 4
The name of the text search parser to use for this configuration\&amp;.
.RE
.PP
\fIsource_config\fR
.RS 4
The name of an existing text search configuration to copy\&amp;.
.RE
.SH "NOTES"
.PP
The
PARSER
and
COPY
options are mutually exclusive, because when an existing configuration is copied, its parser selection is copied too\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBCREATE TEXT SEARCH CONFIGURATION\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TEXT SEARCH CONFIGURATION (\fBALTER_TEXT_SEARCH_CONFIGURATION\fR(7)), DROP TEXT SEARCH CONFIGURATION (\fBDROP_TEXT_SEARCH_CONFIGURATION\fR(7))
'\" t
.\"     Title: CREATE TEXT SEARCH DICTIONARY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TEXT SEARCH DICTIONARY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TEXT_SEARCH_DICTIONARY \- define a new text search dictionary
.SH "SYNOPSIS"
.sp
.nf
CREATE TEXT SEARCH DICTIONARY \fIname\fR (
TEMPLATE = \fItemplate\fR
[, \fIoption\fR = \fIvalue\fR [, \&amp;.\&amp;.\&amp;. ]]
)
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TEXT SEARCH DICTIONARY\fR
creates a new text search dictionary\&amp;. A text search dictionary specifies a way of recognizing interesting or uninteresting words for searching\&amp;. A dictionary depends on a text search template, which specifies the functions that actually perform the work\&amp;. Typically the dictionary provides some options that control the detailed behavior of the template\*(Aqs functions\&amp;.
.PP
If a schema name is given then the text search dictionary is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;.
.PP
The user who defines a text search dictionary becomes its owner\&amp;.
.PP
Refer to
Chapter 12, Full Text Search, in the documentation
for further information\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the text search dictionary to be created\&amp;. The name can be schema\-qualified\&amp;.
.RE
.PP
\fItemplate\fR
.RS 4
The name of the text search template that will define the basic behavior of this dictionary\&amp;.
.RE
.PP
\fIoption\fR
.RS 4
The name of a template\-specific option to be set for this dictionary\&amp;.
.RE
.PP
\fIvalue\fR
.RS 4
The value to use for a template\-specific option\&amp;. If the value is not a simple identifier or number, it must be quoted (but you can always quote it, if you wish)\&amp;.
.RE
.PP
The options can appear in any order\&amp;.
.SH "EXAMPLES"
.PP
The following example command creates a Snowball\-based dictionary with a nonstandard list of stop words\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TEXT SEARCH DICTIONARY my_russian (
template = snowball,
language = russian,
stopwords = myrussian
);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBCREATE TEXT SEARCH DICTIONARY\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TEXT SEARCH DICTIONARY (\fBALTER_TEXT_SEARCH_DICTIONARY\fR(7)), DROP TEXT SEARCH DICTIONARY (\fBDROP_TEXT_SEARCH_DICTIONARY\fR(7))
'\" t
.\"     Title: CREATE TEXT SEARCH PARSER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TEXT SEARCH PARSER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TEXT_SEARCH_PARSER \- define a new text search parser
.SH "SYNOPSIS"
.sp
.nf
CREATE TEXT SEARCH PARSER \fIname\fR (
START = \fIstart_function\fR ,
GETTOKEN = \fIgettoken_function\fR ,
END = \fIend_function\fR ,
LEXTYPES = \fIlextypes_function\fR
[, HEADLINE = \fIheadline_function\fR ]
)
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TEXT SEARCH PARSER\fR
creates a new text search parser\&amp;. A text search parser defines a method for splitting a text string into tokens and assigning types (categories) to the tokens\&amp;. A parser is not particularly useful by itself, but must be bound into a text search configuration along with some text search dictionaries to be used for searching\&amp;.
.PP
If a schema name is given then the text search parser is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;.
.PP
You must be a superuser to use
\fBCREATE TEXT SEARCH PARSER\fR\&amp;. (This restriction is made because an erroneous text search parser definition could confuse or even crash the server\&amp;.)
.PP
Refer to
Chapter 12, Full Text Search, in the documentation
for further information\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the text search parser to be created\&amp;. The name can be schema\-qualified\&amp;.
.RE
.PP
\fIstart_function\fR
.RS 4
The name of the start function for the parser\&amp;.
.RE
.PP
\fIgettoken_function\fR
.RS 4
The name of the get\-next\-token function for the parser\&amp;.
.RE
.PP
\fIend_function\fR
.RS 4
The name of the end function for the parser\&amp;.
.RE
.PP
\fIlextypes_function\fR
.RS 4
The name of the lextypes function for the parser (a function that returns information about the set of token types it produces)\&amp;.
.RE
.PP
\fIheadline_function\fR
.RS 4
The name of the headline function for the parser (a function that summarizes a set of tokens)\&amp;.
.RE
.PP
The function names can be schema\-qualified if necessary\&amp;. Argument types are not given, since the argument list for each type of function is predetermined\&amp;. All except the headline function are required\&amp;.
.PP
The arguments can appear in any order, not only the one shown above\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBCREATE TEXT SEARCH PARSER\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TEXT SEARCH PARSER (\fBALTER_TEXT_SEARCH_PARSER\fR(7)), DROP TEXT SEARCH PARSER (\fBDROP_TEXT_SEARCH_PARSER\fR(7))
'\" t
.\"     Title: CREATE TEXT SEARCH TEMPLATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TEXT SEARCH TEMPLATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TEXT_SEARCH_TEMPLATE \- define a new text search template
.SH "SYNOPSIS"
.sp
.nf
CREATE TEXT SEARCH TEMPLATE \fIname\fR (
[ INIT = \fIinit_function\fR , ]
LEXIZE = \fIlexize_function\fR
)
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TEXT SEARCH TEMPLATE\fR
creates a new text search template\&amp;. Text search templates define the functions that implement text search dictionaries\&amp;. A template is not useful by itself, but must be instantiated as a dictionary to be used\&amp;. The dictionary typically specifies parameters to be given to the template functions\&amp;.
.PP
If a schema name is given then the text search template is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;.
.PP
You must be a superuser to use
\fBCREATE TEXT SEARCH TEMPLATE\fR\&amp;. This restriction is made because an erroneous text search template definition could confuse or even crash the server\&amp;. The reason for separating templates from dictionaries is that a template encapsulates the
\(lqunsafe\(rq
aspects of defining a dictionary\&amp;. The parameters that can be set when defining a dictionary are safe for unprivileged users to set, and so creating a dictionary need not be a privileged operation\&amp;.
.PP
Refer to
Chapter 12, Full Text Search, in the documentation
for further information\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the text search template to be created\&amp;. The name can be schema\-qualified\&amp;.
.RE
.PP
\fIinit_function\fR
.RS 4
The name of the init function for the template\&amp;.
.RE
.PP
\fIlexize_function\fR
.RS 4
The name of the lexize function for the template\&amp;.
.RE
.PP
The function names can be schema\-qualified if necessary\&amp;. Argument types are not given, since the argument list for each type of function is predetermined\&amp;. The lexize function is required, but the init function is optional\&amp;.
.PP
The arguments can appear in any order, not only the one shown above\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBCREATE TEXT SEARCH TEMPLATE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TEXT SEARCH TEMPLATE (\fBALTER_TEXT_SEARCH_TEMPLATE\fR(7)), DROP TEXT SEARCH TEMPLATE (\fBDROP_TEXT_SEARCH_TEMPLATE\fR(7))
'\" t
.\"     Title: CREATE TRANSFORM
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TRANSFORM" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TRANSFORM \- define a new transform
.SH "SYNOPSIS"
.sp
.nf
CREATE [ OR REPLACE ] TRANSFORM FOR \fItype_name\fR LANGUAGE \fIlang_name\fR (
FROM SQL WITH FUNCTION \fIfrom_sql_function_name\fR (\fIargument_type\fR [, \&amp;.\&amp;.\&amp;.]),
TO SQL WITH FUNCTION \fIto_sql_function_name\fR (\fIargument_type\fR [, \&amp;.\&amp;.\&amp;.])
);
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TRANSFORM\fR
defines a new transform\&amp;.
\fBCREATE OR REPLACE TRANSFORM\fR
will either create a new transform, or replace an existing definition\&amp;.
.PP
A transform specifies how to adapt a data type to a procedural language\&amp;. For example, when writing a function in PL/Python using the
hstore
type, PL/Python has no prior knowledge how to present
hstore
values in the Python environment\&amp;. Language implementations usually default to using the text representation, but that is inconvenient when, for example, an associative array or a list would be more appropriate\&amp;.
.PP
A transform specifies two functions:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A
\(lqfrom SQL\(rq
function that converts the type from the SQL environment to the language\&amp;. This function will be invoked on the arguments of a function written in the language\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A
\(lqto SQL\(rq
function that converts the type from the language to the SQL environment\&amp;. This function will be invoked on the return value of a function written in the language\&amp;.
.RE
.sp
It is not necessary to provide both of these functions\&amp;. If one is not specified, the language\-specific default behavior will be used if necessary\&amp;. (To prevent a transformation in a certain direction from happening at all, you could also write a transform function that always errors out\&amp;.)
.PP
To be able to create a transform, you must own and have
USAGE
privilege on the type, have
USAGE
privilege on the language, and own and have
EXECUTE
privilege on the from\-SQL and to\-SQL functions, if specified\&amp;.
.SH "PARAMETERS"
.PP
\fItype_name\fR
.RS 4
The name of the data type of the transform\&amp;.
.RE
.PP
\fIlang_name\fR
.RS 4
The name of the language of the transform\&amp;.
.RE
.PP
\fIfrom_sql_function_name\fR(\fIargument_type\fR [, \&amp;.\&amp;.\&amp;.])
.RS 4
The name of the function for converting the type from the SQL environment to the language\&amp;. It must take one argument of type
internal
and return type
internal\&amp;. The actual argument will be of the type for the transform, and the function should be coded as if it were\&amp;. (But it is not allowed to declare an SQL\-level function returning
internal
without at least one argument of type
internal\&amp;.) The actual return value will be something specific to the language implementation\&amp;.
.RE
.PP
\fIto_sql_function_name\fR(\fIargument_type\fR [, \&amp;.\&amp;.\&amp;.])
.RS 4
The name of the function for converting the type from the language to the SQL environment\&amp;. It must take one argument of type
internal
and return the type that is the type for the transform\&amp;. The actual argument value will be something specific to the language implementation\&amp;.
.RE
.SH "NOTES"
.PP
Use
DROP TRANSFORM (\fBDROP_TRANSFORM\fR(7))
to remove transforms\&amp;.
.SH "EXAMPLES"
.PP
To create a transform for type
hstore
and language
plpythonu, first set up the type and the language:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE hstore \&amp;.\&amp;.\&amp;.;

CREATE LANGUAGE plpythonu \&amp;.\&amp;.\&amp;.;
.fi
.if n \{\
.RE
.\}
.sp
Then create the necessary functions:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION hstore_to_plpython(val internal) RETURNS internal
LANGUAGE C STRICT IMMUTABLE
AS \&amp;.\&amp;.\&amp;.;

CREATE FUNCTION plpython_to_hstore(val internal) RETURNS hstore
LANGUAGE C STRICT IMMUTABLE
AS \&amp;.\&amp;.\&amp;.;
.fi
.if n \{\
.RE
.\}
.sp
And finally create the transform to connect them all together:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TRANSFORM FOR hstore LANGUAGE plpythonu (
FROM SQL WITH FUNCTION hstore_to_plpython(internal),
TO SQL WITH FUNCTION plpython_to_hstore(internal)
);
.fi
.if n \{\
.RE
.\}
.sp
In practice, these commands would be wrapped up in extensions\&amp;.
.PP
The
contrib
section contains a number of extensions that provide transforms, which can serve as real\-world examples\&amp;.
.SH "COMPATIBILITY"
.PP
This form of
\fBCREATE TRANSFORM\fR
is a
PostgreSQL
extension\&amp;. There is a
\fBCREATE TRANSFORM\fR
command in the
SQL
standard, but it is for adapting data types to client languages\&amp;. That usage is not supported by
PostgreSQL\&amp;.
.SH "SEE ALSO"
.PP
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)),
CREATE LANGUAGE (\fBCREATE_LANGUAGE\fR(7)),
CREATE TYPE (\fBCREATE_TYPE\fR(7)),
DROP TRANSFORM (\fBDROP_TRANSFORM\fR(7))
'\" t
.\"     Title: CREATE TRIGGER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TRIGGER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TRIGGER \- define a new trigger
.SH "SYNOPSIS"
.sp
.nf
CREATE [ CONSTRAINT ] TRIGGER \fIname\fR { BEFORE | AFTER | INSTEAD OF } { \fIevent\fR [ OR \&amp;.\&amp;.\&amp;. ] }
ON \fItable_name\fR
[ FROM \fIreferenced_table_name\fR ]
[ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
[ FOR [ EACH ] { ROW | STATEMENT } ]
[ WHEN ( \fIcondition\fR ) ]
EXECUTE PROCEDURE \fIfunction_name\fR ( \fIarguments\fR )

where \fIevent\fR can be one of:

INSERT
UPDATE [ OF \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;. ] ]
DELETE
TRUNCATE
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TRIGGER\fR
creates a new trigger\&amp;. The trigger will be associated with the specified table, view, or foreign table and will execute the specified function
\fIfunction_name\fR
when certain events occur\&amp;.
.PP
The trigger can be specified to fire before the operation is attempted on a row (before constraints are checked and the
\fBINSERT\fR,
\fBUPDATE\fR, or
\fBDELETE\fR
is attempted); or after the operation has completed (after constraints are checked and the
\fBINSERT\fR,
\fBUPDATE\fR, or
\fBDELETE\fR
has completed); or instead of the operation (in the case of inserts, updates or deletes on a view)\&amp;. If the trigger fires before or instead of the event, the trigger can skip the operation for the current row, or change the row being inserted (for
\fBINSERT\fR
and
\fBUPDATE\fR
operations only)\&amp;. If the trigger fires after the event, all changes, including the effects of other triggers, are
\(lqvisible\(rq
to the trigger\&amp;.
.PP
A trigger that is marked
FOR EACH ROW
is called once for every row that the operation modifies\&amp;. For example, a
\fBDELETE\fR
that affects 10 rows will cause any
ON DELETE
triggers on the target relation to be called 10 separate times, once for each deleted row\&amp;. In contrast, a trigger that is marked
FOR EACH STATEMENT
only executes once for any given operation, regardless of how many rows it modifies (in particular, an operation that modifies zero rows will still result in the execution of any applicable
FOR EACH STATEMENT
triggers)\&amp;. Note that with an
\fBINSERT\fR
with an
ON CONFLICT DO UPDATE
clause, both
\fBINSERT\fR
and
\fBUPDATE\fR
statement level trigger will be fired\&amp;.
.PP
Triggers that are specified to fire
INSTEAD OF
the trigger event must be marked
FOR EACH ROW, and can only be defined on views\&amp;.
BEFORE
and
AFTER
triggers on a view must be marked as
FOR EACH STATEMENT\&amp;.
.PP
In addition, triggers may be defined to fire for
\fBTRUNCATE\fR, though only
FOR EACH STATEMENT\&amp;.
.PP
The following table summarizes which types of triggers may be used on tables, views, and foreign tables:
.TS
allbox tab(:);
lB lB lB lB.
T{
When
T}:T{
Event
T}:T{
Row\-level
T}:T{
Statement\-level
T}
.T&amp;
c c c c
^ c c c
c c c c
^ c c c
c c c c
^ c c c.
T{
BEFORE
T}:T{
\fBINSERT\fR/\fBUPDATE\fR/\fBDELETE\fR
T}:T{
Tables and foreign tables
T}:T{
Tables, views, and foreign tables
T}
:T{
\fBTRUNCATE\fR
T}:T{
\(em
T}:T{
Tables
T}
T{
AFTER
T}:T{
\fBINSERT\fR/\fBUPDATE\fR/\fBDELETE\fR
T}:T{
Tables and foreign tables
T}:T{
Tables, views, and foreign tables
T}
:T{
\fBTRUNCATE\fR
T}:T{
\(em
T}:T{
Tables
T}
T{
INSTEAD OF
T}:T{
\fBINSERT\fR/\fBUPDATE\fR/\fBDELETE\fR
T}:T{
Views
T}:T{
\(em
T}
:T{
\fBTRUNCATE\fR
T}:T{
\(em
T}:T{
\(em
T}
.TE
.sp 1
.PP
Also, a trigger definition can specify a Boolean
WHEN
condition, which will be tested to see whether the trigger should be fired\&amp;. In row\-level triggers the
WHEN
condition can examine the old and/or new values of columns of the row\&amp;. Statement\-level triggers can also have
WHEN
conditions, although the feature is not so useful for them since the condition cannot refer to any values in the table\&amp;.
.PP
If multiple triggers of the same kind are defined for the same event, they will be fired in alphabetical order by name\&amp;.
.PP
When the
CONSTRAINT
option is specified, this command creates a
constraint trigger\&amp;. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using
SET CONSTRAINTS (\fBSET_CONSTRAINTS\fR(7))\&amp;. Constraint triggers must be
AFTER ROW
triggers on tables\&amp;. They can be fired either at the end of the statement causing the triggering event, or at the end of the containing transaction; in the latter case they are said to be
deferred\&amp;. A pending deferred\-trigger firing can also be forced to happen immediately by using
\fBSET CONSTRAINTS\fR\&amp;. Constraint triggers are expected to raise an exception when the constraints they implement are violated\&amp;.
.PP
\fBSELECT\fR
does not modify any rows so you cannot create
\fBSELECT\fR
triggers\&amp;. Rules and views are more appropriate in such cases\&amp;.
.PP
Refer to
Chapter 37, Triggers, in the documentation
for more information about triggers\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name to give the new trigger\&amp;. This must be distinct from the name of any other trigger for the same table\&amp;. The name cannot be schema\-qualified \(em the trigger inherits the schema of its table\&amp;. For a constraint trigger, this is also the name to use when modifying the trigger\*(Aqs behavior using
\fBSET CONSTRAINTS\fR\&amp;.
.RE
.PP
BEFORE
.br
AFTER
.br
INSTEAD OF
.RS 4
Determines whether the function is called before, after, or instead of the event\&amp;. A constraint trigger can only be specified as
AFTER\&amp;.
.RE
.PP
\fIevent\fR
.RS 4
One of
INSERT,
UPDATE,
DELETE, or
TRUNCATE; this specifies the event that will fire the trigger\&amp;. Multiple events can be specified using
OR\&amp;.
.sp
For
UPDATE
events, it is possible to specify a list of columns using this syntax:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE OF \fIcolumn_name1\fR [, \fIcolumn_name2\fR \&amp;.\&amp;.\&amp;. ]
.fi
.if n \{\
.RE
.\}
.sp
The trigger will only fire if at least one of the listed columns is mentioned as a target of the
\fBUPDATE\fR
command\&amp;.
.sp
INSTEAD OF UPDATE
events do not support lists of columns\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table, view, or foreign table the trigger is for\&amp;.
.RE
.PP
\fIreferenced_table_name\fR
.RS 4
The (possibly schema\-qualified) name of another table referenced by the constraint\&amp;. This option is used for foreign\-key constraints and is not recommended for general use\&amp;. This can only be specified for constraint triggers\&amp;.
.RE
.PP
DEFERRABLE
.br
NOT DEFERRABLE
.br
INITIALLY IMMEDIATE
.br
INITIALLY DEFERRED
.RS 4
The default timing of the trigger\&amp;. See the
CREATE TABLE (\fBCREATE_TABLE\fR(7))
documentation for details of these constraint options\&amp;. This can only be specified for constraint triggers\&amp;.
.RE
.PP
FOR EACH ROW
.br
FOR EACH STATEMENT
.RS 4
This specifies whether the trigger procedure should be fired once for every row affected by the trigger event, or just once per SQL statement\&amp;. If neither is specified,
FOR EACH STATEMENT
is the default\&amp;. Constraint triggers can only be specified
FOR EACH ROW\&amp;.
.RE
.PP
\fIcondition\fR
.RS 4
A Boolean expression that determines whether the trigger function will actually be executed\&amp;. If
WHEN
is specified, the function will only be called if the
\fIcondition\fR
returns
true\&amp;. In
FOR EACH ROW
triggers, the
WHEN
condition can refer to columns of the old and/or new row values by writing
OLD\&amp;.\fIcolumn_name\fR
or
NEW\&amp;.\fIcolumn_name\fR
respectively\&amp;. Of course,
INSERT
triggers cannot refer to
OLD
and
DELETE
triggers cannot refer to
NEW\&amp;.
.sp
INSTEAD OF
triggers do not support
WHEN
conditions\&amp;.
.sp
Currently,
WHEN
expressions cannot contain subqueries\&amp;.
.sp
Note that for constraint triggers, evaluation of the
WHEN
condition is not deferred, but occurs immediately after the row update operation is performed\&amp;. If the condition does not evaluate to true then the trigger is not queued for deferred execution\&amp;.
.RE
.PP
\fIfunction_name\fR
.RS 4
A user\-supplied function that is declared as taking no arguments and returning type
trigger, which is executed when the trigger fires\&amp;.
.RE
.PP
\fIarguments\fR
.RS 4
An optional comma\-separated list of arguments to be provided to the function when the trigger is executed\&amp;. The arguments are literal string constants\&amp;. Simple names and numeric constants can be written here, too, but they will all be converted to strings\&amp;. Please check the description of the implementation language of the trigger function to find out how these arguments can be accessed within the function; it might be different from normal function arguments\&amp;.
.RE
.SH "NOTES"
.PP
To create a trigger on a table, the user must have the
TRIGGER
privilege on the table\&amp;. The user must also have
EXECUTE
privilege on the trigger function\&amp;.
.PP
Use
DROP TRIGGER (\fBDROP_TRIGGER\fR(7))
to remove a trigger\&amp;.
.PP
A column\-specific trigger (one defined using the
UPDATE OF \fIcolumn_name\fR
syntax) will fire when any of its columns are listed as targets in the
\fBUPDATE\fR
command\*(Aqs
SET
list\&amp;. It is possible for a column\*(Aqs value to change even when the trigger is not fired, because changes made to the row\*(Aqs contents by
BEFORE UPDATE
triggers are not considered\&amp;. Conversely, a command such as
UPDATE \&amp;.\&amp;.\&amp;. SET x = x \&amp;.\&amp;.\&amp;.
will fire a trigger on column
x, even though the column\*(Aqs value did not change\&amp;.
.PP
In a
BEFORE
trigger, the
WHEN
condition is evaluated just before the function is or would be executed, so using
WHEN
is not materially different from testing the same condition at the beginning of the trigger function\&amp;. Note in particular that the
NEW
row seen by the condition is the current value, as possibly modified by earlier triggers\&amp;. Also, a
BEFORE
trigger\*(Aqs
WHEN
condition is not allowed to examine the system columns of the
NEW
row (such as
oid), because those won\*(Aqt have been set yet\&amp;.
.PP
In an
AFTER
trigger, the
WHEN
condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement\&amp;. So when an
AFTER
trigger\*(Aqs
WHEN
condition does not return true, it is not necessary to queue an event nor to re\-fetch the row at end of statement\&amp;. This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows\&amp;.
.PP
In
PostgreSQL
versions before 7\&amp;.3, it was necessary to declare trigger functions as returning the placeholder type
opaque, rather than
trigger\&amp;. To support loading of old dump files,
\fBCREATE TRIGGER\fR
will accept a function declared as returning
opaque, but it will issue a notice and change the function\*(Aqs declared return type to
trigger\&amp;.
.SH "EXAMPLES"
.PP
Execute the function
\fBcheck_account_update\fR
whenever a row of the table
accounts
is about to be updated:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update();
.fi
.if n \{\
.RE
.\}
.sp
The same, but only execute the function if column
balance
is specified as a target in the
\fBUPDATE\fR
command:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TRIGGER check_update
BEFORE UPDATE OF balance ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update();
.fi
.if n \{\
.RE
.\}
.sp
This form only executes the function if column
balance
has in fact changed value:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
WHEN (OLD\&amp;.balance IS DISTINCT FROM NEW\&amp;.balance)
EXECUTE PROCEDURE check_account_update();
.fi
.if n \{\
.RE
.\}
.sp
Call a function to log updates of
accounts, but only if something changed:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TRIGGER log_update
AFTER UPDATE ON accounts
FOR EACH ROW
WHEN (OLD\&amp;.* IS DISTINCT FROM NEW\&amp;.*)
EXECUTE PROCEDURE log_account_update();
.fi
.if n \{\
.RE
.\}
.sp
Execute the function
\fBview_insert_row\fR
for each row to insert rows into the tables underlying a view:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TRIGGER view_insert
INSTEAD OF INSERT ON my_view
FOR EACH ROW
EXECUTE PROCEDURE view_insert_row();
.fi
.if n \{\
.RE
.\}
.PP
Section 37.4, \(lqA Complete Trigger Example\(rq, in the documentation
contains a complete example of a trigger function written in C\&amp;.
.SH "COMPATIBILITY"
.PP
The
\fBCREATE TRIGGER\fR
statement in
PostgreSQL
implements a subset of the
SQL
standard\&amp;. The following functionalities are currently missing:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
SQL allows you to define aliases for the
\(lqold\(rq
and
\(lqnew\(rq
rows or tables for use in the definition of the triggered action (e\&amp;.g\&amp;.,
CREATE TRIGGER \&amp;.\&amp;.\&amp;. ON tablename REFERENCING OLD ROW AS somename NEW ROW AS othername \&amp;.\&amp;.\&amp;.)\&amp;. Since
PostgreSQL
allows trigger procedures to be written in any number of user\-defined languages, access to the data is handled in a language\-specific way\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
PostgreSQL
does not allow the old and new tables to be referenced in statement\-level triggers, i\&amp;.e\&amp;., the tables that contain all the old and/or new rows, which are referred to by the
OLD TABLE
and
NEW TABLE
clauses in the
SQL
standard\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
PostgreSQL
only allows the execution of a user\-defined function for the triggered action\&amp;. The standard allows the execution of a number of other SQL commands, such as
\fBCREATE TABLE\fR, as the triggered action\&amp;. This limitation is not hard to work around by creating a user\-defined function that executes the desired commands\&amp;.
.RE
.PP
SQL specifies that multiple triggers should be fired in time\-of\-creation order\&amp;.
PostgreSQL
uses name order, which was judged to be more convenient\&amp;.
.PP
SQL specifies that
BEFORE DELETE
triggers on cascaded deletes fire
\fIafter\fR
the cascaded
DELETE
completes\&amp;. The
PostgreSQL
behavior is for
BEFORE DELETE
to always fire before the delete action, even a cascading one\&amp;. This is considered more consistent\&amp;. There is also nonstandard behavior if
BEFORE
triggers modify rows or prevent updates during an update that is caused by a referential action\&amp;. This can lead to constraint violations or stored data that does not honor the referential constraint\&amp;.
.PP
The ability to specify multiple actions for a single trigger using
OR
is a
PostgreSQL
extension of the SQL standard\&amp;.
.PP
The ability to fire triggers for
\fBTRUNCATE\fR
is a
PostgreSQL
extension of the SQL standard, as is the ability to define statement\-level triggers on views\&amp;.
.PP
\fBCREATE CONSTRAINT TRIGGER\fR
is a
PostgreSQL
extension of the
SQL
standard\&amp;.
.SH "SEE ALSO"
ALTER TRIGGER (\fBALTER_TRIGGER\fR(7)), DROP TRIGGER (\fBDROP_TRIGGER\fR(7)), CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)), SET CONSTRAINTS (\fBSET_CONSTRAINTS\fR(7))
'\" t
.\"     Title: CREATE TYPE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE TYPE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_TYPE \- define a new data type
.SH "SYNOPSIS"
.sp
.nf
CREATE TYPE \fIname\fR AS
( [ \fIattribute_name\fR \fIdata_type\fR [ COLLATE \fIcollation\fR ] [, \&amp;.\&amp;.\&amp;. ] ] )

CREATE TYPE \fIname\fR AS ENUM
( [ \*(Aq\fIlabel\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] ] )

CREATE TYPE \fIname\fR AS RANGE (
SUBTYPE = \fIsubtype\fR
[ , SUBTYPE_OPCLASS = \fIsubtype_operator_class\fR ]
[ , COLLATION = \fIcollation\fR ]
[ , CANONICAL = \fIcanonical_function\fR ]
[ , SUBTYPE_DIFF = \fIsubtype_diff_function\fR ]
)

CREATE TYPE \fIname\fR (
INPUT = \fIinput_function\fR,
OUTPUT = \fIoutput_function\fR
[ , RECEIVE = \fIreceive_function\fR ]
[ , SEND = \fIsend_function\fR ]
[ , TYPMOD_IN = \fItype_modifier_input_function\fR ]
[ , TYPMOD_OUT = \fItype_modifier_output_function\fR ]
[ , ANALYZE = \fIanalyze_function\fR ]
[ , INTERNALLENGTH = { \fIinternallength\fR | VARIABLE } ]
[ , PASSEDBYVALUE ]
[ , ALIGNMENT = \fIalignment\fR ]
[ , STORAGE = \fIstorage\fR ]
[ , LIKE = \fIlike_type\fR ]
[ , CATEGORY = \fIcategory\fR ]
[ , PREFERRED = \fIpreferred\fR ]
[ , DEFAULT = \fIdefault\fR ]
[ , ELEMENT = \fIelement\fR ]
[ , DELIMITER = \fIdelimiter\fR ]
[ , COLLATABLE = \fIcollatable\fR ]
)

CREATE TYPE \fIname\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE TYPE\fR
registers a new data type for use in the current database\&amp;. The user who defines a type becomes its owner\&amp;.
.PP
If a schema name is given then the type is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. The type name must be distinct from the name of any existing type or domain in the same schema\&amp;. (Because tables have associated data types, the type name must also be distinct from the name of any existing table in the same schema\&amp;.)
.PP
There are five forms of
\fBCREATE TYPE\fR, as shown in the syntax synopsis above\&amp;. They respectively create a
composite type, an
enum type, a
range type, a
base type, or a
shell type\&amp;. The first four of these are discussed in turn below\&amp;. A shell type is simply a placeholder for a type to be defined later; it is created by issuing
\fBCREATE TYPE\fR
with no parameters except for the type name\&amp;. Shell types are needed as forward references when creating range types and base types, as discussed in those sections\&amp;.
.SS "Composite Types"
.PP
The first form of
\fBCREATE TYPE\fR
creates a composite type\&amp;. The composite type is specified by a list of attribute names and data types\&amp;. An attribute\*(Aqs collation can be specified too, if its data type is collatable\&amp;. A composite type is essentially the same as the row type of a table, but using
\fBCREATE TYPE\fR
avoids the need to create an actual table when all that is wanted is to define a type\&amp;. A stand\-alone composite type is useful, for example, as the argument or return type of a function\&amp;.
.PP
To be able to create a composite type, you must have
USAGE
privilege on all attribute types\&amp;.
.SS "Enumerated Types"
.PP
The second form of
\fBCREATE TYPE\fR
creates an enumerated (enum) type, as described in
Section 8.7, \(lqEnumerated Types\(rq, in the documentation\&amp;. Enum types take a list of one or more quoted labels, each of which must be less than
NAMEDATALEN
bytes long (64 bytes in a standard
PostgreSQL
build)\&amp;.
.SS "Range Types"
.PP
The third form of
\fBCREATE TYPE\fR
creates a new range type, as described in
Section 8.17, \(lqRange Types\(rq, in the documentation\&amp;.
.PP
The range type\*(Aqs
\fIsubtype\fR
can be any type with an associated b\-tree operator class (to determine the ordering of values for the range type)\&amp;. Normally the subtype\*(Aqs default b\-tree operator class is used to determine ordering; to use a non\-default operator class, specify its name with
\fIsubtype_opclass\fR\&amp;. If the subtype is collatable, and you want to use a non\-default collation in the range\*(Aqs ordering, specify the desired collation with the
\fIcollation\fR
option\&amp;.
.PP
The optional
\fIcanonical\fR
function must take one argument of the range type being defined, and return a value of the same type\&amp;. This is used to convert range values to a canonical form, when applicable\&amp;. See
Section 8.17.8, \(lqDefining New Range Types\(rq, in the documentation
for more information\&amp;. Creating a
\fIcanonical\fR
function is a bit tricky, since it must be defined before the range type can be declared\&amp;. To do this, you must first create a shell type, which is a placeholder type that has no properties except a name and an owner\&amp;. This is done by issuing the command
CREATE TYPE \fIname\fR, with no additional parameters\&amp;. Then the function can be declared using the shell type as argument and result, and finally the range type can be declared using the same name\&amp;. This automatically replaces the shell type entry with a valid range type\&amp;.
.PP
The optional
\fIsubtype_diff\fR
function must take two values of the
\fIsubtype\fR
type as argument, and return a
double precision
value representing the difference between the two given values\&amp;. While this is optional, providing it allows much greater efficiency of GiST indexes on columns of the range type\&amp;. See
Section 8.17.8, \(lqDefining New Range Types\(rq, in the documentation
for more information\&amp;.
.SS "Base Types"
.PP
The fourth form of
\fBCREATE TYPE\fR
creates a new base type (scalar type)\&amp;. To create a new base type, you must be a superuser\&amp;. (This restriction is made because an erroneous type definition could confuse or even crash the server\&amp;.)
.PP
The parameters can appear in any order, not only that illustrated above, and most are optional\&amp;. You must register two or more functions (using
\fBCREATE FUNCTION\fR) before defining the type\&amp;. The support functions
\fIinput_function\fR
and
\fIoutput_function\fR
are required, while the functions
\fIreceive_function\fR,
\fIsend_function\fR,
\fItype_modifier_input_function\fR,
\fItype_modifier_output_function\fR
and
\fIanalyze_function\fR
are optional\&amp;. Generally these functions have to be coded in C or another low\-level language\&amp;.
.PP
The
\fIinput_function\fR
converts the type\*(Aqs external textual representation to the internal representation used by the operators and functions defined for the type\&amp;.
\fIoutput_function\fR
performs the reverse transformation\&amp;. The input function can be declared as taking one argument of type
cstring, or as taking three arguments of types
cstring,
oid,
integer\&amp;. The first argument is the input text as a C string, the second argument is the type\*(Aqs own OID (except for array types, which instead receive their element type\*(Aqs OID), and the third is the
typmod
of the destination column, if known (\-1 will be passed if not)\&amp;. The input function must return a value of the data type itself\&amp;. Usually, an input function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value\&amp;. The function must still return NULL in this case, unless it raises an error\&amp;. (This case is mainly meant to support domain input functions, which might need to reject NULL inputs\&amp;.) The output function must be declared as taking one argument of the new data type\&amp;. The output function must return type
cstring\&amp;. Output functions are not invoked for NULL values\&amp;.
.PP
The optional
\fIreceive_function\fR
converts the type\*(Aqs external binary representation to the internal representation\&amp;. If this function is not supplied, the type cannot participate in binary input\&amp;. The binary representation should be chosen to be cheap to convert to internal form, while being reasonably portable\&amp;. (For example, the standard integer data types use network byte order as the external binary representation, while the internal representation is in the machine\*(Aqs native byte order\&amp;.) The receive function should perform adequate checking to ensure that the value is valid\&amp;. The receive function can be declared as taking one argument of type
internal, or as taking three arguments of types
internal,
oid,
integer\&amp;. The first argument is a pointer to a
StringInfo
buffer holding the received byte string; the optional arguments are the same as for the text input function\&amp;. The receive function must return a value of the data type itself\&amp;. Usually, a receive function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value\&amp;. The function must still return NULL in this case, unless it raises an error\&amp;. (This case is mainly meant to support domain receive functions, which might need to reject NULL inputs\&amp;.) Similarly, the optional
\fIsend_function\fR
converts from the internal representation to the external binary representation\&amp;. If this function is not supplied, the type cannot participate in binary output\&amp;. The send function must be declared as taking one argument of the new data type\&amp;. The send function must return type
bytea\&amp;. Send functions are not invoked for NULL values\&amp;.
.PP
You should at this point be wondering how the input and output functions can be declared to have results or arguments of the new type, when they have to be created before the new type can be created\&amp;. The answer is that the type should first be defined as a
shell type, which is a placeholder type that has no properties except a name and an owner\&amp;. This is done by issuing the command
CREATE TYPE \fIname\fR, with no additional parameters\&amp;. Then the C I/O functions can be defined referencing the shell type\&amp;. Finally,
\fBCREATE TYPE\fR
with a full definition replaces the shell entry with a complete, valid type definition, after which the new type can be used normally\&amp;.
.PP
The optional
\fItype_modifier_input_function\fR
and
\fItype_modifier_output_function\fR
are needed if the type supports modifiers, that is optional constraints attached to a type declaration, such as
char(5)
or
numeric(30,2)\&amp;.
PostgreSQL
allows user\-defined types to take one or more simple constants or identifiers as modifiers\&amp;. However, this information must be capable of being packed into a single non\-negative integer value for storage in the system catalogs\&amp;. The
\fItype_modifier_input_function\fR
is passed the declared modifier(s) in the form of a
cstring
array\&amp;. It must check the values for validity (throwing an error if they are wrong), and if they are correct, return a single non\-negative
integer
value that will be stored as the column
\(lqtypmod\(rq\&amp;. Type modifiers will be rejected if the type does not have a
\fItype_modifier_input_function\fR\&amp;. The
\fItype_modifier_output_function\fR
converts the internal integer typmod value back to the correct form for user display\&amp;. It must return a
cstring
value that is the exact string to append to the type name; for example
numeric\*(Aqs function might return
(30,2)\&amp;. It is allowed to omit the
\fItype_modifier_output_function\fR, in which case the default display format is just the stored typmod integer value enclosed in parentheses\&amp;.
.PP
The optional
\fIanalyze_function\fR
performs type\-specific statistics collection for columns of the data type\&amp;. By default,
\fBANALYZE\fR
will attempt to gather statistics using the type\*(Aqs
\(lqequals\(rq
and
\(lqless\-than\(rq
operators, if there is a default b\-tree operator class for the type\&amp;. For non\-scalar types this behavior is likely to be unsuitable, so it can be overridden by specifying a custom analysis function\&amp;. The analysis function must be declared to take a single argument of type
internal, and return a
boolean
result\&amp;. The detailed API for analysis functions appears in
src/include/commands/vacuum\&amp;.h\&amp;.
.PP
While the details of the new type\*(Aqs internal representation are only known to the I/O functions and other functions you create to work with the type, there are several properties of the internal representation that must be declared to
PostgreSQL\&amp;. Foremost of these is
\fIinternallength\fR\&amp;. Base data types can be fixed\-length, in which case
\fIinternallength\fR
is a positive integer, or variable\-length, indicated by setting
\fIinternallength\fR
to
VARIABLE\&amp;. (Internally, this is represented by setting
typlen
to \-1\&amp;.) The internal representation of all variable\-length types must start with a 4\-byte integer giving the total length of this value of the type\&amp;. (Note that the length field is often encoded, as described in
Section 65.2, \(lqTOAST\(rq, in the documentation; it\*(Aqs unwise to access it directly\&amp;.)
.PP
The optional flag
PASSEDBYVALUE
indicates that values of this data type are passed by value, rather than by reference\&amp;. Types passed by value must be fixed\-length, and their internal representation cannot be larger than the size of the
Datum
type (4 bytes on some machines, 8 bytes on others)\&amp;.
.PP
The
\fIalignment\fR
parameter specifies the storage alignment required for the data type\&amp;. The allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries\&amp;. Note that variable\-length types must have an alignment of at least 4, since they necessarily contain an
int4
as their first component\&amp;.
.PP
The
\fIstorage\fR
parameter allows selection of storage strategies for variable\-length data types\&amp;. (Only
plain
is allowed for fixed\-length types\&amp;.)
plain
specifies that data of the type will always be stored in\-line and not compressed\&amp;.
extended
specifies that the system will first try to compress a long data value, and will move the value out of the main table row if it\*(Aqs still too long\&amp;.
external
allows the value to be moved out of the main table, but the system will not try to compress it\&amp;.
main
allows compression, but discourages moving the value out of the main table\&amp;. (Data items with this storage strategy might still be moved out of the main table if there is no other way to make a row fit, but they will be kept in the main table preferentially over
extended
and
external
items\&amp;.)
.PP
All
\fIstorage\fR
values other than
plain
imply that the functions of the data type can handle values that have been
toasted, as described in
Section 65.2, \(lqTOAST\(rq, in the documentation
and
Section 36.11.1, \(lqTOAST Considerations\(rq, in the documentation\&amp;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using
ALTER TABLE SET STORAGE\&amp;.
.PP
The
\fIlike_type\fR
parameter provides an alternative method for specifying the basic representation properties of a data type: copy them from some existing type\&amp;. The values of
\fIinternallength\fR,
\fIpassedbyvalue\fR,
\fIalignment\fR, and
\fIstorage\fR
are copied from the named type\&amp;. (It is possible, though usually undesirable, to override some of these values by specifying them along with the
LIKE
clause\&amp;.) Specifying representation this way is especially useful when the low\-level implementation of the new type
\(lqpiggybacks\(rq
on an existing type in some fashion\&amp;.
.PP
The
\fIcategory\fR
and
\fIpreferred\fR
parameters can be used to help control which implicit cast will be applied in ambiguous situations\&amp;. Each data type belongs to a category named by a single ASCII character, and each type is either
\(lqpreferred\(rq
or not within its category\&amp;. The parser will prefer casting to preferred types (but only from other types within the same category) when this rule is helpful in resolving overloaded functions or operators\&amp;. For more details see
Chapter 10, Type Conversion, in the documentation\&amp;. For types that have no implicit casts to or from any other types, it is sufficient to leave these settings at the defaults\&amp;. However, for a group of related types that have implicit casts, it is often helpful to mark them all as belonging to a category and select one or two of the
\(lqmost general\(rq
types as being preferred within the category\&amp;. The
\fIcategory\fR
parameter is especially useful when adding a user\-defined type to an existing built\-in category, such as the numeric or string types\&amp;. However, it is also possible to create new entirely\-user\-defined type categories\&amp;. Select any ASCII character other than an upper\-case letter to name such a category\&amp;.
.PP
A default value can be specified, in case a user wants columns of the data type to default to something other than the null value\&amp;. Specify the default with the
DEFAULT
key word\&amp;. (Such a default can be overridden by an explicit
DEFAULT
clause attached to a particular column\&amp;.)
.PP
To indicate that a type is an array, specify the type of the array elements using the
ELEMENT
key word\&amp;. For example, to define an array of 4\-byte integers (int4), specify
ELEMENT = int4\&amp;. More details about array types appear below\&amp;.
.PP
To indicate the delimiter to be used between values in the external representation of arrays of this type,
\fIdelimiter\fR
can be set to a specific character\&amp;. The default delimiter is the comma (,)\&amp;. Note that the delimiter is associated with the array element type, not the array type itself\&amp;.
.PP
If the optional Boolean parameter
\fIcollatable\fR
is true, column definitions and expressions of the type may carry collation information through use of the
COLLATE
clause\&amp;. It is up to the implementations of the functions operating on the type to actually make use of the collation information; this does not happen automatically merely by marking the type collatable\&amp;.
.SS "Array Types"
.PP
Whenever a user\-defined type is created,
PostgreSQL
automatically creates an associated array type, whose name consists of the element type\*(Aqs name prepended with an underscore, and truncated if necessary to keep it less than
NAMEDATALEN
bytes long\&amp;. (If the name so generated collides with an existing type name, the process is repeated until a non\-colliding name is found\&amp;.) This implicitly\-created array type is variable length and uses the built\-in input and output functions
array_in
and
array_out\&amp;. The array type tracks any changes in its element type\*(Aqs owner or schema, and is dropped if the element type is\&amp;.
.PP
You might reasonably ask why there is an
\fBELEMENT\fR
option, if the system makes the correct array type automatically\&amp;. The only case where it\*(Aqs useful to use
\fBELEMENT\fR
is when you are making a fixed\-length type that happens to be internally an array of a number of identical things, and you want to allow these things to be accessed directly by subscripting, in addition to whatever operations you plan to provide for the type as a whole\&amp;. For example, type
point
is represented as just two floating\-point numbers, which can be accessed using
point[0]
and
point[1]\&amp;. Note that this facility only works for fixed\-length types whose internal form is exactly a sequence of identical fixed\-length fields\&amp;. A subscriptable variable\-length type must have the generalized internal representation used by
array_in
and
array_out\&amp;. For historical reasons (i\&amp;.e\&amp;., this is clearly wrong but it\*(Aqs far too late to change it), subscripting of fixed\-length array types starts from zero, rather than from one as for variable\-length arrays\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of a type to be created\&amp;.
.RE
.PP
\fIattribute_name\fR
.RS 4
The name of an attribute (column) for the composite type\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
The name of an existing data type to become a column of the composite type\&amp;.
.RE
.PP
\fIcollation\fR
.RS 4
The name of an existing collation to be associated with a column of a composite type, or with a range type\&amp;.
.RE
.PP
\fIlabel\fR
.RS 4
A string literal representing the textual label associated with one value of an enum type\&amp;.
.RE
.PP
\fIsubtype\fR
.RS 4
The name of the element type that the range type will represent ranges of\&amp;.
.RE
.PP
\fIsubtype_operator_class\fR
.RS 4
The name of a b\-tree operator class for the subtype\&amp;.
.RE
.PP
\fIcanonical_function\fR
.RS 4
The name of the canonicalization function for the range type\&amp;.
.RE
.PP
\fIsubtype_diff_function\fR
.RS 4
The name of a difference function for the subtype\&amp;.
.RE
.PP
\fIinput_function\fR
.RS 4
The name of a function that converts data from the type\*(Aqs external textual form to its internal form\&amp;.
.RE
.PP
\fIoutput_function\fR
.RS 4
The name of a function that converts data from the type\*(Aqs internal form to its external textual form\&amp;.
.RE
.PP
\fIreceive_function\fR
.RS 4
The name of a function that converts data from the type\*(Aqs external binary form to its internal form\&amp;.
.RE
.PP
\fIsend_function\fR
.RS 4
The name of a function that converts data from the type\*(Aqs internal form to its external binary form\&amp;.
.RE
.PP
\fItype_modifier_input_function\fR
.RS 4
The name of a function that converts an array of modifier(s) for the type into internal form\&amp;.
.RE
.PP
\fItype_modifier_output_function\fR
.RS 4
The name of a function that converts the internal form of the type\*(Aqs modifier(s) to external textual form\&amp;.
.RE
.PP
\fIanalyze_function\fR
.RS 4
The name of a function that performs statistical analysis for the data type\&amp;.
.RE
.PP
\fIinternallength\fR
.RS 4
A numeric constant that specifies the length in bytes of the new type\*(Aqs internal representation\&amp;. The default assumption is that it is variable\-length\&amp;.
.RE
.PP
\fIalignment\fR
.RS 4
The storage alignment requirement of the data type\&amp;. If specified, it must be
char,
int2,
int4, or
double; the default is
int4\&amp;.
.RE
.PP
\fIstorage\fR
.RS 4
The storage strategy for the data type\&amp;. If specified, must be
plain,
external,
extended, or
main; the default is
plain\&amp;.
.RE
.PP
\fIlike_type\fR
.RS 4
The name of an existing data type that the new type will have the same representation as\&amp;. The values of
\fIinternallength\fR,
\fIpassedbyvalue\fR,
\fIalignment\fR, and
\fIstorage\fR
are copied from that type, unless overridden by explicit specification elsewhere in this
\fBCREATE TYPE\fR
command\&amp;.
.RE
.PP
\fIcategory\fR
.RS 4
The category code (a single ASCII character) for this type\&amp;. The default is
\*(AqU\*(Aq
for
\(lquser\-defined type\(rq\&amp;. Other standard category codes can be found in
Table\ \&amp;50.56, \(lqtypcategory Codes\(rq\&amp;. You may also choose other ASCII characters in order to create custom categories\&amp;.
.RE
.PP
\fIpreferred\fR
.RS 4
True if this type is a preferred type within its type category, else false\&amp;. The default is false\&amp;. Be very careful about creating a new preferred type within an existing type category, as this could cause surprising changes in behavior\&amp;.
.RE
.PP
\fIdefault\fR
.RS 4
The default value for the data type\&amp;. If this is omitted, the default is null\&amp;.
.RE
.PP
\fIelement\fR
.RS 4
The type being created is an array; this specifies the type of the array elements\&amp;.
.RE
.PP
\fIdelimiter\fR
.RS 4
The delimiter character to be used between values in arrays made of this type\&amp;.
.RE
.PP
\fIcollatable\fR
.RS 4
True if this type\*(Aqs operations can use collation information\&amp;. The default is false\&amp;.
.RE
.SH "NOTES"
.PP
Because there are no restrictions on use of a data type once it\*(Aqs been created, creating a base type or range type is tantamount to granting public execute permission on the functions mentioned in the type definition\&amp;. This is usually not an issue for the sorts of functions that are useful in a type definition\&amp;. But you might want to think twice before designing a type in a way that would require
\(lqsecret\(rq
information to be used while converting it to or from external form\&amp;.
.PP
Before
PostgreSQL
version 8\&amp;.3, the name of a generated array type was always exactly the element type\*(Aqs name with one underscore character (_) prepended\&amp;. (Type names were therefore restricted in length to one less character than other names\&amp;.) While this is still usually the case, the array type name may vary from this in case of maximum\-length names or collisions with user type names that begin with underscore\&amp;. Writing code that depends on this convention is therefore deprecated\&amp;. Instead, use
pg_type\&amp;.typarray
to locate the array type associated with a given type\&amp;.
.PP
It may be advisable to avoid using type and table names that begin with underscore\&amp;. While the server will change generated array type names to avoid collisions with user\-given names, there is still risk of confusion, particularly with old client software that may assume that type names beginning with underscores always represent arrays\&amp;.
.PP
Before
PostgreSQL
version 8\&amp;.2, the shell\-type creation syntax
CREATE TYPE \fIname\fR
did not exist\&amp;. The way to create a new base type was to create its input function first\&amp;. In this approach,
PostgreSQL
will first see the name of the new data type as the return type of the input function\&amp;. The shell type is implicitly created in this situation, and then it can be referenced in the definitions of the remaining I/O functions\&amp;. This approach still works, but is deprecated and might be disallowed in some future release\&amp;. Also, to avoid accidentally cluttering the catalogs with shell types as a result of simple typos in function definitions, a shell type will only be made this way when the input function is written in C\&amp;.
.PP
In
PostgreSQL
versions before 7\&amp;.3, it was customary to avoid creating a shell type at all, by replacing the functions\*(Aq forward references to the type name with the placeholder pseudotype
opaque\&amp;. The
cstring
arguments and results also had to be declared as
opaque
before 7\&amp;.3\&amp;. To support loading of old dump files,
\fBCREATE TYPE\fR
will accept I/O functions declared using
opaque, but it will issue a notice and change the function declarations to use the correct types\&amp;.
.SH "EXAMPLES"
.PP
This example creates a composite type and uses it in a function definition:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
.fi
.if n \{\
.RE
.\}
.PP
This example creates an enumerated type and uses it in a table definition:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE bug_status AS ENUM (\*(Aqnew\*(Aq, \*(Aqopen\*(Aq, \*(Aqclosed\*(Aq);

CREATE TABLE bug (
id serial,
description text,
status bug_status
);
.fi
.if n \{\
.RE
.\}
.PP
This example creates a range type:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
.fi
.if n \{\
.RE
.\}
.PP
This example creates the base data type
box
and then uses the type in a table definition:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS \&amp;.\&amp;.\&amp;. ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS \&amp;.\&amp;.\&amp;. ;

CREATE TYPE box (
INTERNALLENGTH = 16,
INPUT = my_box_in_function,
OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
id integer,
description box
);
.fi
.if n \{\
.RE
.\}
.PP
If the internal structure of
box
were an array of four
float4
elements, we might instead use:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE box (
INTERNALLENGTH = 16,
INPUT = my_box_in_function,
OUTPUT = my_box_out_function,
ELEMENT = float4
);
.fi
.if n \{\
.RE
.\}
.sp
which would allow a box value\*(Aqs component numbers to be accessed by subscripting\&amp;. Otherwise the type behaves the same as before\&amp;.
.PP
This example creates a large object type and uses it in a table definition:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE TYPE bigobj (
INPUT = lo_filein, OUTPUT = lo_fileout,
INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
id integer,
obj bigobj
);
.fi
.if n \{\
.RE
.\}
.PP
More examples, including suitable input and output functions, are in
Section 36.11, \(lqUser-defined Types\(rq, in the documentation\&amp;.
.SH "COMPATIBILITY"
.PP
The first form of the
\fBCREATE TYPE\fR
command, which creates a composite type, conforms to the
SQL
standard\&amp;. The other forms are
PostgreSQL
extensions\&amp;. The
\fBCREATE TYPE\fR
statement in the
SQL
standard also defines other forms that are not implemented in
PostgreSQL\&amp;.
.PP
The ability to create a composite type with zero attributes is a
PostgreSQL\-specific deviation from the standard (analogous to the same case in
\fBCREATE TABLE\fR)\&amp;.
.SH "SEE ALSO"
ALTER TYPE (\fBALTER_TYPE\fR(7)), CREATE DOMAIN (\fBCREATE_DOMAIN\fR(7)), CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)), DROP TYPE (\fBDROP_TYPE\fR(7))
'\" t
.\"     Title: CREATE USER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE USER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_USER \- define a new database role
.SH "SYNOPSIS"
.sp
.nf
CREATE USER \fIname\fR [ [ WITH ] \fIoption\fR [ \&amp;.\&amp;.\&amp;. ] ]

where \fIoption\fR can be:

SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| REPLICATION | NOREPLICATION
| BYPASSRLS | NOBYPASSRLS
| CONNECTION LIMIT \fIconnlimit\fR
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD \*(Aq\fIpassword\fR\*(Aq
| VALID UNTIL \*(Aq\fItimestamp\fR\*(Aq
| IN ROLE \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| IN GROUP \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| ROLE \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| ADMIN \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| USER \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
| SYSID \fIuid\fR
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE USER\fR
is now an alias for
CREATE ROLE (\fBCREATE_ROLE\fR(7))\&amp;. The only difference is that when the command is spelled
\fBCREATE USER\fR,
LOGIN
is assumed by default, whereas
NOLOGIN
is assumed when the command is spelled
\fBCREATE ROLE\fR\&amp;.
.SH "COMPATIBILITY"
.PP
The
\fBCREATE USER\fR
statement is a
PostgreSQL
extension\&amp;. The SQL standard leaves the definition of users to the implementation\&amp;.
.SH "SEE ALSO"
CREATE ROLE (\fBCREATE_ROLE\fR(7))
'\" t
.\"     Title: CREATE USER MAPPING
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE USER MAPPING" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_USER_MAPPING \- define a new mapping of a user to a foreign server
.SH "SYNOPSIS"
.sp
.nf
CREATE USER MAPPING FOR { \fIuser_name\fR | USER | CURRENT_USER | PUBLIC }
SERVER \fIserver_name\fR
[ OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [ , \&amp;.\&amp;.\&amp;. ] ) ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE USER MAPPING\fR
defines a mapping of a user to a foreign server\&amp;. A user mapping typically encapsulates connection information that a foreign\-data wrapper uses together with the information encapsulated by a foreign server to access an external data resource\&amp;.
.PP
The owner of a foreign server can create user mappings for that server for any user\&amp;. Also, a user can create a user mapping for their own user name if
USAGE
privilege on the server has been granted to the user\&amp;.
.SH "PARAMETERS"
.PP
\fIuser_name\fR
.RS 4
The name of an existing user that is mapped to foreign server\&amp;.
CURRENT_USER
and
USER
match the name of the current user\&amp;. When
PUBLIC
is specified, a so\-called public mapping is created that is used when no user\-specific mapping is applicable\&amp;.
.RE
.PP
\fIserver_name\fR
.RS 4
The name of an existing server for which the user mapping is to be created\&amp;.
.RE
.PP
OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This clause specifies the options of the user mapping\&amp;. The options typically define the actual user name and password of the mapping\&amp;. Option names must be unique\&amp;. The allowed option names and values are specific to the server\*(Aqs foreign\-data wrapper\&amp;.
.RE
.SH "EXAMPLES"
.PP
Create a user mapping for user
bob, server
foo:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE USER MAPPING FOR bob SERVER foo OPTIONS (user \*(Aqbob\*(Aq, password \*(Aqsecret\*(Aq);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBCREATE USER MAPPING\fR
conforms to ISO/IEC 9075\-9 (SQL/MED)\&amp;.
.SH "SEE ALSO"
ALTER USER MAPPING (\fBALTER_USER_MAPPING\fR(7)), DROP USER MAPPING (\fBDROP_USER_MAPPING\fR(7)), CREATE FOREIGN DATA WRAPPER (\fBCREATE_FOREIGN_DATA_WRAPPER\fR(7)), CREATE SERVER (\fBCREATE_SERVER\fR(7))
'\" t
.\"     Title: CREATE VIEW
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "CREATE VIEW" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
CREATE_VIEW \- define a new view
.SH "SYNOPSIS"
.sp
.nf
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW \fIname\fR [ ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ]
[ WITH ( \fIview_option_name\fR [= \fIview_option_value\fR] [, \&amp;.\&amp;.\&amp;. ] ) ]
AS \fIquery\fR
[ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
.fi
.SH "DESCRIPTION"
.PP
\fBCREATE VIEW\fR
defines a view of a query\&amp;. The view is not physically materialized\&amp;. Instead, the query is run every time the view is referenced in a query\&amp;.
.PP
\fBCREATE OR REPLACE VIEW\fR
is similar, but if a view of the same name already exists, it is replaced\&amp;. The new query must generate the same columns that were generated by the existing view query (that is, the same column names in the same order and with the same data types), but it may add additional columns to the end of the list\&amp;. The calculations giving rise to the output columns may be completely different\&amp;.
.PP
If a schema name is given (for example,
CREATE VIEW myschema\&amp;.myview \&amp;.\&amp;.\&amp;.) then the view is created in the specified schema\&amp;. Otherwise it is created in the current schema\&amp;. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view\&amp;. The name of the view must be distinct from the name of any other view, table, sequence, index or foreign table in the same schema\&amp;.
.SH "PARAMETERS"
.PP
TEMPORARY or TEMP
.RS 4
If specified, the view is created as a temporary view\&amp;. Temporary views are automatically dropped at the end of the current session\&amp;. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema\-qualified names\&amp;.
.sp
If any of the tables referenced by the view are temporary, the view is created as a temporary view (whether
TEMPORARY
is specified or not)\&amp;.
.RE
.PP
RECURSIVE
.RS 4
Creates a recursive view\&amp;. The syntax
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE RECURSIVE VIEW [ \fIschema\fR \&amp;. ] \fIview_name\fR (\fIcolumn_names\fR) AS SELECT \fI\&amp;.\&amp;.\&amp;.\fR;
.fi
.if n \{\
.RE
.\}
.sp
is equivalent to
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE VIEW [ \fIschema\fR \&amp;. ] \fIview_name\fR AS WITH RECURSIVE \fIview_name\fR (\fIcolumn_names\fR) AS (SELECT \fI\&amp;.\&amp;.\&amp;.\fR) SELECT \fIcolumn_names\fR FROM \fIview_name\fR;
.fi
.if n \{\
.RE
.\}
.sp
A view column name list must be specified for a recursive view\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of a view to be created\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
An optional list of names to be used for columns of the view\&amp;. If not given, the column names are deduced from the query\&amp;.
.RE
.PP
WITH ( \fIview_option_name\fR [= \fIview_option_value\fR] [, \&amp;.\&amp;.\&amp;. ] )
.RS 4
This clause specifies optional parameters for a view; the following parameters are supported:
.PP
check_option (string)
.RS 4
This parameter may be either
local
or
cascaded, and is equivalent to specifying
WITH [ CASCADED | LOCAL ] CHECK OPTION
(see below)\&amp;. This option can be changed on existing views using
ALTER VIEW (\fBALTER_VIEW\fR(7))\&amp;.
.RE
.PP
security_barrier (boolean)
.RS 4
This should be used if the view is intended to provide row\-level security\&amp;. See
Section 39.5, \(lqRules and Privileges\(rq, in the documentation
for full details\&amp;.
.RE
.sp
.RE
.PP
\fIquery\fR
.RS 4
A
\fBSELECT\fR(7)
or
\fBVALUES\fR(7)
command which will provide the columns and rows of the view\&amp;.
.RE
.PP
WITH [ CASCADED | LOCAL ] CHECK OPTION
.RS 4
This option controls the behavior of automatically updatable views\&amp;. When this option is specified,
\fBINSERT\fR
and
\fBUPDATE\fR
commands on the view will be checked to ensure that new rows satisfy the view\-defining condition (that is, the new rows are checked to ensure that they are visible through the view)\&amp;. If they are not, the update will be rejected\&amp;. If the
CHECK OPTION
is not specified,
\fBINSERT\fR
and
\fBUPDATE\fR
commands on the view are allowed to create rows that are not visible through the view\&amp;. The following check options are supported:
.PP
LOCAL
.RS 4
New rows are only checked against the conditions defined directly in the view itself\&amp;. Any conditions defined on underlying base views are not checked (unless they also specify the
CHECK OPTION)\&amp;.
.RE
.PP
CASCADED
.RS 4
New rows are checked against the conditions of the view and all underlying base views\&amp;. If the
CHECK OPTION
is specified, and neither
LOCAL
nor
CASCADED
is specified, then
CASCADED
is assumed\&amp;.
.RE
.sp
The
CHECK OPTION
may not be used with
RECURSIVE
views\&amp;.
.sp
Note that the
CHECK OPTION
is only supported on views that are automatically updatable, and do not have
INSTEAD OF
triggers or
INSTEAD
rules\&amp;. If an automatically updatable view is defined on top of a base view that has
INSTEAD OF
triggers, then the
LOCAL CHECK OPTION
may be used to check the conditions on the automatically updatable view, but the conditions on the base view with
INSTEAD OF
triggers will not be checked (a cascaded check option will not cascade down to a trigger\-updatable view, and any check options defined directly on a trigger\-updatable view will be ignored)\&amp;. If the view or any of its base relations has an
INSTEAD
rule that causes the
\fBINSERT\fR
or
\fBUPDATE\fR
command to be rewritten, then all check options will be ignored in the rewritten query, including any checks from automatically updatable views defined on top of the relation with the
INSTEAD
rule\&amp;.
.RE
.SH "NOTES"
.PP
Use the
DROP VIEW (\fBDROP_VIEW\fR(7))
statement to drop views\&amp;.
.PP
Be careful that the names and types of the view\*(Aqs columns will be assigned the way you want\&amp;. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE VIEW vista AS SELECT \*(AqHello World\*(Aq;
.fi
.if n \{\
.RE
.\}
.sp
is bad form in two ways: the column name defaults to
?column?, and the column data type defaults to
unknown\&amp;. If you want a string literal in a view\*(Aqs result, use something like:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE VIEW vista AS SELECT text \*(AqHello World\*(Aq AS hello;
.fi
.if n \{\
.RE
.\}
.PP
Access to tables referenced in the view is determined by permissions of the view owner\&amp;. In some cases, this can be used to provide secure but restricted access to the underlying tables\&amp;. However, not all views are secure against tampering; see
Section 39.5, \(lqRules and Privileges\(rq, in the documentation
for details\&amp;. Functions called in the view are treated the same as if they had been called directly from the query using the view\&amp;. Therefore the user of a view must have permissions to call all functions used by the view\&amp;.
.PP
When
\fBCREATE OR REPLACE VIEW\fR
is used on an existing view, only the view\*(Aqs defining SELECT rule is changed\&amp;. Other view properties, including ownership, permissions, and non\-SELECT rules, remain unchanged\&amp;. You must own the view to replace it (this includes being a member of the owning role)\&amp;.
.SS "Updatable Views"
.PP
Simple views are automatically updatable: the system will allow
\fBINSERT\fR,
\fBUPDATE\fR
and
\fBDELETE\fR
statements to be used on the view in the same way as on a regular table\&amp;. A view is automatically updatable if it satisfies all of the following conditions:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The view must have exactly one entry in its
FROM
list, which must be a table or another updatable view\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The view definition must not contain
WITH,
DISTINCT,
GROUP BY,
HAVING,
LIMIT, or
OFFSET
clauses at the top level\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The view definition must not contain set operations (UNION,
INTERSECT
or
EXCEPT) at the top level\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The view\*(Aqs select list must not contain any aggregates, window functions or set\-returning functions\&amp;.
.RE
.PP
An automatically updatable view may contain a mix of updatable and non\-updatable columns\&amp;. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read\-only, and an error will be raised if an
\fBINSERT\fR
or
\fBUPDATE\fR
statement attempts to assign a value to it\&amp;.
.PP
If the view is automatically updatable the system will convert any
\fBINSERT\fR,
\fBUPDATE\fR
or
\fBDELETE\fR
statement on the view into the corresponding statement on the underlying base relation\&amp;.
\fBINSERT\fR
statements that have an
ON CONFLICT UPDATE
clause are fully supported\&amp;.
.PP
If an automatically updatable view contains a
WHERE
condition, the condition restricts which rows of the base relation are available to be modified by
\fBUPDATE\fR
and
\fBDELETE\fR
statements on the view\&amp;. However, an
\fBUPDATE\fR
is allowed to change a row so that it no longer satisfies the
WHERE
condition, and thus is no longer visible through the view\&amp;. Similarly, an
\fBINSERT\fR
command can potentially insert base\-relation rows that do not satisfy the
WHERE
condition and thus are not visible through the view (ON CONFLICT UPDATE
may similarly affect an existing row not visible through the view)\&amp;. The
CHECK OPTION
may be used to prevent
\fBINSERT\fR
and
\fBUPDATE\fR
commands from creating such rows that are not visible through the view\&amp;.
.PP
If an automatically updatable view is marked with the
security_barrier
property then all the view\*(Aqs
WHERE
conditions (and any conditions using operators which are marked as
LEAKPROOF) will always be evaluated before any conditions that a user of the view has added\&amp;. See
Section 39.5, \(lqRules and Privileges\(rq, in the documentation
for full details\&amp;. Note that, due to this, rows which are not ultimately returned (because they do not pass the user\*(Aqs
WHERE
conditions) may still end up being locked\&amp;.
\fBEXPLAIN\fR
can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not\&amp;.
.PP
A more complex view that does not satisfy all these conditions is read\-only by default: the system will not allow an insert, update, or delete on the view\&amp;. You can get the effect of an updatable view by creating
INSTEAD OF
triggers on the view, which must convert attempted inserts, etc\&amp;. on the view into appropriate actions on other tables\&amp;. For more information see
CREATE TRIGGER (\fBCREATE_TRIGGER\fR(7))\&amp;. Another possibility is to create rules (see
CREATE RULE (\fBCREATE_RULE\fR(7))), but in practice triggers are easier to understand and use correctly\&amp;.
.PP
Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view\&amp;. In addition the view\*(Aqs owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see
Section 39.5, \(lqRules and Privileges\(rq, in the documentation)\&amp;.
.SH "EXAMPLES"
.PP
Create a view consisting of all comedy films:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE VIEW comedies AS
SELECT *
FROM films
WHERE kind = \*(AqComedy\*(Aq;
.fi
.if n \{\
.RE
.\}
.sp
This will create a view containing the columns that are in the
film
table at the time of view creation\&amp;. Though
*
was used to create the view, columns added later to the table will not be part of the view\&amp;.
.PP
Create a view with
LOCAL CHECK OPTION:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE VIEW universal_comedies AS
SELECT *
FROM comedies
WHERE classification = \*(AqU\*(Aq
WITH LOCAL CHECK OPTION;
.fi
.if n \{\
.RE
.\}
.sp
This will create a view based on the
comedies
view, showing only films with
kind = \*(AqComedy\*(Aq
and
classification = \*(AqU\*(Aq\&amp;. Any attempt to
\fBINSERT\fR
or
\fBUPDATE\fR
a row in the view will be rejected if the new row doesn\*(Aqt have
classification = \*(AqU\*(Aq, but the film
kind
will not be checked\&amp;.
.PP
Create a view with
CASCADED CHECK OPTION:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE VIEW pg_comedies AS
SELECT *
FROM comedies
WHERE classification = \*(AqPG\*(Aq
WITH CASCADED CHECK OPTION;
.fi
.if n \{\
.RE
.\}
.sp
This will create a view that checks both the
kind
and
classification
of new rows\&amp;.
.PP
Create a view with a mix of updatable and non\-updatable columns:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE VIEW comedies AS
SELECT f\&amp;.*,
country_code_to_name(f\&amp;.country_code) AS country,
(SELECT avg(r\&amp;.rating)
FROM user_ratings r
WHERE r\&amp;.film_id = f\&amp;.id) AS avg_rating
FROM films f
WHERE f\&amp;.kind = \*(AqComedy\*(Aq;
.fi
.if n \{\
.RE
.\}
.sp
This view will support
\fBINSERT\fR,
\fBUPDATE\fR
and
\fBDELETE\fR\&amp;. All the columns from the
films
table will be updatable, whereas the computed columns
country
and
avg_rating
will be read\-only\&amp;.
.PP
Create a recursive view consisting of the numbers from 1 to 100:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE RECURSIVE VIEW public\&amp;.nums_1_100 (n) AS
VALUES (1)
UNION ALL
SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;
.fi
.if n \{\
.RE
.\}
.sp
Notice that although the recursive view\*(Aqs name is schema\-qualified in this
\fBCREATE\fR, its internal self\-reference is not schema\-qualified\&amp;. This is because the implicitly\-created CTE\*(Aqs name cannot be schema\-qualified\&amp;.
.SH "COMPATIBILITY"
.PP
\fBCREATE OR REPLACE VIEW\fR
is a
PostgreSQL
language extension\&amp;. So is the concept of a temporary view\&amp;. The
WITH ( \&amp;.\&amp;.\&amp;. )
clause is an extension as well\&amp;.
.SH "SEE ALSO"
ALTER VIEW (\fBALTER_VIEW\fR(7)), DROP VIEW (\fBDROP_VIEW\fR(7)), CREATE MATERIALIZED VIEW (\fBCREATE_MATERIALIZED_VIEW\fR(7))
'\" t
.\"     Title: DEALLOCATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DEALLOCATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DEALLOCATE \- deallocate a prepared statement
.SH "SYNOPSIS"
.sp
.nf
DEALLOCATE [ PREPARE ] { \fIname\fR | ALL }
.fi
.SH "DESCRIPTION"
.PP
\fBDEALLOCATE\fR
is used to deallocate a previously prepared SQL statement\&amp;. If you do not explicitly deallocate a prepared statement, it is deallocated when the session ends\&amp;.
.PP
For more information on prepared statements, see
\fBPREPARE\fR(7)\&amp;.
.SH "PARAMETERS"
.PP
PREPARE
.RS 4
This key word is ignored\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the prepared statement to deallocate\&amp;.
.RE
.PP
ALL
.RS 4
Deallocate all prepared statements\&amp;.
.RE
.SH "COMPATIBILITY"
.PP
The SQL standard includes a
\fBDEALLOCATE\fR
statement, but it is only for use in embedded SQL\&amp;.
.SH "SEE ALSO"
\fBEXECUTE\fR(7), \fBPREPARE\fR(7)
'\" t
.\"     Title: DECLARE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DECLARE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DECLARE \- define a cursor
.SH "SYNOPSIS"
.sp
.nf
DECLARE \fIname\fR [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]
CURSOR [ { WITH | WITHOUT } HOLD ] FOR \fIquery\fR
.fi
.SH "DESCRIPTION"
.PP
\fBDECLARE\fR
allows a user to create cursors, which can be used to retrieve a small number of rows at a time out of a larger query\&amp;. After the cursor is created, rows are fetched from it using
\fBFETCH\fR(7)\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This page describes usage of cursors at the SQL command level\&amp;. If you are trying to use cursors inside a
PL/pgSQL
function, the rules are different \(em see
Section 41.7, \(lqCursors\(rq, in the documentation\&amp;.
.sp .5v
.RE
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the cursor to be created\&amp;.
.RE
.PP
BINARY
.RS 4
Causes the cursor to return data in binary rather than in text format\&amp;.
.RE
.PP
INSENSITIVE
.RS 4
Indicates that data retrieved from the cursor should be unaffected by updates to the table(s) underlying the cursor that occur after the cursor is created\&amp;. In
PostgreSQL, this is the default behavior; so this key word has no effect and is only accepted for compatibility with the SQL standard\&amp;.
.RE
.PP
SCROLL
.br
NO SCROLL
.RS 4
SCROLL
specifies that the cursor can be used to retrieve rows in a nonsequential fashion (e\&amp;.g\&amp;., backward)\&amp;. Depending upon the complexity of the query\*(Aqs execution plan, specifying
SCROLL
might impose a performance penalty on the query\*(Aqs execution time\&amp;.
NO SCROLL
specifies that the cursor cannot be used to retrieve rows in a nonsequential fashion\&amp;. The default is to allow scrolling in some cases; this is not the same as specifying
SCROLL\&amp;. See
NOTES
for details\&amp;.
.RE
.PP
WITH HOLD
.br
WITHOUT HOLD
.RS 4
WITH HOLD
specifies that the cursor can continue to be used after the transaction that created it successfully commits\&amp;.
WITHOUT HOLD
specifies that the cursor cannot be used outside of the transaction that created it\&amp;. If neither
WITHOUT HOLD
nor
WITH HOLD
is specified,
WITHOUT HOLD
is the default\&amp;.
.RE
.PP
\fIquery\fR
.RS 4
A
\fBSELECT\fR(7)
or
\fBVALUES\fR(7)
command which will provide the rows to be returned by the cursor\&amp;.
.RE
.PP
The key words
BINARY,
INSENSITIVE, and
SCROLL
can appear in any order\&amp;.
.SH "NOTES"
.PP
Normal cursors return data in text format, the same as a
\fBSELECT\fR
would produce\&amp;. The
BINARY
option specifies that the cursor should return data in binary format\&amp;. This reduces conversion effort for both the server and client, at the cost of more programmer effort to deal with platform\-dependent binary data formats\&amp;. As an example, if a query returns a value of one from an integer column, you would get a string of
1
with a default cursor, whereas with a binary cursor you would get a 4\-byte field containing the internal representation of the value (in big\-endian byte order)\&amp;.
.PP
Binary cursors should be used carefully\&amp;. Many applications, including
psql, are not prepared to handle binary cursors and expect data to come back in the text format\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
When the client application uses the
\(lqextended query\(rq
protocol to issue a
\fBFETCH\fR
command, the Bind protocol message specifies whether data is to be retrieved in text or binary format\&amp;. This choice overrides the way that the cursor is defined\&amp;. The concept of a binary cursor as such is thus obsolete when using extended query protocol \(em any cursor can be treated as either text or binary\&amp;.
.sp .5v
.RE
.PP
Unless
WITH HOLD
is specified, the cursor created by this command can only be used within the current transaction\&amp;. Thus,
\fBDECLARE\fR
without
WITH HOLD
is useless outside a transaction block: the cursor would survive only to the completion of the statement\&amp;. Therefore
PostgreSQL
reports an error if such a command is used outside a transaction block\&amp;. Use
\fBBEGIN\fR(7)
and
\fBCOMMIT\fR(7)
(or
\fBROLLBACK\fR(7)) to define a transaction block\&amp;.
.PP
If
WITH HOLD
is specified and the transaction that created the cursor successfully commits, the cursor can continue to be accessed by subsequent transactions in the same session\&amp;. (But if the creating transaction is aborted, the cursor is removed\&amp;.) A cursor created with
WITH HOLD
is closed when an explicit
\fBCLOSE\fR
command is issued on it, or the session ends\&amp;. In the current implementation, the rows represented by a held cursor are copied into a temporary file or memory area so that they remain available for subsequent transactions\&amp;.
.PP
WITH HOLD
may not be specified when the query includes
FOR UPDATE
or
FOR SHARE\&amp;.
.PP
The
SCROLL
option should be specified when defining a cursor that will be used to fetch backwards\&amp;. This is required by the SQL standard\&amp;. However, for compatibility with earlier versions,
PostgreSQL
will allow backward fetches without
SCROLL, if the cursor\*(Aqs query plan is simple enough that no extra overhead is needed to support it\&amp;. However, application developers are advised not to rely on using backward fetches from a cursor that has not been created with
SCROLL\&amp;. If
NO SCROLL
is specified, then backward fetches are disallowed in any case\&amp;.
.PP
Backward fetches are also disallowed when the query includes
FOR UPDATE
or
FOR SHARE; therefore
SCROLL
may not be specified in this case\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBCaution\fR
.ps -1
.br
.PP
Scrollable and
WITH HOLD
cursors may give unexpected results if they invoke any volatile functions (see
Section 36.6, \(lqFunction Volatility Categories\(rq, in the documentation)\&amp;. When a previously fetched row is re\-fetched, the functions might be re\-executed, perhaps leading to results different from the first time\&amp;. One workaround for such cases is to declare the cursor
WITH HOLD
and commit the transaction before reading any rows from it\&amp;. This will force the entire output of the cursor to be materialized in temporary storage, so that volatile functions are executed exactly once for each row\&amp;.
.sp .5v
.RE
.PP
If the cursor\*(Aqs query includes
FOR UPDATE
or
FOR SHARE, then returned rows are locked at the time they are first fetched, in the same way as for a regular
\fBSELECT\fR(7)
command with these options\&amp;. In addition, the returned rows will be the most up\-to\-date versions; therefore these options provide the equivalent of what the SQL standard calls a
\(lqsensitive cursor\(rq\&amp;. (Specifying
INSENSITIVE
together with
FOR UPDATE
or
FOR SHARE
is an error\&amp;.)
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBCaution\fR
.ps -1
.br
.PP
It is generally recommended to use
FOR UPDATE
if the cursor is intended to be used with
\fBUPDATE \&amp;.\&amp;.\&amp;. WHERE CURRENT OF\fR
or
\fBDELETE \&amp;.\&amp;.\&amp;. WHERE CURRENT OF\fR\&amp;. Using
FOR UPDATE
prevents other sessions from changing the rows between the time they are fetched and the time they are updated\&amp;. Without
FOR UPDATE, a subsequent
WHERE CURRENT OF
command will have no effect if the row was changed since the cursor was created\&amp;.
.PP
Another reason to use
FOR UPDATE
is that without it, a subsequent
WHERE CURRENT OF
might fail if the cursor query does not meet the SQL standard\*(Aqs rules for being
\(lqsimply updatable\(rq
(in particular, the cursor must reference just one table and not use grouping or
ORDER BY)\&amp;. Cursors that are not simply updatable might work, or might not, depending on plan choice details; so in the worst case, an application might work in testing and then fail in production\&amp;.
.PP
The main reason not to use
FOR UPDATE
with
WHERE CURRENT OF
is if you need the cursor to be scrollable, or to be insensitive to the subsequent updates (that is, continue to show the old data)\&amp;. If this is a requirement, pay close heed to the caveats shown above\&amp;.
.sp .5v
.RE
.PP
The SQL standard only makes provisions for cursors in embedded
SQL\&amp;. The
PostgreSQL
server does not implement an
\fBOPEN\fR
statement for cursors; a cursor is considered to be open when it is declared\&amp;. However,
ECPG, the embedded SQL preprocessor for
PostgreSQL, supports the standard SQL cursor conventions, including those involving
\fBDECLARE\fR
and
\fBOPEN\fR
statements\&amp;.
.PP
You can see all available cursors by querying the
pg_cursors
system view\&amp;.
.SH "EXAMPLES"
.PP
To declare a cursor:
.sp
.if n \{\
.RS 4
.\}
.nf
DECLARE liahona CURSOR FOR SELECT * FROM films;
.fi
.if n \{\
.RE
.\}
.sp
See
\fBFETCH\fR(7)
for more examples of cursor usage\&amp;.
.SH "COMPATIBILITY"
.PP
The SQL standard says that it is implementation\-dependent whether cursors are sensitive to concurrent updates of the underlying data by default\&amp;. In
PostgreSQL, cursors are insensitive by default, and can be made sensitive by specifying
FOR UPDATE\&amp;. Other products may work differently\&amp;.
.PP
The SQL standard allows cursors only in embedded
SQL
and in modules\&amp;.
PostgreSQL
permits cursors to be used interactively\&amp;.
.PP
Binary cursors are a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
\fBCLOSE\fR(7), \fBFETCH\fR(7), \fBMOVE\fR(7)
'\" t
.\"     Title: DELETE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DELETE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DELETE \- delete rows of a table
.SH "SYNOPSIS"
.sp
.nf
[ WITH [ RECURSIVE ] \fIwith_query\fR [, \&amp;.\&amp;.\&amp;.] ]
DELETE FROM [ ONLY ] \fItable_name\fR [ * ] [ [ AS ] \fIalias\fR ]
[ USING \fIusing_list\fR ]
[ WHERE \fIcondition\fR | WHERE CURRENT OF \fIcursor_name\fR ]
[ RETURNING * | \fIoutput_expression\fR [ [ AS ] \fIoutput_name\fR ] [, \&amp;.\&amp;.\&amp;.] ]
.fi
.SH "DESCRIPTION"
.PP
\fBDELETE\fR
deletes rows that satisfy the
WHERE
clause from the specified table\&amp;. If the
WHERE
clause is absent, the effect is to delete all rows in the table\&amp;. The result is a valid, but empty table\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBTip\fR
.ps -1
.br
.PP
\fBTRUNCATE\fR(7)
is a
PostgreSQL
extension that provides a faster mechanism to remove all rows from a table\&amp;.
.sp .5v
.RE
.PP
There are two ways to delete rows in a table using information contained in other tables in the database: using sub\-selects, or specifying additional tables in the
USING
clause\&amp;. Which technique is more appropriate depends on the specific circumstances\&amp;.
.PP
The optional
RETURNING
clause causes
\fBDELETE\fR
to compute and return value(s) based on each row actually deleted\&amp;. Any expression using the table\*(Aqs columns, and/or columns of other tables mentioned in
USING, can be computed\&amp;. The syntax of the
RETURNING
list is identical to that of the output list of
\fBSELECT\fR\&amp;.
.PP
You must have the
DELETE
privilege on the table to delete from it, as well as the
SELECT
privilege for any table in the
USING
clause or whose values are read in the
\fIcondition\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIwith_query\fR
.RS 4
The
WITH
clause allows you to specify one or more subqueries that can be referenced by name in the
\fBDELETE\fR
query\&amp;. See
Section 7.8, \(lqWITH Queries (Common Table Expressions)\(rq, in the documentation
and
\fBSELECT\fR(7)
for details\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table to delete rows from\&amp;. If
ONLY
is specified before the table name, matching rows are deleted from the named table only\&amp;. If
ONLY
is not specified, matching rows are also deleted from any tables inheriting from the named table\&amp;. Optionally,
*
can be specified after the table name to explicitly indicate that descendant tables are included\&amp;.
.RE
.PP
\fIalias\fR
.RS 4
A substitute name for the target table\&amp;. When an alias is provided, it completely hides the actual name of the table\&amp;. For example, given
DELETE FROM foo AS f, the remainder of the
\fBDELETE\fR
statement must refer to this table as
f
not
foo\&amp;.
.RE
.PP
\fIusing_list\fR
.RS 4
A list of table expressions, allowing columns from other tables to appear in the
WHERE
condition\&amp;. This is similar to the list of tables that can be specified in the
FROM Clause
of a
\fBSELECT\fR
statement; for example, an alias for the table name can be specified\&amp;. Do not repeat the target table in the
\fIusing_list\fR, unless you wish to set up a self\-join\&amp;.
.RE
.PP
\fIcondition\fR
.RS 4
An expression that returns a value of type
boolean\&amp;. Only rows for which this expression returns
true
will be deleted\&amp;.
.RE
.PP
\fIcursor_name\fR
.RS 4
The name of the cursor to use in a
WHERE CURRENT OF
condition\&amp;. The row to be deleted is the one most recently fetched from this cursor\&amp;. The cursor must be a non\-grouping query on the
\fBDELETE\fR\*(Aqs target table\&amp;. Note that
WHERE CURRENT OF
cannot be specified together with a Boolean condition\&amp;. See
\fBDECLARE\fR(7)
for more information about using cursors with
WHERE CURRENT OF\&amp;.
.RE
.PP
\fIoutput_expression\fR
.RS 4
An expression to be computed and returned by the
\fBDELETE\fR
command after each row is deleted\&amp;. The expression can use any column names of the table named by
\fItable_name\fR
or table(s) listed in
USING\&amp;. Write
*
to return all columns\&amp;.
.RE
.PP
\fIoutput_name\fR
.RS 4
A name to use for a returned column\&amp;.
.RE
.SH "OUTPUTS"
.PP
On successful completion, a
\fBDELETE\fR
command returns a command tag of the form
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE \fIcount\fR
.fi
.if n \{\
.RE
.\}
.sp
The
\fIcount\fR
is the number of rows deleted\&amp;. Note that the number may be less than the number of rows that matched the
\fIcondition\fR
when deletes were suppressed by a
BEFORE DELETE
trigger\&amp;. If
\fIcount\fR
is 0, no rows were deleted by the query (this is not considered an error)\&amp;.
.PP
If the
\fBDELETE\fR
command contains a
RETURNING
clause, the result will be similar to that of a
\fBSELECT\fR
statement containing the columns and values defined in the
RETURNING
list, computed over the row(s) deleted by the command\&amp;.
.SH "NOTES"
.PP
PostgreSQL
lets you reference columns of other tables in the
WHERE
condition by specifying the other tables in the
USING
clause\&amp;. For example, to delete all films produced by a given producer, one can do:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM films USING producers
WHERE producer_id = producers\&amp;.id AND producers\&amp;.name = \*(Aqfoo\*(Aq;
.fi
.if n \{\
.RE
.\}
.sp
What is essentially happening here is a join between
films
and
producers, with all successfully joined
films
rows being marked for deletion\&amp;. This syntax is not standard\&amp;. A more standard way to do it is:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM films
WHERE producer_id IN (SELECT id FROM producers WHERE name = \*(Aqfoo\*(Aq);
.fi
.if n \{\
.RE
.\}
.sp
In some cases the join style is easier to write or faster to execute than the sub\-select style\&amp;.
.SH "EXAMPLES"
.PP
Delete all films but musicals:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM films WHERE kind &lt;&gt; \*(AqMusical\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Clear the table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM films;
.fi
.if n \{\
.RE
.\}
.PP
Delete completed tasks, returning full details of the deleted rows:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM tasks WHERE status = \*(AqDONE\*(Aq RETURNING *;
.fi
.if n \{\
.RE
.\}
.PP
Delete the row of
tasks
on which the cursor
c_tasks
is currently positioned:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM tasks WHERE CURRENT OF c_tasks;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command conforms to the
SQL
standard, except that the
USING
and
RETURNING
clauses are
PostgreSQL
extensions, as is the ability to use
WITH
with
\fBDELETE\fR\&amp;.
'\" t
.\"     Title: DISCARD
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DISCARD" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DISCARD \- discard session state
.SH "SYNOPSIS"
.sp
.nf
DISCARD { ALL | PLANS | SEQUENCES | TEMPORARY | TEMP }
.fi
.SH "DESCRIPTION"
.PP
\fBDISCARD\fR
releases internal resources associated with a database session\&amp;. This command is useful for partially or fully resetting the session\*(Aqs state\&amp;. There are several subcommands to release different types of resources; the
\fBDISCARD ALL\fR
variant subsumes all the others, and also resets additional state\&amp;.
.SH "PARAMETERS"
.PP
PLANS
.RS 4
Releases all cached query plans, forcing re\-planning to occur the next time the associated prepared statement is used\&amp;.
.RE
.PP
SEQUENCES
.RS 4
Discards all cached sequence\-related state, including
\fBcurrval()\fR/\fBlastval()\fR
information and any preallocated sequence values that have not yet been returned by
\fBnextval()\fR\&amp;. (See
CREATE SEQUENCE (\fBCREATE_SEQUENCE\fR(7))
for a description of preallocated sequence values\&amp;.)
.RE
.PP
TEMPORARY or TEMP
.RS 4
Drops all temporary tables created in the current session\&amp;.
.RE
.PP
ALL
.RS 4
Releases all temporary resources associated with the current session and resets the session to its initial state\&amp;. Currently, this has the same effect as executing the following sequence of statements:
.sp
.if n \{\
.RS 4
.\}
.nf
SET SESSION AUTHORIZATION DEFAULT;
RESET ALL;
DEALLOCATE ALL;
CLOSE ALL;
UNLISTEN *;
SELECT pg_advisory_unlock_all();
DISCARD PLANS;
DISCARD SEQUENCES;
DISCARD TEMP;
.fi
.if n \{\
.RE
.\}
.RE
.SH "NOTES"
.PP
\fBDISCARD ALL\fR
cannot be executed inside a transaction block\&amp;.
.SH "COMPATIBILITY"
.PP
\fBDISCARD\fR
is a
PostgreSQL
extension\&amp;.
'\" t
.\"     Title: DO
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DO" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DO \- execute an anonymous code block
.SH "SYNOPSIS"
.sp
.nf
DO [ LANGUAGE \fIlang_name\fR ] \fIcode\fR
.fi
.SH "DESCRIPTION"
.PP
\fBDO\fR
executes an anonymous code block, or in other words a transient anonymous function in a procedural language\&amp;.
.PP
The code block is treated as though it were the body of a function with no parameters, returning
void\&amp;. It is parsed and executed a single time\&amp;.
.PP
The optional
LANGUAGE
clause can be written either before or after the code block\&amp;.
.SH "PARAMETERS"
.PP
\fIcode\fR
.RS 4
The procedural language code to be executed\&amp;. This must be specified as a string literal, just as in
\fBCREATE FUNCTION\fR\&amp;. Use of a dollar\-quoted literal is recommended\&amp;.
.RE
.PP
\fIlang_name\fR
.RS 4
The name of the procedural language the code is written in\&amp;. If omitted, the default is
plpgsql\&amp;.
.RE
.SH "NOTES"
.PP
The procedural language to be used must already have been installed into the current database by means of
\fBCREATE LANGUAGE\fR\&amp;.
plpgsql
is installed by default, but other languages are not\&amp;.
.PP
The user must have
USAGE
privilege for the procedural language, or must be a superuser if the language is untrusted\&amp;. This is the same privilege requirement as for creating a function in the language\&amp;.
.SH "EXAMPLES"
.PP
Grant all privileges on all views in schema
public
to role
webuser:
.sp
.if n \{\
.RS 4
.\}
.nf
DO $$DECLARE r record;
BEGIN
FOR r IN SELECT table_schema, table_name FROM information_schema\&amp;.tables
WHERE table_type = \*(AqVIEW\*(Aq AND table_schema = \*(Aqpublic\*(Aq
LOOP
EXECUTE \*(AqGRANT ALL ON \*(Aq || quote_ident(r\&amp;.table_schema) || \*(Aq\&amp;.\*(Aq || quote_ident(r\&amp;.table_name) || \*(Aq TO webuser\*(Aq;
END LOOP;
END$$;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBDO\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE LANGUAGE (\fBCREATE_LANGUAGE\fR(7))
'\" t
.\"     Title: DROP ACCESS METHOD
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP ACCESS METHOD" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_ACCESS_METHOD \- remove an access method
.SH "SYNOPSIS"
.sp
.nf
DROP ACCESS METHOD [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP ACCESS METHOD\fR
removes an existing access method\&amp;. Only superusers can drop access methods\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the access method does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of an existing access method\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the access method (such as operator classes, operator families, and indexes), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the access method if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Drop the access method
heptree:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP ACCESS METHOD heptree;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP ACCESS METHOD\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE ACCESS METHOD (\fBCREATE_ACCESS_METHOD\fR(7))
'\" t
.\"     Title: DROP AGGREGATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP AGGREGATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_AGGREGATE \- remove an aggregate function
.SH "SYNOPSIS"
.sp
.nf
DROP AGGREGATE [ IF EXISTS ] \fIname\fR ( \fIaggregate_signature\fR ) [ CASCADE | RESTRICT ]

where \fIaggregate_signature\fR is:

* |
[ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] |
[ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] ] ORDER BY [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP AGGREGATE\fR
removes an existing aggregate function\&amp;. To execute this command the current user must be the owner of the aggregate function\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the aggregate does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing aggregate function\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of an argument:
IN
or
VARIADIC\&amp;. If omitted, the default is
IN\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of an argument\&amp;. Note that
\fBDROP AGGREGATE\fR
does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function\*(Aqs identity\&amp;.
.RE
.PP
\fIargtype\fR
.RS 4
An input data type on which the aggregate function operates\&amp;. To reference a zero\-argument aggregate function, write
*
in place of the list of argument specifications\&amp;. To reference an ordered\-set aggregate function, write
ORDER BY
between the direct and aggregated argument specifications\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the aggregate function (such as views using it), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the aggregate function if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "NOTES"
.PP
Alternative syntaxes for referencing ordered\-set aggregates are described under
ALTER AGGREGATE (\fBALTER_AGGREGATE\fR(7))\&amp;.
.SH "EXAMPLES"
.PP
To remove the aggregate function
myavg
for type
integer:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP AGGREGATE myavg(integer);
.fi
.if n \{\
.RE
.\}
.PP
To remove the hypothetical\-set aggregate function
myrank, which takes an arbitrary list of ordering columns and a matching list of direct arguments:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP AGGREGATE myrank(VARIADIC "any" ORDER BY VARIADIC "any");
.fi
.if n \{\
.RE
.\}
.sp
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP AGGREGATE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER AGGREGATE (\fBALTER_AGGREGATE\fR(7)), CREATE AGGREGATE (\fBCREATE_AGGREGATE\fR(7))
'\" t
.\"     Title: DROP CAST
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP CAST" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_CAST \- remove a cast
.SH "SYNOPSIS"
.sp
.nf
DROP CAST [ IF EXISTS ] (\fIsource_type\fR AS \fItarget_type\fR) [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP CAST\fR
removes a previously defined cast\&amp;.
.PP
To be able to drop a cast, you must own the source or the target data type\&amp;. These are the same privileges that are required to create a cast\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the cast does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIsource_type\fR
.RS 4
The name of the source data type of the cast\&amp;.
.RE
.PP
\fItarget_type\fR
.RS 4
The name of the target data type of the cast\&amp;.
.RE
.PP
CASCADE
.br
RESTRICT
.RS 4
These key words do not have any effect, since there are no dependencies on casts\&amp;.
.RE
.SH "EXAMPLES"
.PP
To drop the cast from type
text
to type
int:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP CAST (text AS int);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBDROP CAST\fR
command conforms to the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE CAST (\fBCREATE_CAST\fR(7))
'\" t
.\"     Title: DROP COLLATION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP COLLATION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_COLLATION \- remove a collation
.SH "SYNOPSIS"
.sp
.nf
DROP COLLATION [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP COLLATION\fR
removes a previously defined collation\&amp;. To be able to drop a collation, you must own the collation\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the collation does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the collation\&amp;. The collation name can be schema\-qualified\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the collation, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the collation if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To drop the collation named
german:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP COLLATION german;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBDROP COLLATION\fR
command conforms to the
SQL
standard, apart from the
IF EXISTS
option, which is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER COLLATION (\fBALTER_COLLATION\fR(7)), CREATE COLLATION (\fBCREATE_COLLATION\fR(7))
'\" t
.\"     Title: DROP CONVERSION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP CONVERSION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_CONVERSION \- remove a conversion
.SH "SYNOPSIS"
.sp
.nf
DROP CONVERSION [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP CONVERSION\fR
removes a previously defined conversion\&amp;. To be able to drop a conversion, you must own the conversion\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the conversion does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the conversion\&amp;. The conversion name can be schema\-qualified\&amp;.
.RE
.PP
CASCADE
.br
RESTRICT
.RS 4
These key words do not have any effect, since there are no dependencies on conversions\&amp;.
.RE
.SH "EXAMPLES"
.PP
To drop the conversion named
myname:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP CONVERSION myname;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP CONVERSION\fR
statement in the SQL standard, but a
\fBDROP TRANSLATION\fR
statement that goes along with the
\fBCREATE TRANSLATION\fR
statement that is similar to the
\fBCREATE CONVERSION\fR
statement in PostgreSQL\&amp;.
.SH "SEE ALSO"
ALTER CONVERSION (\fBALTER_CONVERSION\fR(7)), CREATE CONVERSION (\fBCREATE_CONVERSION\fR(7))
'\" t
.\"     Title: DROP DATABASE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP DATABASE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_DATABASE \- remove a database
.SH "SYNOPSIS"
.sp
.nf
DROP DATABASE [ IF EXISTS ] \fIname\fR
.fi
.SH "DESCRIPTION"
.PP
\fBDROP DATABASE\fR
drops a database\&amp;. It removes the catalog entries for the database and deletes the directory containing the data\&amp;. It can only be executed by the database owner\&amp;. Also, it cannot be executed while you or anyone else are connected to the target database\&amp;. (Connect to
postgres
or any other database to issue this command\&amp;.)
.PP
\fBDROP DATABASE\fR
cannot be undone\&amp;. Use it with care!
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the database does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the database to remove\&amp;.
.RE
.SH "NOTES"
.PP
\fBDROP DATABASE\fR
cannot be executed inside a transaction block\&amp;.
.PP
This command cannot be executed while connected to the target database\&amp;. Thus, it might be more convenient to use the program
\fBdropdb\fR(1)
instead, which is a wrapper around this command\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP DATABASE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE DATABASE (\fBCREATE_DATABASE\fR(7))
'\" t
.\"     Title: DROP DOMAIN
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP DOMAIN" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_DOMAIN \- remove a domain
.SH "SYNOPSIS"
.sp
.nf
DROP DOMAIN [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP DOMAIN\fR
removes a domain\&amp;. Only the owner of a domain can remove it\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the domain does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing domain\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the domain (such as table columns), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the domain if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To remove the domain
box:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP DOMAIN box;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command conforms to the SQL standard, except for the
IF EXISTS
option, which is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE DOMAIN (\fBCREATE_DOMAIN\fR(7)), ALTER DOMAIN (\fBALTER_DOMAIN\fR(7))
'\" t
.\"     Title: DROP EVENT TRIGGER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP EVENT TRIGGER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_EVENT_TRIGGER \- remove an event trigger
.SH "SYNOPSIS"
.sp
.nf
DROP EVENT TRIGGER [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP EVENT TRIGGER\fR
removes an existing event trigger\&amp;. To execute this command, the current user must be the owner of the event trigger\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the event trigger does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the event trigger to remove\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the trigger, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the trigger if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Destroy the trigger
snitch:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP EVENT TRIGGER snitch;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP EVENT TRIGGER\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE EVENT TRIGGER (\fBCREATE_EVENT_TRIGGER\fR(7)), ALTER EVENT TRIGGER (\fBALTER_EVENT_TRIGGER\fR(7))
'\" t
.\"     Title: DROP EXTENSION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP EXTENSION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_EXTENSION \- remove an extension
.SH "SYNOPSIS"
.sp
.nf
DROP EXTENSION [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP EXTENSION\fR
removes extensions from the database\&amp;. Dropping an extension causes its component objects to be dropped as well\&amp;.
.PP
You must own the extension to use
\fBDROP EXTENSION\fR\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the extension does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of an installed extension\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the extension, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the extension if any objects depend on it (other than its own member objects and other extensions listed in the same
\fBDROP\fR
command)\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To remove the extension
hstore
from the current database:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP EXTENSION hstore;
.fi
.if n \{\
.RE
.\}
.sp
This command will fail if any of
hstore\*(Aqs objects are in use in the database, for example if any tables have columns of the
hstore
type\&amp;. Add the
CASCADE
option to forcibly remove those dependent objects as well\&amp;.
.SH "COMPATIBILITY"
.PP
\fBDROP EXTENSION\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE EXTENSION (\fBCREATE_EXTENSION\fR(7)), ALTER EXTENSION (\fBALTER_EXTENSION\fR(7))
'\" t
.\"     Title: DROP FOREIGN DATA WRAPPER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP FOREIGN DATA WRAPPER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_FOREIGN_DATA_WRAPPER \- remove a foreign\-data wrapper
.SH "SYNOPSIS"
.sp
.nf
DROP FOREIGN DATA WRAPPER [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP FOREIGN DATA WRAPPER\fR
removes an existing foreign\-data wrapper\&amp;. To execute this command, the current user must be the owner of the foreign\-data wrapper\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the foreign\-data wrapper does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of an existing foreign\-data wrapper\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the foreign\-data wrapper (such as foreign tables and servers), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the foreign\-data wrapper if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Drop the foreign\-data wrapper
dbi:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP FOREIGN DATA WRAPPER dbi;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP FOREIGN DATA WRAPPER\fR
conforms to ISO/IEC 9075\-9 (SQL/MED)\&amp;. The
IF EXISTS
clause is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE FOREIGN DATA WRAPPER (\fBCREATE_FOREIGN_DATA_WRAPPER\fR(7)), ALTER FOREIGN DATA WRAPPER (\fBALTER_FOREIGN_DATA_WRAPPER\fR(7))
'\" t
.\"     Title: DROP FOREIGN TABLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP FOREIGN TABLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_FOREIGN_TABLE \- remove a foreign table
.SH "SYNOPSIS"
.sp
.nf
DROP FOREIGN TABLE [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP FOREIGN TABLE\fR
removes a foreign table\&amp;. Only the owner of a foreign table can remove it\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the foreign table does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the foreign table to drop\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the foreign table (such as views), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the foreign table if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To destroy two foreign tables,
films
and
distributors:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP FOREIGN TABLE films, distributors;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command conforms to the ISO/IEC 9075\-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the
IF EXISTS
option, which is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER FOREIGN TABLE (\fBALTER_FOREIGN_TABLE\fR(7)), CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7))
'\" t
.\"     Title: DROP FUNCTION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP FUNCTION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_FUNCTION \- remove a function
.SH "SYNOPSIS"
.sp
.nf
DROP FUNCTION [ IF EXISTS ] \fIname\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] )
[ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP FUNCTION\fR
removes the definition of an existing function\&amp;. To execute this command the user must be the owner of the function\&amp;. The argument types to the function must be specified, since several different functions can exist with the same name and different argument lists\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the function does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing function\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of an argument:
IN,
OUT,
INOUT, or
VARIADIC\&amp;. If omitted, the default is
IN\&amp;. Note that
\fBDROP FUNCTION\fR
does not actually pay any attention to
OUT
arguments, since only the input arguments are needed to determine the function\*(Aqs identity\&amp;. So it is sufficient to list the
IN,
INOUT, and
VARIADIC
arguments\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of an argument\&amp;. Note that
\fBDROP FUNCTION\fR
does not actually pay any attention to argument names, since only the argument data types are needed to determine the function\*(Aqs identity\&amp;.
.RE
.PP
\fIargtype\fR
.RS 4
The data type(s) of the function\*(Aqs arguments (optionally schema\-qualified), if any\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the function (such as operators or triggers), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the function if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
This command removes the square root function:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP FUNCTION sqrt(integer);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
A
\fBDROP FUNCTION\fR
statement is defined in the SQL standard, but it is not compatible with this command\&amp;.
.SH "SEE ALSO"
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)), ALTER FUNCTION (\fBALTER_FUNCTION\fR(7))
'\" t
.\"     Title: DROP GROUP
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP GROUP" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_GROUP \- remove a database role
.SH "SYNOPSIS"
.sp
.nf
DROP GROUP [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP GROUP\fR
is now an alias for
DROP ROLE (\fBDROP_ROLE\fR(7))\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP GROUP\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
DROP ROLE (\fBDROP_ROLE\fR(7))
'\" t
.\"     Title: DROP INDEX
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP INDEX" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_INDEX \- remove an index
.SH "SYNOPSIS"
.sp
.nf
DROP INDEX [ CONCURRENTLY ] [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP INDEX\fR
drops an existing index from the database system\&amp;. To execute this command you must be the owner of the index\&amp;.
.SH "PARAMETERS"
.PP
CONCURRENTLY
.RS 4
Drop the index without locking out concurrent selects, inserts, updates, and deletes on the index\*(Aqs table\&amp;. A normal
\fBDROP INDEX\fR
acquires exclusive lock on the table, blocking other accesses until the index drop can be completed\&amp;. With this option, the command instead waits until conflicting transactions have completed\&amp;.
.sp
There are several caveats to be aware of when using this option\&amp;. Only one index name can be specified, and the
CASCADE
option is not supported\&amp;. (Thus, an index that supports a
UNIQUE
or
PRIMARY KEY
constraint cannot be dropped this way\&amp;.) Also, regular
\fBDROP INDEX\fR
commands can be performed within a transaction block, but
\fBDROP INDEX CONCURRENTLY\fR
cannot\&amp;.
.RE
.PP
IF EXISTS
.RS 4
Do not throw an error if the index does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an index to remove\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the index, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the index if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
This command will remove the index
title_idx:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP INDEX title_idx;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP INDEX\fR
is a
PostgreSQL
language extension\&amp;. There are no provisions for indexes in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE INDEX (\fBCREATE_INDEX\fR(7))
'\" t
.\"     Title: DROP LANGUAGE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP LANGUAGE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_LANGUAGE \- remove a procedural language
.SH "SYNOPSIS"
.sp
.nf
DROP [ PROCEDURAL ] LANGUAGE [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP LANGUAGE\fR
removes the definition of a previously registered procedural language\&amp;. You must be a superuser or the owner of the language to use
\fBDROP LANGUAGE\fR\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
As of
PostgreSQL
9\&amp;.1, most procedural languages have been made into
\(lqextensions\(rq, and should therefore be removed with
DROP EXTENSION (\fBDROP_EXTENSION\fR(7))
not
\fBDROP LANGUAGE\fR\&amp;.
.sp .5v
.RE
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the language does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of an existing procedural language\&amp;. For backward compatibility, the name can be enclosed by single quotes\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the language (such as functions in the language), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the language if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
This command removes the procedural language
plsample:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP LANGUAGE plsample;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP LANGUAGE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER LANGUAGE (\fBALTER_LANGUAGE\fR(7)), CREATE LANGUAGE (\fBCREATE_LANGUAGE\fR(7)), \fBdroplang\fR(1)
'\" t
.\"     Title: DROP MATERIALIZED VIEW
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP MATERIALIZED VIEW" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_MATERIALIZED_VIEW \- remove a materialized view
.SH "SYNOPSIS"
.sp
.nf
DROP MATERIALIZED VIEW [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP MATERIALIZED VIEW\fR
drops an existing materialized view\&amp;. To execute this command you must be the owner of the materialized view\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the materialized view does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the materialized view to remove\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the materialized view (such as other materialized views, or regular views), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the materialized view if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
This command will remove the materialized view called
order_summary:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP MATERIALIZED VIEW order_summary;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP MATERIALIZED VIEW\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE MATERIALIZED VIEW (\fBCREATE_MATERIALIZED_VIEW\fR(7)), ALTER MATERIALIZED VIEW (\fBALTER_MATERIALIZED_VIEW\fR(7)), REFRESH MATERIALIZED VIEW (\fBREFRESH_MATERIALIZED_VIEW\fR(7))
'\" t
.\"     Title: DROP OPERATOR
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP OPERATOR" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_OPERATOR \- remove an operator
.SH "SYNOPSIS"
.sp
.nf
DROP OPERATOR [ IF EXISTS ] \fIname\fR ( { \fIleft_type\fR | NONE } , { \fIright_type\fR | NONE } ) [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP OPERATOR\fR
drops an existing operator from the database system\&amp;. To execute this command you must be the owner of the operator\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the operator does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing operator\&amp;.
.RE
.PP
\fIleft_type\fR
.RS 4
The data type of the operator\*(Aqs left operand; write
NONE
if the operator has no left operand\&amp;.
.RE
.PP
\fIright_type\fR
.RS 4
The data type of the operator\*(Aqs right operand; write
NONE
if the operator has no right operand\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the operator (such as views using it), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the operator if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Remove the power operator
a^b
for type
integer:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP OPERATOR ^ (integer, integer);
.fi
.if n \{\
.RE
.\}
.PP
Remove the left unary bitwise complement operator
~b
for type
bit:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP OPERATOR ~ (none, bit);
.fi
.if n \{\
.RE
.\}
.PP
Remove the right unary factorial operator
x!
for type
bigint:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP OPERATOR ! (bigint, none);
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP OPERATOR\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
CREATE OPERATOR (\fBCREATE_OPERATOR\fR(7)), ALTER OPERATOR (\fBALTER_OPERATOR\fR(7))
'\" t
.\"     Title: DROP OPERATOR CLASS
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP OPERATOR CLASS" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_OPERATOR_CLASS \- remove an operator class
.SH "SYNOPSIS"
.sp
.nf
DROP OPERATOR CLASS [ IF EXISTS ] \fIname\fR USING \fIindex_method\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP OPERATOR CLASS\fR
drops an existing operator class\&amp;. To execute this command you must be the owner of the operator class\&amp;.
.PP
\fBDROP OPERATOR CLASS\fR
does not drop any of the operators or functions referenced by the class\&amp;. If there are any indexes depending on the operator class, you will need to specify
CASCADE
for the drop to complete\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the operator class does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing operator class\&amp;.
.RE
.PP
\fIindex_method\fR
.RS 4
The name of the index access method the operator class is for\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the operator class (such as indexes), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the operator class if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "NOTES"
.PP
\fBDROP OPERATOR CLASS\fR
will not drop the operator family containing the class, even if there is nothing else left in the family (in particular, in the case where the family was implicitly created by
\fBCREATE OPERATOR CLASS\fR)\&amp;. An empty operator family is harmless, but for the sake of tidiness you might wish to remove the family with
\fBDROP OPERATOR FAMILY\fR; or perhaps better, use
\fBDROP OPERATOR FAMILY\fR
in the first place\&amp;.
.SH "EXAMPLES"
.PP
Remove the B\-tree operator class
widget_ops:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP OPERATOR CLASS widget_ops USING btree;
.fi
.if n \{\
.RE
.\}
.sp
This command will not succeed if there are any existing indexes that use the operator class\&amp;. Add
CASCADE
to drop such indexes along with the operator class\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP OPERATOR CLASS\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER OPERATOR CLASS (\fBALTER_OPERATOR_CLASS\fR(7)), CREATE OPERATOR CLASS (\fBCREATE_OPERATOR_CLASS\fR(7)), DROP OPERATOR FAMILY (\fBDROP_OPERATOR_FAMILY\fR(7))
'\" t
.\"     Title: DROP OPERATOR FAMILY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP OPERATOR FAMILY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_OPERATOR_FAMILY \- remove an operator family
.SH "SYNOPSIS"
.sp
.nf
DROP OPERATOR FAMILY [ IF EXISTS ] \fIname\fR USING \fIindex_method\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP OPERATOR FAMILY\fR
drops an existing operator family\&amp;. To execute this command you must be the owner of the operator family\&amp;.
.PP
\fBDROP OPERATOR FAMILY\fR
includes dropping any operator classes contained in the family, but it does not drop any of the operators or functions referenced by the family\&amp;. If there are any indexes depending on operator classes within the family, you will need to specify
CASCADE
for the drop to complete\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the operator family does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing operator family\&amp;.
.RE
.PP
\fIindex_method\fR
.RS 4
The name of the index access method the operator family is for\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the operator family, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the operator family if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Remove the B\-tree operator family
float_ops:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP OPERATOR FAMILY float_ops USING btree;
.fi
.if n \{\
.RE
.\}
.sp
This command will not succeed if there are any existing indexes that use operator classes within the family\&amp;. Add
CASCADE
to drop such indexes along with the operator family\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP OPERATOR FAMILY\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER OPERATOR FAMILY (\fBALTER_OPERATOR_FAMILY\fR(7)), CREATE OPERATOR FAMILY (\fBCREATE_OPERATOR_FAMILY\fR(7)), ALTER OPERATOR CLASS (\fBALTER_OPERATOR_CLASS\fR(7)), CREATE OPERATOR CLASS (\fBCREATE_OPERATOR_CLASS\fR(7)), DROP OPERATOR CLASS (\fBDROP_OPERATOR_CLASS\fR(7))
'\" t
.\"     Title: DROP OWNED
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP OWNED" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_OWNED \- remove database objects owned by a database role
.SH "SYNOPSIS"
.sp
.nf
DROP OWNED BY { \fIname\fR | CURRENT_USER | SESSION_USER } [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP OWNED\fR
drops all the objects within the current database that are owned by one of the specified roles\&amp;. Any privileges granted to the given roles on objects in the current database and on shared objects (databases, tablespaces) will also be revoked\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of a role whose objects will be dropped, and whose privileges will be revoked\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the affected objects, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the objects owned by a role if any other database objects depend on one of the affected objects\&amp;. This is the default\&amp;.
.RE
.SH "NOTES"
.PP
\fBDROP OWNED\fR
is often used to prepare for the removal of one or more roles\&amp;. Because
\fBDROP OWNED\fR
only affects the objects in the current database, it is usually necessary to execute this command in each database that contains objects owned by a role that is to be removed\&amp;.
.PP
Using the
CASCADE
option might make the command recurse to objects owned by other users\&amp;.
.PP
The
REASSIGN OWNED (\fBREASSIGN_OWNED\fR(7))
command is an alternative that reassigns the ownership of all the database objects owned by one or more roles\&amp;. However,
\fBREASSIGN OWNED\fR
does not deal with privileges for other objects\&amp;.
.PP
Databases and tablespaces owned by the role(s) will not be removed\&amp;.
.PP
See
Section 21.4, \(lqDropping Roles\(rq, in the documentation
for more discussion\&amp;.
.SH "COMPATIBILITY"
.PP
The
\fBDROP OWNED\fR
command is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
REASSIGN OWNED (\fBREASSIGN_OWNED\fR(7)), DROP ROLE (\fBDROP_ROLE\fR(7))
'\" t
.\"     Title: DROP POLICY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP POLICY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_POLICY \- remove a row level security policy from a table
.SH "SYNOPSIS"
.sp
.nf
DROP POLICY [ IF EXISTS ] \fIname\fR ON \fItable_name\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP POLICY\fR
removes the specified policy from the table\&amp;. Note that if the last policy is removed for a table and the table still has row level security enabled via
\fBALTER TABLE\fR, then the default\-deny policy will be used\&amp;.
ALTER TABLE \&amp;.\&amp;.\&amp;. DISABLE ROW LEVEL SECURITY
can be used to disable row level security for a table, whether policies for the table exist or not\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the policy does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the policy to drop\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table that the policy is on\&amp;.
.RE
.PP
CASCADE
.br
RESTRICT
.RS 4
These key words do not have any effect, since there are no dependencies on policies\&amp;.
.RE
.SH "EXAMPLES"
.PP
To drop the policy called
p1
on the table named
my_table:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP POLICY p1 ON my_table;
.fi
.if n \{\
.RE
.\}
.sp
.SH "COMPATIBILITY"
.PP
\fBDROP POLICY\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE POLICY (\fBCREATE_POLICY\fR(7)), ALTER POLICY (\fBALTER_POLICY\fR(7))
'\" t
.\"     Title: DROP ROLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP ROLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_ROLE \- remove a database role
.SH "SYNOPSIS"
.sp
.nf
DROP ROLE [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP ROLE\fR
removes the specified role(s)\&amp;. To drop a superuser role, you must be a superuser yourself; to drop non\-superuser roles, you must have
CREATEROLE
privilege\&amp;.
.PP
A role cannot be removed if it is still referenced in any database of the cluster; an error will be raised if so\&amp;. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects\&amp;. The
REASSIGN OWNED (\fBREASSIGN_OWNED\fR(7))
and
DROP OWNED (\fBDROP_OWNED\fR(7))
commands can be useful for this purpose; see
Section 21.4, \(lqDropping Roles\(rq, in the documentation
for more discussion\&amp;.
.PP
However, it is not necessary to remove role memberships involving the role;
\fBDROP ROLE\fR
automatically revokes any memberships of the target role in other roles, and of other roles in the target role\&amp;. The other roles are not dropped nor otherwise affected\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the role does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the role to remove\&amp;.
.RE
.SH "NOTES"
.PP
PostgreSQL
includes a program
\fBdropuser\fR(1)
that has the same functionality as this command (in fact, it calls this command) but can be run from the command shell\&amp;.
.SH "EXAMPLES"
.PP
To drop a role:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP ROLE jonathan;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The SQL standard defines
\fBDROP ROLE\fR, but it allows only one role to be dropped at a time, and it specifies different privilege requirements than
PostgreSQL
uses\&amp;.
.SH "SEE ALSO"
CREATE ROLE (\fBCREATE_ROLE\fR(7)), ALTER ROLE (\fBALTER_ROLE\fR(7)), SET ROLE (\fBSET_ROLE\fR(7))
'\" t
.\"     Title: DROP RULE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP RULE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_RULE \- remove a rewrite rule
.SH "SYNOPSIS"
.sp
.nf
DROP RULE [ IF EXISTS ] \fIname\fR ON \fItable_name\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP RULE\fR
drops a rewrite rule\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the rule does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the rule to drop\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table or view that the rule applies to\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the rule, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the rule if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To drop the rewrite rule
newrule:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP RULE newrule ON mytable;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP RULE\fR
is a
PostgreSQL
language extension, as is the entire query rewrite system\&amp;.
.SH "SEE ALSO"
CREATE RULE (\fBCREATE_RULE\fR(7)), ALTER RULE (\fBALTER_RULE\fR(7))
'\" t
.\"     Title: DROP SCHEMA
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP SCHEMA" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_SCHEMA \- remove a schema
.SH "SYNOPSIS"
.sp
.nf
DROP SCHEMA [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP SCHEMA\fR
removes schemas from the database\&amp;.
.PP
A schema can only be dropped by its owner or a superuser\&amp;. Note that the owner can drop the schema (and thereby all contained objects) even if they do not own some of the objects within the schema\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the schema does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of a schema\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects (tables, functions, etc\&amp;.) that are contained in the schema, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the schema if it contains any objects\&amp;. This is the default\&amp;.
.RE
.SH "NOTES"
.PP
Using the
CASCADE
option might make the command remove objects in other schemas besides the one(s) named\&amp;.
.SH "EXAMPLES"
.PP
To remove schema
mystuff
from the database, along with everything it contains:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP SCHEMA mystuff CASCADE;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP SCHEMA\fR
is fully conforming with the SQL standard, except that the standard only allows one schema to be dropped per command, and apart from the
IF EXISTS
option, which is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER SCHEMA (\fBALTER_SCHEMA\fR(7)), CREATE SCHEMA (\fBCREATE_SCHEMA\fR(7))
'\" t
.\"     Title: DROP SEQUENCE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP SEQUENCE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_SEQUENCE \- remove a sequence
.SH "SYNOPSIS"
.sp
.nf
DROP SEQUENCE [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP SEQUENCE\fR
removes sequence number generators\&amp;. A sequence can only be dropped by its owner or a superuser\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the sequence does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of a sequence\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the sequence, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the sequence if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To remove the sequence
serial:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP SEQUENCE serial;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP SEQUENCE\fR
conforms to the
SQL
standard, except that the standard only allows one sequence to be dropped per command, and apart from the
IF EXISTS
option, which is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE SEQUENCE (\fBCREATE_SEQUENCE\fR(7)), ALTER SEQUENCE (\fBALTER_SEQUENCE\fR(7))
'\" t
.\"     Title: DROP SERVER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP SERVER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_SERVER \- remove a foreign server descriptor
.SH "SYNOPSIS"
.sp
.nf
DROP SERVER [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP SERVER\fR
removes an existing foreign server descriptor\&amp;. To execute this command, the current user must be the owner of the server\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the server does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of an existing server\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the server (such as user mappings), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the server if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Drop a server
foo
if it exists:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP SERVER IF EXISTS foo;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP SERVER\fR
conforms to ISO/IEC 9075\-9 (SQL/MED)\&amp;. The
IF EXISTS
clause is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE SERVER (\fBCREATE_SERVER\fR(7)), ALTER SERVER (\fBALTER_SERVER\fR(7))
'\" t
.\"     Title: DROP TABLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TABLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TABLE \- remove a table
.SH "SYNOPSIS"
.sp
.nf
DROP TABLE [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TABLE\fR
removes tables from the database\&amp;. Only the table owner, the schema owner, and superuser can drop a table\&amp;. To empty a table of rows without destroying the table, use
\fBDELETE\fR(7)
or
\fBTRUNCATE\fR(7)\&amp;.
.PP
\fBDROP TABLE\fR
always removes any indexes, rules, triggers, and constraints that exist for the target table\&amp;. However, to drop a table that is referenced by a view or a foreign\-key constraint of another table,
CASCADE
must be specified\&amp;. (CASCADE
will remove a dependent view entirely, but in the foreign\-key case it will only remove the foreign\-key constraint, not the other table entirely\&amp;.)
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the table does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the table to drop\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the table (such as views), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the table if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To destroy two tables,
films
and
distributors:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TABLE films, distributors;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command conforms to the SQL standard, except that the standard only allows one table to be dropped per command, and apart from the
IF EXISTS
option, which is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER TABLE (\fBALTER_TABLE\fR(7)), CREATE TABLE (\fBCREATE_TABLE\fR(7))
'\" t
.\"     Title: DROP TABLESPACE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TABLESPACE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TABLESPACE \- remove a tablespace
.SH "SYNOPSIS"
.sp
.nf
DROP TABLESPACE [ IF EXISTS ] \fIname\fR
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TABLESPACE\fR
removes a tablespace from the system\&amp;.
.PP
A tablespace can only be dropped by its owner or a superuser\&amp;. The tablespace must be empty of all database objects before it can be dropped\&amp;. It is possible that objects in other databases might still reside in the tablespace even if no objects in the current database are using the tablespace\&amp;. Also, if the tablespace is listed in the
temp_tablespaces
setting of any active session, the
\fBDROP\fR
might fail due to temporary files residing in the tablespace\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the tablespace does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of a tablespace\&amp;.
.RE
.SH "NOTES"
.PP
\fBDROP TABLESPACE\fR
cannot be executed inside a transaction block\&amp;.
.SH "EXAMPLES"
.PP
To remove tablespace
mystuff
from the system:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TABLESPACE mystuff;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP TABLESPACE\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE TABLESPACE (\fBCREATE_TABLESPACE\fR(7)), ALTER TABLESPACE (\fBALTER_TABLESPACE\fR(7))
'\" t
.\"     Title: DROP TEXT SEARCH CONFIGURATION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TEXT SEARCH CONFIGURATION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TEXT_SEARCH_CONFIGURATION \- remove a text search configuration
.SH "SYNOPSIS"
.sp
.nf
DROP TEXT SEARCH CONFIGURATION [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TEXT SEARCH CONFIGURATION\fR
drops an existing text search configuration\&amp;. To execute this command you must be the owner of the configuration\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the text search configuration does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing text search configuration\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the text search configuration, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the text search configuration if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Remove the text search configuration
my_english:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TEXT SEARCH CONFIGURATION my_english;
.fi
.if n \{\
.RE
.\}
.sp
This command will not succeed if there are any existing indexes that reference the configuration in
\fBto_tsvector\fR
calls\&amp;. Add
CASCADE
to drop such indexes along with the text search configuration\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP TEXT SEARCH CONFIGURATION\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TEXT SEARCH CONFIGURATION (\fBALTER_TEXT_SEARCH_CONFIGURATION\fR(7)), CREATE TEXT SEARCH CONFIGURATION (\fBCREATE_TEXT_SEARCH_CONFIGURATION\fR(7))
'\" t
.\"     Title: DROP TEXT SEARCH DICTIONARY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TEXT SEARCH DICTIONARY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TEXT_SEARCH_DICTIONARY \- remove a text search dictionary
.SH "SYNOPSIS"
.sp
.nf
DROP TEXT SEARCH DICTIONARY [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TEXT SEARCH DICTIONARY\fR
drops an existing text search dictionary\&amp;. To execute this command you must be the owner of the dictionary\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the text search dictionary does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing text search dictionary\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the text search dictionary, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the text search dictionary if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Remove the text search dictionary
english:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TEXT SEARCH DICTIONARY english;
.fi
.if n \{\
.RE
.\}
.sp
This command will not succeed if there are any existing text search configurations that use the dictionary\&amp;. Add
CASCADE
to drop such configurations along with the dictionary\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP TEXT SEARCH DICTIONARY\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TEXT SEARCH DICTIONARY (\fBALTER_TEXT_SEARCH_DICTIONARY\fR(7)), CREATE TEXT SEARCH DICTIONARY (\fBCREATE_TEXT_SEARCH_DICTIONARY\fR(7))
'\" t
.\"     Title: DROP TEXT SEARCH PARSER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TEXT SEARCH PARSER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TEXT_SEARCH_PARSER \- remove a text search parser
.SH "SYNOPSIS"
.sp
.nf
DROP TEXT SEARCH PARSER [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TEXT SEARCH PARSER\fR
drops an existing text search parser\&amp;. You must be a superuser to use this command\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the text search parser does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing text search parser\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the text search parser, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the text search parser if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Remove the text search parser
my_parser:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TEXT SEARCH PARSER my_parser;
.fi
.if n \{\
.RE
.\}
.sp
This command will not succeed if there are any existing text search configurations that use the parser\&amp;. Add
CASCADE
to drop such configurations along with the parser\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP TEXT SEARCH PARSER\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TEXT SEARCH PARSER (\fBALTER_TEXT_SEARCH_PARSER\fR(7)), CREATE TEXT SEARCH PARSER (\fBCREATE_TEXT_SEARCH_PARSER\fR(7))
'\" t
.\"     Title: DROP TEXT SEARCH TEMPLATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TEXT SEARCH TEMPLATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TEXT_SEARCH_TEMPLATE \- remove a text search template
.SH "SYNOPSIS"
.sp
.nf
DROP TEXT SEARCH TEMPLATE [ IF EXISTS ] \fIname\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TEXT SEARCH TEMPLATE\fR
drops an existing text search template\&amp;. You must be a superuser to use this command\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the text search template does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing text search template\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the text search template, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the text search template if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Remove the text search template
thesaurus:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TEXT SEARCH TEMPLATE thesaurus;
.fi
.if n \{\
.RE
.\}
.sp
This command will not succeed if there are any existing text search dictionaries that use the template\&amp;. Add
CASCADE
to drop such dictionaries along with the template\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBDROP TEXT SEARCH TEMPLATE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TEXT SEARCH TEMPLATE (\fBALTER_TEXT_SEARCH_TEMPLATE\fR(7)), CREATE TEXT SEARCH TEMPLATE (\fBCREATE_TEXT_SEARCH_TEMPLATE\fR(7))
'\" t
.\"     Title: DROP TRANSFORM
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TRANSFORM" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TRANSFORM \- remove a transform
.SH "SYNOPSIS"
.sp
.nf
DROP TRANSFORM [ IF EXISTS ] FOR \fItype_name\fR LANGUAGE \fIlang_name\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TRANSFORM\fR
removes a previously defined transform\&amp;.
.PP
To be able to drop a transform, you must own the type and the language\&amp;. These are the same privileges that are required to create a transform\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the transform does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fItype_name\fR
.RS 4
The name of the data type of the transform\&amp;.
.RE
.PP
\fIlang_name\fR
.RS 4
The name of the language of the transform\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the transform, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the transform if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To drop the transform for type
hstore
and language
plpythonu:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TRANSFORM FOR hstore LANGUAGE plpythonu;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This form of
\fBDROP TRANSFORM\fR
is a
PostgreSQL
extension\&amp;. See
CREATE TRANSFORM (\fBCREATE_TRANSFORM\fR(7))
for details\&amp;.
.SH "SEE ALSO"
CREATE TRANSFORM (\fBCREATE_TRANSFORM\fR(7))
'\" t
.\"     Title: DROP TRIGGER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TRIGGER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TRIGGER \- remove a trigger
.SH "SYNOPSIS"
.sp
.nf
DROP TRIGGER [ IF EXISTS ] \fIname\fR ON \fItable_name\fR [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TRIGGER\fR
removes an existing trigger definition\&amp;. To execute this command, the current user must be the owner of the table for which the trigger is defined\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the trigger does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the trigger to remove\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table for which the trigger is defined\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the trigger, and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the trigger if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
Destroy the trigger
if_dist_exists
on the table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TRIGGER if_dist_exists ON films;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBDROP TRIGGER\fR
statement in
PostgreSQL
is incompatible with the SQL standard\&amp;. In the SQL standard, trigger names are not local to tables, so the command is simply
DROP TRIGGER \fIname\fR\&amp;.
.SH "SEE ALSO"
CREATE TRIGGER (\fBCREATE_TRIGGER\fR(7))
'\" t
.\"     Title: DROP TYPE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP TYPE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_TYPE \- remove a data type
.SH "SYNOPSIS"
.sp
.nf
DROP TYPE [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP TYPE\fR
removes a user\-defined data type\&amp;. Only the owner of a type can remove it\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the type does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the data type to remove\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the type (such as table columns, functions, and operators), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the type if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
To remove the data type
box:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP TYPE box;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command is similar to the corresponding command in the SQL standard, apart from the
IF EXISTS
option, which is a
PostgreSQL
extension\&amp;. But note that much of the
\fBCREATE TYPE\fR
command and the data type extension mechanisms in
PostgreSQL
differ from the SQL standard\&amp;.
.SH "SEE ALSO"
ALTER TYPE (\fBALTER_TYPE\fR(7)), CREATE TYPE (\fBCREATE_TYPE\fR(7))
'\" t
.\"     Title: DROP USER
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP USER" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_USER \- remove a database role
.SH "SYNOPSIS"
.sp
.nf
DROP USER [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP USER\fR
is simply an alternate spelling of
DROP ROLE (\fBDROP_ROLE\fR(7))\&amp;.
.SH "COMPATIBILITY"
.PP
The
\fBDROP USER\fR
statement is a
PostgreSQL
extension\&amp;. The SQL standard leaves the definition of users to the implementation\&amp;.
.SH "SEE ALSO"
DROP ROLE (\fBDROP_ROLE\fR(7))
'\" t
.\"     Title: DROP USER MAPPING
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP USER MAPPING" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_USER_MAPPING \- remove a user mapping for a foreign server
.SH "SYNOPSIS"
.sp
.nf
DROP USER MAPPING [ IF EXISTS ] FOR { \fIuser_name\fR | USER | CURRENT_USER | PUBLIC } SERVER \fIserver_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBDROP USER MAPPING\fR
removes an existing user mapping from foreign server\&amp;.
.PP
The owner of a foreign server can drop user mappings for that server for any user\&amp;. Also, a user can drop a user mapping for their own user name if
USAGE
privilege on the server has been granted to the user\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the user mapping does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIuser_name\fR
.RS 4
User name of the mapping\&amp;.
CURRENT_USER
and
USER
match the name of the current user\&amp;.
PUBLIC
is used to match all present and future user names in the system\&amp;.
.RE
.PP
\fIserver_name\fR
.RS 4
Server name of the user mapping\&amp;.
.RE
.SH "EXAMPLES"
.PP
Drop a user mapping
bob, server
foo
if it exists:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP USER MAPPING IF EXISTS FOR bob SERVER foo;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBDROP USER MAPPING\fR
conforms to ISO/IEC 9075\-9 (SQL/MED)\&amp;. The
IF EXISTS
clause is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE USER MAPPING (\fBCREATE_USER_MAPPING\fR(7)), ALTER USER MAPPING (\fBALTER_USER_MAPPING\fR(7))
'\" t
.\"     Title: DROP VIEW
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "DROP VIEW" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DROP_VIEW \- remove a view
.SH "SYNOPSIS"
.sp
.nf
DROP VIEW [ IF EXISTS ] \fIname\fR [, \&amp;.\&amp;.\&amp;.] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBDROP VIEW\fR
drops an existing view\&amp;. To execute this command you must be the owner of the view\&amp;.
.SH "PARAMETERS"
.PP
IF EXISTS
.RS 4
Do not throw an error if the view does not exist\&amp;. A notice is issued in this case\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the view to remove\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically drop objects that depend on the view (such as other views), and in turn all objects that depend on those objects (see
Section 5.13, \(lqDependency Tracking\(rq, in the documentation)\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to drop the view if any objects depend on it\&amp;. This is the default\&amp;.
.RE
.SH "EXAMPLES"
.PP
This command will remove the view called
kinds:
.sp
.if n \{\
.RS 4
.\}
.nf
DROP VIEW kinds;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command conforms to the SQL standard, except that the standard only allows one view to be dropped per command, and apart from the
IF EXISTS
option, which is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
ALTER VIEW (\fBALTER_VIEW\fR(7)), CREATE VIEW (\fBCREATE_VIEW\fR(7))
'\" t
.\"     Title: END
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "END" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
END \- commit the current transaction
.SH "SYNOPSIS"
.sp
.nf
END [ WORK | TRANSACTION ]
.fi
.SH "DESCRIPTION"
.PP
\fBEND\fR
commits the current transaction\&amp;. All changes made by the transaction become visible to others and are guaranteed to be durable if a crash occurs\&amp;. This command is a
PostgreSQL
extension that is equivalent to
\fBCOMMIT\fR(7)\&amp;.
.SH "PARAMETERS"
.PP
WORK
.br
TRANSACTION
.RS 4
Optional key words\&amp;. They have no effect\&amp;.
.RE
.SH "NOTES"
.PP
Use
\fBROLLBACK\fR(7)
to abort a transaction\&amp;.
.PP
Issuing
\fBEND\fR
when not inside a transaction does no harm, but it will provoke a warning message\&amp;.
.SH "EXAMPLES"
.PP
To commit the current transaction and make all changes permanent:
.sp
.if n \{\
.RS 4
.\}
.nf
END;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBEND\fR
is a
PostgreSQL
extension that provides functionality equivalent to
\fBCOMMIT\fR(7), which is specified in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBBEGIN\fR(7), \fBCOMMIT\fR(7), \fBROLLBACK\fR(7)
'\" t
.\"     Title: EXECUTE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "EXECUTE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
EXECUTE \- execute a prepared statement
.SH "SYNOPSIS"
.sp
.nf
EXECUTE \fIname\fR [ ( \fIparameter\fR [, \&amp;.\&amp;.\&amp;.] ) ]
.fi
.SH "DESCRIPTION"
.PP
\fBEXECUTE\fR
is used to execute a previously prepared statement\&amp;. Since prepared statements only exist for the duration of a session, the prepared statement must have been created by a
\fBPREPARE\fR
statement executed earlier in the current session\&amp;.
.PP
If the
\fBPREPARE\fR
statement that created the statement specified some parameters, a compatible set of parameters must be passed to the
\fBEXECUTE\fR
statement, or else an error is raised\&amp;. Note that (unlike functions) prepared statements are not overloaded based on the type or number of their parameters; the name of a prepared statement must be unique within a database session\&amp;.
.PP
For more information on the creation and usage of prepared statements, see
\fBPREPARE\fR(7)\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of the prepared statement to execute\&amp;.
.RE
.PP
\fIparameter\fR
.RS 4
The actual value of a parameter to the prepared statement\&amp;. This must be an expression yielding a value that is compatible with the data type of this parameter, as was determined when the prepared statement was created\&amp;.
.RE
.SH "OUTPUTS"
.PP
The command tag returned by
\fBEXECUTE\fR
is that of the prepared statement, and not
EXECUTE\&amp;.
.SH "EXAMPLES"
.PP
Examples are given in the
EXAMPLES
section of the
\fBPREPARE\fR(7)
documentation\&amp;.
.SH "COMPATIBILITY"
.PP
The SQL standard includes an
\fBEXECUTE\fR
statement, but it is only for use in embedded SQL\&amp;. This version of the
\fBEXECUTE\fR
statement also uses a somewhat different syntax\&amp;.
.SH "SEE ALSO"
\fBDEALLOCATE\fR(7), \fBPREPARE\fR(7)
'\" t
.\"     Title: EXPLAIN
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "EXPLAIN" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
EXPLAIN \- show the execution plan of a statement
.SH "SYNOPSIS"
.sp
.nf
EXPLAIN [ ( \fIoption\fR [, \&amp;.\&amp;.\&amp;.] ) ] \fIstatement\fR
EXPLAIN [ ANALYZE ] [ VERBOSE ] \fIstatement\fR

where \fIoption\fR can be one of:

ANALYZE [ \fIboolean\fR ]
VERBOSE [ \fIboolean\fR ]
COSTS [ \fIboolean\fR ]
BUFFERS [ \fIboolean\fR ]
TIMING [ \fIboolean\fR ]
FORMAT { TEXT | XML | JSON | YAML }
.fi
.SH "DESCRIPTION"
.PP
This command displays the execution plan that the
PostgreSQL
planner generates for the supplied statement\&amp;. The execution plan shows how the table(s) referenced by the statement will be scanned \(em by plain sequential scan, index scan, etc\&amp;. \(em and if multiple tables are referenced, what join algorithms will be used to bring together the required rows from each input table\&amp;.
.PP
The most critical part of the display is the estimated statement execution cost, which is the planner\*(Aqs guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches)\&amp;. Actually two numbers are shown: the start\-up cost before the first row can be returned, and the total cost to return all the rows\&amp;. For most queries the total cost is what matters, but in contexts such as a subquery in
EXISTS, the planner will choose the smallest start\-up cost instead of the smallest total cost (since the executor will stop after getting one row, anyway)\&amp;. Also, if you limit the number of rows to return with a
LIMIT
clause, the planner makes an appropriate interpolation between the endpoint costs to estimate which plan is really the cheapest\&amp;.
.PP
The
ANALYZE
option causes the statement to be actually executed, not only planned\&amp;. Then actual run time statistics are added to the display, including the total elapsed time expended within each plan node (in milliseconds) and the total number of rows it actually returned\&amp;. This is useful for seeing whether the planner\*(Aqs estimates are close to reality\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBImportant\fR
.ps -1
.br
.PP
Keep in mind that the statement is actually executed when the
ANALYZE
option is used\&amp;. Although
\fBEXPLAIN\fR
will discard any output that a
\fBSELECT\fR
would return, other side effects of the statement will happen as usual\&amp;. If you wish to use
\fBEXPLAIN ANALYZE\fR
on an
\fBINSERT\fR,
\fBUPDATE\fR,
\fBDELETE\fR,
\fBCREATE TABLE AS\fR, or
\fBEXECUTE\fR
statement without letting the command affect your data, use this approach:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
EXPLAIN ANALYZE \&amp;.\&amp;.\&amp;.;
ROLLBACK;
.fi
.if n \{\
.RE
.\}
.sp .5v
.RE
.PP
Only the
ANALYZE
and
VERBOSE
options can be specified, and only in that order, without surrounding the option list in parentheses\&amp;. Prior to
PostgreSQL
9\&amp;.0, the unparenthesized syntax was the only one supported\&amp;. It is expected that all new options will be supported only in the parenthesized syntax\&amp;.
.SH "PARAMETERS"
.PP
ANALYZE
.RS 4
Carry out the command and show actual run times and other statistics\&amp;. This parameter defaults to
FALSE\&amp;.
.RE
.PP
VERBOSE
.RS 4
Display additional information regarding the plan\&amp;. Specifically, include the output column list for each node in the plan tree, schema\-qualify table and function names, always label variables in expressions with their range table alias, and always print the name of each trigger for which statistics are displayed\&amp;. This parameter defaults to
FALSE\&amp;.
.RE
.PP
COSTS
.RS 4
Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row\&amp;. This parameter defaults to
TRUE\&amp;.
.RE
.PP
BUFFERS
.RS 4
Include information on buffer usage\&amp;. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written\&amp;. A
\fIhit\fR
means that a read was avoided because the block was found already in cache when needed\&amp;. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short\-term working data used in sorts, hashes, Materialize plan nodes, and similar cases\&amp;. The number of blocks
\fIdirtied\fR
indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks
\fIwritten\fR
indicates the number of previously\-dirtied blocks evicted from cache by this backend during query processing\&amp;. The number of blocks shown for an upper\-level node includes those used by all its child nodes\&amp;. In text format, only non\-zero values are printed\&amp;. This parameter may only be used when
ANALYZE
is also enabled\&amp;. It defaults to
FALSE\&amp;.
.RE
.PP
TIMING
.RS 4
Include actual startup time and time spent in each node in the output\&amp;. The overhead of repeatedly reading the system clock can slow down the query significantly on some systems, so it may be useful to set this parameter to
FALSE
when only actual row counts, and not exact times, are needed\&amp;. Run time of the entire statement is always measured, even when node\-level timing is turned off with this option\&amp;. This parameter may only be used when
ANALYZE
is also enabled\&amp;. It defaults to
TRUE\&amp;.
.RE
.PP
FORMAT
.RS 4
Specify the output format, which can be TEXT, XML, JSON, or YAML\&amp;. Non\-text output contains the same information as the text output format, but is easier for programs to parse\&amp;. This parameter defaults to
TEXT\&amp;.
.RE
.PP
\fIboolean\fR
.RS 4
Specifies whether the selected option should be turned on or off\&amp;. You can write
TRUE,
ON, or
1
to enable the option, and
FALSE,
OFF, or
0
to disable it\&amp;. The
\fIboolean\fR
value can also be omitted, in which case
TRUE
is assumed\&amp;.
.RE
.PP
\fIstatement\fR
.RS 4
Any
\fBSELECT\fR,
\fBINSERT\fR,
\fBUPDATE\fR,
\fBDELETE\fR,
\fBVALUES\fR,
\fBEXECUTE\fR,
\fBDECLARE\fR,
\fBCREATE TABLE AS\fR, or
\fBCREATE MATERIALIZED VIEW AS\fR
statement, whose execution plan you wish to see\&amp;.
.RE
.SH "OUTPUTS"
.PP
The command\*(Aqs result is a textual description of the plan selected for the
\fIstatement\fR, optionally annotated with execution statistics\&amp;.
Section 14.1, \(lqUsing EXPLAIN\(rq, in the documentation
describes the information provided\&amp;.
.SH "NOTES"
.PP
In order to allow the
PostgreSQL
query planner to make reasonably informed decisions when optimizing queries, the
pg_statistic
data should be up\-to\-date for all tables used in the query\&amp;. Normally the
autovacuum daemon
will take care of that automatically\&amp;. But if a table has recently had substantial changes in its contents, you might need to do a manual
\fBANALYZE\fR(7)
rather than wait for autovacuum to catch up with the changes\&amp;.
.PP
In order to measure the run\-time cost of each node in the execution plan, the current implementation of
\fBEXPLAIN ANALYZE\fR
adds profiling overhead to query execution\&amp;. As a result, running
\fBEXPLAIN ANALYZE\fR
on a query can sometimes take significantly longer than executing the query normally\&amp;. The amount of overhead depends on the nature of the query, as well as the platform being used\&amp;. The worst case occurs for plan nodes that in themselves require very little time per execution, and on machines that have relatively slow operating system calls for obtaining the time of day\&amp;.
.SH "EXAMPLES"
.PP
To show the plan for a simple query on a table with a single
integer
column and 10000 rows:
.sp
.if n \{\
.RS 4
.\}
.nf
EXPLAIN SELECT * FROM foo;

QUERY PLAN
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
Seq Scan on foo  (cost=0\&amp;.00\&amp;.\&amp;.155\&amp;.00 rows=10000 width=4)
(1 row)
.fi
.if n \{\
.RE
.\}
.PP
Here is the same query, with JSON output formatting:
.sp
.if n \{\
.RS 4
.\}
.nf
EXPLAIN (FORMAT JSON) SELECT * FROM foo;
QUERY PLAN
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
[                             +
{                           +
"Plan": {                 +
"Node Type": "Seq Scan",+
"Relation Name": "foo", +
"Alias": "foo",         +
"Startup Cost": 0\&amp;.00,   +
"Total Cost": 155\&amp;.00,   +
"Plan Rows": 10000,     +
"Plan Width": 4         +
}                         +
}                           +
]
(1 row)
.fi
.if n \{\
.RE
.\}
.PP
If there is an index and we use a query with an indexable
WHERE
condition,
\fBEXPLAIN\fR
might show a different plan:
.sp
.if n \{\
.RS 4
.\}
.nf
EXPLAIN SELECT * FROM foo WHERE i = 4;

QUERY PLAN
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
Index Scan using fi on foo  (cost=0\&amp;.00\&amp;.\&amp;.5\&amp;.98 rows=1 width=4)
Index Cond: (i = 4)
(2 rows)
.fi
.if n \{\
.RE
.\}
.PP
Here is the same query, but in YAML format:
.sp
.if n \{\
.RS 4
.\}
.nf
EXPLAIN (FORMAT YAML) SELECT * FROM foo WHERE i=\*(Aq4\*(Aq;
QUERY PLAN
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\- Plan:                      +
Node Type: "Index Scan"  +
Scan Direction: "Forward"+
Index Name: "fi"         +
Relation Name: "foo"     +
Alias: "foo"             +
Startup Cost: 0\&amp;.00       +
Total Cost: 5\&amp;.98         +
Plan Rows: 1             +
Plan Width: 4            +
Index Cond: "(i = 4)"    
(1 row)
.fi
.if n \{\
.RE
.\}
.sp
XML format is left as an exercise for the reader\&amp;.
.PP
Here is the same plan with cost estimates suppressed:
.sp
.if n \{\
.RS 4
.\}
.nf
EXPLAIN (COSTS FALSE) SELECT * FROM foo WHERE i = 4;

QUERY PLAN
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
Index Scan using fi on foo
Index Cond: (i = 4)
(2 rows)
.fi
.if n \{\
.RE
.\}
.PP
Here is an example of a query plan for a query using an aggregate function:
.sp
.if n \{\
.RS 4
.\}
.nf
EXPLAIN SELECT sum(i) FROM foo WHERE i &lt; 10;

QUERY PLAN
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
Aggregate  (cost=23\&amp;.93\&amp;.\&amp;.23\&amp;.93 rows=1 width=4)
\-&gt;  Index Scan using fi on foo  (cost=0\&amp;.00\&amp;.\&amp;.23\&amp;.92 rows=6 width=4)
Index Cond: (i &lt; 10)
(3 rows)
.fi
.if n \{\
.RE
.\}
.PP
Here is an example of using
\fBEXPLAIN EXECUTE\fR
to display the execution plan for a prepared query:
.sp
.if n \{\
.RS 4
.\}
.nf
PREPARE query(int, int) AS SELECT sum(bar) FROM test
WHERE id &gt; $1 AND id &lt; $2
GROUP BY foo;

EXPLAIN ANALYZE EXECUTE query(100, 200);

QUERY PLAN                                                       
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
HashAggregate  (cost=9\&amp;.54\&amp;.\&amp;.9\&amp;.54 rows=1 width=8) (actual time=0\&amp;.156\&amp;.\&amp;.0\&amp;.161 rows=11 loops=1)
Group Key: foo
\-&gt;  Index Scan using test_pkey on test  (cost=0\&amp;.29\&amp;.\&amp;.9\&amp;.29 rows=50 width=8) (actual time=0\&amp;.039\&amp;.\&amp;.0\&amp;.091 rows=99 loops=1)
Index Cond: ((id &gt; $1) AND (id &lt; $2))
Planning time: 0\&amp;.197 ms
Execution time: 0\&amp;.225 ms
(6 rows)
.fi
.if n \{\
.RE
.\}
.PP
Of course, the specific numbers shown here depend on the actual contents of the tables involved\&amp;. Also note that the numbers, and even the selected query strategy, might vary between
PostgreSQL
releases due to planner improvements\&amp;. In addition, the
\fBANALYZE\fR
command uses random sampling to estimate data statistics; therefore, it is possible for cost estimates to change after a fresh run of
\fBANALYZE\fR, even if the actual distribution of data in the table has not changed\&amp;.
.SH "COMPATIBILITY"
.PP
There is no
\fBEXPLAIN\fR
statement defined in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBANALYZE\fR(7)
'\" t
.\"     Title: FETCH
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "FETCH" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
FETCH \- retrieve rows from a query using a cursor
.SH "SYNOPSIS"
.sp
.nf
FETCH [ \fIdirection\fR [ FROM | IN ] ] \fIcursor_name\fR

where \fIdirection\fR can be empty or one of:

NEXT
PRIOR
FIRST
LAST
ABSOLUTE \fIcount\fR
RELATIVE \fIcount\fR
\fIcount\fR
ALL
FORWARD
FORWARD \fIcount\fR
FORWARD ALL
BACKWARD
BACKWARD \fIcount\fR
BACKWARD ALL
.fi
.SH "DESCRIPTION"
.PP
\fBFETCH\fR
retrieves rows using a previously\-created cursor\&amp;.
.PP
A cursor has an associated position, which is used by
\fBFETCH\fR\&amp;. The cursor position can be before the first row of the query result, on any particular row of the result, or after the last row of the result\&amp;. When created, a cursor is positioned before the first row\&amp;. After fetching some rows, the cursor is positioned on the row most recently retrieved\&amp;. If
\fBFETCH\fR
runs off the end of the available rows then the cursor is left positioned after the last row, or before the first row if fetching backward\&amp;.
\fBFETCH ALL\fR
or
\fBFETCH BACKWARD ALL\fR
will always leave the cursor positioned after the last row or before the first row\&amp;.
.PP
The forms
NEXT,
PRIOR,
FIRST,
LAST,
ABSOLUTE,
RELATIVE
fetch a single row after moving the cursor appropriately\&amp;. If there is no such row, an empty result is returned, and the cursor is left positioned before the first row or after the last row as appropriate\&amp;.
.PP
The forms using
FORWARD
and
BACKWARD
retrieve the indicated number of rows moving in the forward or backward direction, leaving the cursor positioned on the last\-returned row (or after/before all rows, if the
\fIcount\fR
exceeds the number of rows available)\&amp;.
.PP
RELATIVE 0,
FORWARD 0, and
BACKWARD 0
all request fetching the current row without moving the cursor, that is, re\-fetching the most recently fetched row\&amp;. This will succeed unless the cursor is positioned before the first row or after the last row; in which case, no row is returned\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This page describes usage of cursors at the SQL command level\&amp;. If you are trying to use cursors inside a
PL/pgSQL
function, the rules are different \(em see
Section 41.7, \(lqCursors\(rq, in the documentation\&amp;.
.sp .5v
.RE
.SH "PARAMETERS"
.PP
\fIdirection\fR
.RS 4
\fIdirection\fR
defines the fetch direction and number of rows to fetch\&amp;. It can be one of the following:
.PP
NEXT
.RS 4
Fetch the next row\&amp;. This is the default if
\fIdirection\fR
is omitted\&amp;.
.RE
.PP
PRIOR
.RS 4
Fetch the prior row\&amp;.
.RE
.PP
FIRST
.RS 4
Fetch the first row of the query (same as
ABSOLUTE 1)\&amp;.
.RE
.PP
LAST
.RS 4
Fetch the last row of the query (same as
ABSOLUTE \-1)\&amp;.
.RE
.PP
ABSOLUTE \fIcount\fR
.RS 4
Fetch the
\fIcount\fR\*(Aqth row of the query, or the
abs(\fIcount\fR)\*(Aqth row from the end if
\fIcount\fR
is negative\&amp;. Position before first row or after last row if
\fIcount\fR
is out of range; in particular,
ABSOLUTE 0
positions before the first row\&amp;.
.RE
.PP
RELATIVE \fIcount\fR
.RS 4
Fetch the
\fIcount\fR\*(Aqth succeeding row, or the
abs(\fIcount\fR)\*(Aqth prior row if
\fIcount\fR
is negative\&amp;.
RELATIVE 0
re\-fetches the current row, if any\&amp;.
.RE
.PP
\fIcount\fR
.RS 4
Fetch the next
\fIcount\fR
rows (same as
FORWARD \fIcount\fR)\&amp;.
.RE
.PP
ALL
.RS 4
Fetch all remaining rows (same as
FORWARD ALL)\&amp;.
.RE
.PP
FORWARD
.RS 4
Fetch the next row (same as
NEXT)\&amp;.
.RE
.PP
FORWARD \fIcount\fR
.RS 4
Fetch the next
\fIcount\fR
rows\&amp;.
FORWARD 0
re\-fetches the current row\&amp;.
.RE
.PP
FORWARD ALL
.RS 4
Fetch all remaining rows\&amp;.
.RE
.PP
BACKWARD
.RS 4
Fetch the prior row (same as
PRIOR)\&amp;.
.RE
.PP
BACKWARD \fIcount\fR
.RS 4
Fetch the prior
\fIcount\fR
rows (scanning backwards)\&amp;.
BACKWARD 0
re\-fetches the current row\&amp;.
.RE
.PP
BACKWARD ALL
.RS 4
Fetch all prior rows (scanning backwards)\&amp;.
.RE
.RE
.PP
\fIcount\fR
.RS 4
\fIcount\fR
is a possibly\-signed integer constant, determining the location or number of rows to fetch\&amp;. For
FORWARD
and
BACKWARD
cases, specifying a negative
\fIcount\fR
is equivalent to changing the sense of
FORWARD
and
BACKWARD\&amp;.
.RE
.PP
\fIcursor_name\fR
.RS 4
An open cursor\*(Aqs name\&amp;.
.RE
.SH "OUTPUTS"
.PP
On successful completion, a
\fBFETCH\fR
command returns a command tag of the form
.sp
.if n \{\
.RS 4
.\}
.nf
FETCH \fIcount\fR
.fi
.if n \{\
.RE
.\}
.sp
The
\fIcount\fR
is the number of rows fetched (possibly zero)\&amp;. Note that in
psql, the command tag will not actually be displayed, since
psql
displays the fetched rows instead\&amp;.
.SH "NOTES"
.PP
The cursor should be declared with the
SCROLL
option if one intends to use any variants of
\fBFETCH\fR
other than
\fBFETCH NEXT\fR
or
\fBFETCH FORWARD\fR
with a positive count\&amp;. For simple queries
PostgreSQL
will allow backwards fetch from cursors not declared with
SCROLL, but this behavior is best not relied on\&amp;. If the cursor is declared with
NO SCROLL, no backward fetches are allowed\&amp;.
.PP
ABSOLUTE
fetches are not any faster than navigating to the desired row with a relative move: the underlying implementation must traverse all the intermediate rows anyway\&amp;. Negative absolute fetches are even worse: the query must be read to the end to find the last row, and then traversed backward from there\&amp;. However, rewinding to the start of the query (as with
FETCH ABSOLUTE 0) is fast\&amp;.
.PP
\fBDECLARE\fR(7)
is used to define a cursor\&amp;. Use
\fBMOVE\fR(7)
to change cursor position without retrieving data\&amp;.
.SH "EXAMPLES"
.PP
The following example traverses a table using a cursor:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN WORK;

\-\- Set up a cursor:
DECLARE liahona SCROLL CURSOR FOR SELECT * FROM films;

\-\- Fetch the first 5 rows in the cursor liahona:
FETCH FORWARD 5 FROM liahona;

code  |          title          | did | date_prod  |   kind   |  len
\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-
BL101 | The Third Man           | 101 | 1949\-12\-23 | Drama    | 01:44
BL102 | The African Queen       | 101 | 1951\-08\-11 | Romantic | 01:43
JL201 | Une Femme est une Femme | 102 | 1961\-03\-12 | Romantic | 01:25
P_301 | Vertigo                 | 103 | 1958\-11\-14 | Action   | 02:08
P_302 | Becket                  | 103 | 1964\-02\-03 | Drama    | 02:28

\-\- Fetch the previous row:
FETCH PRIOR FROM liahona;

code  |  title  | did | date_prod  |  kind  |  len
\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-
P_301 | Vertigo | 103 | 1958\-11\-14 | Action | 02:08

\-\- Close the cursor and end the transaction:
CLOSE liahona;
COMMIT WORK;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The SQL standard defines
\fBFETCH\fR
for use in embedded SQL only\&amp;. The variant of
\fBFETCH\fR
described here returns the data as if it were a
\fBSELECT\fR
result rather than placing it in host variables\&amp;. Other than this point,
\fBFETCH\fR
is fully upward\-compatible with the SQL standard\&amp;.
.PP
The
\fBFETCH\fR
forms involving
FORWARD
and
BACKWARD, as well as the forms
FETCH \fIcount\fR
and
FETCH ALL, in which
FORWARD
is implicit, are
PostgreSQL
extensions\&amp;.
.PP
The SQL standard allows only
FROM
preceding the cursor name; the option to use
IN, or to leave them out altogether, is an extension\&amp;.
.SH "SEE ALSO"
\fBCLOSE\fR(7), \fBDECLARE\fR(7), \fBMOVE\fR(7)
'\" t
.\"     Title: GRANT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "GRANT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
GRANT \- define access privileges
.SH "SYNOPSIS"
.sp
.nf
GRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON { [ TABLE ] \fItable_name\fR [, \&amp;.\&amp;.\&amp;.]
| ALL TABLES IN SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.] }
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { { SELECT | INSERT | UPDATE | REFERENCES } ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] )
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) }
ON [ TABLE ] \fItable_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { { USAGE | SELECT | UPDATE }
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON { SEQUENCE \fIsequence_name\fR [, \&amp;.\&amp;.\&amp;.]
| ALL SEQUENCES IN SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.] }
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON DATABASE \fIdatabase_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
ON DOMAIN \fIdomain_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
ON FOREIGN DATA WRAPPER \fIfdw_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
ON FOREIGN SERVER \fIserver_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { EXECUTE | ALL [ PRIVILEGES ] }
ON { FUNCTION \fIfunction_name\fR ( [ [ \fIargmode\fR ] [ \fIarg_name\fR ] \fIarg_type\fR [, \&amp;.\&amp;.\&amp;.] ] ) [, \&amp;.\&amp;.\&amp;.]
| ALL FUNCTIONS IN SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.] }
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
ON LANGUAGE \fIlang_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { { SELECT | UPDATE } [, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON LARGE OBJECT \fIloid\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { { CREATE | USAGE } [, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { CREATE | ALL [ PRIVILEGES ] }
ON TABLESPACE \fItablespace_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
ON TYPE \fItype_name\fR [, \&amp;.\&amp;.\&amp;.]
TO \fIrole_specification\fR [, \&amp;.\&amp;.\&amp;.] [ WITH GRANT OPTION ]

where \fIrole_specification\fR can be:

[ GROUP ] \fIrole_name\fR
| PUBLIC
| CURRENT_USER
| SESSION_USER

GRANT \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.] TO \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.] [ WITH ADMIN OPTION ]
.fi
.SH "DESCRIPTION"
.PP
The
\fBGRANT\fR
command has two basic variants: one that grants privileges on a database object (table, column, view, foreign table, sequence, database, foreign\-data wrapper, foreign server, function, procedural language, schema, or tablespace), and one that grants membership in a role\&amp;. These variants are similar in many ways, but they are different enough to be described separately\&amp;.
.SS "GRANT on Database Objects"
.PP
This variant of the
\fBGRANT\fR
command gives specific privileges on a database object to one or more roles\&amp;. These privileges are added to those already granted, if any\&amp;.
.PP
There is also an option to grant privileges on all objects of the same type within one or more schemas\&amp;. This functionality is currently supported only for tables, sequences, and functions (but note that
ALL TABLES
is considered to include views and foreign tables)\&amp;.
.PP
The key word
PUBLIC
indicates that the privileges are to be granted to all roles, including those that might be created later\&amp;.
PUBLIC
can be thought of as an implicitly defined group that always includes all roles\&amp;. Any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to
PUBLIC\&amp;.
.PP
If
WITH GRANT OPTION
is specified, the recipient of the privilege can in turn grant it to others\&amp;. Without a grant option, the recipient cannot do that\&amp;. Grant options cannot be granted to
PUBLIC\&amp;.
.PP
There is no need to grant privileges to the owner of an object (usually the user that created it), as the owner has all privileges by default\&amp;. (The owner could, however, choose to revoke some of their own privileges for safety\&amp;.)
.PP
The right to drop an object, or to alter its definition in any way, is not treated as a grantable privilege; it is inherent in the owner, and cannot be granted or revoked\&amp;. (However, a similar effect can be obtained by granting or revoking membership in the role that owns the object; see below\&amp;.) The owner implicitly has all grant options for the object, too\&amp;.
.PP
PostgreSQL grants default privileges on some types of objects to
PUBLIC\&amp;. No privileges are granted to
PUBLIC
by default on tables, columns, schemas or tablespaces\&amp;. For other types, the default privileges granted to
PUBLIC
are as follows:
CONNECT
and
CREATE TEMP TABLE
for databases;
EXECUTE
privilege for functions; and
USAGE
privilege for languages\&amp;. The object owner can, of course,
\fBREVOKE\fR
both default and expressly granted privileges\&amp;. (For maximum security, issue the
\fBREVOKE\fR
in the same transaction that creates the object; then there is no window in which another user can use the object\&amp;.) Also, these initial default privilege settings can be changed using the
ALTER DEFAULT PRIVILEGES (\fBALTER_DEFAULT_PRIVILEGES\fR(7))
command\&amp;.
.PP
The possible privileges are:
.PP
SELECT
.RS 4
Allows
\fBSELECT\fR(7)
from any column, or the specific columns listed, of the specified table, view, or sequence\&amp;. Also allows the use of
\fBCOPY\fR(7)
TO\&amp;. This privilege is also needed to reference existing column values in
\fBUPDATE\fR(7)
or
\fBDELETE\fR(7)\&amp;. For sequences, this privilege also allows the use of the
\fBcurrval\fR
function\&amp;. For large objects, this privilege allows the object to be read\&amp;.
.RE
.PP
INSERT
.RS 4
Allows
\fBINSERT\fR(7)
of a new row into the specified table\&amp;. If specific columns are listed, only those columns may be assigned to in the
\fBINSERT\fR
command (other columns will therefore receive default values)\&amp;. Also allows
\fBCOPY\fR(7)
FROM\&amp;.
.RE
.PP
UPDATE
.RS 4
Allows
\fBUPDATE\fR(7)
of any column, or the specific columns listed, of the specified table\&amp;. (In practice, any nontrivial
\fBUPDATE\fR
command will require
SELECT
privilege as well, since it must reference table columns to determine which rows to update, and/or to compute new values for columns\&amp;.)
SELECT \&amp;.\&amp;.\&amp;. FOR UPDATE
and
SELECT \&amp;.\&amp;.\&amp;. FOR SHARE
also require this privilege on at least one column, in addition to the
SELECT
privilege\&amp;. For sequences, this privilege allows the use of the
\fBnextval\fR
and
\fBsetval\fR
functions\&amp;. For large objects, this privilege allows writing or truncating the object\&amp;.
.RE
.PP
DELETE
.RS 4
Allows
\fBDELETE\fR(7)
of a row from the specified table\&amp;. (In practice, any nontrivial
\fBDELETE\fR
command will require
SELECT
privilege as well, since it must reference table columns to determine which rows to delete\&amp;.)
.RE
.PP
TRUNCATE
.RS 4
Allows
\fBTRUNCATE\fR(7)
on the specified table\&amp;.
.RE
.PP
REFERENCES
.RS 4
To create a foreign key constraint, it is necessary to have this privilege on both the referencing and referenced columns\&amp;. The privilege may be granted for all columns of a table, or just specific columns\&amp;.
.RE
.PP
TRIGGER
.RS 4
Allows the creation of a trigger on the specified table\&amp;. (See the
CREATE TRIGGER (\fBCREATE_TRIGGER\fR(7))
statement\&amp;.)
.RE
.PP
CREATE
.RS 4
For databases, allows new schemas to be created within the database\&amp;.
.sp
For schemas, allows new objects to be created within the schema\&amp;. To rename an existing object, you must own the object
\fIand\fR
have this privilege for the containing schema\&amp;.
.sp
For tablespaces, allows tables, indexes, and temporary files to be created within the tablespace, and allows databases to be created that have the tablespace as their default tablespace\&amp;. (Note that revoking this privilege will not alter the placement of existing objects\&amp;.)
.RE
.PP
CONNECT
.RS 4
Allows the user to connect to the specified database\&amp;. This privilege is checked at connection startup (in addition to checking any restrictions imposed by
pg_hba\&amp;.conf)\&amp;.
.RE
.PP
TEMPORARY
.br
TEMP
.RS 4
Allows temporary tables to be created while using the specified database\&amp;.
.RE
.PP
EXECUTE
.RS 4
Allows the use of the specified function and the use of any operators that are implemented on top of the function\&amp;. This is the only type of privilege that is applicable to functions\&amp;. (This syntax works for aggregate functions, as well\&amp;.)
.RE
.PP
USAGE
.RS 4
For procedural languages, allows the use of the specified language for the creation of functions in that language\&amp;. This is the only type of privilege that is applicable to procedural languages\&amp;.
.sp
For schemas, allows access to objects contained in the specified schema (assuming that the objects\*(Aq own privilege requirements are also met)\&amp;. Essentially this allows the grantee to
\(lqlook up\(rq
objects within the schema\&amp;. Without this permission, it is still possible to see the object names, e\&amp;.g\&amp;. by querying the system tables\&amp;. Also, after revoking this permission, existing backends might have statements that have previously performed this lookup, so this is not a completely secure way to prevent object access\&amp;.
.sp
For sequences, this privilege allows the use of the
\fBcurrval\fR
and
\fBnextval\fR
functions\&amp;.
.sp
For types and domains, this privilege allow the use of the type or domain in the creation of tables, functions, and other schema objects\&amp;. (Note that it does not control general
\(lqusage\(rq
of the type, such as values of the type appearing in queries\&amp;. It only prevents objects from being created that depend on the type\&amp;. The main purpose of the privilege is controlling which users create dependencies on a type, which could prevent the owner from changing the type later\&amp;.)
.sp
For foreign\-data wrappers, this privilege enables the grantee to create new servers using that foreign\-data wrapper\&amp;.
.sp
For servers, this privilege enables the grantee to create foreign tables using the server, and also to create, alter, or drop their own user\*(Aqs user mappings associated with that server\&amp;.
.RE
.PP
ALL PRIVILEGES
.RS 4
Grant all of the available privileges at once\&amp;. The
PRIVILEGES
key word is optional in
PostgreSQL, though it is required by strict SQL\&amp;.
.RE
The privileges required by other commands are listed on the reference page of the respective command\&amp;.
.SS "GRANT on Roles"
.PP
This variant of the
\fBGRANT\fR
command grants membership in a role to one or more other roles\&amp;. Membership in a role is significant because it conveys the privileges granted to a role to each of its members\&amp;.
.PP
If
WITH ADMIN OPTION
is specified, the member can in turn grant membership in the role to others, and revoke membership in the role as well\&amp;. Without the admin option, ordinary users cannot do that\&amp;. A role is not considered to hold
WITH ADMIN OPTION
on itself, but it may grant or revoke membership in itself from a database session where the session user matches the role\&amp;. Database superusers can grant or revoke membership in any role to anyone\&amp;. Roles having
CREATEROLE
privilege can grant or revoke membership in any role that is not a superuser\&amp;.
.PP
Unlike the case with privileges, membership in a role cannot be granted to
PUBLIC\&amp;. Note also that this form of the command does not allow the noise word
GROUP\&amp;.
.SH "NOTES"
.PP
The
\fBREVOKE\fR(7)
command is used to revoke access privileges\&amp;.
.PP
Since
PostgreSQL
8\&amp;.1, the concepts of users and groups have been unified into a single kind of entity called a role\&amp;. It is therefore no longer necessary to use the keyword
GROUP
to identify whether a grantee is a user or a group\&amp;.
GROUP
is still allowed in the command, but it is a noise word\&amp;.
.PP
A user may perform
\fBSELECT\fR,
\fBINSERT\fR, etc\&amp;. on a column if they hold that privilege for either the specific column or its whole table\&amp;. Granting the privilege at the table level and then revoking it for one column will not do what one might wish: the table\-level grant is unaffected by a column\-level operation\&amp;.
.PP
When a non\-owner of an object attempts to
\fBGRANT\fR
privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object\&amp;. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options\&amp;. The
\fBGRANT ALL PRIVILEGES\fR
forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held\&amp;. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur\&amp;.)
.PP
It should be noted that database superusers can access all objects regardless of object privilege settings\&amp;. This is comparable to the rights of
root
in a Unix system\&amp;. As with
root, it\*(Aqs unwise to operate as a superuser except when absolutely necessary\&amp;.
.PP
If a superuser chooses to issue a
\fBGRANT\fR
or
\fBREVOKE\fR
command, the command is performed as though it were issued by the owner of the affected object\&amp;. In particular, privileges granted via such a command will appear to have been granted by the object owner\&amp;. (For role membership, the membership appears to have been granted by the containing role itself\&amp;.)
.PP
\fBGRANT\fR
and
\fBREVOKE\fR
can also be done by a role that is not the owner of the affected object, but is a member of the role that owns the object, or is a member of a role that holds privileges
WITH GRANT OPTION
on the object\&amp;. In this case the privileges will be recorded as having been granted by the role that actually owns the object or holds the privileges
WITH GRANT OPTION\&amp;. For example, if table
t1
is owned by role
g1, of which role
u1
is a member, then
u1
can grant privileges on
t1
to
u2, but those privileges will appear to have been granted directly by
g1\&amp;. Any other member of role
g1
could revoke them later\&amp;.
.PP
If the role executing
\fBGRANT\fR
holds the required privileges indirectly via more than one role membership path, it is unspecified which containing role will be recorded as having done the grant\&amp;. In such cases it is best practice to use
\fBSET ROLE\fR
to become the specific role you want to do the
\fBGRANT\fR
as\&amp;.
.PP
Granting permission on a table does not automatically extend permissions to any sequences used by the table, including sequences tied to
SERIAL
columns\&amp;. Permissions on sequences must be set separately\&amp;.
.PP
Use
\fBpsql\fR(1)\*(Aqs
\fB\edp\fR
command to obtain information about existing privileges for tables and columns\&amp;. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
=&gt; \edp mytable
Access privileges
Schema |  Name   | Type  |   Access privileges   | Column access privileges 
\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
public | mytable | table | miriam=arwdDxt/miriam | col1:
: =r/miriam             :   miriam_rw=rw/miriam
: admin=arw/miriam        
(1 row)
.fi
.if n \{\
.RE
.\}
.sp
The entries shown by
\fB\edp\fR
are interpreted thus:
.sp
.if n \{\
.RS 4
.\}
.nf
rolename=xxxx \-\- privileges granted to a role
=xxxx \-\- privileges granted to PUBLIC

r \-\- SELECT ("read")
w \-\- UPDATE ("write")
a \-\- INSERT ("append")
d \-\- DELETE
D \-\- TRUNCATE
x \-\- REFERENCES
t \-\- TRIGGER
X \-\- EXECUTE
U \-\- USAGE
C \-\- CREATE
c \-\- CONNECT
T \-\- TEMPORARY
arwdDxt \-\- ALL PRIVILEGES (for tables, varies for other objects)
* \-\- grant option for preceding privilege

/yyyy \-\- role that granted this privilege
.fi
.if n \{\
.RE
.\}
.sp
The above example display would be seen by user
miriam
after creating table
mytable
and doing:
.sp
.if n \{\
.RS 4
.\}
.nf
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO admin;
GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;
.fi
.if n \{\
.RE
.\}
.PP
For non\-table objects there are other
\fB\ed\fR
commands that can display their privileges\&amp;.
.PP
If the
\(lqAccess privileges\(rq
column is empty for a given object, it means the object has default privileges (that is, its privileges column is null)\&amp;. Default privileges always include all privileges for the owner, and can include some privileges for
PUBLIC
depending on the object type, as explained above\&amp;. The first
\fBGRANT\fR
or
\fBREVOKE\fR
on an object will instantiate the default privileges (producing, for example,
{miriam=arwdDxt/miriam}) and then modify them per the specified request\&amp;. Similarly, entries are shown in
\(lqColumn access privileges\(rq
only for columns with nondefault privileges\&amp;. (Note: for this purpose,
\(lqdefault privileges\(rq
always means the built\-in default privileges for the object\*(Aqs type\&amp;. An object whose privileges have been affected by an
\fBALTER DEFAULT PRIVILEGES\fR
command will always be shown with an explicit privilege entry that includes the effects of the
\fBALTER\fR\&amp;.)
.PP
Notice that the owner\*(Aqs implicit grant options are not marked in the access privileges display\&amp;. A
*
will appear only when grant options have been explicitly granted to someone\&amp;.
.SH "EXAMPLES"
.PP
Grant insert privilege to all users on table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
GRANT INSERT ON films TO PUBLIC;
.fi
.if n \{\
.RE
.\}
.PP
Grant all available privileges to user
manuel
on view
kinds:
.sp
.if n \{\
.RS 4
.\}
.nf
GRANT ALL PRIVILEGES ON kinds TO manuel;
.fi
.if n \{\
.RE
.\}
.sp
Note that while the above will indeed grant all privileges if executed by a superuser or the owner of
kinds, when executed by someone else it will only grant those permissions for which the someone else has grant options\&amp;.
.PP
Grant membership in role
admins
to user
joe:
.sp
.if n \{\
.RS 4
.\}
.nf
GRANT admins TO joe;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
According to the SQL standard, the
PRIVILEGES
key word in
ALL PRIVILEGES
is required\&amp;. The SQL standard does not support setting the privileges on more than one object per command\&amp;.
.PP
PostgreSQL
allows an object owner to revoke their own ordinary privileges: for example, a table owner can make the table read\-only to themselves by revoking their own
INSERT,
UPDATE,
DELETE, and
TRUNCATE
privileges\&amp;. This is not possible according to the SQL standard\&amp;. The reason is that
PostgreSQL
treats the owner\*(Aqs privileges as having been granted by the owner to themselves; therefore they can revoke them too\&amp;. In the SQL standard, the owner\*(Aqs privileges are granted by an assumed entity
\(lq_SYSTEM\(rq\&amp;. Not being
\(lq_SYSTEM\(rq, the owner cannot revoke these rights\&amp;.
.PP
According to the SQL standard, grant options can be granted to
PUBLIC; PostgreSQL only supports granting grant options to roles\&amp;.
.PP
The SQL standard provides for a
USAGE
privilege on other kinds of objects: character sets, collations, translations\&amp;.
.PP
In the SQL standard, sequences only have a
USAGE
privilege, which controls the use of the
NEXT VALUE FOR
expression, which is equivalent to the function
\fBnextval\fR
in PostgreSQL\&amp;. The sequence privileges
SELECT
and
UPDATE
are PostgreSQL extensions\&amp;. The application of the sequence
USAGE
privilege to the
currval
function is also a PostgreSQL extension (as is the function itself)\&amp;.
.PP
Privileges on databases, tablespaces, schemas, and languages are
PostgreSQL
extensions\&amp;.
.SH "SEE ALSO"
\fBREVOKE\fR(7), ALTER DEFAULT PRIVILEGES (\fBALTER_DEFAULT_PRIVILEGES\fR(7))
'\" t
.\"     Title: IMPORT FOREIGN SCHEMA
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "IMPORT FOREIGN SCHEMA" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
IMPORT_FOREIGN_SCHEMA \- import table definitions from a foreign server
.SH "SYNOPSIS"
.sp
.nf
IMPORT FOREIGN SCHEMA \fIremote_schema\fR
[ { LIMIT TO | EXCEPT } ( \fItable_name\fR [, \&amp;.\&amp;.\&amp;.] ) ]
FROM SERVER \fIserver_name\fR
INTO \fIlocal_schema\fR
[ OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;. ] ) ]
.fi
.SH "DESCRIPTION"
.PP
\fBIMPORT FOREIGN SCHEMA\fR
creates foreign tables that represent tables existing on a foreign server\&amp;. The new foreign tables will be owned by the user issuing the command and are created with the correct column definitions and options to match the remote tables\&amp;.
.PP
By default, all tables and views existing in a particular schema on the foreign server are imported\&amp;. Optionally, the list of tables can be limited to a specified subset, or specific tables can be excluded\&amp;. The new foreign tables are all created in the target schema, which must already exist\&amp;.
.PP
To use
\fBIMPORT FOREIGN SCHEMA\fR, the user must have
USAGE
privilege on the foreign server, as well as
CREATE
privilege on the target schema\&amp;.
.SH "PARAMETERS"
.PP
\fIremote_schema\fR
.RS 4
The remote schema to import from\&amp;. The specific meaning of a remote schema depends on the foreign data wrapper in use\&amp;.
.RE
.PP
LIMIT TO ( \fItable_name\fR [, \&amp;.\&amp;.\&amp;.] )
.RS 4
Import only foreign tables matching one of the given table names\&amp;. Other tables existing in the foreign schema will be ignored\&amp;.
.RE
.PP
EXCEPT ( \fItable_name\fR [, \&amp;.\&amp;.\&amp;.] )
.RS 4
Exclude specified foreign tables from the import\&amp;. All tables existing in the foreign schema will be imported except the ones listed here\&amp;.
.RE
.PP
\fIserver_name\fR
.RS 4
The foreign server to import from\&amp;.
.RE
.PP
\fIlocal_schema\fR
.RS 4
The schema in which the imported foreign tables will be created\&amp;.
.RE
.PP
OPTIONS ( \fIoption\fR \*(Aq\fIvalue\fR\*(Aq [, \&amp;.\&amp;.\&amp;.] )
.RS 4
Options to be used during the import\&amp;. The allowed option names and values are specific to each foreign data wrapper\&amp;.
.RE
.SH "EXAMPLES"
.PP
Import table definitions from a remote schema
foreign_films
on server
film_server, creating the foreign tables in local schema
films:
.sp
.if n \{\
.RS 4
.\}
.nf
IMPORT FOREIGN SCHEMA foreign_films
FROM SERVER film_server INTO films;
.fi
.if n \{\
.RE
.\}
.PP
As above, but import only the two tables
actors
and
directors
(if they exist):
.sp
.if n \{\
.RS 4
.\}
.nf
IMPORT FOREIGN SCHEMA foreign_films LIMIT TO (actors, directors)
FROM SERVER film_server INTO films;
.fi
.if n \{\
.RE
.\}
.sp
.SH "COMPATIBILITY"
.PP
The
\fBIMPORT FOREIGN SCHEMA\fR
command conforms to the
SQL
standard, except that the
OPTIONS
clause is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE FOREIGN TABLE (\fBCREATE_FOREIGN_TABLE\fR(7)), CREATE SERVER (\fBCREATE_SERVER\fR(7))
'\" t
.\"     Title: INSERT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "INSERT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
INSERT \- create new rows in a table
.SH "SYNOPSIS"
.sp
.nf
[ WITH [ RECURSIVE ] \fIwith_query\fR [, \&amp;.\&amp;.\&amp;.] ]
INSERT INTO \fItable_name\fR [ AS \fIalias\fR ] [ ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ]
{ DEFAULT VALUES | VALUES ( { \fIexpression\fR | DEFAULT } [, \&amp;.\&amp;.\&amp;.] ) [, \&amp;.\&amp;.\&amp;.] | \fIquery\fR }
[ ON CONFLICT [ \fIconflict_target\fR ] \fIconflict_action\fR ]
[ RETURNING * | \fIoutput_expression\fR [ [ AS ] \fIoutput_name\fR ] [, \&amp;.\&amp;.\&amp;.] ]

where \fIconflict_target\fR can be one of:

( { \fIindex_column_name\fR | ( \fIindex_expression\fR ) } [ COLLATE \fIcollation\fR ] [ \fIopclass\fR ] [, \&amp;.\&amp;.\&amp;.] ) [ WHERE \fIindex_predicate\fR ]
ON CONSTRAINT \fIconstraint_name\fR

and \fIconflict_action\fR is one of:

DO NOTHING
DO UPDATE SET { \fIcolumn_name\fR = { \fIexpression\fR | DEFAULT } |
( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) = ( { \fIexpression\fR | DEFAULT } [, \&amp;.\&amp;.\&amp;.] ) |
( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) = ( \fIsub\-SELECT\fR )
} [, \&amp;.\&amp;.\&amp;.]
[ WHERE \fIcondition\fR ]
.fi
.SH "DESCRIPTION"
.PP
\fBINSERT\fR
inserts new rows into a table\&amp;. One can insert one or more rows specified by value expressions, or zero or more rows resulting from a query\&amp;.
.PP
The target column names can be listed in any order\&amp;. If no list of column names is given at all, the default is all the columns of the table in their declared order; or the first
\fIN\fR
column names, if there are only
\fIN\fR
columns supplied by the
VALUES
clause or
\fIquery\fR\&amp;. The values supplied by the
VALUES
clause or
\fIquery\fR
are associated with the explicit or implicit column list left\-to\-right\&amp;.
.PP
Each column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or null if there is none\&amp;.
.PP
If the expression for any column is not of the correct data type, automatic type conversion will be attempted\&amp;.
.PP
ON CONFLICT
can be used to specify an alternative action to raising a unique constraint or exclusion constraint violation error\&amp;. (See
ON CONFLICT Clause
below\&amp;.)
.PP
The optional
RETURNING
clause causes
\fBINSERT\fR
to compute and return value(s) based on each row actually inserted (or updated, if an
ON CONFLICT DO UPDATE
clause was used)\&amp;. This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number\&amp;. However, any expression using the table\*(Aqs columns is allowed\&amp;. The syntax of the
RETURNING
list is identical to that of the output list of
\fBSELECT\fR\&amp;. Only rows that were successfully inserted or updated will be returned\&amp;. For example, if a row was locked but not updated because an
ON CONFLICT DO UPDATE \&amp;.\&amp;.\&amp;. WHERE
clause
\fIcondition\fR
was not satisfied, the row will not be returned\&amp;.
.PP
You must have
INSERT
privilege on a table in order to insert into it\&amp;. If
ON CONFLICT DO UPDATE
is present,
UPDATE
privilege on the table is also required\&amp;.
.PP
If a column list is specified, you only need
INSERT
privilege on the listed columns\&amp;. Similarly, when
ON CONFLICT DO UPDATE
is specified, you only need
UPDATE
privilege on the column(s) that are listed to be updated\&amp;. However,
ON CONFLICT DO UPDATE
also requires
SELECT
privilege on any column whose values are read in the
ON CONFLICT DO UPDATE
expressions or
\fIcondition\fR\&amp;.
.PP
Use of the
RETURNING
clause requires
SELECT
privilege on all columns mentioned in
RETURNING\&amp;. If you use the
\fIquery\fR
clause to insert rows from a query, you of course need to have
SELECT
privilege on any table or column used in the query\&amp;.
.SH "PARAMETERS"
.SS "Inserting"
.PP
This section covers parameters that may be used when only inserting new rows\&amp;. Parameters
\fIexclusively\fR
used with the
ON CONFLICT
clause are described separately\&amp;.
.PP
\fIwith_query\fR
.RS 4
The
WITH
clause allows you to specify one or more subqueries that can be referenced by name in the
\fBINSERT\fR
query\&amp;. See
Section 7.8, \(lqWITH Queries (Common Table Expressions)\(rq, in the documentation
and
\fBSELECT\fR(7)
for details\&amp;.
.sp
It is possible for the
\fIquery\fR
(\fBSELECT\fR
statement) to also contain a
WITH
clause\&amp;. In such a case both sets of
\fIwith_query\fR
can be referenced within the
\fIquery\fR, but the second one takes precedence since it is more closely nested\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of an existing table\&amp;.
.RE
.PP
\fIalias\fR
.RS 4
A substitute name for
\fItable_name\fR\&amp;. When an alias is provided, it completely hides the actual name of the table\&amp;. This is particularly useful when
ON CONFLICT DO UPDATE
targets a table named excluded, since that\*(Aqs also the name of the special table representing rows proposed for insertion\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a column in the table named by
\fItable_name\fR\&amp;. The column name can be qualified with a subfield name or array subscript, if needed\&amp;. (Inserting into only some fields of a composite column leaves the other fields null\&amp;.) When referencing a column with
ON CONFLICT DO UPDATE, do not include the table\*(Aqs name in the specification of a target column\&amp;. For example,
INSERT INTO table_name \&amp;.\&amp;.\&amp;. ON CONFLICT DO UPDATE SET table_name\&amp;.col = 1
is invalid (this follows the general behavior for
\fBUPDATE\fR)\&amp;.
.RE
.PP
DEFAULT VALUES
.RS 4
All columns will be filled with their default values\&amp;.
.RE
.PP
\fIexpression\fR
.RS 4
An expression or value to assign to the corresponding column\&amp;.
.RE
.PP
DEFAULT
.RS 4
The corresponding column will be filled with its default value\&amp;.
.RE
.PP
\fIquery\fR
.RS 4
A query (\fBSELECT\fR
statement) that supplies the rows to be inserted\&amp;. Refer to the
\fBSELECT\fR(7)
statement for a description of the syntax\&amp;.
.RE
.PP
\fIoutput_expression\fR
.RS 4
An expression to be computed and returned by the
\fBINSERT\fR
command after each row is inserted or updated\&amp;. The expression can use any column names of the table named by
\fItable_name\fR\&amp;. Write
*
to return all columns of the inserted or updated row(s)\&amp;.
.RE
.PP
\fIoutput_name\fR
.RS 4
A name to use for a returned column\&amp;.
.RE
.SS "ON CONFLICT Clause"
.PP
The optional
ON CONFLICT
clause specifies an alternative action to raising a unique violation or exclusion constraint violation error\&amp;. For each individual row proposed for insertion, either the insertion proceeds, or, if an
\fIarbiter\fR
constraint or index specified by
\fIconflict_target\fR
is violated, the alternative
\fIconflict_action\fR
is taken\&amp;.
ON CONFLICT DO NOTHING
simply avoids inserting a row as its alternative action\&amp;.
ON CONFLICT DO UPDATE
updates the existing row that conflicts with the row proposed for insertion as its alternative action\&amp;.
.PP
\fIconflict_target\fR
can perform
\fIunique index inference\fR\&amp;. When performing inference, it consists of one or more
\fIindex_column_name\fR
columns and/or
\fIindex_expression\fR
expressions, and an optional
\fIindex_predicate\fR\&amp;. All
\fItable_name\fR
unique indexes that, without regard to order, contain exactly the
\fIconflict_target\fR\-specified columns/expressions are inferred (chosen) as arbiter indexes\&amp;. If an
\fIindex_predicate\fR
is specified, it must, as a further requirement for inference, satisfy arbiter indexes\&amp;. Note that this means a non\-partial unique index (a unique index without a predicate) will be inferred (and thus used by
ON CONFLICT) if such an index satisfying every other criteria is available\&amp;. If an attempt at inference is unsuccessful, an error is raised\&amp;.
.PP
ON CONFLICT DO UPDATE
guarantees an atomic
\fBINSERT\fR
or
\fBUPDATE\fR
outcome; provided there is no independent error, one of those two outcomes is guaranteed, even under high concurrency\&amp;. This is also known as
UPSERT
\(em
\(lqUPDATE or INSERT\(rq\&amp;.
.PP
\fIconflict_target\fR
.RS 4
Specifies which conflicts
ON CONFLICT
takes the alternative action on by choosing
arbiter indexes\&amp;. Either performs
\fIunique index inference\fR, or names a constraint explicitly\&amp;. For
ON CONFLICT DO NOTHING, it is optional to specify a
\fIconflict_target\fR; when omitted, conflicts with all usable constraints (and unique indexes) are handled\&amp;. For
ON CONFLICT DO UPDATE, a
\fIconflict_target\fR\fImust\fR
be provided\&amp;.
.RE
.PP
\fIconflict_action\fR
.RS 4
\fIconflict_action\fR
specifies an alternative
ON CONFLICT
action\&amp;. It can be either
DO NOTHING, or a
DO UPDATE
clause specifying the exact details of the
UPDATE
action to be performed in case of a conflict\&amp;. The
SET
and
WHERE
clauses in
ON CONFLICT DO UPDATE
have access to the existing row using the table\*(Aqs name (or an alias), and to rows proposed for insertion using the special
\fIexcluded\fR
table\&amp;.
SELECT
privilege is required on any column in the target table where corresponding
\fIexcluded\fR
columns are read\&amp;.
.sp
Note that the effects of all per\-row
BEFORE INSERT
triggers are reflected in
\fIexcluded\fR
values, since those effects may have contributed to the row being excluded from insertion\&amp;.
.RE
.PP
\fIindex_column_name\fR
.RS 4
The name of a
\fItable_name\fR
column\&amp;. Used to infer arbiter indexes\&amp;. Follows
\fBCREATE INDEX\fR
format\&amp;.
SELECT
privilege on
\fIindex_column_name\fR
is required\&amp;.
.RE
.PP
\fIindex_expression\fR
.RS 4
Similar to
\fIindex_column_name\fR, but used to infer expressions on
\fItable_name\fR
columns appearing within index definitions (not simple columns)\&amp;. Follows
\fBCREATE INDEX\fR
format\&amp;.
SELECT
privilege on any column appearing within
\fIindex_expression\fR
is required\&amp;.
.RE
.PP
\fIcollation\fR
.RS 4
When specified, mandates that corresponding
\fIindex_column_name\fR
or
\fIindex_expression\fR
use a particular collation in order to be matched during inference\&amp;. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs\&amp;. Follows
\fBCREATE INDEX\fR
format\&amp;.
.RE
.PP
\fIopclass\fR
.RS 4
When specified, mandates that corresponding
\fIindex_column_name\fR
or
\fIindex_expression\fR
use particular operator class in order to be matched during inference\&amp;. Typically this is omitted, as the
\fIequality\fR
semantics are often equivalent across a type\*(Aqs operator classes anyway, or because it\*(Aqs sufficient to trust that the defined unique indexes have the pertinent definition of equality\&amp;. Follows
\fBCREATE INDEX\fR
format\&amp;.
.RE
.PP
\fIindex_predicate\fR
.RS 4
Used to allow inference of partial unique indexes\&amp;. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred\&amp;. Follows
\fBCREATE INDEX\fR
format\&amp;.
SELECT
privilege on any column appearing within
\fIindex_predicate\fR
is required\&amp;.
.RE
.PP
\fIconstraint_name\fR
.RS 4
Explicitly specifies an arbiter
\fIconstraint\fR
by name, rather than inferring a constraint or index\&amp;.
.RE
.PP
\fIcondition\fR
.RS 4
An expression that returns a value of type
boolean\&amp;. Only rows for which this expression returns
true
will be updated, although all rows will be locked when the
ON CONFLICT DO UPDATE
action is taken\&amp;. Note that
\fIcondition\fR
is evaluated last, after a conflict has been identified as a candidate to update\&amp;.
.RE
.PP
Note that exclusion constraints are not supported as arbiters with
ON CONFLICT DO UPDATE\&amp;. In all cases, only
NOT DEFERRABLE
constraints and unique indexes are supported as arbiters\&amp;.
.PP
\fBINSERT\fR
with an
ON CONFLICT DO UPDATE
clause is a
\(lqdeterministic\(rq
statement\&amp;. This means that the command will not be allowed to affect any single existing row more than once; a cardinality violation error will be raised when this situation arises\&amp;. Rows proposed for insertion should not duplicate each other in terms of attributes constrained by an arbiter index or constraint\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBTip\fR
.ps -1
.br
.PP
It is often preferable to use unique index inference rather than naming a constraint directly using
ON CONFLICT ON CONSTRAINT\fI constraint_name\fR\&amp;. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when using
CREATE UNIQUE INDEX \&amp;.\&amp;.\&amp;. CONCURRENTLY
before dropping the index being replaced\&amp;.
.sp .5v
.RE
.SH "OUTPUTS"
.PP
On successful completion, an
\fBINSERT\fR
command returns a command tag of the form
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT \fIoid\fR \fIcount\fR
.fi
.if n \{\
.RE
.\}
.sp
The
\fIcount\fR
is the number of rows inserted or updated\&amp;. If
\fIcount\fR
is exactly one, and the target table has OIDs, then
\fIoid\fR
is the
OID
assigned to the inserted row\&amp;. The single row must have been inserted rather than updated\&amp;. Otherwise
\fIoid\fR
is zero\&amp;.
.PP
If the
\fBINSERT\fR
command contains a
RETURNING
clause, the result will be similar to that of a
\fBSELECT\fR
statement containing the columns and values defined in the
RETURNING
list, computed over the row(s) inserted or updated by the command\&amp;.
.SH "EXAMPLES"
.PP
Insert a single row into table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO films VALUES
(\*(AqUA502\*(Aq, \*(AqBananas\*(Aq, 105, \*(Aq1971\-07\-13\*(Aq, \*(AqComedy\*(Aq, \*(Aq82 minutes\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
In this example, the
len
column is omitted and therefore it will have the default value:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO films (code, title, did, date_prod, kind)
VALUES (\*(AqT_601\*(Aq, \*(AqYojimbo\*(Aq, 106, \*(Aq1961\-06\-16\*(Aq, \*(AqDrama\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
This example uses the
DEFAULT
clause for the date columns rather than specifying a value:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO films VALUES
(\*(AqUA502\*(Aq, \*(AqBananas\*(Aq, 105, DEFAULT, \*(AqComedy\*(Aq, \*(Aq82 minutes\*(Aq);
INSERT INTO films (code, title, did, date_prod, kind)
VALUES (\*(AqT_601\*(Aq, \*(AqYojimbo\*(Aq, 106, DEFAULT, \*(AqDrama\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
To insert a row consisting entirely of default values:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO films DEFAULT VALUES;
.fi
.if n \{\
.RE
.\}
.PP
To insert multiple rows using the multirow
\fBVALUES\fR
syntax:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO films (code, title, did, date_prod, kind) VALUES
(\*(AqB6717\*(Aq, \*(AqTampopo\*(Aq, 110, \*(Aq1985\-02\-10\*(Aq, \*(AqComedy\*(Aq),
(\*(AqHG120\*(Aq, \*(AqThe Dinner Game\*(Aq, 140, DEFAULT, \*(AqComedy\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
This example inserts some rows into table
films
from a table
tmp_films
with the same column layout as
films:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; \*(Aq2004\-05\-07\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
This example inserts into array columns:
.sp
.if n \{\
.RS 4
.\}
.nf
\-\- Create an empty 3x3 gameboard for noughts\-and\-crosses
INSERT INTO tictactoe (game, board[1:3][1:3])
VALUES (1, \*(Aq{{" "," "," "},{" "," "," "},{" "," "," "}}\*(Aq);
\-\- The subscripts in the above example aren\*(Aqt really needed
INSERT INTO tictactoe (game, board)
VALUES (2, \*(Aq{{X," "," "},{" ",O," "},{" ",X," "}}\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
Insert a single row into table
distributors, returning the sequence number generated by the
DEFAULT
clause:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO distributors (did, dname) VALUES (DEFAULT, \*(AqXYZ Widgets\*(Aq)
RETURNING did;
.fi
.if n \{\
.RE
.\}
.PP
Increment the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:
.sp
.if n \{\
.RS 4
.\}
.nf
WITH upd AS (
UPDATE employees SET sales_count = sales_count + 1 WHERE id =
(SELECT sales_person FROM accounts WHERE name = \*(AqAcme Corporation\*(Aq)
RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;
.fi
.if n \{\
.RE
.\}
.PP
Insert or update new distributors as appropriate\&amp;. Assumes a unique index has been defined that constrains values appearing in the
did
column\&amp;. Note that the special
\fIexcluded\fR
table is used to reference values originally proposed for insertion:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO distributors (did, dname)
VALUES (5, \*(AqGizmo Transglobal\*(Aq), (6, \*(AqAssociated Computing, Inc\*(Aq)
ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED\&amp;.dname;
.fi
.if n \{\
.RE
.\}
.PP
Insert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists\&amp;. Example assumes a unique index has been defined that constrains values appearing in the
did
column:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO distributors (did, dname) VALUES (7, \*(AqRedline GmbH\*(Aq)
ON CONFLICT (did) DO NOTHING;
.fi
.if n \{\
.RE
.\}
.PP
Insert or update new distributors as appropriate\&amp;. Example assumes a unique index has been defined that constrains values appearing in the
did
column\&amp;.
WHERE
clause is used to limit the rows actually updated (any existing row not updated will still be locked, though):
.sp
.if n \{\
.RS 4
.\}
.nf
\-\- Don\*(Aqt update existing distributors based in a certain ZIP code
INSERT INTO distributors AS d (did, dname) VALUES (8, \*(AqAnvil Distribution\*(Aq)
ON CONFLICT (did) DO UPDATE
SET dname = EXCLUDED\&amp;.dname || \*(Aq (formerly \*(Aq || d\&amp;.dname || \*(Aq)\*(Aq
WHERE d\&amp;.zipcode &lt;&gt; \*(Aq21201\*(Aq;

\-\- Name a constraint directly in the statement (uses associated
\-\- index to arbitrate taking the DO NOTHING action)
INSERT INTO distributors (did, dname) VALUES (9, \*(AqAntwerp Design\*(Aq)
ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
.fi
.if n \{\
.RE
.\}
.PP
Insert new distributor if possible; otherwise
DO NOTHING\&amp;. Example assumes a unique index has been defined that constrains values appearing in the
did
column on a subset of rows where the
is_active
Boolean column evaluates to
true:
.sp
.if n \{\
.RS 4
.\}
.nf
\-\- This statement could infer a partial unique index on "did"
\-\- with a predicate of "WHERE is_active", but it could also
\-\- just use a regular unique constraint on "did"
INSERT INTO distributors (did, dname) VALUES (10, \*(AqConrad International\*(Aq)
ON CONFLICT (did) WHERE is_active DO NOTHING;
.fi
.if n \{\
.RE
.\}
.sp
.SH "COMPATIBILITY"
.PP
\fBINSERT\fR
conforms to the SQL standard, except that the
RETURNING
clause is a
PostgreSQL
extension, as is the ability to use
WITH
with
\fBINSERT\fR, and the ability to specify an alternative action with
ON CONFLICT\&amp;. Also, the case in which a column name list is omitted, but not all the columns are filled from the
VALUES
clause or
\fIquery\fR, is disallowed by the standard\&amp;.
.PP
Possible limitations of the
\fIquery\fR
clause are documented under
\fBSELECT\fR(7)\&amp;.
'\" t
.\"     Title: LISTEN
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "LISTEN" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
LISTEN \- listen for a notification
.SH "SYNOPSIS"
.sp
.nf
LISTEN \fIchannel\fR
.fi
.SH "DESCRIPTION"
.PP
\fBLISTEN\fR
registers the current session as a listener on the notification channel named
\fIchannel\fR\&amp;. If the current session is already registered as a listener for this notification channel, nothing is done\&amp;.
.PP
Whenever the command
\fBNOTIFY \fR\fB\fIchannel\fR\fR
is invoked, either by this session or another one connected to the same database, all the sessions currently listening on that notification channel are notified, and each will in turn notify its connected client application\&amp;.
.PP
A session can be unregistered for a given notification channel with the
\fBUNLISTEN\fR
command\&amp;. A session\*(Aqs listen registrations are automatically cleared when the session ends\&amp;.
.PP
The method a client application must use to detect notification events depends on which
PostgreSQL
application programming interface it uses\&amp;. With the
libpq
library, the application issues
\fBLISTEN\fR
as an ordinary SQL command, and then must periodically call the function
\fBPQnotifies\fR
to find out whether any notification events have been received\&amp;. Other interfaces such as
libpgtcl
provide higher\-level methods for handling notify events; indeed, with
libpgtcl
the application programmer should not even issue
\fBLISTEN\fR
or
\fBUNLISTEN\fR
directly\&amp;. See the documentation for the interface you are using for more details\&amp;.
.PP
\fBNOTIFY\fR(7)
contains a more extensive discussion of the use of
\fBLISTEN\fR
and
\fBNOTIFY\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIchannel\fR
.RS 4
Name of a notification channel (any identifier)\&amp;.
.RE
.SH "NOTES"
.PP
\fBLISTEN\fR
takes effect at transaction commit\&amp;. If
\fBLISTEN\fR
or
\fBUNLISTEN\fR
is executed within a transaction that later rolls back, the set of notification channels being listened to is unchanged\&amp;.
.PP
A transaction that has executed
\fBLISTEN\fR
cannot be prepared for two\-phase commit\&amp;.
.SH "EXAMPLES"
.PP
Configure and execute a listen/notify sequence from
psql:
.sp
.if n \{\
.RS 4
.\}
.nf
LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448\&amp;.
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBLISTEN\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBNOTIFY\fR(7), \fBUNLISTEN\fR(7)
'\" t
.\"     Title: LOAD
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "LOAD" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
LOAD \- load a shared library file
.SH "SYNOPSIS"
.sp
.nf
LOAD \*(Aq\fIfilename\fR\*(Aq
.fi
.SH "DESCRIPTION"
.PP
This command loads a shared library file into the
PostgreSQL
server\*(Aqs address space\&amp;. If the file has been loaded already, the command does nothing\&amp;. Shared library files that contain C functions are automatically loaded whenever one of their functions is called\&amp;. Therefore, an explicit
\fBLOAD\fR
is usually only needed to load a library that modifies the server\*(Aqs behavior through
\(lqhooks\(rq
rather than providing a set of functions\&amp;.
.PP
The file name is specified in the same way as for shared library names in
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7)); in particular, one can rely on a search path and automatic addition of the system\*(Aqs standard shared library file name extension\&amp;. See
Section 36.9, \(lqC-Language Functions\(rq, in the documentation
for more information on this topic\&amp;.
.PP
Non\-superusers can only apply
\fBLOAD\fR
to library files located in
$libdir/plugins/
\(em the specified
\fIfilename\fR
must begin with exactly that string\&amp;. (It is the database administrator\*(Aqs responsibility to ensure that only
\(lqsafe\(rq
libraries are installed there\&amp;.)
.SH "COMPATIBILITY"
.PP
\fBLOAD\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
.PP
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))
'\" t
.\"     Title: LOCK
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "LOCK" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
LOCK \- lock a table
.SH "SYNOPSIS"
.sp
.nf
LOCK [ TABLE ] [ ONLY ] \fIname\fR [ * ] [, \&amp;.\&amp;.\&amp;.] [ IN \fIlockmode\fR MODE ] [ NOWAIT ]

where \fIlockmode\fR is one of:

ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE
| SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE
.fi
.SH "DESCRIPTION"
.PP
\fBLOCK TABLE\fR
obtains a table\-level lock, waiting if necessary for any conflicting locks to be released\&amp;. If
NOWAIT
is specified,
\fBLOCK TABLE\fR
does not wait to acquire the desired lock: if it cannot be acquired immediately, the command is aborted and an error is emitted\&amp;. Once obtained, the lock is held for the remainder of the current transaction\&amp;. (There is no
\fBUNLOCK TABLE\fR
command; locks are always released at transaction end\&amp;.)
.PP
When acquiring locks automatically for commands that reference tables,
PostgreSQL
always uses the least restrictive lock mode possible\&amp;.
\fBLOCK TABLE\fR
provides for cases when you might need more restrictive locking\&amp;. For example, suppose an application runs a transaction at the
READ COMMITTED
isolation level and needs to ensure that data in a table remains stable for the duration of the transaction\&amp;. To achieve this you could obtain
SHARE
lock mode over the table before querying\&amp;. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because
SHARE
lock mode conflicts with the
ROW EXCLUSIVE
lock acquired by writers, and your
\fBLOCK TABLE \fR\fB\fIname\fR\fR\fB IN SHARE MODE\fR
statement will wait until any concurrent holders of
ROW EXCLUSIVE
mode locks commit or roll back\&amp;. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock\&amp;.
.PP
To achieve a similar effect when running a transaction at the
REPEATABLE READ
or
SERIALIZABLE
isolation level, you have to execute the
\fBLOCK TABLE\fR
statement before executing any
\fBSELECT\fR
or data modification statement\&amp;. A
REPEATABLE READ
or
SERIALIZABLE
transaction\*(Aqs view of data will be frozen when its first
\fBSELECT\fR
or data modification statement begins\&amp;. A
\fBLOCK TABLE\fR
later in the transaction will still prevent concurrent writes \(em but it won\*(Aqt ensure that what the transaction reads corresponds to the latest committed values\&amp;.
.PP
If a transaction of this sort is going to change the data in the table, then it should use
SHARE ROW EXCLUSIVE
lock mode instead of
SHARE
mode\&amp;. This ensures that only one transaction of this type runs at a time\&amp;. Without this, a deadlock is possible: two transactions might both acquire
SHARE
mode, and then be unable to also acquire
ROW EXCLUSIVE
mode to actually perform their updates\&amp;. (Note that a transaction\*(Aqs own locks never conflict, so a transaction can acquire
ROW EXCLUSIVE
mode when it holds
SHARE
mode \(em but not if anyone else holds
SHARE
mode\&amp;.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first\&amp;.
.PP
More information about the lock modes and locking strategies can be found in
Section 13.3, \(lqExplicit Locking\(rq, in the documentation\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of an existing table to lock\&amp;. If
ONLY
is specified before the table name, only that table is locked\&amp;. If
ONLY
is not specified, the table and all its descendant tables (if any) are locked\&amp;. Optionally,
*
can be specified after the table name to explicitly indicate that descendant tables are included\&amp;.
.sp
The command
LOCK TABLE a, b;
is equivalent to
LOCK TABLE a; LOCK TABLE b;\&amp;. The tables are locked one\-by\-one in the order specified in the
\fBLOCK TABLE\fR
command\&amp;.
.RE
.PP
\fIlockmode\fR
.RS 4
The lock mode specifies which locks this lock conflicts with\&amp;. Lock modes are described in
Section 13.3, \(lqExplicit Locking\(rq, in the documentation\&amp;.
.sp
If no lock mode is specified, then
ACCESS EXCLUSIVE, the most restrictive mode, is used\&amp;.
.RE
.PP
NOWAIT
.RS 4
Specifies that
\fBLOCK TABLE\fR
should not wait for any conflicting locks to be released: if the specified lock(s) cannot be acquired immediately without waiting, the transaction is aborted\&amp;.
.RE
.SH "NOTES"
.PP
LOCK TABLE \&amp;.\&amp;.\&amp;. IN ACCESS SHARE MODE
requires
SELECT
privileges on the target table\&amp;.
LOCK TABLE \&amp;.\&amp;.\&amp;. IN ROW EXCLUSIVE MODE
requires
INSERT,
UPDATE,
DELETE, or
TRUNCATE
privileges on the target table\&amp;. All other forms of
\fBLOCK\fR
require table\-level
UPDATE,
DELETE, or
TRUNCATE
privileges\&amp;.
.PP
\fBLOCK TABLE\fR
is useless outside a transaction block: the lock would remain held only to the completion of the statement\&amp;. Therefore
PostgreSQL
reports an error if
\fBLOCK\fR
is used outside a transaction block\&amp;. Use
\fBBEGIN\fR(7)
and
\fBCOMMIT\fR(7)
(or
\fBROLLBACK\fR(7)) to define a transaction block\&amp;.
.PP
\fBLOCK TABLE\fR
only deals with table\-level locks, and so the mode names involving
ROW
are all misnomers\&amp;. These mode names should generally be read as indicating the intention of the user to acquire row\-level locks within the locked table\&amp;. Also,
ROW EXCLUSIVE
mode is a shareable table lock\&amp;. Keep in mind that all the lock modes have identical semantics so far as
\fBLOCK TABLE\fR
is concerned, differing only in the rules about which modes conflict with which\&amp;. For information on how to acquire an actual row\-level lock, see
Section 13.3.2, \(lqRow-level Locks\(rq, in the documentation
and the
The Locking Clause
in the
\fBSELECT\fR
reference documentation\&amp;.
.SH "EXAMPLES"
.PP
Obtain a
SHARE
lock on a primary key table when going to perform inserts into a foreign key table:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN WORK;
LOCK TABLE films IN SHARE MODE;
SELECT id FROM films
WHERE name = \*(AqStar Wars: Episode I \- The Phantom Menace\*(Aq;
\-\- Do ROLLBACK if record was not returned
INSERT INTO films_user_comments VALUES
(_id_, \*(AqGREAT! I was waiting for it for so long!\*(Aq);
COMMIT WORK;
.fi
.if n \{\
.RE
.\}
.PP
Take a
SHARE ROW EXCLUSIVE
lock on a primary key table when going to perform a delete operation:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN WORK;
LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM films_user_comments WHERE id IN
(SELECT id FROM films WHERE rating &lt; 5);
DELETE FROM films WHERE rating &lt; 5;
COMMIT WORK;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBLOCK TABLE\fR
in the SQL standard, which instead uses
\fBSET TRANSACTION\fR
to specify concurrency levels on transactions\&amp;.
PostgreSQL
supports that too; see
SET TRANSACTION (\fBSET_TRANSACTION\fR(7))
for details\&amp;.
.PP
Except for
ACCESS SHARE,
ACCESS EXCLUSIVE, and
SHARE UPDATE EXCLUSIVE
lock modes, the
PostgreSQL
lock modes and the
\fBLOCK TABLE\fR
syntax are compatible with those present in
Oracle\&amp;.
'\" t
.\"     Title: MOVE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "MOVE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
MOVE \- position a cursor
.SH "SYNOPSIS"
.sp
.nf
MOVE [ \fIdirection\fR [ FROM | IN ] ] \fIcursor_name\fR

where \fIdirection\fR can be empty or one of:

NEXT
PRIOR
FIRST
LAST
ABSOLUTE \fIcount\fR
RELATIVE \fIcount\fR
\fIcount\fR
ALL
FORWARD
FORWARD \fIcount\fR
FORWARD ALL
BACKWARD
BACKWARD \fIcount\fR
BACKWARD ALL
.fi
.SH "DESCRIPTION"
.PP
\fBMOVE\fR
repositions a cursor without retrieving any data\&amp;.
\fBMOVE\fR
works exactly like the
\fBFETCH\fR
command, except it only positions the cursor and does not return rows\&amp;.
.PP
The parameters for the
\fBMOVE\fR
command are identical to those of the
\fBFETCH\fR
command; refer to
\fBFETCH\fR(7)
for details on syntax and usage\&amp;.
.SH "OUTPUTS"
.PP
On successful completion, a
\fBMOVE\fR
command returns a command tag of the form
.sp
.if n \{\
.RS 4
.\}
.nf
MOVE \fIcount\fR
.fi
.if n \{\
.RE
.\}
.sp
The
\fIcount\fR
is the number of rows that a
\fBFETCH\fR
command with the same parameters would have returned (possibly zero)\&amp;.
.SH "EXAMPLES"
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN WORK;
DECLARE liahona CURSOR FOR SELECT * FROM films;

\-\- Skip the first 5 rows:
MOVE FORWARD 5 IN liahona;
MOVE 5

\-\- Fetch the 6th row from the cursor liahona:
FETCH 1 FROM liahona;
code  | title  | did | date_prod  |  kind  |  len
\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-
P_303 | 48 Hrs | 103 | 1982\-10\-22 | Action | 01:37
(1 row)

\-\- Close the cursor liahona and end the transaction:
CLOSE liahona;
COMMIT WORK;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBMOVE\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBCLOSE\fR(7), \fBDECLARE\fR(7), \fBFETCH\fR(7)
'\" t
.\"     Title: NOTIFY
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "NOTIFY" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
NOTIFY \- generate a notification
.SH "SYNOPSIS"
.sp
.nf
NOTIFY \fIchannel\fR [ , \fIpayload\fR ]
.fi
.SH "DESCRIPTION"
.PP
The
\fBNOTIFY\fR
command sends a notification event together with an optional
\(lqpayload\(rq
string to each client application that has previously executed
\fBLISTEN \fR\fB\fIchannel\fR\fR
for the specified channel name in the current database\&amp;. Notifications are visible to all users\&amp;.
.PP
\fBNOTIFY\fR
provides a simple interprocess communication mechanism for a collection of processes accessing the same
PostgreSQL
database\&amp;. A payload string can be sent along with the notification, and higher\-level mechanisms for passing structured data can be built by using tables in the database to pass additional data from notifier to listener(s)\&amp;.
.PP
The information passed to the client for a notification event includes the notification channel name, the notifying session\*(Aqs server process
PID, and the payload string, which is an empty string if it has not been specified\&amp;.
.PP
It is up to the database designer to define the channel names that will be used in a given database and what each one means\&amp;. Commonly, the channel name is the same as the name of some table in the database, and the notify event essentially means,
\(lqI changed this table, take a look at it to see what\*(Aqs new\(rq\&amp;. But no such association is enforced by the
\fBNOTIFY\fR
and
\fBLISTEN\fR
commands\&amp;. For example, a database designer could use several different channel names to signal different sorts of changes to a single table\&amp;. Alternatively, the payload string could be used to differentiate various cases\&amp;.
.PP
When
\fBNOTIFY\fR
is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the
\fBNOTIFY\fR
in a statement trigger that is triggered by table updates\&amp;. In this way, notification happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it\&amp;.
.PP
\fBNOTIFY\fR
interacts with SQL transactions in some important ways\&amp;. Firstly, if a
\fBNOTIFY\fR
is executed inside a transaction, the notify events are not delivered until and unless the transaction is committed\&amp;. This is appropriate, since if the transaction is aborted, all the commands within it have had no effect, including
\fBNOTIFY\fR\&amp;. But it can be disconcerting if one is expecting the notification events to be delivered immediately\&amp;. Secondly, if a listening session receives a notification signal while it is within a transaction, the notification event will not be delivered to its connected client until just after the transaction is completed (either committed or aborted)\&amp;. Again, the reasoning is that if a notification were delivered within a transaction that was later aborted, one would want the notification to be undone somehow \(em but the server cannot
\(lqtake back\(rq
a notification once it has sent it to the client\&amp;. So notification events are only delivered between transactions\&amp;. The upshot of this is that applications using
\fBNOTIFY\fR
for real\-time signaling should try to keep their transactions short\&amp;.
.PP
If the same channel name is signaled multiple times from the same transaction with identical payload strings, the database server can decide to deliver a single notification only\&amp;. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications\&amp;. Similarly, notifications from different transactions will never get folded into one notification\&amp;. Except for dropping later instances of duplicate notifications,
\fBNOTIFY\fR
guarantees that notifications from the same transaction get delivered in the order they were sent\&amp;. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed\&amp;.
.PP
It is common for a client that executes
\fBNOTIFY\fR
to be listening on the same notification channel itself\&amp;. In that case it will get back a notification event, just like all the other listening sessions\&amp;. Depending on the application logic, this could result in useless work, for example, reading a database table to find the same updates that that session just wrote out\&amp;. It is possible to avoid such extra work by noticing whether the notifying session\*(Aqs server process
PID
(supplied in the notification event message) is the same as one\*(Aqs own session\*(Aqs
PID
(available from
libpq)\&amp;. When they are the same, the notification event is one\*(Aqs own work bouncing back, and can be ignored\&amp;.
.SH "PARAMETERS"
.PP
\fIchannel\fR
.RS 4
Name of the notification channel to be signaled (any identifier)\&amp;.
.RE
.PP
\fIpayload\fR
.RS 4
The
\(lqpayload\(rq
string to be communicated along with the notification\&amp;. This must be specified as a simple string literal\&amp;. In the default configuration it must be shorter than 8000 bytes\&amp;. (If binary data or large amounts of information need to be communicated, it\*(Aqs best to put it in a database table and send the key of the record\&amp;.)
.RE
.SH "NOTES"
.PP
There is a queue that holds notifications that have been sent but not yet processed by all listening sessions\&amp;. If this queue becomes full, transactions calling
\fBNOTIFY\fR
will fail at commit\&amp;. The queue is quite large (8GB in a standard installation) and should be sufficiently sized for almost every use case\&amp;. However, no cleanup can take place if a session executes
\fBLISTEN\fR
and then enters a transaction for a very long time\&amp;. Once the queue is half full you will see warnings in the log file pointing you to the session that is preventing cleanup\&amp;. In this case you should make sure that this session ends its current transaction so that cleanup can proceed\&amp;.
.PP
The function
\fBpg_notification_queue_usage\fR
returns the fraction of the queue that is currently occupied by pending notifications\&amp;. See
Section 9.25, \(lqSystem Information Functions\(rq, in the documentation
for more information\&amp;.
.PP
A transaction that has executed
\fBNOTIFY\fR
cannot be prepared for two\-phase commit\&amp;.
.SS "pg_notify"
.PP
To send a notification you can also use the function
\fBpg_notify\fR(text, text)\&amp;. The function takes the channel name as the first argument and the payload as the second\&amp;. The function is much easier to use than the
\fBNOTIFY\fR
command if you need to work with non\-constant channel names and payloads\&amp;.
.SH "EXAMPLES"
.PP
Configure and execute a listen/notify sequence from
psql:
.sp
.if n \{\
.RS 4
.\}
.nf
LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448\&amp;.
NOTIFY virtual, \*(AqThis is the payload\*(Aq;
Asynchronous notification "virtual" with payload "This is the payload" received from server process with PID 8448\&amp;.

LISTEN foo;
SELECT pg_notify(\*(Aqfo\*(Aq || \*(Aqo\*(Aq, \*(Aqpay\*(Aq || \*(Aqload\*(Aq);
Asynchronous notification "foo" with payload "payload" received from server process with PID 14728\&amp;.
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBNOTIFY\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBLISTEN\fR(7), \fBUNLISTEN\fR(7)
'\" t
.\"     Title: PREPARE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "PREPARE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
PREPARE \- prepare a statement for execution
.SH "SYNOPSIS"
.sp
.nf
PREPARE \fIname\fR [ ( \fIdata_type\fR [, \&amp;.\&amp;.\&amp;.] ) ] AS \fIstatement\fR
.fi
.SH "DESCRIPTION"
.PP
\fBPREPARE\fR
creates a prepared statement\&amp;. A prepared statement is a server\-side object that can be used to optimize performance\&amp;. When the
\fBPREPARE\fR
statement is executed, the specified statement is parsed, analyzed, and rewritten\&amp;. When an
\fBEXECUTE\fR
command is subsequently issued, the prepared statement is planned and executed\&amp;. This division of labor avoids repetitive parse analysis work, while allowing the execution plan to depend on the specific parameter values supplied\&amp;.
.PP
Prepared statements can take parameters: values that are substituted into the statement when it is executed\&amp;. When creating the prepared statement, refer to parameters by position, using
$1,
$2, etc\&amp;. A corresponding list of parameter data types can optionally be specified\&amp;. When a parameter\*(Aqs data type is not specified or is declared as
unknown, the type is inferred from the context in which the parameter is used (if possible)\&amp;. When executing the statement, specify the actual values for these parameters in the
\fBEXECUTE\fR
statement\&amp;. Refer to
\fBEXECUTE\fR(7)
for more information about that\&amp;.
.PP
Prepared statements only last for the duration of the current database session\&amp;. When the session ends, the prepared statement is forgotten, so it must be recreated before being used again\&amp;. This also means that a single prepared statement cannot be used by multiple simultaneous database clients; however, each client can create their own prepared statement to use\&amp;. Prepared statements can be manually cleaned up using the
\fBDEALLOCATE\fR(7)
command\&amp;.
.PP
Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements\&amp;. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e\&amp;.g\&amp;. if the query involves a join of many tables or requires the application of several rules\&amp;. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
An arbitrary name given to this particular prepared statement\&amp;. It must be unique within a single session and is subsequently used to execute or deallocate a previously prepared statement\&amp;.
.RE
.PP
\fIdata_type\fR
.RS 4
The data type of a parameter to the prepared statement\&amp;. If the data type of a particular parameter is unspecified or is specified as
unknown, it will be inferred from the context in which the parameter is used\&amp;. To refer to the parameters in the prepared statement itself, use
$1,
$2, etc\&amp;.
.RE
.PP
\fIstatement\fR
.RS 4
Any
\fBSELECT\fR,
\fBINSERT\fR,
\fBUPDATE\fR,
\fBDELETE\fR, or
\fBVALUES\fR
statement\&amp;.
.RE
.SH "NOTES"
.PP
Prepared statements can use generic plans rather than re\-planning with each set of supplied
\fBEXECUTE\fR
values\&amp;. This occurs immediately for prepared statements with no parameters; otherwise it occurs only after five or more executions produce plans whose estimated cost average (including planning overhead) is more expensive than the generic plan cost estimate\&amp;. Once a generic plan is chosen, it is used for the remaining lifetime of the prepared statement\&amp;. Using
\fBEXECUTE\fR
values which are rare in columns with many duplicates can generate custom plans that are so much cheaper than the generic plan, even after adding planning overhead, that the generic plan might never be used\&amp;.
.PP
A generic plan assumes that each value supplied to
\fBEXECUTE\fR
is one of the column\*(Aqs distinct values and that column values are uniformly distributed\&amp;. For example, if statistics record three distinct column values, a generic plan assumes a column equality comparison will match 33% of processed rows\&amp;. Column statistics also allow generic plans to accurately compute the selectivity of unique columns\&amp;. Comparisons on non\-uniformly\-distributed columns and specification of non\-existent values affects the average plan cost, and hence if and when a generic plan is chosen\&amp;.
.PP
To examine the query plan
PostgreSQL
is using for a prepared statement, use
\fBEXPLAIN\fR(7), e\&amp;.g\&amp;.
\fBEXPLAIN EXECUTE\fR\&amp;. If a generic plan is in use, it will contain parameter symbols
$\fIn\fR, while a custom plan will have the supplied parameter values substituted into it\&amp;. The row estimates in the generic plan reflect the selectivity computed for the parameters\&amp;.
.PP
For more information on query planning and the statistics collected by
PostgreSQL
for that purpose, see the
\fBANALYZE\fR(7)
documentation\&amp;.
.PP
Although the main point of a prepared statement is to avoid repeated parse analysis and planning of the statement,
PostgreSQL
will force re\-analysis and re\-planning of the statement before using it whenever database objects used in the statement have undergone definitional (DDL) changes since the previous use of the prepared statement\&amp;. Also, if the value of
search_path
changes from one use to the next, the statement will be re\-parsed using the new
\fIsearch_path\fR\&amp;. (This latter behavior is new as of
PostgreSQL
9\&amp;.3\&amp;.) These rules make use of a prepared statement semantically almost equivalent to re\-submitting the same query text over and over, but with a performance benefit if no object definitions are changed, especially if the best plan remains the same across uses\&amp;. An example of a case where the semantic equivalence is not perfect is that if the statement refers to a table by an unqualified name, and then a new table of the same name is created in a schema appearing earlier in the
\fIsearch_path\fR, no automatic re\-parse will occur since no object used in the statement changed\&amp;. However, if some other change forces a re\-parse, the new table will be referenced in subsequent uses\&amp;.
.PP
You can see all prepared statements available in the session by querying the
pg_prepared_statements
system view\&amp;.
.SH "EXAMPLES"
.PP
Create a prepared statement for an
\fBINSERT\fR
statement, and then execute it:
.sp
.if n \{\
.RS 4
.\}
.nf
PREPARE fooplan (int, text, bool, numeric) AS
INSERT INTO foo VALUES($1, $2, $3, $4);
EXECUTE fooplan(1, \*(AqHunter Valley\*(Aq, \*(Aqt\*(Aq, 200\&amp;.00);
.fi
.if n \{\
.RE
.\}
.PP
Create a prepared statement for a
\fBSELECT\fR
statement, and then execute it:
.sp
.if n \{\
.RS 4
.\}
.nf
PREPARE usrrptplan (int) AS
SELECT * FROM users u, logs l WHERE u\&amp;.usrid=$1 AND u\&amp;.usrid=l\&amp;.usrid
AND l\&amp;.date = $2;
EXECUTE usrrptplan(1, current_date);
.fi
.if n \{\
.RE
.\}
.sp
Note that the data type of the second parameter is not specified, so it is inferred from the context in which
$2
is used\&amp;.
.SH "COMPATIBILITY"
.PP
The SQL standard includes a
\fBPREPARE\fR
statement, but it is only for use in embedded SQL\&amp;. This version of the
\fBPREPARE\fR
statement also uses a somewhat different syntax\&amp;.
.SH "SEE ALSO"
\fBDEALLOCATE\fR(7), \fBEXECUTE\fR(7)
'\" t
.\"     Title: PREPARE TRANSACTION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "PREPARE TRANSACTION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
PREPARE_TRANSACTION \- prepare the current transaction for two\-phase commit
.SH "SYNOPSIS"
.sp
.nf
PREPARE TRANSACTION \fItransaction_id\fR
.fi
.SH "DESCRIPTION"
.PP
\fBPREPARE TRANSACTION\fR
prepares the current transaction for two\-phase commit\&amp;. After this command, the transaction is no longer associated with the current session; instead, its state is fully stored on disk, and there is a very high probability that it can be committed successfully, even if a database crash occurs before the commit is requested\&amp;.
.PP
Once prepared, a transaction can later be committed or rolled back with
COMMIT PREPARED (\fBCOMMIT_PREPARED\fR(7))
or
ROLLBACK PREPARED (\fBROLLBACK_PREPARED\fR(7)), respectively\&amp;. Those commands can be issued from any session, not only the one that executed the original transaction\&amp;.
.PP
From the point of view of the issuing session,
\fBPREPARE TRANSACTION\fR
is not unlike a
\fBROLLBACK\fR
command: after executing it, there is no active current transaction, and the effects of the prepared transaction are no longer visible\&amp;. (The effects will become visible again if the transaction is committed\&amp;.)
.PP
If the
\fBPREPARE TRANSACTION\fR
command fails for any reason, it becomes a
\fBROLLBACK\fR: the current transaction is canceled\&amp;.
.SH "PARAMETERS"
.PP
\fItransaction_id\fR
.RS 4
An arbitrary identifier that later identifies this transaction for
\fBCOMMIT PREPARED\fR
or
\fBROLLBACK PREPARED\fR\&amp;. The identifier must be written as a string literal, and must be less than 200 bytes long\&amp;. It must not be the same as the identifier used for any currently prepared transaction\&amp;.
.RE
.SH "NOTES"
.PP
\fBPREPARE TRANSACTION\fR
is not intended for use in applications or interactive sessions\&amp;. Its purpose is to allow an external transaction manager to perform atomic global transactions across multiple databases or other transactional resources\&amp;. Unless you\*(Aqre writing a transaction manager, you probably shouldn\*(Aqt be using
\fBPREPARE TRANSACTION\fR\&amp;.
.PP
This command must be used inside a transaction block\&amp;. Use
\fBBEGIN\fR(7)
to start one\&amp;.
.PP
It is not currently allowed to
\fBPREPARE\fR
a transaction that has executed any operations involving temporary tables, created any cursors
WITH HOLD, or executed
\fBLISTEN\fR
or
\fBUNLISTEN\fR\&amp;. Those features are too tightly tied to the current session to be useful in a transaction to be prepared\&amp;.
.PP
If the transaction modified any run\-time parameters with
\fBSET\fR
(without the
LOCAL
option), those effects persist after
\fBPREPARE TRANSACTION\fR, and will not be affected by any later
\fBCOMMIT PREPARED\fR
or
\fBROLLBACK PREPARED\fR\&amp;. Thus, in this one respect
\fBPREPARE TRANSACTION\fR
acts more like
\fBCOMMIT\fR
than
\fBROLLBACK\fR\&amp;.
.PP
All currently available prepared transactions are listed in the
pg_prepared_xacts
system view\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBCaution\fR
.ps -1
.br
.PP
It is unwise to leave transactions in the prepared state for a long time\&amp;. This will interfere with the ability of
\fBVACUUM\fR
to reclaim storage, and in extreme cases could cause the database to shut down to prevent transaction ID wraparound (see
Section 24.1.5, \(lqPreventing Transaction ID Wraparound Failures\(rq, in the documentation)\&amp;. Keep in mind also that the transaction continues to hold whatever locks it held\&amp;. The intended usage of the feature is that a prepared transaction will normally be committed or rolled back as soon as an external transaction manager has verified that other databases are also prepared to commit\&amp;.
.PP
If you have not set up an external transaction manager to track prepared transactions and ensure they get closed out promptly, it is best to keep the prepared\-transaction feature disabled by setting
max_prepared_transactions
to zero\&amp;. This will prevent accidental creation of prepared transactions that might then be forgotten and eventually cause problems\&amp;.
.sp .5v
.RE
.SH "EXAMPLES"
.PP
Prepare the current transaction for two\-phase commit, using
foobar
as the transaction identifier:
.sp
.if n \{\
.RS 4
.\}
.nf
PREPARE TRANSACTION \*(Aqfoobar\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBPREPARE TRANSACTION\fR
is a
PostgreSQL
extension\&amp;. It is intended for use by external transaction management systems, some of which are covered by standards (such as X/Open XA), but the SQL side of those systems is not standardized\&amp;.
.SH "SEE ALSO"
COMMIT PREPARED (\fBCOMMIT_PREPARED\fR(7)), ROLLBACK PREPARED (\fBROLLBACK_PREPARED\fR(7))
'\" t
.\"     Title: REASSIGN OWNED
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "REASSIGN OWNED" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
REASSIGN_OWNED \- change the ownership of database objects owned by a database role
.SH "SYNOPSIS"
.sp
.nf
REASSIGN OWNED BY { \fIold_role\fR | CURRENT_USER | SESSION_USER } [, \&amp;.\&amp;.\&amp;.]
TO { \fInew_role\fR | CURRENT_USER | SESSION_USER }
.fi
.SH "DESCRIPTION"
.PP
\fBREASSIGN OWNED\fR
instructs the system to change the ownership of database objects owned by any of the
\fIold_roles\fR
to
\fInew_role\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIold_role\fR
.RS 4
The name of a role\&amp;. The ownership of all the objects within the current database, and of all shared objects (databases, tablespaces), owned by this role will be reassigned to
\fInew_role\fR\&amp;.
.RE
.PP
\fInew_role\fR
.RS 4
The name of the role that will be made the new owner of the affected objects\&amp;.
.RE
.SH "NOTES"
.PP
\fBREASSIGN OWNED\fR
is often used to prepare for the removal of one or more roles\&amp;. Because
\fBREASSIGN OWNED\fR
does not affect objects within other databases, it is usually necessary to execute this command in each database that contains objects owned by a role that is to be removed\&amp;.
.PP
\fBREASSIGN OWNED\fR
requires privileges on both the source role(s) and the target role\&amp;.
.PP
The
DROP OWNED (\fBDROP_OWNED\fR(7))
command is an alternative that simply drops all the database objects owned by one or more roles\&amp;.
.PP
The
\fBREASSIGN OWNED\fR
command does not affect any privileges granted to the
\fIold_roles\fR
for objects that are not owned by them\&amp;. Use
\fBDROP OWNED\fR
to revoke such privileges\&amp;.
.PP
See
Section 21.4, \(lqDropping Roles\(rq, in the documentation
for more discussion\&amp;.
.SH "COMPATIBILITY"
.PP
The
\fBREASSIGN OWNED\fR
command is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
DROP OWNED (\fBDROP_OWNED\fR(7)), DROP ROLE (\fBDROP_ROLE\fR(7)), ALTER DATABASE (\fBALTER_DATABASE\fR(7))
'\" t
.\"     Title: REFRESH MATERIALIZED VIEW
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "REFRESH MATERIALIZED VIEW" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
REFRESH_MATERIALIZED_VIEW \- replace the contents of a materialized view
.SH "SYNOPSIS"
.sp
.nf
REFRESH MATERIALIZED VIEW [ CONCURRENTLY ] \fIname\fR
[ WITH [ NO ] DATA ]
.fi
.SH "DESCRIPTION"
.PP
\fBREFRESH MATERIALIZED VIEW\fR
completely replaces the contents of a materialized view\&amp;. The old contents are discarded\&amp;. If
WITH DATA
is specified (or defaults) the backing query is executed to provide the new data, and the materialized view is left in a scannable state\&amp;. If
WITH NO DATA
is specified no new data is generated and the materialized view is left in an unscannable state\&amp;.
.PP
CONCURRENTLY
and
WITH NO DATA
may not be specified together\&amp;.
.SH "PARAMETERS"
.PP
CONCURRENTLY
.RS 4
Refresh the materialized view without locking out concurrent selects on the materialized view\&amp;. Without this option a refresh which affects a lot of rows will tend to use fewer resources and complete more quickly, but could block other connections which are trying to read from the materialized view\&amp;. This option may be faster in cases where a small number of rows are affected\&amp;.
.sp
This option is only allowed if there is at least one
UNIQUE
index on the materialized view which uses only column names and includes all rows; that is, it must not index on any expressions nor include a
WHERE
clause\&amp;.
.sp
This option may not be used when the materialized view is not already populated\&amp;.
.sp
Even with this option only one
REFRESH
at a time may run against any one materialized view\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of the materialized view to refresh\&amp;.
.RE
.SH "NOTES"
.PP
While the default index for future
\fBCLUSTER\fR(7)
operations is retained,
\fBREFRESH MATERIALIZED VIEW\fR
does not order the generated rows based on this property\&amp;. If you want the data to be ordered upon generation, you must use an
ORDER BY
clause in the backing query\&amp;.
.SH "EXAMPLES"
.PP
This command will replace the contents of the materialized view called
order_summary
using the query from the materialized view\*(Aqs definition, and leave it in a scannable state:
.sp
.if n \{\
.RS 4
.\}
.nf
REFRESH MATERIALIZED VIEW order_summary;
.fi
.if n \{\
.RE
.\}
.PP
This command will free storage associated with the materialized view
annual_statistics_basis
and leave it in an unscannable state:
.sp
.if n \{\
.RS 4
.\}
.nf
REFRESH MATERIALIZED VIEW annual_statistics_basis WITH NO DATA;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBREFRESH MATERIALIZED VIEW\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
CREATE MATERIALIZED VIEW (\fBCREATE_MATERIALIZED_VIEW\fR(7)), ALTER MATERIALIZED VIEW (\fBALTER_MATERIALIZED_VIEW\fR(7)), DROP MATERIALIZED VIEW (\fBDROP_MATERIALIZED_VIEW\fR(7))
'\" t
.\"     Title: REINDEX
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "REINDEX" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
REINDEX \- rebuild indexes
.SH "SYNOPSIS"
.sp
.nf
REINDEX [ ( VERBOSE ) ] { INDEX | TABLE | SCHEMA | DATABASE | SYSTEM } \fIname\fR
.fi
.SH "DESCRIPTION"
.PP
\fBREINDEX\fR
rebuilds an index using the data stored in the index\*(Aqs table, replacing the old copy of the index\&amp;. There are several scenarios in which to use
\fBREINDEX\fR:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An index has become corrupted, and no longer contains valid data\&amp;. Although in theory this should never happen, in practice indexes can become corrupted due to software bugs or hardware failures\&amp;.
\fBREINDEX\fR
provides a recovery method\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An index has become
\(lqbloated\(rq, that is it contains many empty or nearly\-empty pages\&amp;. This can occur with B\-tree indexes in
PostgreSQL
under certain uncommon access patterns\&amp;.
\fBREINDEX\fR
provides a way to reduce the space consumption of the index by writing a new version of the index without the dead pages\&amp;. See
Section 24.2, \(lqRoutine Reindexing\(rq, in the documentation
for more information\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
You have altered a storage parameter (such as fillfactor) for an index, and wish to ensure that the change has taken full effect\&amp;.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An index build with the
CONCURRENTLY
option failed, leaving an
\(lqinvalid\(rq
index\&amp;. Such indexes are useless but it can be convenient to use
\fBREINDEX\fR
to rebuild them\&amp;. Note that
\fBREINDEX\fR
will not perform a concurrent build\&amp;. To build the index without interfering with production you should drop the index and reissue the
\fBCREATE INDEX CONCURRENTLY\fR
command\&amp;.
.RE
.SH "PARAMETERS"
.PP
INDEX
.RS 4
Recreate the specified index\&amp;.
.RE
.PP
TABLE
.RS 4
Recreate all indexes of the specified table\&amp;. If the table has a secondary
\(lqTOAST\(rq
table, that is reindexed as well\&amp;.
.RE
.PP
SCHEMA
.RS 4
Recreate all indexes of the specified schema\&amp;. If a table of this schema has a secondary
\(lqTOAST\(rq
table, that is reindexed as well\&amp;. Indexes on shared system catalogs are also processed\&amp;. This form of
\fBREINDEX\fR
cannot be executed inside a transaction block\&amp;.
.RE
.PP
DATABASE
.RS 4
Recreate all indexes within the current database\&amp;. Indexes on shared system catalogs are also processed\&amp;. This form of
\fBREINDEX\fR
cannot be executed inside a transaction block\&amp;.
.RE
.PP
SYSTEM
.RS 4
Recreate all indexes on system catalogs within the current database\&amp;. Indexes on shared system catalogs are included\&amp;. Indexes on user tables are not processed\&amp;. This form of
\fBREINDEX\fR
cannot be executed inside a transaction block\&amp;.
.RE
.PP
\fIname\fR
.RS 4
The name of the specific index, table, or database to be reindexed\&amp;. Index and table names can be schema\-qualified\&amp;. Presently,
\fBREINDEX DATABASE\fR
and
\fBREINDEX SYSTEM\fR
can only reindex the current database, so their parameter must match the current database\*(Aqs name\&amp;.
.RE
.PP
VERBOSE
.RS 4
Prints a progress report as each index is reindexed\&amp;.
.RE
.SH "NOTES"
.PP
If you suspect corruption of an index on a user table, you can simply rebuild that index, or all indexes on the table, using
\fBREINDEX INDEX\fR
or
\fBREINDEX TABLE\fR\&amp;.
.PP
Things are more difficult if you need to recover from corruption of an index on a system table\&amp;. In this case it\*(Aqs important for the system to not have used any of the suspect indexes itself\&amp;. (Indeed, in this sort of scenario you might find that server processes are crashing immediately at start\-up, due to reliance on the corrupted indexes\&amp;.) To recover safely, the server must be started with the
\fB\-P\fR
option, which prevents it from using indexes for system catalog lookups\&amp;.
.PP
One way to do this is to shut down the server and start a single\-user
PostgreSQL
server with the
\fB\-P\fR
option included on its command line\&amp;. Then,
\fBREINDEX DATABASE\fR,
\fBREINDEX SYSTEM\fR,
\fBREINDEX TABLE\fR, or
\fBREINDEX INDEX\fR
can be issued, depending on how much you want to reconstruct\&amp;. If in doubt, use
\fBREINDEX SYSTEM\fR
to select reconstruction of all system indexes in the database\&amp;. Then quit the single\-user server session and restart the regular server\&amp;. See the
\fBpostgres\fR(1)
reference page for more information about how to interact with the single\-user server interface\&amp;.
.PP
Alternatively, a regular server session can be started with
\fB\-P\fR
included in its command line options\&amp;. The method for doing this varies across clients, but in all
libpq\-based clients, it is possible to set the
\fBPGOPTIONS\fR
environment variable to
\-P
before starting the client\&amp;. Note that while this method does not require locking out other clients, it might still be wise to prevent other users from connecting to the damaged database until repairs have been completed\&amp;.
.PP
\fBREINDEX\fR
is similar to a drop and recreate of the index in that the index contents are rebuilt from scratch\&amp;. However, the locking considerations are rather different\&amp;.
\fBREINDEX\fR
locks out writes but not reads of the index\*(Aqs parent table\&amp;. It also takes an exclusive lock on the specific index being processed, which will block reads that attempt to use that index\&amp;. In contrast,
\fBDROP INDEX\fR
momentarily takes an exclusive lock on the parent table, blocking both writes and reads\&amp;. The subsequent
\fBCREATE INDEX\fR
locks out writes but not reads; since the index is not there, no read will attempt to use it, meaning that there will be no blocking but reads might be forced into expensive sequential scans\&amp;.
.PP
Reindexing a single index or table requires being the owner of that index or table\&amp;. Reindexing a database requires being the owner of the database (note that the owner can therefore rebuild indexes of tables owned by other users)\&amp;. Of course, superusers can always reindex anything\&amp;.
.SH "EXAMPLES"
.PP
Rebuild a single index:
.sp
.if n \{\
.RS 4
.\}
.nf
REINDEX INDEX my_index;
.fi
.if n \{\
.RE
.\}
.PP
Rebuild all the indexes on the table
my_table:
.sp
.if n \{\
.RS 4
.\}
.nf
REINDEX TABLE my_table;
.fi
.if n \{\
.RE
.\}
.PP
Rebuild all indexes in a particular database, without trusting the system indexes to be valid already:
.sp
.if n \{\
.RS 4
.\}
.nf
$ \fBexport PGOPTIONS="\-P"\fR
$ \fBpsql broken_db\fR
\&amp;.\&amp;.\&amp;.
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \eq
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBREINDEX\fR
command in the SQL standard\&amp;.
'\" t
.\"     Title: RELEASE SAVEPOINT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "RELEASE SAVEPOINT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
RELEASE_SAVEPOINT \- destroy a previously defined savepoint
.SH "SYNOPSIS"
.sp
.nf
RELEASE [ SAVEPOINT ] \fIsavepoint_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBRELEASE SAVEPOINT\fR
destroys a savepoint previously defined in the current transaction\&amp;.
.PP
Destroying a savepoint makes it unavailable as a rollback point, but it has no other user visible behavior\&amp;. It does not undo the effects of commands executed after the savepoint was established\&amp;. (To do that, see
ROLLBACK TO SAVEPOINT (\fBROLLBACK_TO_SAVEPOINT\fR(7))\&amp;.) Destroying a savepoint when it is no longer needed allows the system to reclaim some resources earlier than transaction end\&amp;.
.PP
\fBRELEASE SAVEPOINT\fR
also destroys all savepoints that were established after the named savepoint was established\&amp;.
.SH "PARAMETERS"
.PP
\fIsavepoint_name\fR
.RS 4
The name of the savepoint to destroy\&amp;.
.RE
.SH "NOTES"
.PP
Specifying a savepoint name that was not previously defined is an error\&amp;.
.PP
It is not possible to release a savepoint when the transaction is in an aborted state\&amp;.
.PP
If multiple savepoints have the same name, only the one that was most recently defined is released\&amp;.
.SH "EXAMPLES"
.PP
To establish and later destroy a savepoint:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
INSERT INTO table1 VALUES (3);
SAVEPOINT my_savepoint;
INSERT INTO table1 VALUES (4);
RELEASE SAVEPOINT my_savepoint;
COMMIT;
.fi
.if n \{\
.RE
.\}
.sp
The above transaction will insert both 3 and 4\&amp;.
.SH "COMPATIBILITY"
.PP
This command conforms to the
SQL
standard\&amp;. The standard specifies that the key word
SAVEPOINT
is mandatory, but
PostgreSQL
allows it to be omitted\&amp;.
.SH "SEE ALSO"
\fBBEGIN\fR(7), \fBCOMMIT\fR(7), \fBROLLBACK\fR(7), ROLLBACK TO SAVEPOINT (\fBROLLBACK_TO_SAVEPOINT\fR(7)), \fBSAVEPOINT\fR(7)
'\" t
.\"     Title: RESET
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "RESET" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
RESET \- restore the value of a run\-time parameter to the default value
.SH "SYNOPSIS"
.sp
.nf
RESET \fIconfiguration_parameter\fR
RESET ALL
.fi
.SH "DESCRIPTION"
.PP
\fBRESET\fR
restores run\-time parameters to their default values\&amp;.
\fBRESET\fR
is an alternative spelling for
.sp
.if n \{\
.RS 4
.\}
.nf
SET \fIconfiguration_parameter\fR TO DEFAULT
.fi
.if n \{\
.RE
.\}
.sp
Refer to
\fBSET\fR(7)
for details\&amp;.
.PP
The default value is defined as the value that the parameter would have had, if no
\fBSET\fR
had ever been issued for it in the current session\&amp;. The actual source of this value might be a compiled\-in default, the configuration file, command\-line options, or per\-database or per\-user default settings\&amp;. This is subtly different from defining it as
\(lqthe value that the parameter had at session start\(rq, because if the value came from the configuration file, it will be reset to whatever is specified by the configuration file now\&amp;. See
Chapter 19, Server Configuration, in the documentation
for details\&amp;.
.PP
The transactional behavior of
\fBRESET\fR
is the same as
\fBSET\fR: its effects will be undone by transaction rollback\&amp;.
.SH "PARAMETERS"
.PP
\fIconfiguration_parameter\fR
.RS 4
Name of a settable run\-time parameter\&amp;. Available parameters are documented in
Chapter 19, Server Configuration, in the documentation
and on the
\fBSET\fR(7)
reference page\&amp;.
.RE
.PP
ALL
.RS 4
Resets all settable run\-time parameters to default values\&amp;.
.RE
.SH "EXAMPLES"
.PP
Set the
\fItimezone\fR
configuration variable to its default value:
.sp
.if n \{\
.RS 4
.\}
.nf
RESET timezone;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBRESET\fR
is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
\fBSET\fR(7), \fBSHOW\fR(7)
'\" t
.\"     Title: REVOKE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "REVOKE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
REVOKE \- remove access privileges
.SH "SYNOPSIS"
.sp
.nf
REVOKE [ GRANT OPTION FOR ]
{ { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON { [ TABLE ] \fItable_name\fR [, \&amp;.\&amp;.\&amp;.]
| ALL TABLES IN SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.] }
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ { SELECT | INSERT | UPDATE | REFERENCES } ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] )
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) }
ON [ TABLE ] \fItable_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ { USAGE | SELECT | UPDATE }
[, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON { SEQUENCE \fIsequence_name\fR [, \&amp;.\&amp;.\&amp;.]
| ALL SEQUENCES IN SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.] }
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ { CREATE | CONNECT | TEMPORARY | TEMP } [, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON DATABASE \fIdatabase_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ USAGE | ALL [ PRIVILEGES ] }
ON DOMAIN \fIdomain_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ USAGE | ALL [ PRIVILEGES ] }
ON FOREIGN DATA WRAPPER \fIfdw_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ USAGE | ALL [ PRIVILEGES ] }
ON FOREIGN SERVER \fIserver_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ EXECUTE | ALL [ PRIVILEGES ] }
ON { FUNCTION \fIfunction_name\fR ( [ [ \fIargmode\fR ] [ \fIarg_name\fR ] \fIarg_type\fR [, \&amp;.\&amp;.\&amp;.] ] ) [, \&amp;.\&amp;.\&amp;.]
| ALL FUNCTIONS IN SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.] }
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ USAGE | ALL [ PRIVILEGES ] }
ON LANGUAGE \fIlang_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ { SELECT | UPDATE } [, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON LARGE OBJECT \fIloid\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ { CREATE | USAGE } [, \&amp;.\&amp;.\&amp;.] | ALL [ PRIVILEGES ] }
ON SCHEMA \fIschema_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ CREATE | ALL [ PRIVILEGES ] }
ON TABLESPACE \fItablespace_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ USAGE | ALL [ PRIVILEGES ] }
ON TYPE \fItype_name\fR [, \&amp;.\&amp;.\&amp;.]
FROM { [ GROUP ] \fIrole_name\fR | PUBLIC } [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]

REVOKE [ ADMIN OPTION FOR ]
\fIrole_name\fR [, \&amp;.\&amp;.\&amp;.] FROM \fIrole_name\fR [, \&amp;.\&amp;.\&amp;.]
[ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
The
\fBREVOKE\fR
command revokes previously granted privileges from one or more roles\&amp;. The key word
PUBLIC
refers to the implicitly defined group of all roles\&amp;.
.PP
See the description of the
\fBGRANT\fR(7)
command for the meaning of the privilege types\&amp;.
.PP
Note that any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to
PUBLIC\&amp;. Thus, for example, revoking
SELECT
privilege from
PUBLIC
does not necessarily mean that all roles have lost
SELECT
privilege on the object: those who have it granted directly or via another role will still have it\&amp;. Similarly, revoking
SELECT
from a user might not prevent that user from using
SELECT
if
PUBLIC
or another membership role still has
SELECT
rights\&amp;.
.PP
If
GRANT OPTION FOR
is specified, only the grant option for the privilege is revoked, not the privilege itself\&amp;. Otherwise, both the privilege and the grant option are revoked\&amp;.
.PP
If a user holds a privilege with grant option and has granted it to other users then the privileges held by those other users are called dependent privileges\&amp;. If the privilege or the grant option held by the first user is being revoked and dependent privileges exist, those dependent privileges are also revoked if
CASCADE
is specified; if it is not, the revoke action will fail\&amp;. This recursive revocation only affects privileges that were granted through a chain of users that is traceable to the user that is the subject of this
REVOKE
command\&amp;. Thus, the affected users might effectively keep the privilege if it was also granted through other users\&amp;.
.PP
When revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well\&amp;. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect\&amp;.
.PP
When revoking membership in a role,
GRANT OPTION
is instead called
ADMIN OPTION, but the behavior is similar\&amp;. Note also that this form of the command does not allow the noise word
GROUP\&amp;.
.SH "NOTES"
.PP
Use
\fBpsql\fR(1)\*(Aqs
\fB\edp\fR
command to display the privileges granted on existing tables and columns\&amp;. See
\fBGRANT\fR(7)
for information about the format\&amp;. For non\-table objects there are other
\fB\ed\fR
commands that can display their privileges\&amp;.
.PP
A user can only revoke privileges that were granted directly by that user\&amp;. If, for example, user A has granted a privilege with grant option to user B, and user B has in turned granted it to user C, then user A cannot revoke the privilege directly from C\&amp;. Instead, user A could revoke the grant option from user B and use the
CASCADE
option so that the privilege is in turn revoked from user C\&amp;. For another example, if both A and B have granted the same privilege to C, A can revoke their own grant but not B\*(Aqs grant, so C will still effectively have the privilege\&amp;.
.PP
When a non\-owner of an object attempts to
\fBREVOKE\fR
privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object\&amp;. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options\&amp;. The
\fBREVOKE ALL PRIVILEGES\fR
forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held\&amp;. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur\&amp;.)
.PP
If a superuser chooses to issue a
\fBGRANT\fR
or
\fBREVOKE\fR
command, the command is performed as though it were issued by the owner of the affected object\&amp;. Since all privileges ultimately come from the object owner (possibly indirectly via chains of grant options), it is possible for a superuser to revoke all privileges, but this might require use of
CASCADE
as stated above\&amp;.
.PP
\fBREVOKE\fR
can also be done by a role that is not the owner of the affected object, but is a member of the role that owns the object, or is a member of a role that holds privileges
WITH GRANT OPTION
on the object\&amp;. In this case the command is performed as though it were issued by the containing role that actually owns the object or holds the privileges
WITH GRANT OPTION\&amp;. For example, if table
t1
is owned by role
g1, of which role
u1
is a member, then
u1
can revoke privileges on
t1
that are recorded as being granted by
g1\&amp;. This would include grants made by
u1
as well as by other members of role
g1\&amp;.
.PP
If the role executing
\fBREVOKE\fR
holds privileges indirectly via more than one role membership path, it is unspecified which containing role will be used to perform the command\&amp;. In such cases it is best practice to use
\fBSET ROLE\fR
to become the specific role you want to do the
\fBREVOKE\fR
as\&amp;. Failure to do so might lead to revoking privileges other than the ones you intended, or not revoking anything at all\&amp;.
.SH "EXAMPLES"
.PP
Revoke insert privilege for the public on table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
REVOKE INSERT ON films FROM PUBLIC;
.fi
.if n \{\
.RE
.\}
.PP
Revoke all privileges from user
manuel
on view
kinds:
.sp
.if n \{\
.RS 4
.\}
.nf
REVOKE ALL PRIVILEGES ON kinds FROM manuel;
.fi
.if n \{\
.RE
.\}
.sp
Note that this actually means
\(lqrevoke all privileges that I granted\(rq\&amp;.
.PP
Revoke membership in role
admins
from user
joe:
.sp
.if n \{\
.RS 4
.\}
.nf
REVOKE admins FROM joe;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The compatibility notes of the
\fBGRANT\fR(7)
command apply analogously to
\fBREVOKE\fR\&amp;. The keyword
RESTRICT
or
CASCADE
is required according to the standard, but
PostgreSQL
assumes
RESTRICT
by default\&amp;.
.SH "SEE ALSO"
.sp
\fBGRANT\fR(7)
'\" t
.\"     Title: ROLLBACK
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ROLLBACK" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ROLLBACK \- abort the current transaction
.SH "SYNOPSIS"
.sp
.nf
ROLLBACK [ WORK | TRANSACTION ]
.fi
.SH "DESCRIPTION"
.PP
\fBROLLBACK\fR
rolls back the current transaction and causes all the updates made by the transaction to be discarded\&amp;.
.SH "PARAMETERS"
.PP
WORK
.br
TRANSACTION
.RS 4
Optional key words\&amp;. They have no effect\&amp;.
.RE
.SH "NOTES"
.PP
Use
\fBCOMMIT\fR(7)
to successfully terminate a transaction\&amp;.
.PP
Issuing
\fBROLLBACK\fR
outside of a transaction block emits a warning and otherwise has no effect\&amp;.
.SH "EXAMPLES"
.PP
To abort all changes:
.sp
.if n \{\
.RS 4
.\}
.nf
ROLLBACK;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The SQL standard only specifies the two forms
ROLLBACK
and
ROLLBACK WORK\&amp;. Otherwise, this command is fully conforming\&amp;.
.SH "SEE ALSO"
\fBBEGIN\fR(7), \fBCOMMIT\fR(7), ROLLBACK TO SAVEPOINT (\fBROLLBACK_TO_SAVEPOINT\fR(7))
'\" t
.\"     Title: ROLLBACK PREPARED
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ROLLBACK PREPARED" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ROLLBACK_PREPARED \- cancel a transaction that was earlier prepared for two\-phase commit
.SH "SYNOPSIS"
.sp
.nf
ROLLBACK PREPARED \fItransaction_id\fR
.fi
.SH "DESCRIPTION"
.PP
\fBROLLBACK PREPARED\fR
rolls back a transaction that is in prepared state\&amp;.
.SH "PARAMETERS"
.PP
\fItransaction_id\fR
.RS 4
The transaction identifier of the transaction that is to be rolled back\&amp;.
.RE
.SH "NOTES"
.PP
To roll back a prepared transaction, you must be either the same user that executed the transaction originally, or a superuser\&amp;. But you do not have to be in the same session that executed the transaction\&amp;.
.PP
This command cannot be executed inside a transaction block\&amp;. The prepared transaction is rolled back immediately\&amp;.
.PP
All currently available prepared transactions are listed in the
pg_prepared_xacts
system view\&amp;.
.SH "EXAMPLES"
.PP
Roll back the transaction identified by the transaction identifier
foobar:
.sp
.if n \{\
.RS 4
.\}
.nf
ROLLBACK PREPARED \*(Aqfoobar\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
\fBROLLBACK PREPARED\fR
is a
PostgreSQL
extension\&amp;. It is intended for use by external transaction management systems, some of which are covered by standards (such as X/Open XA), but the SQL side of those systems is not standardized\&amp;.
.SH "SEE ALSO"
PREPARE TRANSACTION (\fBPREPARE_TRANSACTION\fR(7)), COMMIT PREPARED (\fBCOMMIT_PREPARED\fR(7))
'\" t
.\"     Title: ROLLBACK TO SAVEPOINT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "ROLLBACK TO SAVEPOINT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
ROLLBACK_TO_SAVEPOINT \- roll back to a savepoint
.SH "SYNOPSIS"
.sp
.nf
ROLLBACK [ WORK | TRANSACTION ] TO [ SAVEPOINT ] \fIsavepoint_name\fR
.fi
.SH "DESCRIPTION"
.PP
Roll back all commands that were executed after the savepoint was established\&amp;. The savepoint remains valid and can be rolled back to again later, if needed\&amp;.
.PP
\fBROLLBACK TO SAVEPOINT\fR
implicitly destroys all savepoints that were established after the named savepoint\&amp;.
.SH "PARAMETERS"
.PP
\fIsavepoint_name\fR
.RS 4
The savepoint to roll back to\&amp;.
.RE
.SH "NOTES"
.PP
Use
RELEASE SAVEPOINT (\fBRELEASE_SAVEPOINT\fR(7))
to destroy a savepoint without discarding the effects of commands executed after it was established\&amp;.
.PP
Specifying a savepoint name that has not been established is an error\&amp;.
.PP
Cursors have somewhat non\-transactional behavior with respect to savepoints\&amp;. Any cursor that is opened inside a savepoint will be closed when the savepoint is rolled back\&amp;. If a previously opened cursor is affected by a
\fBFETCH\fR
or
\fBMOVE\fR
command inside a savepoint that is later rolled back, the cursor remains at the position that
\fBFETCH\fR
left it pointing to (that is, the cursor motion caused by
\fBFETCH\fR
is not rolled back)\&amp;. Closing a cursor is not undone by rolling back, either\&amp;. However, other side\-effects caused by the cursor\*(Aqs query (such as side\-effects of volatile functions called by the query)
\fIare\fR
rolled back if they occur during a savepoint that is later rolled back\&amp;. A cursor whose execution causes a transaction to abort is put in a cannot\-execute state, so while the transaction can be restored using
\fBROLLBACK TO SAVEPOINT\fR, the cursor can no longer be used\&amp;.
.SH "EXAMPLES"
.PP
To undo the effects of the commands executed after
my_savepoint
was established:
.sp
.if n \{\
.RS 4
.\}
.nf
ROLLBACK TO SAVEPOINT my_savepoint;
.fi
.if n \{\
.RE
.\}
.PP
Cursor positions are not affected by savepoint rollback:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;

DECLARE foo CURSOR FOR SELECT 1 UNION SELECT 2;

SAVEPOINT foo;

FETCH 1 FROM foo;
?column? 
\-\-\-\-\-\-\-\-\-\-
1

ROLLBACK TO SAVEPOINT foo;

FETCH 1 FROM foo;
?column? 
\-\-\-\-\-\-\-\-\-\-
2

COMMIT;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
SQL
standard specifies that the key word
SAVEPOINT
is mandatory, but
PostgreSQL
and
Oracle
allow it to be omitted\&amp;. SQL allows only
WORK, not
TRANSACTION, as a noise word after
ROLLBACK\&amp;. Also, SQL has an optional clause
AND [ NO ] CHAIN
which is not currently supported by
PostgreSQL\&amp;. Otherwise, this command conforms to the SQL standard\&amp;.
.SH "SEE ALSO"
\fBBEGIN\fR(7), \fBCOMMIT\fR(7), RELEASE SAVEPOINT (\fBRELEASE_SAVEPOINT\fR(7)), \fBROLLBACK\fR(7), \fBSAVEPOINT\fR(7)
'\" t
.\"     Title: SAVEPOINT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SAVEPOINT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SAVEPOINT \- define a new savepoint within the current transaction
.SH "SYNOPSIS"
.sp
.nf
SAVEPOINT \fIsavepoint_name\fR
.fi
.SH "DESCRIPTION"
.PP
\fBSAVEPOINT\fR
establishes a new savepoint within the current transaction\&amp;.
.PP
A savepoint is a special mark inside a transaction that allows all commands that are executed after it was established to be rolled back, restoring the transaction state to what it was at the time of the savepoint\&amp;.
.SH "PARAMETERS"
.PP
\fIsavepoint_name\fR
.RS 4
The name to give to the new savepoint\&amp;.
.RE
.SH "NOTES"
.PP
Use
ROLLBACK TO SAVEPOINT (\fBROLLBACK_TO_SAVEPOINT\fR(7))
to rollback to a savepoint\&amp;. Use
RELEASE SAVEPOINT (\fBRELEASE_SAVEPOINT\fR(7))
to destroy a savepoint, keeping the effects of commands executed after it was established\&amp;.
.PP
Savepoints can only be established when inside a transaction block\&amp;. There can be multiple savepoints defined within a transaction\&amp;.
.SH "EXAMPLES"
.PP
To establish a savepoint and later undo the effects of all commands executed after it was established:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
INSERT INTO table1 VALUES (1);
SAVEPOINT my_savepoint;
INSERT INTO table1 VALUES (2);
ROLLBACK TO SAVEPOINT my_savepoint;
INSERT INTO table1 VALUES (3);
COMMIT;
.fi
.if n \{\
.RE
.\}
.sp
The above transaction will insert the values 1 and 3, but not 2\&amp;.
.PP
To establish and later destroy a savepoint:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
INSERT INTO table1 VALUES (3);
SAVEPOINT my_savepoint;
INSERT INTO table1 VALUES (4);
RELEASE SAVEPOINT my_savepoint;
COMMIT;
.fi
.if n \{\
.RE
.\}
.sp
The above transaction will insert both 3 and 4\&amp;.
.SH "COMPATIBILITY"
.PP
SQL requires a savepoint to be destroyed automatically when another savepoint with the same name is established\&amp;. In
PostgreSQL, the old savepoint is kept, though only the more recent one will be used when rolling back or releasing\&amp;. (Releasing the newer savepoint with
\fBRELEASE SAVEPOINT\fR
will cause the older one to again become accessible to
\fBROLLBACK TO SAVEPOINT\fR
and
\fBRELEASE SAVEPOINT\fR\&amp;.) Otherwise,
\fBSAVEPOINT\fR
is fully SQL conforming\&amp;.
.SH "SEE ALSO"
\fBBEGIN\fR(7), \fBCOMMIT\fR(7), RELEASE SAVEPOINT (\fBRELEASE_SAVEPOINT\fR(7)), \fBROLLBACK\fR(7), ROLLBACK TO SAVEPOINT (\fBROLLBACK_TO_SAVEPOINT\fR(7))
'\" t
.\"     Title: SECURITY LABEL
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SECURITY LABEL" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SECURITY_LABEL \- define or change a security label applied to an object
.SH "SYNOPSIS"
.sp
.nf
SECURITY LABEL [ FOR \fIprovider\fR ] ON
{
TABLE \fIobject_name\fR |
COLUMN \fItable_name\fR\&amp;.\fIcolumn_name\fR |
AGGREGATE \fIaggregate_name\fR ( \fIaggregate_signature\fR ) |
DATABASE \fIobject_name\fR |
DOMAIN \fIobject_name\fR |
EVENT TRIGGER \fIobject_name\fR |
FOREIGN TABLE \fIobject_name\fR
FUNCTION \fIfunction_name\fR ( [ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [, \&amp;.\&amp;.\&amp;.] ] ) |
LARGE OBJECT \fIlarge_object_oid\fR |
MATERIALIZED VIEW \fIobject_name\fR |
[ PROCEDURAL ] LANGUAGE \fIobject_name\fR |
ROLE \fIobject_name\fR |
SCHEMA \fIobject_name\fR |
SEQUENCE \fIobject_name\fR |
TABLESPACE \fIobject_name\fR |
TYPE \fIobject_name\fR |
VIEW \fIobject_name\fR
} IS \*(Aq\fIlabel\fR\*(Aq

where \fIaggregate_signature\fR is:

* |
[ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] |
[ [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ] ] ORDER BY [ \fIargmode\fR ] [ \fIargname\fR ] \fIargtype\fR [ , \&amp;.\&amp;.\&amp;. ]
.fi
.SH "DESCRIPTION"
.PP
\fBSECURITY LABEL\fR
applies a security label to a database object\&amp;. An arbitrary number of security labels, one per label provider, can be associated with a given database object\&amp;. Label providers are loadable modules which register themselves by using the function
\fBregister_label_provider\fR\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
\fBregister_label_provider\fR
is not an SQL function; it can only be called from C code loaded into the backend\&amp;.
.sp .5v
.RE
.PP
The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object\&amp;. The meaning of a given label is likewise at the discretion of the label provider\&amp;.
PostgreSQL
places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them\&amp;. In practice, this facility is intended to allow integration with label\-based mandatory access control (MAC) systems such as
SE\-Linux\&amp;. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups\&amp;.
.SH "PARAMETERS"
.PP
\fIobject_name\fR
.br
\fItable_name\&amp;.column_name\fR
.br
\fIaggregate_name\fR
.br
\fIfunction_name\fR
.RS 4
The name of the object to be labeled\&amp;. Names of tables, aggregates, domains, foreign tables, functions, sequences, types, and views can be schema\-qualified\&amp;.
.RE
.PP
\fIprovider\fR
.RS 4
The name of the provider with which this label is to be associated\&amp;. The named provider must be loaded and must consent to the proposed labeling operation\&amp;. If exactly one provider is loaded, the provider name may be omitted for brevity\&amp;.
.RE
.PP
\fIargmode\fR
.RS 4
The mode of a function or aggregate argument:
IN,
OUT,
INOUT, or
VARIADIC\&amp;. If omitted, the default is
IN\&amp;. Note that
\fBSECURITY LABEL\fR
does not actually pay any attention to
OUT
arguments, since only the input arguments are needed to determine the function\*(Aqs identity\&amp;. So it is sufficient to list the
IN,
INOUT, and
VARIADIC
arguments\&amp;.
.RE
.PP
\fIargname\fR
.RS 4
The name of a function or aggregate argument\&amp;. Note that
\fBSECURITY LABEL\fR
does not actually pay any attention to argument names, since only the argument data types are needed to determine the function\*(Aqs identity\&amp;.
.RE
.PP
\fIargtype\fR
.RS 4
The data type of a function or aggregate argument\&amp;.
.RE
.PP
\fIlarge_object_oid\fR
.RS 4
The OID of the large object\&amp;.
.RE
.PP
PROCEDURAL
.RS 4
This is a noise word\&amp;.
.RE
.PP
\fIlabel\fR
.RS 4
The new security label, written as a string literal; or
NULL
to drop the security label\&amp;.
.RE
.SH "EXAMPLES"
.PP
The following example shows how the security label of a table might be changed\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
SECURITY LABEL FOR selinux ON TABLE mytable IS \*(Aqsystem_u:object_r:sepgsql_table_t:s0\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBSECURITY LABEL\fR
command in the SQL standard\&amp;.
.SH "SEE ALSO"
sepgsql, src/test/modules/dummy_seclabel
'\" t
.\"     Title: SELECT
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SELECT" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SELECT, TABLE, WITH \- retrieve rows from a table or view
.SH "SYNOPSIS"
.sp
.nf
[ WITH [ RECURSIVE ] \fIwith_query\fR [, \&amp;.\&amp;.\&amp;.] ]
SELECT [ ALL | DISTINCT [ ON ( \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
[ * | \fIexpression\fR [ [ AS ] \fIoutput_name\fR ] [, \&amp;.\&amp;.\&amp;.] ]
[ FROM \fIfrom_item\fR [, \&amp;.\&amp;.\&amp;.] ]
[ WHERE \fIcondition\fR ]
[ GROUP BY \fIgrouping_element\fR [, \&amp;.\&amp;.\&amp;.] ]
[ HAVING \fIcondition\fR [, \&amp;.\&amp;.\&amp;.] ]
[ WINDOW \fIwindow_name\fR AS ( \fIwindow_definition\fR ) [, \&amp;.\&amp;.\&amp;.] ]
[ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] \fIselect\fR ]
[ ORDER BY \fIexpression\fR [ ASC | DESC | USING \fIoperator\fR ] [ NULLS { FIRST | LAST } ] [, \&amp;.\&amp;.\&amp;.] ]
[ LIMIT { \fIcount\fR | ALL } ]
[ OFFSET \fIstart\fR [ ROW | ROWS ] ]
[ FETCH { FIRST | NEXT } [ \fIcount\fR ] { ROW | ROWS } ONLY ]
[ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF \fItable_name\fR [, \&amp;.\&amp;.\&amp;.] ] [ NOWAIT | SKIP LOCKED ] [\&amp;.\&amp;.\&amp;.] ]

where \fIfrom_item\fR can be one of:

[ ONLY ] \fItable_name\fR [ * ] [ [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
[ TABLESAMPLE \fIsampling_method\fR ( \fIargument\fR [, \&amp;.\&amp;.\&amp;.] ) [ REPEATABLE ( \fIseed\fR ) ] ]
[ LATERAL ] ( \fIselect\fR ) [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, \&amp;.\&amp;.\&amp;.] ) ]
\fIwith_query_name\fR [ [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
[ LATERAL ] \fIfunction_name\fR ( [ \fIargument\fR [, \&amp;.\&amp;.\&amp;.] ] )
[ WITH ORDINALITY ] [ [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
[ LATERAL ] \fIfunction_name\fR ( [ \fIargument\fR [, \&amp;.\&amp;.\&amp;.] ] ) [ AS ] \fIalias\fR ( \fIcolumn_definition\fR [, \&amp;.\&amp;.\&amp;.] )
[ LATERAL ] \fIfunction_name\fR ( [ \fIargument\fR [, \&amp;.\&amp;.\&amp;.] ] ) AS ( \fIcolumn_definition\fR [, \&amp;.\&amp;.\&amp;.] )
[ LATERAL ] ROWS FROM( \fIfunction_name\fR ( [ \fIargument\fR [, \&amp;.\&amp;.\&amp;.] ] ) [ AS ( \fIcolumn_definition\fR [, \&amp;.\&amp;.\&amp;.] ) ] [, \&amp;.\&amp;.\&amp;.] )
[ WITH ORDINALITY ] [ [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
\fIfrom_item\fR [ NATURAL ] \fIjoin_type\fR \fIfrom_item\fR [ ON \fIjoin_condition\fR | USING ( \fIjoin_column\fR [, \&amp;.\&amp;.\&amp;.] ) ]

and \fIgrouping_element\fR can be one of:

( )
\fIexpression\fR
( \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] )
ROLLUP ( { \fIexpression\fR | ( \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] ) } [, \&amp;.\&amp;.\&amp;.] )
CUBE ( { \fIexpression\fR | ( \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] ) } [, \&amp;.\&amp;.\&amp;.] )
GROUPING SETS ( \fIgrouping_element\fR [, \&amp;.\&amp;.\&amp;.] )

and \fIwith_query\fR is:

\fIwith_query_name\fR [ ( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ] AS ( \fIselect\fR | \fIvalues\fR | \fIinsert\fR | \fIupdate\fR | \fIdelete\fR )

TABLE [ ONLY ] \fItable_name\fR [ * ]
.fi
.SH "DESCRIPTION"
.PP
\fBSELECT\fR
retrieves rows from zero or more tables\&amp;. The general processing of
\fBSELECT\fR
is as follows:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
All queries in the
WITH
list are computed\&amp;. These effectively serve as temporary tables that can be referenced in the
FROM
list\&amp;. A
WITH
query that is referenced more than once in
FROM
is computed only once\&amp;. (See
WITH Clause
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
All elements in the
FROM
list are computed\&amp;. (Each element in the
FROM
list is a real or virtual table\&amp;.) If more than one element is specified in the
FROM
list, they are cross\-joined together\&amp;. (See
FROM Clause
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
If the
WHERE
clause is specified, all rows that do not satisfy the condition are eliminated from the output\&amp;. (See
WHERE Clause
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
If the
GROUP BY
clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed\&amp;. If the
HAVING
clause is present, it eliminates groups that do not satisfy the given condition\&amp;. (See
GROUP BY Clause
and
HAVING Clause
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
The actual output rows are computed using the
\fBSELECT\fR
output expressions for each selected row or row group\&amp;. (See
SELECT List
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
SELECT DISTINCT
eliminates duplicate rows from the result\&amp;.
SELECT DISTINCT ON
eliminates rows that match on all the specified expressions\&amp;.
SELECT ALL
(the default) will return all candidate rows, including duplicates\&amp;. (See
DISTINCT Clause
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
Using the operators
UNION,
INTERSECT, and
EXCEPT, the output of more than one
\fBSELECT\fR
statement can be combined to form a single result set\&amp;. The
UNION
operator returns all rows that are in one or both of the result sets\&amp;. The
INTERSECT
operator returns all rows that are strictly in both result sets\&amp;. The
EXCEPT
operator returns the rows that are in the first result set but not in the second\&amp;. In all three cases, duplicate rows are eliminated unless
ALL
is specified\&amp;. The noise word
DISTINCT
can be added to explicitly specify eliminating duplicate rows\&amp;. Notice that
DISTINCT
is the default behavior here, even though
ALL
is the default for
\fBSELECT\fR
itself\&amp;. (See
UNION Clause,
INTERSECT Clause, and
EXCEPT Clause
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
If the
ORDER BY
clause is specified, the returned rows are sorted in the specified order\&amp;. If
ORDER BY
is not given, the rows are returned in whatever order the system finds fastest to produce\&amp;. (See
ORDER BY Clause
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
If the
LIMIT
(or
FETCH FIRST) or
OFFSET
clause is specified, the
\fBSELECT\fR
statement only returns a subset of the result rows\&amp;. (See
LIMIT Clause
below\&amp;.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
If
FOR UPDATE,
FOR NO KEY UPDATE,
FOR SHARE
or
FOR KEY SHARE
is specified, the
\fBSELECT\fR
statement locks the selected rows against concurrent updates\&amp;. (See
The Locking Clause
below\&amp;.)
.RE
.PP
You must have
SELECT
privilege on each column used in a
\fBSELECT\fR
command\&amp;. The use of
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE
or
FOR KEY SHARE
requires
UPDATE
privilege as well (for at least one column of each table so selected)\&amp;.
.SH "PARAMETERS"
.SS "WITH Clause"
.PP
The
WITH
clause allows you to specify one or more subqueries that can be referenced by name in the primary query\&amp;. The subqueries effectively act as temporary tables or views for the duration of the primary query\&amp;. Each subquery can be a
\fBSELECT\fR,
\fBTABLE\fR,
\fBVALUES\fR,
\fBINSERT\fR,
\fBUPDATE\fR
or
\fBDELETE\fR
statement\&amp;. When writing a data\-modifying statement (\fBINSERT\fR,
\fBUPDATE\fR
or
\fBDELETE\fR) in
WITH, it is usual to include a
RETURNING
clause\&amp;. It is the output of
RETURNING,
\fInot\fR
the underlying table that the statement modifies, that forms the temporary table that is read by the primary query\&amp;. If
RETURNING
is omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query\&amp;.
.PP
A name (without schema qualification) must be specified for each
WITH
query\&amp;. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery\&amp;.
.PP
If
RECURSIVE
is specified, it allows a
\fBSELECT\fR
subquery to reference itself by name\&amp;. Such a subquery must have the form
.sp
.if n \{\
.RS 4
.\}
.nf
\fInon_recursive_term\fR UNION [ ALL | DISTINCT ] \fIrecursive_term\fR
.fi
.if n \{\
.RE
.\}
.sp
where the recursive self\-reference must appear on the right\-hand side of the
UNION\&amp;. Only one recursive self\-reference is permitted per query\&amp;. Recursive data\-modifying statements are not supported, but you can use the results of a recursive
\fBSELECT\fR
query in a data\-modifying statement\&amp;. See
Section 7.8, \(lqWITH Queries (Common Table Expressions)\(rq, in the documentation
for an example\&amp;.
.PP
Another effect of
RECURSIVE
is that
WITH
queries need not be ordered: a query can reference another one that is later in the list\&amp;. (However, circular references, or mutual recursion, are not implemented\&amp;.) Without
RECURSIVE,
WITH
queries can only reference sibling
WITH
queries that are earlier in the
WITH
list\&amp;.
.PP
A key property of
WITH
queries is that they are evaluated only once per execution of the primary query, even if the primary query refers to them more than once\&amp;. In particular, data\-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output\&amp;.
.PP
The primary query and the
WITH
queries are all (notionally) executed at the same time\&amp;. This implies that the effects of a data\-modifying statement in
WITH
cannot be seen from other parts of the query, other than by reading its
RETURNING
output\&amp;. If two such data\-modifying statements attempt to modify the same row, the results are unspecified\&amp;.
.PP
See
Section 7.8, \(lqWITH Queries (Common Table Expressions)\(rq, in the documentation
for additional information\&amp;.
.SS "FROM Clause"
.PP
The
FROM
clause specifies one or more source tables for the
\fBSELECT\fR\&amp;. If multiple sources are specified, the result is the Cartesian product (cross join) of all the sources\&amp;. But usually qualification conditions are added (via
WHERE) to restrict the returned rows to a small subset of the Cartesian product\&amp;.
.PP
The
FROM
clause can contain the following elements:
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of an existing table or view\&amp;. If
ONLY
is specified before the table name, only that table is scanned\&amp;. If
ONLY
is not specified, the table and all its descendant tables (if any) are scanned\&amp;. Optionally,
*
can be specified after the table name to explicitly indicate that descendant tables are included\&amp;.
.RE
.PP
\fIalias\fR
.RS 4
A substitute name for the
FROM
item containing the alias\&amp;. An alias is used for brevity or to eliminate ambiguity for self\-joins (where the same table is scanned multiple times)\&amp;. When an alias is provided, it completely hides the actual name of the table or function; for example given
FROM foo AS f, the remainder of the
\fBSELECT\fR
must refer to this
FROM
item as
f
not
foo\&amp;. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table\&amp;.
.RE
.PP
TABLESAMPLE \fIsampling_method\fR ( \fIargument\fR [, \&amp;.\&amp;.\&amp;.] ) [ REPEATABLE ( \fIseed\fR ) ]
.RS 4
A
TABLESAMPLE
clause after a
\fItable_name\fR
indicates that the specified
\fIsampling_method\fR
should be used to retrieve a subset of the rows in that table\&amp;. This sampling precedes the application of any other filters such as
WHERE
clauses\&amp;. The standard
PostgreSQL
distribution includes two sampling methods,
BERNOULLI
and
SYSTEM, and other sampling methods can be installed in the database via extensions\&amp;.
.sp
The
BERNOULLI
and
SYSTEM
sampling methods each accept a single
\fIargument\fR
which is the fraction of the table to sample, expressed as a percentage between 0 and 100\&amp;. This argument can be any
real\-valued expression\&amp;. (Other sampling methods might accept more or different arguments\&amp;.) These two methods each return a randomly\-chosen sample of the table that will contain approximately the specified percentage of the table\*(Aqs rows\&amp;. The
BERNOULLI
method scans the whole table and selects or ignores individual rows independently with the specified probability\&amp;. The
SYSTEM
method does block\-level sampling with each block having the specified chance of being selected; all rows in each selected block are returned\&amp;. The
SYSTEM
method is significantly faster than the
BERNOULLI
method when small sampling percentages are specified, but it may return a less\-random sample of the table as a result of clustering effects\&amp;.
.sp
The optional
REPEATABLE
clause specifies a
\fIseed\fR
number or expression to use for generating random numbers within the sampling method\&amp;. The seed value can be any non\-null floating\-point value\&amp;. Two queries that specify the same seed and
\fIargument\fR
values will select the same sample of the table, if the table has not been changed meanwhile\&amp;. But different seed values will usually produce different samples\&amp;. If
REPEATABLE
is not given then a new random sample is selected for each query, based upon a system\-generated seed\&amp;. Note that some add\-on sampling methods do not accept
REPEATABLE, and will always produce new samples on each use\&amp;.
.RE
.PP
\fIselect\fR
.RS 4
A sub\-\fBSELECT\fR
can appear in the
FROM
clause\&amp;. This acts as though its output were created as a temporary table for the duration of this single
\fBSELECT\fR
command\&amp;. Note that the sub\-\fBSELECT\fR
must be surrounded by parentheses, and an alias
\fImust\fR
be provided for it\&amp;. A
\fBVALUES\fR(7)
command can also be used here\&amp;.
.RE
.PP
\fIwith_query_name\fR
.RS 4
A
WITH
query is referenced by writing its name, just as though the query\*(Aqs name were a table name\&amp;. (In fact, the
WITH
query hides any real table of the same name for the purposes of the primary query\&amp;. If necessary, you can refer to a real table of the same name by schema\-qualifying the table\*(Aqs name\&amp;.) An alias can be provided in the same way as for a table\&amp;.
.RE
.PP
\fIfunction_name\fR
.RS 4
Function calls can appear in the
FROM
clause\&amp;. (This is especially useful for functions that return result sets, but any function can be used\&amp;.) This acts as though the function\*(Aqs output were created as a temporary table for the duration of this single
\fBSELECT\fR
command\&amp;. When the optional
\fBWITH ORDINALITY\fR
clause is added to the function call, a new column is appended after all the function\*(Aqs output columns with numbering for each row\&amp;.
.sp
An alias can be provided in the same way as for a table\&amp;. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function\*(Aqs composite return type, including the column added by
ORDINALITY
if present\&amp;.
.sp
Multiple function calls can be combined into a single
FROM\-clause item by surrounding them with
ROWS FROM( \&amp;.\&amp;.\&amp;. )\&amp;. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc\&amp;. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows\&amp;.
.sp
If the function has been defined as returning the
record
data type, then an alias or the key word
AS
must be present, followed by a column definition list in the form
( \fIcolumn_name\fR \fIdata_type\fR [, \&amp;.\&amp;.\&amp;. ])\&amp;. The column definition list must match the actual number and types of columns returned by the function\&amp;.
.sp
When using the
ROWS FROM( \&amp;.\&amp;.\&amp;. )
syntax, if one of the functions requires a column definition list, it\*(Aqs preferred to put the column definition list after the function call inside
ROWS FROM( \&amp;.\&amp;.\&amp;. )\&amp;. A column definition list can be placed after the
ROWS FROM( \&amp;.\&amp;.\&amp;. )
construct only if there\*(Aqs just a single function and no
WITH ORDINALITY
clause\&amp;.
.sp
To use
ORDINALITY
together with a column definition list, you must use the
ROWS FROM( \&amp;.\&amp;.\&amp;. )
syntax and put the column definition list inside
ROWS FROM( \&amp;.\&amp;.\&amp;. )\&amp;.
.RE
.PP
\fIjoin_type\fR
.RS 4
One of
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
[ INNER ] JOIN
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
LEFT [ OUTER ] JOIN
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
RIGHT [ OUTER ] JOIN
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
FULL [ OUTER ] JOIN
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
CROSS JOIN
.RE
.sp
For the
INNER
and
OUTER
join types, a join condition must be specified, namely exactly one of
NATURAL,
ON \fIjoin_condition\fR, or
USING (\fIjoin_column\fR [, \&amp;.\&amp;.\&amp;.])\&amp;. See below for the meaning\&amp;. For
CROSS JOIN, none of these clauses can appear\&amp;.
.sp
A
JOIN
clause combines two
FROM
items, which for convenience we will refer to as
\(lqtables\(rq, though in reality they can be any type of
FROM
item\&amp;. Use parentheses if necessary to determine the order of nesting\&amp;. In the absence of parentheses,
JOINs nest left\-to\-right\&amp;. In any case
JOIN
binds more tightly than the commas separating
FROM\-list items\&amp;.
.sp
CROSS JOIN
and
INNER JOIN
produce a simple Cartesian product, the same result as you get from listing the two tables at the top level of
FROM, but restricted by the join condition (if any)\&amp;.
CROSS JOIN
is equivalent to
INNER JOIN ON (TRUE), that is, no rows are removed by qualification\&amp;. These join types are just a notational convenience, since they do nothing you couldn\*(Aqt do with plain
FROM
and
WHERE\&amp;.
.sp
LEFT OUTER JOIN
returns all rows in the qualified Cartesian product (i\&amp;.e\&amp;., all combined rows that pass its join condition), plus one copy of each row in the left\-hand table for which there was no right\-hand row that passed the join condition\&amp;. This left\-hand row is extended to the full width of the joined table by inserting null values for the right\-hand columns\&amp;. Note that only the
JOIN
clause\*(Aqs own condition is considered while deciding which rows have matches\&amp;. Outer conditions are applied afterwards\&amp;.
.sp
Conversely,
RIGHT OUTER JOIN
returns all the joined rows, plus one row for each unmatched right\-hand row (extended with nulls on the left)\&amp;. This is just a notational convenience, since you could convert it to a
LEFT OUTER JOIN
by switching the left and right tables\&amp;.
.sp
FULL OUTER JOIN
returns all the joined rows, plus one row for each unmatched left\-hand row (extended with nulls on the right), plus one row for each unmatched right\-hand row (extended with nulls on the left)\&amp;.
.RE
.PP
ON \fIjoin_condition\fR
.RS 4
\fIjoin_condition\fR
is an expression resulting in a value of type
boolean
(similar to a
WHERE
clause) that specifies which rows in a join are considered to match\&amp;.
.RE
.PP
USING ( \fIjoin_column\fR [, \&amp;.\&amp;.\&amp;.] )
.RS 4
A clause of the form
USING ( a, b, \&amp;.\&amp;.\&amp;. )
is shorthand for
ON left_table\&amp;.a = right_table\&amp;.a AND left_table\&amp;.b = right_table\&amp;.b \&amp;.\&amp;.\&amp;.\&amp;. Also,
USING
implies that only one of each pair of equivalent columns will be included in the join output, not both\&amp;.
.RE
.PP
NATURAL
.RS 4
NATURAL
is shorthand for a
USING
list that mentions all columns in the two tables that have the same names\&amp;.
.RE
.PP
LATERAL
.RS 4
The
LATERAL
key word can precede a sub\-\fBSELECT\fRFROM
item\&amp;. This allows the sub\-\fBSELECT\fR
to refer to columns of
FROM
items that appear before it in the
FROM
list\&amp;. (Without
LATERAL, each sub\-\fBSELECT\fR
is evaluated independently and so cannot cross\-reference any other
FROM
item\&amp;.)
.sp
LATERAL
can also precede a function\-call
FROM
item, but in this case it is a noise word, because the function expression can refer to earlier
FROM
items in any case\&amp;.
.sp
A
LATERAL
item can appear at top level in the
FROM
list, or within a
JOIN
tree\&amp;. In the latter case it can also refer to any items that are on the left\-hand side of a
JOIN
that it is on the right\-hand side of\&amp;.
.sp
When a
FROM
item contains
LATERAL
cross\-references, evaluation proceeds as follows: for each row of the
FROM
item providing the cross\-referenced column(s), or set of rows of multiple
FROM
items providing the columns, the
LATERAL
item is evaluated using that row or row set\*(Aqs values of the columns\&amp;. The resulting row(s) are joined as usual with the rows they were computed from\&amp;. This is repeated for each row or set of rows from the column source table(s)\&amp;.
.sp
The column source table(s) must be
INNER
or
LEFT
joined to the
LATERAL
item, else there would not be a well\-defined set of rows from which to compute each set of rows for the
LATERAL
item\&amp;. Thus, although a construct such as
\fIX\fR RIGHT JOIN LATERAL \fIY\fR
is syntactically valid, it is not actually allowed for
\fIY\fR
to reference
\fIX\fR\&amp;.
.RE
.SS "WHERE Clause"
.PP
The optional
WHERE
clause has the general form
.sp
.if n \{\
.RS 4
.\}
.nf
WHERE \fIcondition\fR
.fi
.if n \{\
.RE
.\}
.sp
where
\fIcondition\fR
is any expression that evaluates to a result of type
boolean\&amp;. Any row that does not satisfy this condition will be eliminated from the output\&amp;. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references\&amp;.
.SS "GROUP BY Clause"
.PP
The optional
GROUP BY
clause has the general form
.sp
.if n \{\
.RS 4
.\}
.nf
GROUP BY \fIgrouping_element\fR [, \&amp;.\&amp;.\&amp;.]
.fi
.if n \{\
.RE
.\}
.PP
GROUP BY
will condense into a single row all selected rows that share the same values for the grouped expressions\&amp;. An
\fIexpression\fR
used inside a
\fIgrouping_element\fR
can be an input column name, or the name or ordinal number of an output column (\fBSELECT\fR
list item), or an arbitrary expression formed from input\-column values\&amp;. In case of ambiguity, a
GROUP BY
name will be interpreted as an input\-column name rather than an output column name\&amp;.
.PP
If any of
GROUPING SETS,
ROLLUP
or
CUBE
are present as grouping elements, then the
GROUP BY
clause as a whole defines some number of independent
\fIgrouping sets\fR\&amp;. The effect of this is equivalent to constructing a
UNION ALL
between subqueries with the individual grouping sets as their
GROUP BY
clauses\&amp;. For further details on the handling of grouping sets see
Section 7.2.4, \(lqGROUPING SETS, CUBE, and ROLLUP\(rq, in the documentation\&amp;.
.PP
Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group\&amp;. (If there are aggregate functions but no
GROUP BY
clause, the query is treated as having a single group comprising all the selected rows\&amp;.) The set of rows fed to each aggregate function can be further filtered by attaching a
FILTER
clause to the aggregate function call; see
Section 4.2.7, \(lqAggregate Expressions\(rq, in the documentation
for more information\&amp;. When a
FILTER
clause is present, only those rows matching it are included in the input to that aggregate function\&amp;.
.PP
When
GROUP BY
is present, or any aggregate functions are present, it is not valid for the
\fBSELECT\fR
list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column\&amp;. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column\&amp;.
.PP
Keep in mind that all aggregate functions are evaluated before evaluating any
\(lqscalar\(rq
expressions in the
HAVING
clause or
SELECT
list\&amp;. This means that, for example, a
CASE
expression cannot be used to skip evaluation of an aggregate function; see
Section 4.2.14, \(lqExpression Evaluation Rules\(rq, in the documentation\&amp;.
.PP
Currently,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE
and
FOR KEY SHARE
cannot be specified with
GROUP BY\&amp;.
.SS "HAVING Clause"
.PP
The optional
HAVING
clause has the general form
.sp
.if n \{\
.RS 4
.\}
.nf
HAVING \fIcondition\fR
.fi
.if n \{\
.RE
.\}
.sp
where
\fIcondition\fR
is the same as specified for the
WHERE
clause\&amp;.
.PP
HAVING
eliminates group rows that do not satisfy the condition\&amp;.
HAVING
is different from
WHERE:
WHERE
filters individual rows before the application of
GROUP BY, while
HAVING
filters group rows created by
GROUP BY\&amp;. Each column referenced in
\fIcondition\fR
must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns\&amp;.
.PP
The presence of
HAVING
turns a query into a grouped query even if there is no
GROUP BY
clause\&amp;. This is the same as what happens when the query contains aggregate functions but no
GROUP BY
clause\&amp;. All the selected rows are considered to form a single group, and the
\fBSELECT\fR
list and
HAVING
clause can only reference table columns from within aggregate functions\&amp;. Such a query will emit a single row if the
HAVING
condition is true, zero rows if it is not true\&amp;.
.PP
Currently,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE
and
FOR KEY SHARE
cannot be specified with
HAVING\&amp;.
.SS "WINDOW Clause"
.PP
The optional
WINDOW
clause has the general form
.sp
.if n \{\
.RS 4
.\}
.nf
WINDOW \fIwindow_name\fR AS ( \fIwindow_definition\fR ) [, \&amp;.\&amp;.\&amp;.]
.fi
.if n \{\
.RE
.\}
.sp
where
\fIwindow_name\fR
is a name that can be referenced from
OVER
clauses or subsequent window definitions, and
\fIwindow_definition\fR
is
.sp
.if n \{\
.RS 4
.\}
.nf
[ \fIexisting_window_name\fR ]
[ PARTITION BY \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] ]
[ ORDER BY \fIexpression\fR [ ASC | DESC | USING \fIoperator\fR ] [ NULLS { FIRST | LAST } ] [, \&amp;.\&amp;.\&amp;.] ]
[ \fIframe_clause\fR ]
.fi
.if n \{\
.RE
.\}
.PP
If an
\fIexisting_window_name\fR
is specified it must refer to an earlier entry in the
WINDOW
list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any\&amp;. In this case the new window cannot specify its own
PARTITION BY
clause, and it can specify
ORDER BY
only if the copied window does not have one\&amp;. The new window always uses its own frame clause; the copied window must not specify a frame clause\&amp;.
.PP
The elements of the
PARTITION BY
list are interpreted in much the same fashion as elements of a
GROUP BY Clause, except that they are always simple expressions and never the name or number of an output column\&amp;. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular
GROUP BY
clause\&amp;. They are allowed here because windowing occurs after grouping and aggregation\&amp;.
.PP
Similarly, the elements of the
ORDER BY
list are interpreted in much the same fashion as elements of an
ORDER BY Clause, except that the expressions are always taken as simple expressions and never the name or number of an output column\&amp;.
.PP
The optional
\fIframe_clause\fR
defines the
window frame
for window functions that depend on the frame (not all do)\&amp;. The window frame is a set of related rows for each row of the query (called the
current row)\&amp;. The
\fIframe_clause\fR
can be one of
.sp
.if n \{\
.RS 4
.\}
.nf
{ RANGE | ROWS } \fIframe_start\fR
{ RANGE | ROWS } BETWEEN \fIframe_start\fR AND \fIframe_end\fR
.fi
.if n \{\
.RE
.\}
.sp
where
\fIframe_start\fR
and
\fIframe_end\fR
can be one of
.sp
.if n \{\
.RS 4
.\}
.nf
UNBOUNDED PRECEDING
\fIvalue\fR PRECEDING
CURRENT ROW
\fIvalue\fR FOLLOWING
UNBOUNDED FOLLOWING
.fi
.if n \{\
.RE
.\}
.sp
If
\fIframe_end\fR
is omitted it defaults to
CURRENT ROW\&amp;. Restrictions are that
\fIframe_start\fR
cannot be
UNBOUNDED FOLLOWING,
\fIframe_end\fR
cannot be
UNBOUNDED PRECEDING, and the
\fIframe_end\fR
choice cannot appear earlier in the above list than the
\fIframe_start\fR
choice \(em for example
RANGE BETWEEN CURRENT ROW AND \fIvalue\fR PRECEDING
is not allowed\&amp;.
.PP
The default framing option is
RANGE UNBOUNDED PRECEDING, which is the same as
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW; it sets the frame to be all rows from the partition start up through the current row\*(Aqs last peer (a row that
ORDER BY
considers equivalent to the current row, or all rows if there is no
ORDER BY)\&amp;. In general,
UNBOUNDED PRECEDING
means that the frame starts with the first row of the partition, and similarly
UNBOUNDED FOLLOWING
means that the frame ends with the last row of the partition (regardless of
RANGE
or
ROWS
mode)\&amp;. In
ROWS
mode,
CURRENT ROW
means that the frame starts or ends with the current row; but in
RANGE
mode it means that the frame starts or ends with the current row\*(Aqs first or last peer in the
ORDER BY
ordering\&amp;. The
\fIvalue\fRPRECEDING
and
\fIvalue\fRFOLLOWING
cases are currently only allowed in
ROWS
mode\&amp;. They indicate that the frame starts or ends with the row that many rows before or after the current row\&amp;.
\fIvalue\fR
must be an integer expression not containing any variables, aggregate functions, or window functions\&amp;. The value must not be null or negative; but it can be zero, which selects the current row itself\&amp;.
.PP
Beware that the
ROWS
options can produce unpredictable results if the
ORDER BY
ordering does not order the rows uniquely\&amp;. The
RANGE
options are designed to ensure that rows that are peers in the
ORDER BY
ordering are treated alike; all peer rows will be in the same frame\&amp;.
.PP
The purpose of a
WINDOW
clause is to specify the behavior of
window functions
appearing in the query\*(Aqs
SELECT List
or
ORDER BY Clause\&amp;. These functions can reference the
WINDOW
clause entries by name in their
OVER
clauses\&amp;. A
WINDOW
clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored\&amp;. It is possible to use window functions without any
WINDOW
clause at all, since a window function call can specify its window definition directly in its
OVER
clause\&amp;. However, the
WINDOW
clause saves typing when the same window definition is needed for more than one window function\&amp;.
.PP
Currently,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE
and
FOR KEY SHARE
cannot be specified with
WINDOW\&amp;.
.PP
Window functions are described in detail in
Section 3.5, \(lqWindow Functions\(rq, in the documentation,
Section 4.2.8, \(lqWindow Function Calls\(rq, in the documentation, and
Section 7.2.5, \(lqWindow Function Processing\(rq, in the documentation\&amp;.
.SS "SELECT List"
.PP
The
\fBSELECT\fR
list (between the key words
SELECT
and
FROM) specifies expressions that form the output rows of the
\fBSELECT\fR
statement\&amp;. The expressions can (and usually do) refer to columns computed in the
FROM
clause\&amp;.
.PP
Just as in a table, every output column of a
\fBSELECT\fR
has a name\&amp;. In a simple
\fBSELECT\fR
this name is just used to label the column for display, but when the
\fBSELECT\fR
is a sub\-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub\-query\&amp;. To specify the name to use for an output column, write
AS\fIoutput_name\fR
after the column\*(Aqs expression\&amp;. (You can omit
AS, but only if the desired output name does not match any
PostgreSQL
keyword (see
Appendix\ \&amp;C, SQL Key Words)\&amp;. For protection against possible future keyword additions, it is recommended that you always either write
AS
or double\-quote the output name\&amp;.) If you do not specify a column name, a name is chosen automatically by
PostgreSQL\&amp;. If the column\*(Aqs expression is a simple column reference then the chosen name is the same as that column\*(Aqs name\&amp;. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as
?column?\&amp;.
.PP
An output column\*(Aqs name can be used to refer to the column\*(Aqs value in
ORDER BY
and
GROUP BY
clauses, but not in the
WHERE
or
HAVING
clauses; there you must write out the expression instead\&amp;.
.PP
Instead of an expression,
*
can be written in the output list as a shorthand for all the columns of the selected rows\&amp;. Also, you can write
\fItable_name\fR\&amp;.*
as a shorthand for the columns coming from just that table\&amp;. In these cases it is not possible to specify new names with
AS; the output column names will be the same as the table columns\*(Aq names\&amp;.
.PP
According to the SQL standard, the expressions in the output list should be computed before applying
DISTINCT,
ORDER BY, or
LIMIT\&amp;. This is obviously necessary when using
DISTINCT, since otherwise it\*(Aqs not clear what values are being made distinct\&amp;. However, in many cases it is convenient if output expressions are computed after
ORDER BY
and
LIMIT; particularly if the output list contains any volatile or expensive functions\&amp;. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output\&amp;.
PostgreSQL
will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in
DISTINCT,
ORDER BY
or
GROUP BY\&amp;. (As a counterexample,
SELECT f(x) FROM tab ORDER BY 1
clearly must evaluate
\fBf(x)\fR
before sorting\&amp;.) Output expressions that contain set\-returning functions are effectively evaluated after sorting and before limiting, so that
LIMIT
will act to cut off the output from a set\-returning function\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
PostgreSQL
versions before 9\&amp;.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan\&amp;.
.sp .5v
.RE
.SS "DISTINCT Clause"
.PP
If
SELECT DISTINCT
is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates)\&amp;.
SELECT ALL
specifies the opposite: all rows are kept; that is the default\&amp;.
.PP
SELECT DISTINCT ON ( \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] )
keeps only the first row of each set of rows where the given expressions evaluate to equal\&amp;. The
DISTINCT ON
expressions are interpreted using the same rules as for
ORDER BY
(see above)\&amp;. Note that the
\(lqfirst row\(rq
of each set is unpredictable unless
ORDER BY
is used to ensure that the desired row appears first\&amp;. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT DISTINCT ON (location) location, time, report
FROM weather_reports
ORDER BY location, time DESC;
.fi
.if n \{\
.RE
.\}
.sp
retrieves the most recent weather report for each location\&amp;. But if we had not used
ORDER BY
to force descending order of time values for each location, we\*(Aqd have gotten a report from an unpredictable time for each location\&amp;.
.PP
The
DISTINCT ON
expression(s) must match the leftmost
ORDER BY
expression(s)\&amp;. The
ORDER BY
clause will normally contain additional expression(s) that determine the desired precedence of rows within each
DISTINCT ON
group\&amp;.
.PP
Currently,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE
and
FOR KEY SHARE
cannot be specified with
DISTINCT\&amp;.
.SS "UNION Clause"
.PP
The
UNION
clause has this general form:
.sp
.if n \{\
.RS 4
.\}
.nf
\fIselect_statement\fR UNION [ ALL | DISTINCT ] \fIselect_statement\fR
.fi
.if n \{\
.RE
.\}
.sp
\fIselect_statement\fR
is any
\fBSELECT\fR
statement without an
ORDER BY,
LIMIT,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE, or
FOR KEY SHARE
clause\&amp;. (ORDER BY
and
LIMIT
can be attached to a subexpression if it is enclosed in parentheses\&amp;. Without parentheses, these clauses will be taken to apply to the result of the
UNION, not to its right\-hand input expression\&amp;.)
.PP
The
UNION
operator computes the set union of the rows returned by the involved
\fBSELECT\fR
statements\&amp;. A row is in the set union of two result sets if it appears in at least one of the result sets\&amp;. The two
\fBSELECT\fR
statements that represent the direct operands of the
UNION
must produce the same number of columns, and corresponding columns must be of compatible data types\&amp;.
.PP
The result of
UNION
does not contain any duplicate rows unless the
ALL
option is specified\&amp;.
ALL
prevents elimination of duplicates\&amp;. (Therefore,
UNION ALL
is usually significantly quicker than
UNION; use
ALL
when you can\&amp;.)
DISTINCT
can be written to explicitly specify the default behavior of eliminating duplicate rows\&amp;.
.PP
Multiple
UNION
operators in the same
\fBSELECT\fR
statement are evaluated left to right, unless otherwise indicated by parentheses\&amp;.
.PP
Currently,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE
and
FOR KEY SHARE
cannot be specified either for a
UNION
result or for any input of a
UNION\&amp;.
.SS "INTERSECT Clause"
.PP
The
INTERSECT
clause has this general form:
.sp
.if n \{\
.RS 4
.\}
.nf
\fIselect_statement\fR INTERSECT [ ALL | DISTINCT ] \fIselect_statement\fR
.fi
.if n \{\
.RE
.\}
.sp
\fIselect_statement\fR
is any
\fBSELECT\fR
statement without an
ORDER BY,
LIMIT,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE, or
FOR KEY SHARE
clause\&amp;.
.PP
The
INTERSECT
operator computes the set intersection of the rows returned by the involved
\fBSELECT\fR
statements\&amp;. A row is in the intersection of two result sets if it appears in both result sets\&amp;.
.PP
The result of
INTERSECT
does not contain any duplicate rows unless the
ALL
option is specified\&amp;. With
ALL, a row that has
\fIm\fR
duplicates in the left table and
\fIn\fR
duplicates in the right table will appear min(\fIm\fR,\fIn\fR) times in the result set\&amp;.
DISTINCT
can be written to explicitly specify the default behavior of eliminating duplicate rows\&amp;.
.PP
Multiple
INTERSECT
operators in the same
\fBSELECT\fR
statement are evaluated left to right, unless parentheses dictate otherwise\&amp;.
INTERSECT
binds more tightly than
UNION\&amp;. That is,
A UNION B INTERSECT C
will be read as
A UNION (B INTERSECT C)\&amp;.
.PP
Currently,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE
and
FOR KEY SHARE
cannot be specified either for an
INTERSECT
result or for any input of an
INTERSECT\&amp;.
.SS "EXCEPT Clause"
.PP
The
EXCEPT
clause has this general form:
.sp
.if n \{\
.RS 4
.\}
.nf
\fIselect_statement\fR EXCEPT [ ALL | DISTINCT ] \fIselect_statement\fR
.fi
.if n \{\
.RE
.\}
.sp
\fIselect_statement\fR
is any
\fBSELECT\fR
statement without an
ORDER BY,
LIMIT,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE, or
FOR KEY SHARE
clause\&amp;.
.PP
The
EXCEPT
operator computes the set of rows that are in the result of the left
\fBSELECT\fR
statement but not in the result of the right one\&amp;.
.PP
The result of
EXCEPT
does not contain any duplicate rows unless the
ALL
option is specified\&amp;. With
ALL, a row that has
\fIm\fR
duplicates in the left table and
\fIn\fR
duplicates in the right table will appear max(\fIm\fR\-\fIn\fR,0) times in the result set\&amp;.
DISTINCT
can be written to explicitly specify the default behavior of eliminating duplicate rows\&amp;.
.PP
Multiple
EXCEPT
operators in the same
\fBSELECT\fR
statement are evaluated left to right, unless parentheses dictate otherwise\&amp;.
EXCEPT
binds at the same level as
UNION\&amp;.
.PP
Currently,
FOR NO KEY UPDATE,
FOR UPDATE,
FOR SHARE
and
FOR KEY SHARE
cannot be specified either for an
EXCEPT
result or for any input of an
EXCEPT\&amp;.
.SS "ORDER BY Clause"
.PP
The optional
ORDER BY
clause has this general form:
.sp
.if n \{\
.RS 4
.\}
.nf
ORDER BY \fIexpression\fR [ ASC | DESC | USING \fIoperator\fR ] [ NULLS { FIRST | LAST } ] [, \&amp;.\&amp;.\&amp;.]
.fi
.if n \{\
.RE
.\}
.sp
The
ORDER BY
clause causes the result rows to be sorted according to the specified expression(s)\&amp;. If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on\&amp;. If they are equal according to all specified expressions, they are returned in an implementation\-dependent order\&amp;.
.PP
Each
\fIexpression\fR
can be the name or ordinal number of an output column (\fBSELECT\fR
list item), or it can be an arbitrary expression formed from input\-column values\&amp;.
.PP
The ordinal number refers to the ordinal (left\-to\-right) position of the output column\&amp;. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name\&amp;. This is never absolutely necessary because it is always possible to assign a name to an output column using the
AS
clause\&amp;.
.PP
It is also possible to use arbitrary expressions in the
ORDER BY
clause, including columns that do not appear in the
\fBSELECT\fR
output list\&amp;. Thus the following statement is valid:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT name FROM distributors ORDER BY code;
.fi
.if n \{\
.RE
.\}
.sp
A limitation of this feature is that an
ORDER BY
clause applying to the result of a
UNION,
INTERSECT, or
EXCEPT
clause can only specify an output column name or number, not an expression\&amp;.
.PP
If an
ORDER BY
expression is a simple name that matches both an output column name and an input column name,
ORDER BY
will interpret it as the output column name\&amp;. This is the opposite of the choice that
GROUP BY
will make in the same situation\&amp;. This inconsistency is made to be compatible with the SQL standard\&amp;.
.PP
Optionally one can add the key word
ASC
(ascending) or
DESC
(descending) after any expression in the
ORDER BY
clause\&amp;. If not specified,
ASC
is assumed by default\&amp;. Alternatively, a specific ordering operator name can be specified in the
USING
clause\&amp;. An ordering operator must be a less\-than or greater\-than member of some B\-tree operator family\&amp;.
ASC
is usually equivalent to
USING &lt;
and
DESC
is usually equivalent to
USING &gt;\&amp;. (But the creator of a user\-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names\&amp;.)
.PP
If
NULLS LAST
is specified, null values sort after all non\-null values; if
NULLS FIRST
is specified, null values sort before all non\-null values\&amp;. If neither is specified, the default behavior is
NULLS LAST
when
ASC
is specified or implied, and
NULLS FIRST
when
DESC
is specified (thus, the default is to act as though nulls are larger than non\-nulls)\&amp;. When
USING
is specified, the default nulls ordering depends on whether the operator is a less\-than or greater\-than operator\&amp;.
.PP
Note that ordering options apply only to the expression they follow; for example
ORDER BY x, y DESC
does not mean the same thing as
ORDER BY x DESC, y DESC\&amp;.
.PP
Character\-string data is sorted according to the collation that applies to the column being sorted\&amp;. That can be overridden at need by including a
COLLATE
clause in the
\fIexpression\fR, for example
ORDER BY mycolumn COLLATE "en_US"\&amp;. For more information see
Section 4.2.10, \(lqCollation Expressions\(rq, in the documentation
and
Section 23.2, \(lqCollation Support\(rq, in the documentation\&amp;.
.SS "LIMIT Clause"
.PP
The
LIMIT
clause consists of two independent sub\-clauses:
.sp
.if n \{\
.RS 4
.\}
.nf
LIMIT { \fIcount\fR | ALL }
OFFSET \fIstart\fR
.fi
.if n \{\
.RE
.\}
.sp
\fIcount\fR
specifies the maximum number of rows to return, while
\fIstart\fR
specifies the number of rows to skip before starting to return rows\&amp;. When both are specified,
\fIstart\fR
rows are skipped before starting to count the
\fIcount\fR
rows to be returned\&amp;.
.PP
If the
\fIcount\fR
expression evaluates to NULL, it is treated as
LIMIT ALL, i\&amp;.e\&amp;., no limit\&amp;. If
\fIstart\fR
evaluates to NULL, it is treated the same as
OFFSET 0\&amp;.
.PP
SQL:2008 introduced a different syntax to achieve the same result, which
PostgreSQL
also supports\&amp;. It is:
.sp
.if n \{\
.RS 4
.\}
.nf
OFFSET \fIstart\fR { ROW | ROWS }
FETCH { FIRST | NEXT } [ \fIcount\fR ] { ROW | ROWS } ONLY
.fi
.if n \{\
.RE
.\}
.sp
In this syntax, to write anything except a simple integer constant for
\fIstart\fR
or
\fIcount\fR, you must write parentheses around it\&amp;. If
\fIcount\fR
is omitted in a
FETCH
clause, it defaults to 1\&amp;.
ROW
and
ROWS
as well as
FIRST
and
NEXT
are noise words that don\*(Aqt influence the effects of these clauses\&amp;. According to the standard, the
OFFSET
clause must come before the
FETCH
clause if both are present; but
PostgreSQL
is laxer and allows either order\&amp;.
.PP
When using
LIMIT, it is a good idea to use an
ORDER BY
clause that constrains the result rows into a unique order\&amp;. Otherwise you will get an unpredictable subset of the query\*(Aqs rows \(em you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don\*(Aqt know what ordering unless you specify
ORDER BY\&amp;.
.PP
The query planner takes
LIMIT
into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for
LIMIT
and
OFFSET\&amp;. Thus, using different
LIMIT/OFFSET
values to select different subsets of a query result
\fIwill give inconsistent results\fR
unless you enforce a predictable result ordering with
ORDER BY\&amp;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless
ORDER BY
is used to constrain the order\&amp;.
.PP
It is even possible for repeated executions of the same
LIMIT
query to return different subsets of the rows of a table, if there is not an
ORDER BY
to enforce selection of a deterministic subset\&amp;. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case\&amp;.
.SS "The Locking Clause"
.PP
FOR UPDATE,
FOR NO KEY UPDATE,
FOR SHARE
and
FOR KEY SHARE
are
locking clauses; they affect how
SELECT
locks rows as they are obtained from the table\&amp;.
.PP
The locking clause has the general form
.sp
.if n \{\
.RS 4
.\}
.nf
FOR \fIlock_strength\fR [ OF \fItable_name\fR [, \&amp;.\&amp;.\&amp;.] ] [ NOWAIT | SKIP LOCKED ]
.fi
.if n \{\
.RE
.\}
.sp
where
\fIlock_strength\fR
can be one of
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
.fi
.if n \{\
.RE
.\}
.PP
For more information on each row\-level lock mode, refer to
Section 13.3.2, \(lqRow-level Locks\(rq, in the documentation\&amp;.
.PP
To prevent the operation from waiting for other transactions to commit, use either the
NOWAIT
or
SKIP LOCKED
option\&amp;. With
NOWAIT, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately\&amp;. With
SKIP LOCKED, any selected rows that cannot be immediately locked are skipped\&amp;. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue\-like table\&amp;. Note that
NOWAIT
and
SKIP LOCKED
apply only to the row\-level lock(s) \(em the required
ROW SHARE
table\-level lock is still taken in the ordinary way (see
Chapter 13, Concurrency Control, in the documentation)\&amp;. You can use
\fBLOCK\fR(7)
with the
NOWAIT
option first, if you need to acquire the table\-level lock without waiting\&amp;.
.PP
If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the
\fBSELECT\fR
are simply read as usual\&amp;. A locking clause without a table list affects all tables used in the statement\&amp;. If a locking clause is applied to a view or sub\-query, it affects all tables used in the view or sub\-query\&amp;. However, these clauses do not apply to
WITH
queries referenced by the primary query\&amp;. If you want row locking to occur within a
WITH
query, specify a locking clause within the
WITH
query\&amp;.
.PP
Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables\&amp;. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one\&amp;. Similarly, a table is processed as
NOWAIT
if that is specified in any of the clauses affecting it\&amp;. Otherwise, it is processed as
SKIP LOCKED
if that is specified in any of the clauses affecting it\&amp;.
.PP
The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation\&amp;.
.PP
When a locking clause appears at the top level of a
\fBSELECT\fR
query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows\&amp;. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions\&amp;. If a
LIMIT
is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by
OFFSET
will get locked)\&amp;. Similarly, if a locking clause is used in a cursor\*(Aqs query, only rows actually fetched or stepped past by the cursor will be locked\&amp;.
.PP
When a locking clause appears in a sub\-\fBSELECT\fR, the rows locked are those returned to the outer query by the sub\-query\&amp;. This might involve fewer rows than inspection of the sub\-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub\-query\&amp;. For example,
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
.fi
.if n \{\
.RE
.\}
.sp
will lock only rows having
col1 = 5, even though that condition is not textually within the sub\-query\&amp;.
.PP
Previous releases failed to preserve a lock which is upgraded by a later savepoint\&amp;. For example, this code:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET \&amp;.\&amp;.\&amp;. WHERE key = 1;
ROLLBACK TO s;
.fi
.if n \{\
.RE
.\}
.sp
would fail to preserve the
FOR UPDATE
lock after the
\fBROLLBACK TO\fR\&amp;. This has been fixed in release 9\&amp;.3\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBCaution\fR
.ps -1
.br
.PP
It is possible for a
\fBSELECT\fR
command running at the
READ COMMITTED
transaction isolation level and using
ORDER BY
and a locking clause to return rows out of order\&amp;. This is because
ORDER BY
is applied first\&amp;. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows\&amp;. Once the
SELECT
unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values)\&amp;. This can be worked around at need by placing the
FOR UPDATE/SHARE
clause in a sub\-query, for example
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;
.fi
.if n \{\
.RE
.\}
.sp
Note that this will result in locking all rows of
mytable, whereas
FOR UPDATE
at the top level would lock only the actually returned rows\&amp;. This can make for a significant performance difference, particularly if the
ORDER BY
is combined with
LIMIT
or other restrictions\&amp;. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required\&amp;.
.PP
At the
REPEATABLE READ
or
SERIALIZABLE
transaction isolation level this would cause a serialization failure (with a
SQLSTATE
of
\*(Aq40001\*(Aq), so there is no possibility of receiving rows out of order under these isolation levels\&amp;.
.sp .5v
.RE
.SS "TABLE Command"
.PP
The command
.sp
.if n \{\
.RS 4
.\}
.nf
TABLE \fIname\fR
.fi
.if n \{\
.RE
.\}
.sp
is equivalent to
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT * FROM \fIname\fR
.fi
.if n \{\
.RE
.\}
.sp
It can be used as a top\-level command or as a space\-saving syntax variant in parts of complex queries\&amp;. Only the
WITH,
UNION,
INTERSECT,
EXCEPT,
ORDER BY,
LIMIT,
OFFSET,
FETCH
and
FOR
locking clauses can be used with
\fBTABLE\fR; the
WHERE
clause and any form of aggregation cannot be used\&amp;.
.SH "EXAMPLES"
.PP
To join the table
films
with the table
distributors:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT f\&amp;.title, f\&amp;.did, d\&amp;.name, f\&amp;.date_prod, f\&amp;.kind
FROM distributors d, films f
WHERE f\&amp;.did = d\&amp;.did

title       | did |     name     | date_prod  |   kind
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-
The Third Man     | 101 | British Lion | 1949\-12\-23 | Drama
The African Queen | 101 | British Lion | 1951\-08\-11 | Romantic
\&amp;.\&amp;.\&amp;.
.fi
.if n \{\
.RE
.\}
.PP
To sum the column
len
of all films and group the results by
kind:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT kind, sum(len) AS total FROM films GROUP BY kind;

kind   | total
\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-
Action   | 07:34
Comedy   | 02:58
Drama    | 14:28
Musical  | 06:42
Romantic | 04:38
.fi
.if n \{\
.RE
.\}
.PP
To sum the column
len
of all films, group the results by
kind
and show those group totals that are less than 5 hours:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT kind, sum(len) AS total
FROM films
GROUP BY kind
HAVING sum(len) &lt; interval \*(Aq5 hours\*(Aq;

kind   | total
\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-
Comedy   | 02:58
Romantic | 04:38
.fi
.if n \{\
.RE
.\}
.PP
The following two examples are identical ways of sorting the individual results according to the contents of the second column (name):
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

did |       name
\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
109 | 20th Century Fox
110 | Bavaria Atelier
101 | British Lion
107 | Columbia
102 | Jean Luc Godard
113 | Luso films
104 | Mosfilm
103 | Paramount
106 | Toho
105 | United Artists
111 | Walt Disney
112 | Warner Bros\&amp;.
108 | Westward
.fi
.if n \{\
.RE
.\}
.PP
The next example shows how to obtain the union of the tables
distributors
and
actors, restricting the results to those that begin with the letter W in each table\&amp;. Only distinct rows are wanted, so the key word
ALL
is omitted\&amp;.
.sp
.if n \{\
.RS 4
.\}
.nf
distributors:               actors:
did |     name              id |     name
\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-        \-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
108 | Westward               1 | Woody Allen
111 | Walt Disney            2 | Warren Beatty
112 | Warner Bros\&amp;.           3 | Walter Matthau
\&amp;.\&amp;.\&amp;.                         \&amp;.\&amp;.\&amp;.

SELECT distributors\&amp;.name
FROM distributors
WHERE distributors\&amp;.name LIKE \*(AqW%\*(Aq
UNION
SELECT actors\&amp;.name
FROM actors
WHERE actors\&amp;.name LIKE \*(AqW%\*(Aq;

name
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
Walt Disney
Walter Matthau
Warner Bros\&amp;.
Warren Beatty
Westward
Woody Allen
.fi
.if n \{\
.RE
.\}
.PP
This example shows how to use a function in the
FROM
clause, both with and without a column definition list:
.sp
.if n \{\
.RS 4
.\}
.nf
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
did |    name
\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-
111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
f1  |     f2
\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-
111 | Walt Disney
.fi
.if n \{\
.RE
.\}
.PP
Here is an example of a function with an ordinality column added:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT * FROM unnest(ARRAY[\*(Aqa\*(Aq,\*(Aqb\*(Aq,\*(Aqc\*(Aq,\*(Aqd\*(Aq,\*(Aqe\*(Aq,\*(Aqf\*(Aq]) WITH ORDINALITY;
unnest | ordinality
\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-
a      |        1
b      |        2
c      |        3
d      |        4
e      |        5
f      |        6
(6 rows)
.fi
.if n \{\
.RE
.\}
.PP
This example shows how to use a simple
WITH
clause:
.sp
.if n \{\
.RS 4
.\}
.nf
WITH t AS (
SELECT random() as x FROM generate_series(1, 3)
)
SELECT * FROM t
UNION ALL
SELECT * FROM t

x          
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
0\&amp;.534150459803641
0\&amp;.520092216785997
0\&amp;.0735620250925422
0\&amp;.534150459803641
0\&amp;.520092216785997
0\&amp;.0735620250925422
.fi
.if n \{\
.RE
.\}
.sp
Notice that the
WITH
query was evaluated only once, so that we got two sets of the same three random values\&amp;.
.PP
This example uses
WITH RECURSIVE
to find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:
.sp
.if n \{\
.RS 4
.\}
.nf
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
SELECT 1, employee_name, manager_name
FROM employee
WHERE manager_name = \*(AqMary\*(Aq
UNION ALL
SELECT er\&amp;.distance + 1, e\&amp;.employee_name, e\&amp;.manager_name
FROM employee_recursive er, employee e
WHERE er\&amp;.employee_name = e\&amp;.manager_name
)
SELECT distance, employee_name FROM employee_recursive;
.fi
.if n \{\
.RE
.\}
.sp
Notice the typical form of recursive queries: an initial condition, followed by
UNION, followed by the recursive part of the query\&amp;. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely\&amp;. (See
Section 7.8, \(lqWITH Queries (Common Table Expressions)\(rq, in the documentation
for more examples\&amp;.)
.PP
This example uses
LATERAL
to apply a set\-returning function
\fBget_product_names()\fR
for each row of the
manufacturers
table:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT m\&amp;.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m\&amp;.id) pname;
.fi
.if n \{\
.RE
.\}
.sp
Manufacturers not currently having any products would not appear in the result, since it is an inner join\&amp;. If we wished to include the names of such manufacturers in the result, we could do:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT m\&amp;.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m\&amp;.id) pname ON true;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
Of course, the
\fBSELECT\fR
statement is compatible with the SQL standard\&amp;. But there are some extensions and some missing features\&amp;.
.SS "Omitted FROM Clauses"
.PP
PostgreSQL
allows one to omit the
FROM
clause\&amp;. It has a straightforward use to compute the results of simple expressions:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT 2+2;

?column?
\-\-\-\-\-\-\-\-\-\-
4
.fi
.if n \{\
.RE
.\}
.sp
Some other
SQL
databases cannot do this except by introducing a dummy one\-row table from which to do the
\fBSELECT\fR\&amp;.
.PP
Note that if a
FROM
clause is not specified, the query cannot reference any database tables\&amp;. For example, the following query is invalid:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT distributors\&amp;.* WHERE distributors\&amp;.name = \*(AqWestward\*(Aq;
.fi
.if n \{\
.RE
.\}
.sp
PostgreSQL
releases prior to 8\&amp;.1 would accept queries of this form, and add an implicit entry to the query\*(Aqs
FROM
clause for each table referenced by the query\&amp;. This is no longer allowed\&amp;.
.SS "Empty SELECT Lists"
.PP
The list of output expressions after
SELECT
can be empty, producing a zero\-column result table\&amp;. This is not valid syntax according to the SQL standard\&amp;.
PostgreSQL
allows it to be consistent with allowing zero\-column tables\&amp;. However, an empty list is not allowed when
DISTINCT
is used\&amp;.
.SS "Omitting the AS Key Word"
.PP
In the SQL standard, the optional key word
AS
can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword)\&amp;.
PostgreSQL
is slightly more restrictive:
AS
is required if the new column name matches any keyword at all, reserved or not\&amp;. Recommended practice is to use
AS
or double\-quote output column names, to prevent any possible conflict against future keyword additions\&amp;.
.PP
In
FROM
items, both the standard and
PostgreSQL
allow
AS
to be omitted before an alias that is an unreserved keyword\&amp;. But this is impractical for output column names, because of syntactic ambiguities\&amp;.
.SS "ONLY and Inheritance"
.PP
The SQL standard requires parentheses around the table name when writing
ONLY, for example
SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE \&amp;.\&amp;.\&amp;.\&amp;.
PostgreSQL
considers these parentheses to be optional\&amp;.
.PP
PostgreSQL
allows a trailing
*
to be written to explicitly specify the non\-ONLY
behavior of including child tables\&amp;. The standard does not allow this\&amp;.
.PP
(These points apply equally to all SQL commands supporting the
ONLY
option\&amp;.)
.SS "TABLESAMPLE Clause Restrictions"
.PP
The
TABLESAMPLE
clause is currently accepted only on regular tables and materialized views\&amp;. According to the SQL standard it should be possible to apply it to any
FROM
item\&amp;.
.SS "Function Calls in FROM"
.PP
PostgreSQL
allows a function call to be written directly as a member of the
FROM
list\&amp;. In the SQL standard it would be necessary to wrap such a function call in a sub\-\fBSELECT\fR; that is, the syntax
FROM \fIfunc\fR(\&amp;.\&amp;.\&amp;.) \fIalias\fR
is approximately equivalent to
FROM LATERAL (SELECT \fIfunc\fR(\&amp;.\&amp;.\&amp;.)) \fIalias\fR\&amp;. Note that
LATERAL
is considered to be implicit; this is because the standard requires
LATERAL
semantics for an
UNNEST()
item in
FROM\&amp;.
PostgreSQL
treats
UNNEST()
the same as other set\-returning functions\&amp;.
.SS "Namespace Available to GROUP BY and ORDER BY"
.PP
In the SQL\-92 standard, an
ORDER BY
clause can only use output column names or numbers, while a
GROUP BY
clause can only use expressions based on input column names\&amp;.
PostgreSQL
extends each of these clauses to allow the other choice as well (but it uses the standard\*(Aqs interpretation if there is ambiguity)\&amp;.
PostgreSQL
also allows both clauses to specify arbitrary expressions\&amp;. Note that names appearing in an expression will always be taken as input\-column names, not as output\-column names\&amp;.
.PP
SQL:1999 and later use a slightly different definition which is not entirely upward compatible with SQL\-92\&amp;. In most cases, however,
PostgreSQL
will interpret an
ORDER BY
or
GROUP BY
expression the same way SQL:1999 does\&amp;.
.SS "Functional Dependencies"
.PP
PostgreSQL
recognizes functional dependency (allowing columns to be omitted from
GROUP BY) only when a table\*(Aqs primary key is included in the
GROUP BY
list\&amp;. The SQL standard specifies additional conditions that should be recognized\&amp;.
.SS "WINDOW Clause Restrictions"
.PP
The SQL standard provides additional options for the window
\fIframe_clause\fR\&amp;.
PostgreSQL
currently supports only the options listed above\&amp;.
.SS "LIMIT and OFFSET"
.PP
The clauses
LIMIT
and
OFFSET
are
PostgreSQL\-specific syntax, also used by
MySQL\&amp;. The SQL:2008 standard has introduced the clauses
OFFSET \&amp;.\&amp;.\&amp;. FETCH {FIRST|NEXT} \&amp;.\&amp;.\&amp;.
for the same functionality, as shown above in
LIMIT Clause\&amp;. This syntax is also used by
IBM DB2\&amp;. (Applications written for
Oracle
frequently use a workaround involving the automatically generated
rownum
column, which is not available in PostgreSQL, to implement the effects of these clauses\&amp;.)
.SS "FOR NO KEY UPDATE, FOR UPDATE, FOR SHARE, FOR KEY SHARE"
.PP
Although
FOR UPDATE
appears in the SQL standard, the standard allows it only as an option of
\fBDECLARE CURSOR\fR\&amp;.
PostgreSQL
allows it in any
\fBSELECT\fR
query as well as in sub\-\fBSELECT\fRs, but this is an extension\&amp;. The
FOR NO KEY UPDATE,
FOR SHARE
and
FOR KEY SHARE
variants, as well as the
NOWAIT
and
SKIP LOCKED
options, do not appear in the standard\&amp;.
.SS "Data\-Modifying Statements in WITH"
.PP
PostgreSQL
allows
\fBINSERT\fR,
\fBUPDATE\fR, and
\fBDELETE\fR
to be used as
WITH
queries\&amp;. This is not found in the SQL standard\&amp;.
.SS "Nonstandard Clauses"
.PP
DISTINCT ON ( \&amp;.\&amp;.\&amp;. )
is an extension of the SQL standard\&amp;.
.PP
ROWS FROM( \&amp;.\&amp;.\&amp;. )
is an extension of the SQL standard\&amp;.
'\" t
.\"     Title: SELECT INTO
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SELECT INTO" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SELECT_INTO \- define a new table from the results of a query
.SH "SYNOPSIS"
.sp
.nf
[ WITH [ RECURSIVE ] \fIwith_query\fR [, \&amp;.\&amp;.\&amp;.] ]
SELECT [ ALL | DISTINCT [ ON ( \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
* | \fIexpression\fR [ [ AS ] \fIoutput_name\fR ] [, \&amp;.\&amp;.\&amp;.]
INTO [ TEMPORARY | TEMP | UNLOGGED ] [ TABLE ] \fInew_table\fR
[ FROM \fIfrom_item\fR [, \&amp;.\&amp;.\&amp;.] ]
[ WHERE \fIcondition\fR ]
[ GROUP BY \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] ]
[ HAVING \fIcondition\fR [, \&amp;.\&amp;.\&amp;.] ]
[ WINDOW \fIwindow_name\fR AS ( \fIwindow_definition\fR ) [, \&amp;.\&amp;.\&amp;.] ]
[ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] \fIselect\fR ]
[ ORDER BY \fIexpression\fR [ ASC | DESC | USING \fIoperator\fR ] [ NULLS { FIRST | LAST } ] [, \&amp;.\&amp;.\&amp;.] ]
[ LIMIT { \fIcount\fR | ALL } ]
[ OFFSET \fIstart\fR [ ROW | ROWS ] ]
[ FETCH { FIRST | NEXT } [ \fIcount\fR ] { ROW | ROWS } ONLY ]
[ FOR { UPDATE | SHARE } [ OF \fItable_name\fR [, \&amp;.\&amp;.\&amp;.] ] [ NOWAIT ] [\&amp;.\&amp;.\&amp;.] ]
.fi
.SH "DESCRIPTION"
.PP
\fBSELECT INTO\fR
creates a new table and fills it with data computed by a query\&amp;. The data is not returned to the client, as it is with a normal
\fBSELECT\fR\&amp;. The new table\*(Aqs columns have the names and data types associated with the output columns of the
\fBSELECT\fR\&amp;.
.SH "PARAMETERS"
.PP
TEMPORARY or TEMP
.RS 4
If specified, the table is created as a temporary table\&amp;. Refer to
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for details\&amp;.
.RE
.PP
UNLOGGED
.RS 4
If specified, the table is created as an unlogged table\&amp;. Refer to
CREATE TABLE (\fBCREATE_TABLE\fR(7))
for details\&amp;.
.RE
.PP
\fInew_table\fR
.RS 4
The name (optionally schema\-qualified) of the table to be created\&amp;.
.RE
.PP
All other parameters are described in detail under
\fBSELECT\fR(7)\&amp;.
.SH "NOTES"
.PP
CREATE TABLE AS (\fBCREATE_TABLE_AS\fR(7))
is functionally similar to
\fBSELECT INTO\fR\&amp;.
\fBCREATE TABLE AS\fR
is the recommended syntax, since this form of
\fBSELECT INTO\fR
is not available in
ECPG
or
PL/pgSQL, because they interpret the
INTO
clause differently\&amp;. Furthermore,
\fBCREATE TABLE AS\fR
offers a superset of the functionality provided by
\fBSELECT INTO\fR\&amp;.
.PP
To add OIDs to the table created by
\fBSELECT INTO\fR, enable the
default_with_oids
configuration variable\&amp;. Alternatively,
\fBCREATE TABLE AS\fR
can be used with the
WITH OIDS
clause\&amp;.
.SH "EXAMPLES"
.PP
Create a new table
films_recent
consisting of only recent entries from the table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT * INTO films_recent FROM films WHERE date_prod &gt;= \*(Aq2002\-01\-01\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The SQL standard uses
\fBSELECT INTO\fR
to represent selecting values into scalar variables of a host program, rather than creating a new table\&amp;. This indeed is the usage found in
ECPG
(see
Chapter 34, ECPG - Embedded SQL in C, in the documentation) and
PL/pgSQL
(see
Chapter 41, PL/pgSQL - SQL Procedural Language, in the documentation)\&amp;. The
PostgreSQL
usage of
\fBSELECT INTO\fR
to represent table creation is historical\&amp;. It is best to use
\fBCREATE TABLE AS\fR
for this purpose in new code\&amp;.
.SH "SEE ALSO"
CREATE TABLE AS (\fBCREATE_TABLE_AS\fR(7))
'\" t
.\"     Title: SET
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SET" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SET \- change a run\-time parameter
.SH "SYNOPSIS"
.sp
.nf
SET [ SESSION | LOCAL ] \fIconfiguration_parameter\fR { TO | = } { \fIvalue\fR | \*(Aq\fIvalue\fR\*(Aq | DEFAULT }
SET [ SESSION | LOCAL ] TIME ZONE { \fItimezone\fR | LOCAL | DEFAULT }
.fi
.SH "DESCRIPTION"
.PP
The
\fBSET\fR
command changes run\-time configuration parameters\&amp;. Many of the run\-time parameters listed in
Chapter 19, Server Configuration, in the documentation
can be changed on\-the\-fly with
\fBSET\fR\&amp;. (But some require superuser privileges to change, and others cannot be changed after server or session start\&amp;.)
\fBSET\fR
only affects the value used by the current session\&amp;.
.PP
If
\fBSET\fR
(or equivalently
\fBSET SESSION\fR) is issued within a transaction that is later aborted, the effects of the
\fBSET\fR
command disappear when the transaction is rolled back\&amp;. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by another
\fBSET\fR\&amp;.
.PP
The effects of
\fBSET LOCAL\fR
last only till the end of the current transaction, whether committed or not\&amp;. A special case is
\fBSET\fR
followed by
\fBSET LOCAL\fR
within a single transaction: the
\fBSET LOCAL\fR
value will be seen until the end of the transaction, but afterwards (if the transaction is committed) the
\fBSET\fR
value will take effect\&amp;.
.PP
The effects of
\fBSET\fR
or
\fBSET LOCAL\fR
are also canceled by rolling back to a savepoint that is earlier than the command\&amp;.
.PP
If
\fBSET LOCAL\fR
is used within a function that has a
SET
option for the same variable (see
CREATE FUNCTION (\fBCREATE_FUNCTION\fR(7))), the effects of the
\fBSET LOCAL\fR
command disappear at function exit; that is, the value in effect when the function was called is restored anyway\&amp;. This allows
\fBSET LOCAL\fR
to be used for dynamic or repeated changes of a parameter within a function, while still having the convenience of using the
SET
option to save and restore the caller\*(Aqs value\&amp;. However, a regular
\fBSET\fR
command overrides any surrounding function\*(Aqs
SET
option; its effects will persist unless rolled back\&amp;.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
In
PostgreSQL
versions 8\&amp;.0 through 8\&amp;.2, the effects of a
\fBSET LOCAL\fR
would be canceled by releasing an earlier savepoint, or by successful exit from a
PL/pgSQL
exception block\&amp;. This behavior has been changed because it was deemed unintuitive\&amp;.
.sp .5v
.RE
.SH "PARAMETERS"
.PP
SESSION
.RS 4
Specifies that the command takes effect for the current session\&amp;. (This is the default if neither
SESSION
nor
LOCAL
appears\&amp;.)
.RE
.PP
LOCAL
.RS 4
Specifies that the command takes effect for only the current transaction\&amp;. After
\fBCOMMIT\fR
or
\fBROLLBACK\fR, the session\-level setting takes effect again\&amp;. Issuing this outside of a transaction block emits a warning and otherwise has no effect\&amp;.
.RE
.PP
\fIconfiguration_parameter\fR
.RS 4
Name of a settable run\-time parameter\&amp;. Available parameters are documented in
Chapter 19, Server Configuration, in the documentation
and below\&amp;.
.RE
.PP
\fIvalue\fR
.RS 4
New value of parameter\&amp;. Values can be specified as string constants, identifiers, numbers, or comma\-separated lists of these, as appropriate for the particular parameter\&amp;.
DEFAULT
can be written to specify resetting the parameter to its default value (that is, whatever value it would have had if no
\fBSET\fR
had been executed in the current session)\&amp;.
.RE
.PP
Besides the configuration parameters documented in
Chapter 19, Server Configuration, in the documentation, there are a few that can only be adjusted using the
\fBSET\fR
command or that have a special syntax:
.PP
SCHEMA
.RS 4
SET SCHEMA \*(Aq\fIvalue\fR\*(Aq
is an alias for
SET search_path TO \fIvalue\fR\&amp;. Only one schema can be specified using this syntax\&amp;.
.RE
.PP
NAMES
.RS 4
SET NAMES \fIvalue\fR
is an alias for
SET client_encoding TO \fIvalue\fR\&amp;.
.RE
.PP
SEED
.RS 4
Sets the internal seed for the random number generator (the function
\fBrandom\fR)\&amp;. Allowed values are floating\-point numbers between \-1 and 1, which are then multiplied by 2^31\-1\&amp;.
.sp
The seed can also be set by invoking the function
\fBsetseed\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT setseed(\fIvalue\fR);
.fi
.if n \{\
.RE
.\}
.RE
.PP
TIME ZONE
.RS 4
SET TIME ZONE \fIvalue\fR
is an alias for
SET timezone TO \fIvalue\fR\&amp;. The syntax
SET TIME ZONE
allows special syntax for the time zone specification\&amp;. Here are examples of valid values:
.PP
\*(AqPST8PDT\*(Aq
.RS 4
The time zone for Berkeley, California\&amp;.
.RE
.PP
\*(AqEurope/Rome\*(Aq
.RS 4
The time zone for Italy\&amp;.
.RE
.PP
\-7
.RS 4
The time zone 7 hours west from UTC (equivalent to PDT)\&amp;. Positive values are east from UTC\&amp;.
.RE
.PP
INTERVAL \*(Aq\-08:00\*(Aq HOUR TO MINUTE
.RS 4
The time zone 8 hours west from UTC (equivalent to PST)\&amp;.
.RE
.PP
LOCAL
.br
DEFAULT
.RS 4
Set the time zone to your local time zone (that is, the server\*(Aqs default value of
\fItimezone\fR)\&amp;.
.RE
.sp
Timezone settings given as numbers or intervals are internally translated to POSIX timezone syntax\&amp;. For example, after
SET TIME ZONE \-7,
\fBSHOW TIME ZONE\fR
would report
&lt;\-07&gt;+07\&amp;.
.sp
See
Section 8.5.3, \(lqTime Zones\(rq, in the documentation
for more information about time zones\&amp;.
.RE
.SH "NOTES"
.PP
The function
\fBset_config\fR
provides equivalent functionality; see
Section 9.26, \(lqSystem Administration Functions\(rq, in the documentation\&amp;. Also, it is possible to UPDATE the
pg_settings
system view to perform the equivalent of
\fBSET\fR\&amp;.
.SH "EXAMPLES"
.PP
Set the schema search path:
.sp
.if n \{\
.RS 4
.\}
.nf
SET search_path TO my_schema, public;
.fi
.if n \{\
.RE
.\}
.PP
Set the style of date to traditional
POSTGRES
with
\(lqday before month\(rq
input convention:
.sp
.if n \{\
.RS 4
.\}
.nf
SET datestyle TO postgres, dmy;
.fi
.if n \{\
.RE
.\}
.PP
Set the time zone for Berkeley, California:
.sp
.if n \{\
.RS 4
.\}
.nf
SET TIME ZONE \*(AqPST8PDT\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Set the time zone for Italy:
.sp
.if n \{\
.RS 4
.\}
.nf
SET TIME ZONE \*(AqEurope/Rome\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
SET TIME ZONE
extends syntax defined in the SQL standard\&amp;. The standard allows only numeric time zone offsets while
PostgreSQL
allows more flexible time\-zone specifications\&amp;. All other
SET
features are
PostgreSQL
extensions\&amp;.
.SH "SEE ALSO"
\fBRESET\fR(7), \fBSHOW\fR(7)
'\" t
.\"     Title: SET CONSTRAINTS
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SET CONSTRAINTS" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SET_CONSTRAINTS \- set constraint check timing for the current transaction
.SH "SYNOPSIS"
.sp
.nf
SET CONSTRAINTS { ALL | \fIname\fR [, \&amp;.\&amp;.\&amp;.] } { DEFERRED | IMMEDIATE }
.fi
.SH "DESCRIPTION"
.PP
\fBSET CONSTRAINTS\fR
sets the behavior of constraint checking within the current transaction\&amp;.
IMMEDIATE
constraints are checked at the end of each statement\&amp;.
DEFERRED
constraints are not checked until transaction commit\&amp;. Each constraint has its own
IMMEDIATE
or
DEFERRED
mode\&amp;.
.PP
Upon creation, a constraint is given one of three characteristics:
DEFERRABLE INITIALLY DEFERRED,
DEFERRABLE INITIALLY IMMEDIATE, or
NOT DEFERRABLE\&amp;. The third class is always
IMMEDIATE
and is not affected by the
\fBSET CONSTRAINTS\fR
command\&amp;. The first two classes start every transaction in the indicated mode, but their behavior can be changed within a transaction by
\fBSET CONSTRAINTS\fR\&amp;.
.PP
\fBSET CONSTRAINTS\fR
with a list of constraint names changes the mode of just those constraints (which must all be deferrable)\&amp;. Each constraint name can be schema\-qualified\&amp;. The current schema search path is used to find the first matching name if no schema name is specified\&amp;.
\fBSET CONSTRAINTS ALL\fR
changes the mode of all deferrable constraints\&amp;.
.PP
When
\fBSET CONSTRAINTS\fR
changes the mode of a constraint from
DEFERRED
to
IMMEDIATE, the new mode takes effect retroactively: any outstanding data modifications that would have been checked at the end of the transaction are instead checked during the execution of the
\fBSET CONSTRAINTS\fR
command\&amp;. If any such constraint is violated, the
\fBSET CONSTRAINTS\fR
fails (and does not change the constraint mode)\&amp;. Thus,
\fBSET CONSTRAINTS\fR
can be used to force checking of constraints to occur at a specific point in a transaction\&amp;.
.PP
Currently, only
UNIQUE,
PRIMARY KEY,
REFERENCES
(foreign key), and
EXCLUDE
constraints are affected by this setting\&amp;.
NOT NULL
and
CHECK
constraints are always checked immediately when a row is inserted or modified (\fInot\fR
at the end of the statement)\&amp;. Uniqueness and exclusion constraints that have not been declared
DEFERRABLE
are also checked immediately\&amp;.
.PP
The firing of triggers that are declared as
\(lqconstraint triggers\(rq
is also controlled by this setting \(em they fire at the same time that the associated constraint should be checked\&amp;.
.SH "NOTES"
.PP
Because
PostgreSQL
does not require constraint names to be unique within a schema (but only per\-table), it is possible that there is more than one match for a specified constraint name\&amp;. In this case
\fBSET CONSTRAINTS\fR
will act on all matches\&amp;. For a non\-schema\-qualified name, once a match or matches have been found in some schema in the search path, schemas appearing later in the path are not searched\&amp;.
.PP
This command only alters the behavior of constraints within the current transaction\&amp;. Issuing this outside of a transaction block emits a warning and otherwise has no effect\&amp;.
.SH "COMPATIBILITY"
.PP
This command complies with the behavior defined in the SQL standard, except for the limitation that, in
PostgreSQL, it does not apply to
NOT NULL
and
CHECK
constraints\&amp;. Also,
PostgreSQL
checks non\-deferrable uniqueness constraints immediately, not at end of statement as the standard would suggest\&amp;.
'\" t
.\"     Title: SET ROLE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SET ROLE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SET_ROLE \- set the current user identifier of the current session
.SH "SYNOPSIS"
.sp
.nf
SET [ SESSION | LOCAL ] ROLE \fIrole_name\fR
SET [ SESSION | LOCAL ] ROLE NONE
RESET ROLE
.fi
.SH "DESCRIPTION"
.PP
This command sets the current user identifier of the current SQL session to be
\fIrole_name\fR\&amp;. The role name can be written as either an identifier or a string literal\&amp;. After
\fBSET ROLE\fR, permissions checking for SQL commands is carried out as though the named role were the one that had logged in originally\&amp;.
.PP
The specified
\fIrole_name\fR
must be a role that the current session user is a member of\&amp;. (If the session user is a superuser, any role can be selected\&amp;.)
.PP
The
SESSION
and
LOCAL
modifiers act the same as for the regular
\fBSET\fR(7)
command\&amp;.
.PP
The
NONE
and
RESET
forms reset the current user identifier to be the current session user identifier\&amp;. These forms can be executed by any user\&amp;.
.SH "NOTES"
.PP
Using this command, it is possible to either add privileges or restrict one\*(Aqs privileges\&amp;. If the session user role has the
INHERITS
attribute, then it automatically has all the privileges of every role that it could
\fBSET ROLE\fR
to; in this case
\fBSET ROLE\fR
effectively drops all the privileges assigned directly to the session user and to the other roles it is a member of, leaving only the privileges available to the named role\&amp;. On the other hand, if the session user role has the
NOINHERITS
attribute,
\fBSET ROLE\fR
drops the privileges assigned directly to the session user and instead acquires the privileges available to the named role\&amp;.
.PP
In particular, when a superuser chooses to
\fBSET ROLE\fR
to a non\-superuser role, they lose their superuser privileges\&amp;.
.PP
\fBSET ROLE\fR
has effects comparable to
SET SESSION AUTHORIZATION (\fBSET_SESSION_AUTHORIZATION\fR(7)), but the privilege checks involved are quite different\&amp;. Also,
\fBSET SESSION AUTHORIZATION\fR
determines which roles are allowable for later
\fBSET ROLE\fR
commands, whereas changing roles with
\fBSET ROLE\fR
does not change the set of roles allowed to a later
\fBSET ROLE\fR\&amp;.
.PP
\fBSET ROLE\fR
does not process session variables as specified by the role\*(Aqs
ALTER ROLE (\fBALTER_ROLE\fR(7))
settings; this only happens during login\&amp;.
.PP
\fBSET ROLE\fR
cannot be used within a
SECURITY DEFINER
function\&amp;.
.SH "EXAMPLES"
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT SESSION_USER, CURRENT_USER;

session_user | current_user 
\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-
peter        | peter

SET ROLE \*(Aqpaul\*(Aq;

SELECT SESSION_USER, CURRENT_USER;

session_user | current_user 
\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-
peter        | paul
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
PostgreSQL
allows identifier syntax ("\fIrolename\fR"), while the SQL standard requires the role name to be written as a string literal\&amp;. SQL does not allow this command during a transaction;
PostgreSQL
does not make this restriction because there is no reason to\&amp;. The
SESSION
and
LOCAL
modifiers are a
PostgreSQL
extension, as is the
RESET
syntax\&amp;.
.SH "SEE ALSO"
SET SESSION AUTHORIZATION (\fBSET_SESSION_AUTHORIZATION\fR(7))
'\" t
.\"     Title: SET SESSION AUTHORIZATION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SET SESSION AUTHORIZATION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SET_SESSION_AUTHORIZATION \- set the session user identifier and the current user identifier of the current session
.SH "SYNOPSIS"
.sp
.nf
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION \fIuser_name\fR
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT
RESET SESSION AUTHORIZATION
.fi
.SH "DESCRIPTION"
.PP
This command sets the session user identifier and the current user identifier of the current SQL session to be
\fIuser_name\fR\&amp;. The user name can be written as either an identifier or a string literal\&amp;. Using this command, it is possible, for example, to temporarily become an unprivileged user and later switch back to being a superuser\&amp;.
.PP
The session user identifier is initially set to be the (possibly authenticated) user name provided by the client\&amp;. The current user identifier is normally equal to the session user identifier, but might change temporarily in the context of
SECURITY DEFINER
functions and similar mechanisms; it can also be changed by
SET ROLE (\fBSET_ROLE\fR(7))\&amp;. The current user identifier is relevant for permission checking\&amp;.
.PP
The session user identifier can be changed only if the initial session user (the
authenticated user) had the superuser privilege\&amp;. Otherwise, the command is accepted only if it specifies the authenticated user name\&amp;.
.PP
The
SESSION
and
LOCAL
modifiers act the same as for the regular
\fBSET\fR(7)
command\&amp;.
.PP
The
DEFAULT
and
RESET
forms reset the session and current user identifiers to be the originally authenticated user name\&amp;. These forms can be executed by any user\&amp;.
.SH "NOTES"
.PP
\fBSET SESSION AUTHORIZATION\fR
cannot be used within a
SECURITY DEFINER
function\&amp;.
.SH "EXAMPLES"
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT SESSION_USER, CURRENT_USER;

session_user | current_user 
\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-
peter        | peter

SET SESSION AUTHORIZATION \*(Aqpaul\*(Aq;

SELECT SESSION_USER, CURRENT_USER;

session_user | current_user 
\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-
paul         | paul
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The SQL standard allows some other expressions to appear in place of the literal
\fIuser_name\fR, but these options are not important in practice\&amp;.
PostgreSQL
allows identifier syntax ("\fIusername\fR"), which SQL does not\&amp;. SQL does not allow this command during a transaction;
PostgreSQL
does not make this restriction because there is no reason to\&amp;. The
SESSION
and
LOCAL
modifiers are a
PostgreSQL
extension, as is the
RESET
syntax\&amp;.
.PP
The privileges necessary to execute this command are left implementation\-defined by the standard\&amp;.
.SH "SEE ALSO"
SET ROLE (\fBSET_ROLE\fR(7))
'\" t
.\"     Title: SET TRANSACTION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SET TRANSACTION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SET_TRANSACTION \- set the characteristics of the current transaction
.SH "SYNOPSIS"
.sp
.nf
SET TRANSACTION \fItransaction_mode\fR [, \&amp;.\&amp;.\&amp;.]
SET TRANSACTION SNAPSHOT \fIsnapshot_id\fR
SET SESSION CHARACTERISTICS AS TRANSACTION \fItransaction_mode\fR [, \&amp;.\&amp;.\&amp;.]

where \fItransaction_mode\fR is one of:

ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }
READ WRITE | READ ONLY
[ NOT ] DEFERRABLE
.fi
.SH "DESCRIPTION"
.PP
The
\fBSET TRANSACTION\fR
command sets the characteristics of the current transaction\&amp;. It has no effect on any subsequent transactions\&amp;.
\fBSET SESSION CHARACTERISTICS\fR
sets the default transaction characteristics for subsequent transactions of a session\&amp;. These defaults can be overridden by
\fBSET TRANSACTION\fR
for an individual transaction\&amp;.
.PP
The available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read\-only), and the deferrable mode\&amp;. In addition, a snapshot can be selected, though only for the current transaction, not as a session default\&amp;.
.PP
The isolation level of a transaction determines what data the transaction can see when other transactions are running concurrently:
.PP
READ COMMITTED
.RS 4
A statement can only see rows committed before it began\&amp;. This is the default\&amp;.
.RE
.PP
REPEATABLE READ
.RS 4
All statements of the current transaction can only see rows committed before the first query or data\-modification statement was executed in this transaction\&amp;.
.RE
.PP
SERIALIZABLE
.RS 4
All statements of the current transaction can only see rows committed before the first query or data\-modification statement was executed in this transaction\&amp;. If a pattern of reads and writes among concurrent serializable transactions would create a situation which could not have occurred for any serial (one\-at\-a\-time) execution of those transactions, one of them will be rolled back with a
serialization_failure
error\&amp;.
.RE
The SQL standard defines one additional level,
READ UNCOMMITTED\&amp;. In
PostgreSQLREAD UNCOMMITTED
is treated as
READ COMMITTED\&amp;.
.PP
The transaction isolation level cannot be changed after the first query or data\-modification statement (\fBSELECT\fR,
\fBINSERT\fR,
\fBDELETE\fR,
\fBUPDATE\fR,
\fBFETCH\fR, or
\fBCOPY\fR) of a transaction has been executed\&amp;. See
Chapter 13, Concurrency Control, in the documentation
for more information about transaction isolation and concurrency control\&amp;.
.PP
The transaction access mode determines whether the transaction is read/write or read\-only\&amp;. Read/write is the default\&amp;. When a transaction is read\-only, the following SQL commands are disallowed:
INSERT,
UPDATE,
DELETE, and
COPY FROM
if the table they would write to is not a temporary table; all
CREATE,
ALTER, and
DROP
commands;
COMMENT,
GRANT,
REVOKE,
TRUNCATE; and
EXPLAIN ANALYZE
and
EXECUTE
if the command they would execute is among those listed\&amp;. This is a high\-level notion of read\-only that does not prevent all writes to disk\&amp;.
.PP
The
DEFERRABLE
transaction property has no effect unless the transaction is also
SERIALIZABLE
and
READ ONLY\&amp;. When all three of these properties are selected for a transaction, the transaction may block when first acquiring its snapshot, after which it is able to run without the normal overhead of a
SERIALIZABLE
transaction and without any risk of contributing to or being canceled by a serialization failure\&amp;. This mode is well suited for long\-running reports or backups\&amp;.
.PP
The
SET TRANSACTION SNAPSHOT
command allows a new transaction to run with the same
snapshot
as an existing transaction\&amp;. The pre\-existing transaction must have exported its snapshot with the
pg_export_snapshot
function (see
Section 9.26.5, \(lqSnapshot Synchronization Functions\(rq, in the documentation)\&amp;. That function returns a snapshot identifier, which must be given to
SET TRANSACTION SNAPSHOT
to specify which snapshot is to be imported\&amp;. The identifier must be written as a string literal in this command, for example
\*(Aq000003A1\-1\*(Aq\&amp;.
SET TRANSACTION SNAPSHOT
can only be executed at the start of a transaction, before the first query or data\-modification statement (\fBSELECT\fR,
\fBINSERT\fR,
\fBDELETE\fR,
\fBUPDATE\fR,
\fBFETCH\fR, or
\fBCOPY\fR) of the transaction\&amp;. Furthermore, the transaction must already be set to
SERIALIZABLE
or
REPEATABLE READ
isolation level (otherwise, the snapshot would be discarded immediately, since
READ COMMITTED
mode takes a new snapshot for each command)\&amp;. If the importing transaction uses
SERIALIZABLE
isolation level, then the transaction that exported the snapshot must also use that isolation level\&amp;. Also, a non\-read\-only serializable transaction cannot import a snapshot from a read\-only transaction\&amp;.
.SH "NOTES"
.PP
If
\fBSET TRANSACTION\fR
is executed without a prior
\fBSTART TRANSACTION\fR
or
\fBBEGIN\fR, it emits a warning and otherwise has no effect\&amp;.
.PP
It is possible to dispense with
\fBSET TRANSACTION\fR
by instead specifying the desired
\fItransaction_modes\fR
in
\fBBEGIN\fR
or
\fBSTART TRANSACTION\fR\&amp;. But that option is not available for
\fBSET TRANSACTION SNAPSHOT\fR\&amp;.
.PP
The session default transaction modes can also be set by setting the configuration parameters
default_transaction_isolation,
default_transaction_read_only, and
default_transaction_deferrable\&amp;. (In fact
\fBSET SESSION CHARACTERISTICS\fR
is just a verbose equivalent for setting these variables with
\fBSET\fR\&amp;.) This means the defaults can be set in the configuration file, via
\fBALTER DATABASE\fR, etc\&amp;. Consult
Chapter 19, Server Configuration, in the documentation
for more information\&amp;.
.SH "EXAMPLES"
.PP
To begin a new transaction with the same snapshot as an already existing transaction, first export the snapshot from the existing transaction\&amp;. That will return the snapshot identifier, for example:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT pg_export_snapshot();
pg_export_snapshot
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
000003A1\-1
(1 row)
.fi
.if n \{\
.RE
.\}
.sp
Then give the snapshot identifier in a
\fBSET TRANSACTION SNAPSHOT\fR
command at the beginning of the newly opened transaction:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION SNAPSHOT \*(Aq000003A1\-1\*(Aq;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
These commands are defined in the
SQL
standard, except for the
DEFERRABLE
transaction mode and the
\fBSET TRANSACTION SNAPSHOT\fR
form, which are
PostgreSQL
extensions\&amp;.
.PP
SERIALIZABLE
is the default transaction isolation level in the standard\&amp;. In
PostgreSQL
the default is ordinarily
READ COMMITTED, but you can change it as mentioned above\&amp;.
.PP
In the SQL standard, there is one other transaction characteristic that can be set with these commands: the size of the diagnostics area\&amp;. This concept is specific to embedded SQL, and therefore is not implemented in the
PostgreSQL
server\&amp;.
.PP
The SQL standard requires commas between successive
\fItransaction_modes\fR, but for historical reasons
PostgreSQL
allows the commas to be omitted\&amp;.
'\" t
.\"     Title: SHOW
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "SHOW" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
SHOW \- show the value of a run\-time parameter
.SH "SYNOPSIS"
.sp
.nf
SHOW \fIname\fR
SHOW ALL
.fi
.SH "DESCRIPTION"
.PP
\fBSHOW\fR
will display the current setting of run\-time parameters\&amp;. These variables can be set using the
\fBSET\fR
statement, by editing the
postgresql\&amp;.conf
configuration file, through the
\fBPGOPTIONS\fR
environmental variable (when using
libpq
or a
libpq\-based application), or through command\-line flags when starting the
\fBpostgres\fR
server\&amp;. See
Chapter 19, Server Configuration, in the documentation
for details\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name of a run\-time parameter\&amp;. Available parameters are documented in
Chapter 19, Server Configuration, in the documentation
and on the
\fBSET\fR(7)
reference page\&amp;. In addition, there are a few parameters that can be shown but not set:
.PP
SERVER_VERSION
.RS 4
Shows the server\*(Aqs version number\&amp;.
.RE
.PP
SERVER_ENCODING
.RS 4
Shows the server\-side character set encoding\&amp;. At present, this parameter can be shown but not set, because the encoding is determined at database creation time\&amp;.
.RE
.PP
LC_COLLATE
.RS 4
Shows the database\*(Aqs locale setting for collation (text ordering)\&amp;. At present, this parameter can be shown but not set, because the setting is determined at database creation time\&amp;.
.RE
.PP
LC_CTYPE
.RS 4
Shows the database\*(Aqs locale setting for character classification\&amp;. At present, this parameter can be shown but not set, because the setting is determined at database creation time\&amp;.
.RE
.PP
IS_SUPERUSER
.RS 4
True if the current role has superuser privileges\&amp;.
.RE
.RE
.PP
ALL
.RS 4
Show the values of all configuration parameters, with descriptions\&amp;.
.RE
.SH "NOTES"
.PP
The function
\fBcurrent_setting\fR
produces equivalent output; see
Section 9.26, \(lqSystem Administration Functions\(rq, in the documentation\&amp;. Also, the
pg_settings
system view produces the same information\&amp;.
.SH "EXAMPLES"
.PP
Show the current setting of the parameter
\fIDateStyle\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
SHOW DateStyle;
DateStyle
\-\-\-\-\-\-\-\-\-\-\-
ISO, MDY
(1 row)
.fi
.if n \{\
.RE
.\}
.PP
Show the current setting of the parameter
\fIgeqo\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
SHOW geqo;
geqo
\-\-\-\-\-\-
on
(1 row)
.fi
.if n \{\
.RE
.\}
.PP
Show all settings:
.sp
.if n \{\
.RS 4
.\}
.nf
SHOW ALL;
name         | setting |                description                                                          
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
allow_system_table_mods | off     | Allows modifications of the structure of \&amp;.\&amp;.\&amp;.
\&amp;.
\&amp;.
\&amp;.
xmloption               | content | Sets whether XML data in implicit parsing \&amp;.\&amp;.\&amp;.
zero_damaged_pages      | off     | Continues processing past damaged page headers\&amp;.
(196 rows)
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The
\fBSHOW\fR
command is a
PostgreSQL
extension\&amp;.
.SH "SEE ALSO"
\fBSET\fR(7), \fBRESET\fR(7)
'\" t
.\"     Title: START TRANSACTION
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "START TRANSACTION" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
START_TRANSACTION \- start a transaction block
.SH "SYNOPSIS"
.sp
.nf
START TRANSACTION [ \fItransaction_mode\fR [, \&amp;.\&amp;.\&amp;.] ]

where \fItransaction_mode\fR is one of:

ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }
READ WRITE | READ ONLY
[ NOT ] DEFERRABLE
.fi
.SH "DESCRIPTION"
.PP
This command begins a new transaction block\&amp;. If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if
SET TRANSACTION (\fBSET_TRANSACTION\fR(7))
was executed\&amp;. This is the same as the
\fBBEGIN\fR(7)
command\&amp;.
.SH "PARAMETERS"
.PP
Refer to
SET TRANSACTION (\fBSET_TRANSACTION\fR(7))
for information on the meaning of the parameters to this statement\&amp;.
.SH "COMPATIBILITY"
.PP
In the standard, it is not necessary to issue
\fBSTART TRANSACTION\fR
to start a transaction block: any SQL command implicitly begins a block\&amp;.
PostgreSQL\*(Aqs behavior can be seen as implicitly issuing a
\fBCOMMIT\fR
after each command that does not follow
\fBSTART TRANSACTION\fR
(or
\fBBEGIN\fR), and it is therefore often called
\(lqautocommit\(rq\&amp;. Other relational database systems might offer an autocommit feature as a convenience\&amp;.
.PP
The
DEFERRABLE\fItransaction_mode\fR
is a
PostgreSQL
language extension\&amp;.
.PP
The SQL standard requires commas between successive
\fItransaction_modes\fR, but for historical reasons
PostgreSQL
allows the commas to be omitted\&amp;.
.PP
See also the compatibility section of
SET TRANSACTION (\fBSET_TRANSACTION\fR(7))\&amp;.
.SH "SEE ALSO"
\fBBEGIN\fR(7), \fBCOMMIT\fR(7), \fBROLLBACK\fR(7), \fBSAVEPOINT\fR(7), SET TRANSACTION (\fBSET_TRANSACTION\fR(7))
.so man7/SELECT.7
'\" t
.\"     Title: TRUNCATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "TRUNCATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
TRUNCATE \- empty a table or set of tables
.SH "SYNOPSIS"
.sp
.nf
TRUNCATE [ TABLE ] [ ONLY ] \fIname\fR [ * ] [, \&amp;.\&amp;.\&amp;. ]
[ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]
.fi
.SH "DESCRIPTION"
.PP
\fBTRUNCATE\fR
quickly removes all rows from a set of tables\&amp;. It has the same effect as an unqualified
\fBDELETE\fR
on each table, but since it does not actually scan the tables it is faster\&amp;. Furthermore, it reclaims disk space immediately, rather than requiring a subsequent
\fBVACUUM\fR
operation\&amp;. This is most useful on large tables\&amp;.
.SH "PARAMETERS"
.PP
\fIname\fR
.RS 4
The name (optionally schema\-qualified) of a table to truncate\&amp;. If
ONLY
is specified before the table name, only that table is truncated\&amp;. If
ONLY
is not specified, the table and all its descendant tables (if any) are truncated\&amp;. Optionally,
*
can be specified after the table name to explicitly indicate that descendant tables are included\&amp;.
.RE
.PP
RESTART IDENTITY
.RS 4
Automatically restart sequences owned by columns of the truncated table(s)\&amp;.
.RE
.PP
CONTINUE IDENTITY
.RS 4
Do not change the values of sequences\&amp;. This is the default\&amp;.
.RE
.PP
CASCADE
.RS 4
Automatically truncate all tables that have foreign\-key references to any of the named tables, or to any tables added to the group due to
CASCADE\&amp;.
.RE
.PP
RESTRICT
.RS 4
Refuse to truncate if any of the tables have foreign\-key references from tables that are not listed in the command\&amp;. This is the default\&amp;.
.RE
.SH "NOTES"
.PP
You must have the
TRUNCATE
privilege on a table to truncate it\&amp;.
.PP
\fBTRUNCATE\fR
acquires an
ACCESS EXCLUSIVE
lock on each table it operates on, which blocks all other concurrent operations on the table\&amp;. When
RESTART IDENTITY
is specified, any sequences that are to be restarted are likewise locked exclusively\&amp;. If concurrent access to a table is required, then the
\fBDELETE\fR
command should be used instead\&amp;.
.PP
\fBTRUNCATE\fR
cannot be used on a table that has foreign\-key references from other tables, unless all such tables are also truncated in the same command\&amp;. Checking validity in such cases would require table scans, and the whole point is not to do one\&amp;. The
CASCADE
option can be used to automatically include all dependent tables \(em but be very careful when using this option, or else you might lose data you did not intend to!
.PP
\fBTRUNCATE\fR
will not fire any
ON DELETE
triggers that might exist for the tables\&amp;. But it will fire
ON TRUNCATE
triggers\&amp;. If
ON TRUNCATE
triggers are defined for any of the tables, then all
BEFORE TRUNCATE
triggers are fired before any truncation happens, and all
AFTER TRUNCATE
triggers are fired after the last truncation is performed and any sequences are reset\&amp;. The triggers will fire in the order that the tables are to be processed (first those listed in the command, and then any that were added due to cascading)\&amp;.
.PP
\fBTRUNCATE\fR
is not MVCC\-safe\&amp;. After truncation, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the truncation occurred\&amp;. See
Section 13.5, \(lqCaveats\(rq, in the documentation
for more details\&amp;.
.PP
\fBTRUNCATE\fR
is transaction\-safe with respect to the data in the tables: the truncation will be safely rolled back if the surrounding transaction does not commit\&amp;.
.PP
When
RESTART IDENTITY
is specified, the implied
\fBALTER SEQUENCE RESTART\fR
operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit\&amp;. This is unlike the normal behavior of
\fBALTER SEQUENCE RESTART\fR\&amp;. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on
\fBcurrval()\fR; that is, after the transaction
\fBcurrval()\fR
will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that\&amp;. This is similar to the usual behavior of
\fBcurrval()\fR
after a failed transaction\&amp;.
.PP
\fBTRUNCATE\fR
is not currently supported for foreign tables\&amp;. This implies that if a specified table has any descendant tables that are foreign, the command will fail\&amp;.
.SH "EXAMPLES"
.PP
Truncate the tables
bigtable
and
fattable:
.sp
.if n \{\
.RS 4
.\}
.nf
TRUNCATE bigtable, fattable;
.fi
.if n \{\
.RE
.\}
.PP
The same, and also reset any associated sequence generators:
.sp
.if n \{\
.RS 4
.\}
.nf
TRUNCATE bigtable, fattable RESTART IDENTITY;
.fi
.if n \{\
.RE
.\}
.PP
Truncate the table
othertable, and cascade to any tables that reference
othertable
via foreign\-key constraints:
.sp
.if n \{\
.RS 4
.\}
.nf
TRUNCATE othertable CASCADE;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
The SQL:2008 standard includes a
\fBTRUNCATE\fR
command with the syntax
TRUNCATE TABLE \fItablename\fR\&amp;. The clauses
CONTINUE IDENTITY/RESTART IDENTITY
also appear in that standard, but have slightly different though related meanings\&amp;. Some of the concurrency behavior of this command is left implementation\-defined by the standard, so the above notes should be considered and compared with other implementations if necessary\&amp;.
'\" t
.\"     Title: UNLISTEN
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "UNLISTEN" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
UNLISTEN \- stop listening for a notification
.SH "SYNOPSIS"
.sp
.nf
UNLISTEN { \fIchannel\fR | * }
.fi
.SH "DESCRIPTION"
.PP
\fBUNLISTEN\fR
is used to remove an existing registration for
\fBNOTIFY\fR
events\&amp;.
\fBUNLISTEN\fR
cancels any existing registration of the current
PostgreSQL
session as a listener on the notification channel named
\fIchannel\fR\&amp;. The special wildcard
*
cancels all listener registrations for the current session\&amp;.
.PP
\fBNOTIFY\fR(7)
contains a more extensive discussion of the use of
\fBLISTEN\fR
and
\fBNOTIFY\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIchannel\fR
.RS 4
Name of a notification channel (any identifier)\&amp;.
.RE
.PP
*
.RS 4
All current listen registrations for this session are cleared\&amp;.
.RE
.SH "NOTES"
.PP
You can unlisten something you were not listening for; no warning or error will appear\&amp;.
.PP
At the end of each session,
\fBUNLISTEN *\fR
is automatically executed\&amp;.
.PP
A transaction that has executed
\fBUNLISTEN\fR
cannot be prepared for two\-phase commit\&amp;.
.SH "EXAMPLES"
.PP
To make a registration:
.sp
.if n \{\
.RS 4
.\}
.nf
LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448\&amp;.
.fi
.if n \{\
.RE
.\}
.PP
Once
\fBUNLISTEN\fR
has been executed, further
\fBNOTIFY\fR
messages will be ignored:
.sp
.if n \{\
.RS 4
.\}
.nf
UNLISTEN virtual;
NOTIFY virtual;
\-\- no NOTIFY event is received
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBUNLISTEN\fR
command in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBLISTEN\fR(7), \fBNOTIFY\fR(7)
'\" t
.\"     Title: UPDATE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "UPDATE" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
UPDATE \- update rows of a table
.SH "SYNOPSIS"
.sp
.nf
[ WITH [ RECURSIVE ] \fIwith_query\fR [, \&amp;.\&amp;.\&amp;.] ]
UPDATE [ ONLY ] \fItable_name\fR [ * ] [ [ AS ] \fIalias\fR ]
SET { \fIcolumn_name\fR = { \fIexpression\fR | DEFAULT } |
( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) = ( { \fIexpression\fR | DEFAULT } [, \&amp;.\&amp;.\&amp;.] ) |
( \fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) = ( \fIsub\-SELECT\fR )
} [, \&amp;.\&amp;.\&amp;.]
[ FROM \fIfrom_list\fR ]
[ WHERE \fIcondition\fR | WHERE CURRENT OF \fIcursor_name\fR ]
[ RETURNING * | \fIoutput_expression\fR [ [ AS ] \fIoutput_name\fR ] [, \&amp;.\&amp;.\&amp;.] ]
.fi
.SH "DESCRIPTION"
.PP
\fBUPDATE\fR
changes the values of the specified columns in all rows that satisfy the condition\&amp;. Only the columns to be modified need be mentioned in the
SET
clause; columns not explicitly modified retain their previous values\&amp;.
.PP
There are two ways to modify a table using information contained in other tables in the database: using sub\-selects, or specifying additional tables in the
FROM
clause\&amp;. Which technique is more appropriate depends on the specific circumstances\&amp;.
.PP
The optional
RETURNING
clause causes
\fBUPDATE\fR
to compute and return value(s) based on each row actually updated\&amp;. Any expression using the table\*(Aqs columns, and/or columns of other tables mentioned in
FROM, can be computed\&amp;. The new (post\-update) values of the table\*(Aqs columns are used\&amp;. The syntax of the
RETURNING
list is identical to that of the output list of
\fBSELECT\fR\&amp;.
.PP
You must have the
UPDATE
privilege on the table, or at least on the column(s) that are listed to be updated\&amp;. You must also have the
SELECT
privilege on any column whose values are read in the
\fIexpressions\fR
or
\fIcondition\fR\&amp;.
.SH "PARAMETERS"
.PP
\fIwith_query\fR
.RS 4
The
WITH
clause allows you to specify one or more subqueries that can be referenced by name in the
\fBUPDATE\fR
query\&amp;. See
Section 7.8, \(lqWITH Queries (Common Table Expressions)\(rq, in the documentation
and
\fBSELECT\fR(7)
for details\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of the table to update\&amp;. If
ONLY
is specified before the table name, matching rows are updated in the named table only\&amp;. If
ONLY
is not specified, matching rows are also updated in any tables inheriting from the named table\&amp;. Optionally,
*
can be specified after the table name to explicitly indicate that descendant tables are included\&amp;.
.RE
.PP
\fIalias\fR
.RS 4
A substitute name for the target table\&amp;. When an alias is provided, it completely hides the actual name of the table\&amp;. For example, given
UPDATE foo AS f, the remainder of the
\fBUPDATE\fR
statement must refer to this table as
f
not
foo\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a column in the table named by
\fItable_name\fR\&amp;. The column name can be qualified with a subfield name or array subscript, if needed\&amp;. Do not include the table\*(Aqs name in the specification of a target column \(em for example,
UPDATE table_name SET table_name\&amp;.col = 1
is invalid\&amp;.
.RE
.PP
\fIexpression\fR
.RS 4
An expression to assign to the column\&amp;. The expression can use the old values of this and other columns in the table\&amp;.
.RE
.PP
DEFAULT
.RS 4
Set the column to its default value (which will be NULL if no specific default expression has been assigned to it)\&amp;.
.RE
.PP
\fIsub\-SELECT\fR
.RS 4
A
SELECT
sub\-query that produces as many output columns as are listed in the parenthesized column list preceding it\&amp;. The sub\-query must yield no more than one row when executed\&amp;. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns\&amp;. The sub\-query can refer to old values of the current row of the table being updated\&amp;.
.RE
.PP
\fIfrom_list\fR
.RS 4
A list of table expressions, allowing columns from other tables to appear in the
WHERE
condition and the update expressions\&amp;. This is similar to the list of tables that can be specified in the
FROM Clause
of a
\fBSELECT\fR
statement\&amp;. Note that the target table must not appear in the
\fIfrom_list\fR, unless you intend a self\-join (in which case it must appear with an alias in the
\fIfrom_list\fR)\&amp;.
.RE
.PP
\fIcondition\fR
.RS 4
An expression that returns a value of type
boolean\&amp;. Only rows for which this expression returns
true
will be updated\&amp;.
.RE
.PP
\fIcursor_name\fR
.RS 4
The name of the cursor to use in a
WHERE CURRENT OF
condition\&amp;. The row to be updated is the one most recently fetched from this cursor\&amp;. The cursor must be a non\-grouping query on the
\fBUPDATE\fR\*(Aqs target table\&amp;. Note that
WHERE CURRENT OF
cannot be specified together with a Boolean condition\&amp;. See
\fBDECLARE\fR(7)
for more information about using cursors with
WHERE CURRENT OF\&amp;.
.RE
.PP
\fIoutput_expression\fR
.RS 4
An expression to be computed and returned by the
\fBUPDATE\fR
command after each row is updated\&amp;. The expression can use any column names of the table named by
\fItable_name\fR
or table(s) listed in
FROM\&amp;. Write
*
to return all columns\&amp;.
.RE
.PP
\fIoutput_name\fR
.RS 4
A name to use for a returned column\&amp;.
.RE
.SH "OUTPUTS"
.PP
On successful completion, an
\fBUPDATE\fR
command returns a command tag of the form
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE \fIcount\fR
.fi
.if n \{\
.RE
.\}
.sp
The
\fIcount\fR
is the number of rows updated, including matched rows whose values did not change\&amp;. Note that the number may be less than the number of rows that matched the
\fIcondition\fR
when updates were suppressed by a
BEFORE UPDATE
trigger\&amp;. If
\fIcount\fR
is 0, no rows were updated by the query (this is not considered an error)\&amp;.
.PP
If the
\fBUPDATE\fR
command contains a
RETURNING
clause, the result will be similar to that of a
\fBSELECT\fR
statement containing the columns and values defined in the
RETURNING
list, computed over the row(s) updated by the command\&amp;.
.SH "NOTES"
.PP
When a
FROM
clause is present, what essentially happens is that the target table is joined to the tables mentioned in the
\fIfrom_list\fR, and each output row of the join represents an update operation for the target table\&amp;. When using
FROM
you should ensure that the join produces at most one output row for each row to be modified\&amp;. In other words, a target row shouldn\*(Aqt join to more than one row from the other table(s)\&amp;. If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable\&amp;.
.PP
Because of this indeterminacy, referencing other tables only within sub\-selects is safer, though often harder to read and slower than using a join\&amp;.
.SH "EXAMPLES"
.PP
Change the word
Drama
to
Dramatic
in the column
kind
of the table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE films SET kind = \*(AqDramatic\*(Aq WHERE kind = \*(AqDrama\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Adjust temperature entries and reset precipitation to its default value in one row of the table
weather:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT
WHERE city = \*(AqSan Francisco\*(Aq AND date = \*(Aq2003\-07\-03\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Perform the same operation and return the updated entries:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT
WHERE city = \*(AqSan Francisco\*(Aq AND date = \*(Aq2003\-07\-03\*(Aq
RETURNING temp_lo, temp_hi, prcp;
.fi
.if n \{\
.RE
.\}
.PP
Use the alternative column\-list syntax to do the same update:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE weather SET (temp_lo, temp_hi, prcp) = (temp_lo+1, temp_lo+15, DEFAULT)
WHERE city = \*(AqSan Francisco\*(Aq AND date = \*(Aq2003\-07\-03\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
Increment the sales count of the salesperson who manages the account for Acme Corporation, using the
FROM
clause syntax:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE employees SET sales_count = sales_count + 1 FROM accounts
WHERE accounts\&amp;.name = \*(AqAcme Corporation\*(Aq
AND employees\&amp;.id = accounts\&amp;.sales_person;
.fi
.if n \{\
.RE
.\}
.PP
Perform the same operation, using a sub\-select in the
WHERE
clause:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE employees SET sales_count = sales_count + 1 WHERE id =
(SELECT sales_person FROM accounts WHERE name = \*(AqAcme Corporation\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
Update contact names in an accounts table to match the currently assigned salesmen:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE accounts SET (contact_first_name, contact_last_name) =
(SELECT first_name, last_name FROM salesmen
WHERE salesmen\&amp;.id = accounts\&amp;.sales_id);
.fi
.if n \{\
.RE
.\}
.sp
A similar result could be accomplished with a join:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE accounts SET contact_first_name = first_name,
contact_last_name = last_name
FROM salesmen WHERE salesmen\&amp;.id = accounts\&amp;.sales_id;
.fi
.if n \{\
.RE
.\}
.sp
However, the second query may give unexpected results if
salesmen\&amp;.id
is not a unique key, whereas the first query is guaranteed to raise an error if there are multiple
id
matches\&amp;. Also, if there is no match for a particular
accounts\&amp;.sales_id
entry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all\&amp;.
.PP
Update statistics in a summary table to match the current data:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE summary s SET (sum_x, sum_y, avg_x, avg_y) =
(SELECT sum(x), sum(y), avg(x), avg(y) FROM data d
WHERE d\&amp;.group_id = s\&amp;.group_id);
.fi
.if n \{\
.RE
.\}
.PP
Attempt to insert a new stock item along with the quantity of stock\&amp;. If the item already exists, instead update the stock count of the existing item\&amp;. To do this without failing the entire transaction, use savepoints:
.sp
.if n \{\
.RS 4
.\}
.nf
BEGIN;
\-\- other operations
SAVEPOINT sp1;
INSERT INTO wines VALUES(\*(AqChateau Lafite 2003\*(Aq, \*(Aq24\*(Aq);
\-\- Assume the above fails because of a unique key violation,
\-\- so now we issue these commands:
ROLLBACK TO sp1;
UPDATE wines SET stock = stock + 24 WHERE winename = \*(AqChateau Lafite 2003\*(Aq;
\-\- continue with other operations, and eventually
COMMIT;
.fi
.if n \{\
.RE
.\}
.PP
Change the
kind
column of the table
films
in the row on which the cursor
c_films
is currently positioned:
.sp
.if n \{\
.RS 4
.\}
.nf
UPDATE films SET kind = \*(AqDramatic\*(Aq WHERE CURRENT OF c_films;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command conforms to the
SQL
standard, except that the
FROM
and
RETURNING
clauses are
PostgreSQL
extensions, as is the ability to use
WITH
with
\fBUPDATE\fR\&amp;.
.PP
Some other database systems offer a
FROM
option in which the target table is supposed to be listed again within
FROM\&amp;. That is not how
PostgreSQL
interprets
FROM\&amp;. Be careful when porting applications that use this extension\&amp;.
.PP
According to the standard, the source value for a parenthesized sub\-list of column names can be any row\-valued expression yielding the correct number of columns\&amp;.
PostgreSQL
only allows the source value to be a parenthesized list of expressions (a row constructor) or a sub\-SELECT\&amp;. An individual column\*(Aqs updated value can be specified as
DEFAULT
in the row\-constructor case, but not inside a sub\-SELECT\&amp;.
'\" t
.\"     Title: VACUUM
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "VACUUM" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
VACUUM \- garbage\-collect and optionally analyze a database
.SH "SYNOPSIS"
.sp
.nf
VACUUM [ ( { FULL | FREEZE | VERBOSE | ANALYZE | DISABLE_PAGE_SKIPPING } [, \&amp;.\&amp;.\&amp;.] ) ] [ \fItable_name\fR [ (\fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ \fItable_name\fR ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] ANALYZE [ \fItable_name\fR [ (\fIcolumn_name\fR [, \&amp;.\&amp;.\&amp;.] ) ] ]
.fi
.SH "DESCRIPTION"
.PP
\fBVACUUM\fR
reclaims storage occupied by dead tuples\&amp;. In normal
PostgreSQL
operation, tuples that are deleted or obsoleted by an update are not physically removed from their table; they remain present until a
\fBVACUUM\fR
is done\&amp;. Therefore it\*(Aqs necessary to do
\fBVACUUM\fR
periodically, especially on frequently\-updated tables\&amp;.
.PP
With no parameter,
\fBVACUUM\fR
processes every table in the current database that the current user has permission to vacuum\&amp;. With a parameter,
\fBVACUUM\fR
processes only that table\&amp;.
.PP
\fBVACUUM ANALYZE\fR
performs a
\fBVACUUM\fR
and then an
\fBANALYZE\fR
for each selected table\&amp;. This is a handy combination form for routine maintenance scripts\&amp;. See
\fBANALYZE\fR(7)
for more details about its processing\&amp;.
.PP
Plain
\fBVACUUM\fR
(without
FULL) simply reclaims space and makes it available for re\-use\&amp;. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained\&amp;. However, extra space is not returned to the operating system (in most cases); it\*(Aqs just kept available for re\-use within the same table\&amp;.
\fBVACUUM FULL\fR
rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system\&amp;. This form is much slower and requires an exclusive lock on each table while it is being processed\&amp;.
.PP
When the option list is surrounded by parentheses, the options can be written in any order\&amp;. Without parentheses, options must be specified in exactly the order shown above\&amp;. The parenthesized syntax was added in
PostgreSQL
9\&amp;.0; the unparenthesized syntax is deprecated\&amp;.
.SH "PARAMETERS"
.PP
FULL
.RS 4
Selects
\(lqfull\(rq
vacuum, which can reclaim more space, but takes much longer and exclusively locks the table\&amp;. This method also requires extra disk space, since it writes a new copy of the table and doesn\*(Aqt release the old copy until the operation is complete\&amp;. Usually this should only be used when a significant amount of space needs to be reclaimed from within the table\&amp;.
.RE
.PP
FREEZE
.RS 4
Selects aggressive
\(lqfreezing\(rq
of tuples\&amp;. Specifying
FREEZE
is equivalent to performing
\fBVACUUM\fR
with the
vacuum_freeze_min_age
and
vacuum_freeze_table_age
parameters set to zero\&amp;. Aggressive freezing is always performed when the table is rewritten, so this option is redundant when
FULL
is specified\&amp;.
.RE
.PP
VERBOSE
.RS 4
Prints a detailed vacuum activity report for each table\&amp;.
.RE
.PP
ANALYZE
.RS 4
Updates statistics used by the planner to determine the most efficient way to execute a query\&amp;.
.RE
.PP
DISABLE_PAGE_SKIPPING
.RS 4
Normally,
\fBVACUUM\fR
will skip pages based on the
visibility map\&amp;. Pages where all tuples are known to be frozen can always be skipped, and those where all tuples are known to be visible to all transactions may be skipped except when performing an aggressive vacuum\&amp;. Furthermore, except when performing an aggressive vacuum, some pages may be skipped in order to avoid waiting for other sessions to finish using them\&amp;. This option disables all page\-skipping behavior, and is intended to be used only the contents of the visibility map are thought to be suspect, which should happen only if there is a hardware or software issue causing database corruption\&amp;.
.RE
.PP
\fItable_name\fR
.RS 4
The name (optionally schema\-qualified) of a specific table to vacuum\&amp;. Defaults to all tables in the current database\&amp;.
.RE
.PP
\fIcolumn_name\fR
.RS 4
The name of a specific column to analyze\&amp;. Defaults to all columns\&amp;. If a column list is specified,
ANALYZE
is implied\&amp;.
.RE
.SH "OUTPUTS"
.PP
When
VERBOSE
is specified,
\fBVACUUM\fR
emits progress messages to indicate which table is currently being processed\&amp;. Various statistics about the tables are printed as well\&amp;.
.SH "NOTES"
.PP
To vacuum a table, one must ordinarily be the table\*(Aqs owner or a superuser\&amp;. However, database owners are allowed to vacuum all tables in their databases, except shared catalogs\&amp;. (The restriction for shared catalogs means that a true database\-wide
\fBVACUUM\fR
can only be performed by a superuser\&amp;.)
\fBVACUUM\fR
will skip over any tables that the calling user does not have permission to vacuum\&amp;.
.PP
\fBVACUUM\fR
cannot be executed inside a transaction block\&amp;.
.PP
For tables with
GIN
indexes,
\fBVACUUM\fR
(in any form) also completes any pending index insertions, by moving pending index entries to the appropriate places in the main
GIN
index structure\&amp;. See
Section 63.4.1, \(lqGIN Fast Update Technique\(rq, in the documentation
for details\&amp;.
.PP
We recommend that active production databases be vacuumed frequently (at least nightly), in order to remove dead rows\&amp;. After adding or deleting a large number of rows, it might be a good idea to issue a
\fBVACUUM ANALYZE\fR
command for the affected table\&amp;. This will update the system catalogs with the results of all recent changes, and allow the
PostgreSQL
query planner to make better choices in planning queries\&amp;.
.PP
The
\fBFULL\fR
option is not recommended for routine use, but might be useful in special cases\&amp;. An example is when you have deleted or updated most of the rows in a table and would like the table to physically shrink to occupy less disk space and allow faster table scans\&amp;.
\fBVACUUM FULL\fR
will usually shrink the table more than a plain
\fBVACUUM\fR
would\&amp;.
.PP
\fBVACUUM\fR
causes a substantial increase in I/O traffic, which might cause poor performance for other active sessions\&amp;. Therefore, it is sometimes advisable to use the cost\-based vacuum delay feature\&amp;. See
Section 19.4.4, \(lqCost-based Vacuum Delay\(rq, in the documentation
for details\&amp;.
.PP
PostgreSQL
includes an
\(lqautovacuum\(rq
facility which can automate routine vacuum maintenance\&amp;. For more information about automatic and manual vacuuming, see
Section 24.1, \(lqRoutine Vacuuming\(rq, in the documentation\&amp;.
.SH "EXAMPLES"
.PP
The following is an example from running
\fBVACUUM\fR
on a table in the regression database:
.sp
.if n \{\
.RS 4
.\}
.nf
regression=# VACUUM (VERBOSE, ANALYZE) onek;
INFO:  vacuuming "public\&amp;.onek"
INFO:  index "onek_unique1" now contains 1000 tuples in 14 pages
DETAIL:  3000 index tuples were removed\&amp;.
0 index pages have been deleted, 0 are currently reusable\&amp;.
CPU 0\&amp;.01s/0\&amp;.08u sec elapsed 0\&amp;.18 sec\&amp;.
INFO:  index "onek_unique2" now contains 1000 tuples in 16 pages
DETAIL:  3000 index tuples were removed\&amp;.
0 index pages have been deleted, 0 are currently reusable\&amp;.
CPU 0\&amp;.00s/0\&amp;.07u sec elapsed 0\&amp;.23 sec\&amp;.
INFO:  index "onek_hundred" now contains 1000 tuples in 13 pages
DETAIL:  3000 index tuples were removed\&amp;.
0 index pages have been deleted, 0 are currently reusable\&amp;.
CPU 0\&amp;.01s/0\&amp;.08u sec elapsed 0\&amp;.17 sec\&amp;.
INFO:  index "onek_stringu1" now contains 1000 tuples in 48 pages
DETAIL:  3000 index tuples were removed\&amp;.
0 index pages have been deleted, 0 are currently reusable\&amp;.
CPU 0\&amp;.01s/0\&amp;.09u sec elapsed 0\&amp;.59 sec\&amp;.
INFO:  "onek": removed 3000 tuples in 108 pages
DETAIL:  CPU 0\&amp;.01s/0\&amp;.06u sec elapsed 0\&amp;.07 sec\&amp;.
INFO:  "onek": found 3000 removable, 1000 nonremovable tuples in 143 pages
DETAIL:  0 dead tuples cannot be removed yet\&amp;.
There were 0 unused item pointers\&amp;.
Skipped 0 pages due to buffer pins\&amp;.
0 pages are entirely empty\&amp;.
CPU 0\&amp;.07s/0\&amp;.39u sec elapsed 1\&amp;.56 sec\&amp;.
INFO:  analyzing "public\&amp;.onek"
INFO:  "onek": 36 pages, 1000 rows sampled, 1000 estimated total rows
VACUUM
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
There is no
\fBVACUUM\fR
statement in the SQL standard\&amp;.
.SH "SEE ALSO"
\fBvacuumdb\fR(1), Section 19.4.4, \(lqCost-based Vacuum Delay\(rq, in the documentation, Section 24.1.6, \(lqThe Autovacuum Daemon\(rq, in the documentation
'\" t
.\"     Title: VALUES
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.78.1 &lt;http://docbook.sf.net/&gt;
.\"      Date: 2016
.\"    Manual: PostgreSQL 9.6.1 Documentation
.\"    Source: PostgreSQL 9.6.1
.\"  Language: English
.\"
.TH "VALUES" "7" "2016" "PostgreSQL 9.6.1" "PostgreSQL 9.6.1 Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
VALUES \- compute a set of rows
.SH "SYNOPSIS"
.sp
.nf
VALUES ( \fIexpression\fR [, \&amp;.\&amp;.\&amp;.] ) [, \&amp;.\&amp;.\&amp;.]
[ ORDER BY \fIsort_expression\fR [ ASC | DESC | USING \fIoperator\fR ] [, \&amp;.\&amp;.\&amp;.] ]
[ LIMIT { \fIcount\fR | ALL } ]
[ OFFSET \fIstart\fR [ ROW | ROWS ] ]
[ FETCH { FIRST | NEXT } [ \fIcount\fR ] { ROW | ROWS } ONLY ]
.fi
.SH "DESCRIPTION"
.PP
\fBVALUES\fR
computes a row value or set of row values specified by value expressions\&amp;. It is most commonly used to generate a
\(lqconstant table\(rq
within a larger command, but it can be used on its own\&amp;.
.PP
When more than one row is specified, all the rows must have the same number of elements\&amp;. The data types of the resulting table\*(Aqs columns are determined by combining the explicit or inferred types of the expressions appearing in that column, using the same rules as for
UNION
(see
Section 10.5, \(lqUNION, CASE, and Related Constructs\(rq, in the documentation)\&amp;.
.PP
Within larger commands,
\fBVALUES\fR
is syntactically allowed anywhere that
\fBSELECT\fR
is\&amp;. Because it is treated like a
\fBSELECT\fR
by the grammar, it is possible to use the
ORDER BY,
LIMIT
(or equivalently
FETCH FIRST), and
OFFSET
clauses with a
\fBVALUES\fR
command\&amp;.
.SH "PARAMETERS"
.PP
\fIexpression\fR
.RS 4
A constant or expression to compute and insert at the indicated place in the resulting table (set of rows)\&amp;. In a
\fBVALUES\fR
list appearing at the top level of an
\fBINSERT\fR, an
\fIexpression\fR
can be replaced by
DEFAULT
to indicate that the destination column\*(Aqs default value should be inserted\&amp;.
DEFAULT
cannot be used when
\fBVALUES\fR
appears in other contexts\&amp;.
.RE
.PP
\fIsort_expression\fR
.RS 4
An expression or integer constant indicating how to sort the result rows\&amp;. This expression can refer to the columns of the
\fBVALUES\fR
result as
column1,
column2, etc\&amp;. For more details see
ORDER BY Clause\&amp;.
.RE
.PP
\fIoperator\fR
.RS 4
A sorting operator\&amp;. For details see
ORDER BY Clause\&amp;.
.RE
.PP
\fIcount\fR
.RS 4
The maximum number of rows to return\&amp;. For details see
LIMIT Clause\&amp;.
.RE
.PP
\fIstart\fR
.RS 4
The number of rows to skip before starting to return rows\&amp;. For details see
LIMIT Clause\&amp;.
.RE
.SH "NOTES"
.PP
\fBVALUES\fR
lists with very large numbers of rows should be avoided, as you might encounter out\-of\-memory failures or poor performance\&amp;.
\fBVALUES\fR
appearing within
\fBINSERT\fR
is a special case (because the desired column types are known from the
\fBINSERT\fR\*(Aqs target table, and need not be inferred by scanning the
\fBVALUES\fR
list), so it can handle larger lists than are practical in other contexts\&amp;.
.SH "EXAMPLES"
.PP
A bare
\fBVALUES\fR
command:
.sp
.if n \{\
.RS 4
.\}
.nf
VALUES (1, \*(Aqone\*(Aq), (2, \*(Aqtwo\*(Aq), (3, \*(Aqthree\*(Aq);
.fi
.if n \{\
.RE
.\}
.sp
This will return a table of two columns and three rows\&amp;. It\*(Aqs effectively equivalent to:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT 1 AS column1, \*(Aqone\*(Aq AS column2
UNION ALL
SELECT 2, \*(Aqtwo\*(Aq
UNION ALL
SELECT 3, \*(Aqthree\*(Aq;
.fi
.if n \{\
.RE
.\}
.PP
More usually,
\fBVALUES\fR
is used within a larger SQL command\&amp;. The most common use is in
\fBINSERT\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO films (code, title, did, date_prod, kind)
VALUES (\*(AqT_601\*(Aq, \*(AqYojimbo\*(Aq, 106, \*(Aq1961\-06\-16\*(Aq, \*(AqDrama\*(Aq);
.fi
.if n \{\
.RE
.\}
.PP
In the context of
\fBINSERT\fR, entries of a
\fBVALUES\fR
list can be
DEFAULT
to indicate that the column default should be used here instead of specifying a value:
.sp
.if n \{\
.RS 4
.\}
.nf
INSERT INTO films VALUES
(\*(AqUA502\*(Aq, \*(AqBananas\*(Aq, 105, DEFAULT, \*(AqComedy\*(Aq, \*(Aq82 minutes\*(Aq),
(\*(AqT_601\*(Aq, \*(AqYojimbo\*(Aq, 106, DEFAULT, \*(AqDrama\*(Aq, DEFAULT);
.fi
.if n \{\
.RE
.\}
.PP
\fBVALUES\fR
can also be used where a sub\-\fBSELECT\fR
might be written, for example in a
FROM
clause:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT f\&amp;.*
FROM films f, (VALUES(\*(AqMGM\*(Aq, \*(AqHorror\*(Aq), (\*(AqUA\*(Aq, \*(AqSci\-Fi\*(Aq)) AS t (studio, kind)
WHERE f\&amp;.studio = t\&amp;.studio AND f\&amp;.kind = t\&amp;.kind;

UPDATE employees SET salary = salary * v\&amp;.increase
FROM (VALUES(1, 200000, 1\&amp;.2), (2, 400000, 1\&amp;.4)) AS v (depno, target, increase)
WHERE employees\&amp;.depno = v\&amp;.depno AND employees\&amp;.sales &gt;= v\&amp;.target;
.fi
.if n \{\
.RE
.\}
.sp
Note that an
AS
clause is required when
\fBVALUES\fR
is used in a
FROM
clause, just as is true for
\fBSELECT\fR\&amp;. It is not required that the
AS
clause specify names for all the columns, but it\*(Aqs good practice to do so\&amp;. (The default column names for
\fBVALUES\fR
are
column1,
column2, etc in
PostgreSQL, but these names might be different in other database systems\&amp;.)
.PP
When
\fBVALUES\fR
is used in
\fBINSERT\fR, the values are all automatically coerced to the data type of the corresponding destination column\&amp;. When it\*(Aqs used in other contexts, it might be necessary to specify the correct data type\&amp;. If the entries are all quoted literal constants, coercing the first is sufficient to determine the assumed type for all:
.sp
.if n \{\
.RS 4
.\}
.nf
SELECT * FROM machines
WHERE ip_address IN (VALUES(\*(Aq192\&amp;.168\&amp;.0\&amp;.1\*(Aq::inet), (\*(Aq192\&amp;.168\&amp;.0\&amp;.10\*(Aq), (\*(Aq192\&amp;.168\&amp;.1\&amp;.43\*(Aq));
.fi
.if n \{\
.RE
.\}
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBTip\fR
.ps -1
.br
.PP
For simple
IN
tests, it\*(Aqs better to rely on the
list-of-scalars
form of
IN
than to write a
\fBVALUES\fR
query as shown above\&amp;. The list of scalars method requires less writing and is often more efficient\&amp;.
.sp .5v
.RE
.SH "COMPATIBILITY"
.PP
\fBVALUES\fR
conforms to the SQL standard\&amp;.
LIMIT
and
OFFSET
are
PostgreSQL
extensions; see also under
\fBSELECT\fR(7)\&amp;.
.SH "SEE ALSO"
\fBINSERT\fR(7), \fBSELECT\fR(7)
.so man7/SELECT.7

</plainxml>
