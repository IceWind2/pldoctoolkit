<?xml version="1.0" encoding="utf-8" ?>
<plainxml>Zend Framework PHP Coding Standard Overview Scope 
                This document provides the code guidelines for developers
                and teams contributing to Zend Framework. The subjects covered are:

                 PHP File Formatting Naming Conventions Coding Style Inline Documentation 
             Goals 
                Good coding standards are important in any development project, but particularly
                when multiple developers are working on the same project. Having coding standards
                helps ensure that the code is of high quality, has fewer bugs, and is easily maintained.
             PHP File Formatting General 
                For files that contain only PHP code, the closing tag (&quot;?&gt;&quot;) is never permitted.  It is
                not required by PHP.  Not including it prevents trailing whitespace from being accidentally
                injected into the output.
             IMPORTANT:  Inclusion of arbitrary binary data as permitted by  __HALT_COMPILER() 
                is prohibited from any Zend framework PHP file or files derived from them. Use of
                this feature is only permitted for special installation scripts.
             Indentation Use an indent of 4 spaces, with no tabs. Maximum Line Length 
                The target line length is 80 characters, i.e. developers should aim keep code
                as close to the 80-column boundary as is practical. However, longer lines are
                acceptable. The maximum length of any line of PHP code is 120 characters.
             Line Termination 
                Line termination is the standard way for Unix text files. Lines must end only
                with a linefeed (LF). Linefeeds are represented as ordinal 10, or hexadecimal 0x0A.
             Do not use carriage returns (CR) like Macintosh computers (0x0D). 
                Do not use the carriage return/linefeed combination (CRLF) as Windows computers
                (0x0D, 0x0A).
             Naming Conventions Classes 
                The Zend Framework employs a class naming convention whereby the names
                of the classes directly map to the directories in which they are stored.
                The root level directory of the Zend Framework is the &quot;Zend/&quot; directory,
                under which all classes are stored hierarchially.
             
                Class names may only contain alphanumeric characters.   Numbers are permitted
                in class names but are discouraged.  Underscores are only permitted in place
                of the path separator -- the filename &quot;Zend/Db/Table.php&quot; must map to the
                class name &quot;Zend_Db_Table&quot;.
             
                If a class name is comprised of more than one word, the first letter of each new
                word must be capitalized.  Successive capitalized letters are not allowed, e.g.
                a class &quot;Zend_PDF&quot; is not allowed while &quot;Zend_Pdf&quot; is acceptable.
             
                Zend Framework classes that are authored by Zend or one of the participating
                partner companies and distributed with the Framework must always start with
                &quot;Zend_&quot; and must be stored under the &quot;Zend/&quot; directory hierarchy accordingly.
             
                These are examples of acceptable names for classes:

                 
Zend_Db

Zend_View

Zend_View_Helper
                 

                 IMPORTANT:  Code that operates with the framework but is not
                part of the framework, e.g. code written by a framework end-user and not Zend or
                one of the framework&#39;s partner companies, must never start with &quot;Zend_&quot;.
             Interfaces 
                Interface classes must follow the same conventions as other classes (see above),
                however must end with the word &quot;Interface&quot;, such as in these examples:

                 
Zend_Log_Adapter_Interface
Zend_Controller_Dispatcher_Interface
                 
             Filenames 
                For all other files, only alphanumeric characters, underscores, and the dash
                character (&quot;-&quot;) are permitted. Spaces are prohibited.
             
                Any file that contains any PHP code must end with the extension &quot;.php&quot;. These
                examples show the acceptable filenames for containing the class names from the
                examples in the section above:

                 
Zend/Db.php

Zend/Controller/Front.php

Zend/View/Helper/FormRadio.php
                 

                File names must follow the mapping to class names described above.
             Functions and Methods 
                Function names may only contain alphanumeric characters. Underscores are not permitted.
                Numbers are permitted in function names but are discouraged.
             
                Function names must always start with a lowercase letter. When a function name consists
                of more than one word, the first letter of each new word must be capitalized. This is
                commonly called &quot;camelCase&quot; formatting.
             
                Verbosity is encouraged. Function names should be as verbose as is practical to enhance the
                understandability of code.
             
                These are examples of acceptable names for functions:

                 
filterInput()

getElementById()

widgetFactory()
                 
             
                For object-oriented programming, accessors for objects should always be prefixed with
                either &quot;get&quot; or &quot;set&quot;. When using design patterns, such as the singleton or factory
                patterns, the name of the method should contain the pattern name where practical to
                make the pattern more readily recognizable.
             
                For methods on objects that are declared with the &quot;private&quot; or &quot;protected&quot; construct,
                the first character of the variable name must be a single underscore. This is the only
                acceptable usage of an underscore in a method name. Methods declared &quot;public&quot;
                may never start with an underscore.
             
                Functions in the global scope (&quot;floating functions&quot;) are permitted but discouraged.
                It is recommended that these functions should be wrapped in a static class.
             Variables 
                Variable names may only contain alphanumeric characters. Underscores are not permitted.
                Numbers are permitted in variable names but are discouraged.
             
                For class member variables that are declared with the &quot;private&quot; or &quot;protected&quot; construct,
                the first character of the variable name must be a single underscore. This is the only
                acceptable usage of an underscore in a variable name. Member variables declared &quot;public&quot;
                may never start with an underscore.
             
                Like function names (see section 3.3, above) variable names must always start with a
                lowercase letter and follow the &quot;camelCaps&quot; capitalization convention.
             
                Verbosity is encouraged. Variables should always be as verbose as practical. Terse variable
                names such as &quot;$i&quot; and &quot;$n&quot; are discouraged for anything other than the smallest loop contexts.
                If a loop contains more than 20 lines of code, the variables for the indices need to have more
                descriptive names.
             Constants 
                Constants may contain both alphanumeric characters and the underscore. Numbers are permitted
                in constant names.
             
                Constants must always have all letters capitalized.
             
                To enhance readablity, words in constant names must be separated by underscore characters. For
                example,  EMBED_SUPPRESS_EMBED_EXCEPTION  is permitted but
                 EMBED_SUPPRESSEMBEDEXCEPTION  is not.
             
                Constants must be defined as class members by using the &quot;const&quot; construct. Defining constants
                in the global scope with &quot;define&quot; is permitted but discouraged.
             Coding Style PHP Code Demarcation 
                PHP code must always be delimited by the full-form, standard PHP tags:

                 &lt;?php

?&gt; 
             
                Short tags are never allowed.  For files containing only PHP code, the
                closing tag must always be omitted (See  ).
             Strings String Literals 
                    When a string is literal (contains no variable substitutions), the apostrophe or
                    &quot;single quote&quot; must always used to demarcate the string:

                     
$a = &#39;Example String&#39;;
                     
                 String Literals Containing Apostrophes 
                    When a literal string itself contains apostrophes, it is permitted to demarcate
                    the string with quotation marks or &quot;double quotes&quot;. This is especially encouraged
                    for SQL statements:

                     
$sql = &quot;SELECT `id`, `name` from `people` WHERE `name`=&#39;Fred&#39; OR `name`=&#39;Susan&#39;&quot;;
                     

                    The above syntax is preferred over escaping apostrophes.
                 Variable Substitution 
                    Variable substitution is permitted using either of these two forms:

                     
$greeting = &quot;Hello $name, welcome back!&quot;;

$greeting = &quot;Hello {$name}, welcome back!&quot;;
                     
                 
                    For consistency, this form is not permitted:

                     
$greeting = &quot;Hello ${name}, welcome back!&quot;;
                     
                 String Concatenation 
                    Strings may be concatenated using the &quot;.&quot; operator. A space must always
                    be added before and after the &quot;.&quot; operator to improve readability:

                     
$company = &#39;Zend&#39; . &#39; &#39; . &#39;Technologies&#39;;
                     
                 
                    When concatenating strings with the &quot;.&quot; operator, it is permitted to
                    break the statement into multiple lines to improve readability. In these
                    cases, each successive line should be padded with whitespace such that the
                    &quot;.&quot;; operator is aligned under the &quot;=&quot; operator:

                     
$sql = &quot;SELECT `id`, `name` FROM `people` &quot;
     . &quot;WHERE `name` = &#39;Susan&#39; &quot;
     . &quot;ORDER BY `name` ASC &quot;;
                     
                 Arrays Numerically Indexed Arrays Negative numbers are not permitted as indices. 
                    An indexed array may be started with any non-negative number, however
                    this is discouraged and it is recommended that all arrays have a base index of 0.
                 
                    When declaring indexed arrays with the  array  construct, a trailing space must be
                    added after each comma delimiter to improve readability:

                     
$sampleArray = array(1, 2, 3, &#39;Zend&#39;, &#39;Studio&#39;);
                     
                 
                    It is also permitted to declare multiline indexed arrays using the &quot;array&quot; construct.
                    In this case, each successive line must be padded with spaces such that beginning of
                    each line aligns as shown below:

                     
$sampleArray = array(1, 2, 3, &#39;Zend&#39;, &#39;Studio&#39;,
                     $a, $b, $c,
                     56.44, $d, 500);
                     
                 Associative Arrays 
                    When declaring associative arrays with the  array  construct, it is encouraged
                    to break the statement into multiple lines. In this case, each successive line must be
                    padded with whitespace such that both the keys and the values are aligned:

                     
$sampleArray = array(&#39;firstKey&#39;  =&gt; &#39;firstValue&#39;,
                     &#39;secondKey&#39; =&gt; &#39;secondValue&#39;);
                     
                 Classes Class Declaration 
                    Classes must be named by following the naming conventions.
                 
                    The brace is always written on the line underneath the class name (&quot;one true brace&quot; form).
                 
                    Every class must have a documentation block that conforms to the PHPDocumentor standard.
                 
                    Any code within a class must be indented four spaces.
                 
                    Only one class is permitted per PHP file.
                 
                    Placing additional code in a class file is permitted but discouraged. In these files, two blank lines must separate the class from any additional PHP code in the file.
                 
                    This is an example of an acceptable class declaration:

                     
/**
 * Documentation Block Here
 */
class SampleClass
{
    // entire content of class
    // must be indented four spaces
}
                     
                 Class Member Variables 
                    Member variables must be named by following the variable naming conventions.
                 
                    Any variables declared in a class must be listed at the top of the class, prior
                    to declaring any methods.
                 
                    The  var  construct is not permitted.  Member variables always declare
                    their visibility by using one of the  private ,  protected ,
                    or  public  constructs. Accessing member variables directly by making
                    them public is permitted but discouraged in favor of accessor
                    methods (set/get).
                 Functions and Methods Function and Method Declaration 
                    Functions must be named by following the naming conventions.
                 
                    Methods inside classes must always declare their visibility by using
                    one of the  private ,  protected ,
                    or  public  constructs.
                 
                    Like classes, the brace is always written on the line underneath the
                    function name (&quot;one true brace&quot; form).

                    There is no space between the
                    function name and the opening parenthesis for the arguments.
                 
                    Functions in the global scope are strongly discouraged.
                 
                    This is an example of an acceptable function declaration in a class:

                     
/**
 * Documentation Block Here
 */
class Foo
{
    /**
     * Documentation Block Here
     */
    public function bar()
    {
        // entire content of function
        // must be indented four spaces
    }
}
                     
                 NOTE:  Pass-by-reference is permitted in the function declaration only:

                     
/**
 * Documentation Block Here
 */
class Foo
{
    /**
     * Documentation Block Here
     */
    public function bar(&amp;$baz)
    {}
}
                     
                 
                    Call-time pass-by-reference is prohibited.
                 
                    The return value must not be enclosed in parentheses.  This can hinder readability
                    and can also break code if a method is later changed to return by reference.

                     
/**
 * Documentation Block Here
 */
class Foo
{
    /**
     * WRONG
     */
    public function bar()
    {
        return($this-&gt;bar);
    }

    /**
     * RIGHT
     */
    public function bar()
    {
        return $this-&gt;bar;
    }
}
                     
                 Function and Method Usage 
                    Function arguments are separated
                    by a single trailing space after the comma delimiter. This is an example of an
                    acceptable function call for a function that takes three arguments:

                     
threeArguments(1, 2, 3);
                     
                 
                    Call-time pass-by-reference is prohibited. See the function declarations section
                    for the proper way to pass function arguments by-reference.
                 
                    For functions whose arguments permit arrays, the function call may include the
                    &quot;array&quot; construct and can be split into multiple lines to improve readability.  In
                    these cases, the standards for writing arrays still apply:

                     
threeArguments(array(1, 2, 3), 2, 3);

threeArguments(array(1, 2, 3, &#39;Zend&#39;, &#39;Studio&#39;,
                     $a, $b, $c,
                     56.44, $d, 500), 2, 3);
                     
                 Control Statements If / Else / Elseif 
                    Control statements based on the  if  and  elseif 
                    constructs must have a single space before the opening parenthesis of the conditional,
                    and a single space after the closing parenthesis.
                 
                    Within the conditional statements between the parentheses, operators must be separated
                    by spaces for readability. Inner parentheses are encouraged to improve logical grouping
                    of larger conditionals.
                 
                    The opening brace is written on the same line as the conditional statement. The closing
                    brace is always written on its own line. Any content within the braces must be
                    indented four spaces.

                     
if ($a != 2) {
    $a = 2;
}
                     
                 
                    For &quot;if&quot; statements that include &quot;elseif&quot; or &quot;else&quot;, the formatting conventions are as shown
                    in the following examples:

                     
if ($a != 2) {
    $a = 2;
} else {
   $a = 7;
}


if ($a != 2) {
    $a = 2;
} elseif ($a == 3) {
   $a = 4;
} else {
   $a = 7;
}
                     
                    PHP allows for these statements to be written without braces in some circumstances.
                    The coding standard makes no differentiation and all &quot;if&quot;, &quot;elseif&quot; or &quot;else&quot; statements
                    must use braces.
                 
                    Use of the &quot;elseif&quot; construct is permitted but highly discouraged in favor of the
                    &quot;else if&quot; combination.
                 Switch 
                    Control statements written with the &quot;switch&quot; construct must have a single space before
                    the opening parenthesis of the conditional statement, and also a single space after
                    the closing parenthesis.
                 
                    All content within the &quot;switch&quot; statement must be indented four spaces. Content under
                    each &quot;case&quot; statement must be indented an additional four spaces.
                 
switch ($numPeople) {
    case 1:
        break;

    case 2:
        break;

    default:
        break;
}
                 
                    The construct  default  may never be omitted from a  switch  statement.
                 NOTE:  It is sometimes useful to write a  case  statement which falls through
                    to the next case by not including a  break  or  return  in that case. To distinguish
                    these cases from bugs, any  case  statement where  break  or  return  are
                    omitted must contain the comment &quot;// break intentionally omitted&quot;.
                 Inline Documentation Documentation Format 
                    All documentation blocks (&quot;docblocks&quot;) must be compatible with the phpDocumentor format.
                    Describing the phpDocumentor format is beyond the scope of this document.
                    For more information, visit:  http://phpdoc.org/ 
                 
                    All source code files written for Zend Framework or that operate with the framework
                    must contain a &quot;file-level&quot; docblock at the top of each file and a &quot;class-level&quot; docblock
                    immediately above each class. Below are examples of such docblocks.
                 Files 
                    Every file that contains PHP code must have a header block at the top of the file that
                    contains these phpDocumentor tags at a minimum:

                     
/**
 * Short description for file
 *
 * Long description for file (if any)...
 *
 * LICENSE: Some license information
 *
 * @copyright  2005 Zend Technologies
 * @license    http://www.zend.com/license/3_0.txt   PHP License 3.0
 * @version    $Id:$
 * @link       http://dev.zend.com/package/PackageName
 * @since      File available since Release 1.2.0
*/
                     
                 Classes 
                    Every class must have a docblock that contains these phpDocumentor tags at a minimum:

                     
/**
 * Short description for class
 *
 * Long description for class (if any)...
 *
 * @copyright  2005 Zend Technologies
 * @license    http://www.zend.com/license/3_0.txt   PHP License 3.0
 * @version    Release: @package_version@
 * @link       http://dev.zend.com/package/PackageName
 * @since      Class available since Release 1.2.0
 * @deprecated Class deprecated in Release 2.0.0
 */
                     
                 Functions 
                Every function, including object methods, must have a docblock that contains at a minimum:

                     A description of the function All of the arguments All of the possible return values 
                 
                    It is not necessary to use the &quot;@access&quot; tag because the access level is already known
                    from the &quot;public&quot;, &quot;private&quot;, or &quot;protected&quot; construct used to declare the function.
                 
                    If a function/method may throw an exception, use @throws:

                     
@throws exceptionclass [description]
                     
                 Copyright Information 
        The following copyrights are applicable to portions of the Zend Framework.
     
        Copyright © 2005-  Zend Technologies Inc.
        ( )
     Installation 
        Zend Framework is built with object-oriented PHP 5 and requires PHP 5.1.4 or later. Please see the
         system requirements appendix  for more detailed information.
     
        Once an appropriate PHP environment is available, the next step is to get a copy of the Zend Framework, which
        may be officially obtained by any of the following methods:

         Download the latest stable release. 
                    This version, available in both  .zip  and  .tar.gz  formats, is a good
                    choice for those who are new to Zend Framework.
                 Download the latest nightly
                    snapshot.  For those who would brave the cutting edge, the nightly snapshots represent the
                    latest progress of Zend Framework development. Snapshots are bundled with documentation either in
                    English only or in all available languages. If you anticipate working with the latest Zend
                    Framework developments, consider using a Subversion (SVN) client.
                 
                    Using a  Subversion  (SVN) client. Zend Framework
                    is open source software, and the Subversion repository used for its development is publicly
                    available. Consider using SVN to get the Zend Framework if you already use SVN for your
                    application development, want to contribute back to the framework, or need to upgrade your
                    framework version more often than releases occur.
                 Exporting  is
                    useful if you want to get a particular framework revision without the  .svn 
                    directories as created in a working copy.
                 Checking out a
                    working copy  is good when you might contribute to Zend Framework, and a working copy can
                    be updated any time with
                     svn
                    update .
                 An externals
                    definition  is highly convenient for developers already using SVN to manage their
                    application working copies.
                 
                    The URL for the trunk of the Zend Framework SVN repository is:
                     http://framework.zend.com/svn/framework/trunk 
                 
     
        Once you have a copy of the Zend Framework available, your application needs to be able to access the
        framework classes. Though there are
         
        several ways to achieve this , your PHP
         include_path 
        needs to contain the path to the Zend Framework library.
     
        One of the Zend Framework&#39;s most useful features is its implementation of the
         Front Controller  and
         Model-View-Controller  (MVC)
        patterns.
         Get started with Zend Framework MVC! 
     
        Since Zend Framework components are rather loosely coupled, various components may be selected for
        independent use as needed. Each of the following chapters documents the use of a particular component.
     Overview 
        Zend Framework is a high quality and open source framework for developing Web
        Applications and Web Services with PHP.
     
        Built in the true PHP spirit, the Zend Framework delivers ease-of-use and
        powerful functionality. It provides solutions for building modern, robust, and
        secure websites.
     System Requirements 
        This section documents requirements for Zend Framework.
     PHP Version Required 
            Zend Framework requires PHP 5.1.4 or later.  Some SPL interfaces
            such as  Countable  were not stable in earlier versions
            of PHP.
         
            Zend Framework has an extensive collection of automated tests,
            which you can run using PHPUnit 3.0 or later.  This version of
            PHPUnit also requires PHP 5.1.4 or later.
         
            Although Zend Framework will function correctly with the PHP version
            mentioned above, you are strongly recommended to use PHP 5.2.3 or
            later.  There are important security and performance improvements
            available in the newer version of PHP.
         PHP Extensions 
            Below is a table that lists all extensions typically found in PHP,
            and how they are used in Zend Framework.  This can help guide you
            to know which extensions are required for your application.
            Not all extensions used by Zend Framework are required for every
            application.
         
            A usage type of &quot;Dependency&quot; means that the components or classes
            are not usable if the respective extension is not available.  A
            usage type of &quot;Optional&quot; means that if the extension is not
            available, the components or classes automatically fall back to
            use alternative code.
         PHP Extensions Used in Zend Framework Extension Usage Type Used by Zend Framework Components apc Dependency Zend_Cache_Backend_Apc bcmath Optional Zend_Locale_Math bitset Optional Zend_Search_Lucene bz2 -- calendar --- com_dotnet --- ctype Dependency Zend_Auth_Adapter_Http ,
                            Zend_Gdata_App ,
                            Zend_Http_Client ,
                            Zend_Pdf ,
                            Zend_Rest_Client ,
                            Zend_Rest_Server ,
                            Zend_Search_Lucene ,
                            Zend_Uri ,
                            Zend_Validate curl Dependency Zend_Http_Client_Adapter_Curl date --- dba --- dbase --- dom Dependency Zend_Feed ,
                             Zend_Gdata ,
                             Zend_Log_Formatter_Xml ,
                             Zend_Rest_Server ,
                             Zend_Search_Lucene ,
                             Zend_Service_Amazon ,
                             Zend_Service_Delicious ,
                             Zend_Service_Flickr ,
                             Zend_Service_Simpy ,
                             Zend_Service_Yahoo ,
                             Zend_XmlRpc exif --- fbsql --- fdf --- filter --- ftp --- gd Dependency Zend_Pdf gettext --- gmp --- hash Dependency Zend_Auth_Adapter_Http ibm_db2 Dependency Zend_Db_Adapter_Db2 iconv Dependency Zend_Locale_Format ,
                             Zend_Mime_Decode ,
                             Zend_Pdf ,
                             Zend_Search_Lucene ,
                             Zend_Service_Audioscrobbler ,
                             Zend_Service_Flickr ,
                             Zend_XmlRpc_Client imap --- informix --- interbase Dependency Zend_Db_Adapter_Firebird json Optional Zend_Json ldap --- libxml Dependency DOM ,
                             SimpleXML ,
                             XSLT mbstring Dependency Zend_Feed mcrypt --- memcache Dependency Zend_Cache_Backend_Memcached mhash --- mime_magic Dependency Zend_Http_Client ming --- msql --- mssql --- mysql --- mysqli Dependency Zend_Db_Adapter_Mysqli ncurses --- oci8 Dependency Zend_Db_Adapter_Oracle odbc --- openssl --- pcntl --- pcre Dependency Virtually all components pdo Dependency All PDO database adapters pdo_dblib --- pdo_firebird --- pdo_mssql Dependency Zend_Db_Adapter_Pdo_Mssql pdo_mysql Dependency Zend_Db_Adapter_Pdo_Mysql pdo_oci Dependency Zend_Db_Adapter_Pdo_Oci pdo_pgsql Dependency Zend_Db_Adapter_Pdo_Pgsql pdo_sqlite Dependency Zend_Db_Adapter_Pdo_Sqlite pgsql --- posix Optional Zend_Mail pspell --- readline --- recode --- Reflection Dependency Zend_Controller ,
                             Zend_Filter ,
                             Zend_Filter_Input ,
                             Zend_Json ,
                             Zend_Log ,
                             Zend_Rest_Server ,
                             Zend_Server_Reflection ,
                             Zend_Validate ,
                             Zend_View ,
                             Zend_XmlRpc_Server session Dependency Zend_Controller_Action_Helper_Redirector ,
                             Zend_Session shmop --- SimpleXML Dependency Zend_Config_Xml ,
                             Zend_Feed ,
                             Zend_Rest_Client ,
                             Zend_Service_Audioscrobbler ,
                             Zend_XmlRpc soap Dependency Zend_Service_StrikeIron sockets --- SPL Dependency Virtually all components SQLite Dependency Zend_Cache_Backend_Sqlite standard Dependency Virtually all components sybase --- sysvmsg --- sysvsem --- sysvshm --- tidy --- tokenizer --- wddx --- xml Dependency Zend_Translate_Adapter_Qt ,
                             Zend_Translate_Adapter_Tmx ,
                             Zend_Translate_Adapter_Xliff XMLReader --- xmlrpc --- XMLWriter --- xsl --- zip --- zlib Dependency Zend_Pdf ,
                             Memcache Zend Framework Components 
            Below is a table that lists all available Zend Framework Components
            and which PHP extension they need. This can help guide you
            to know which extensions are required for your application.
            Not all extensions used by Zend Framework are required for every
            application.
         Zend Framework Components and the PHP Extensions they use Zend Framework Components PHP Extension ( Subclass / Usage Type ) All Components pcre 
                            ( Dependency )
                             SPL 
                            ( Dependency )
                             standard 
                            ( Dependency )
                         Zend_Acl --- Zend_Auth ctype 
                            (  Zend_Auth_Adapter_Http  / Dependency )
                             hash 
                            (  Zend_Auth_Adapter_Http  / Dependency )
                         Zend_Cache apc 
                            (  Zend_Cache_Backend_Apc  / Dependency )
                             memcache 
                            (  Zend_Cache_Backend_Memcached  / Dependency )
                             sqlite 
                            (  Zend_Cache_Backend_Sqlite  / Dependency )
                             zlib 
                            (  Zend_Cache_Backend_Zlib  / Dependency )
                         Zend_Config libxml 
                            (  Zend_Config_Xml  / Dependency )
                             SimpleXML 
                            (  Zend_Config_Xml  / Dependency )
                         Zend_Console_Getopt --- Zend_Controller Reflection 
                            ( Dependency )
                             session 
                            (  Zend_Controller_Action_Helper_Redirector  / Dependency )
                         Zend_Date --- Zend_Db ibm_db2 
                            (  Zend_Db_Adapter_Db2  / Dependency )
                             mysqli 
                            (  Zend_Db_Adapter_Mysqli  / Dependency )
                             oci8 
                            (  Zend_Db_Adapter_Oracle  / Dependency )
                             pdo 
                            ( All PDO Adapters / Dependency )
                             pdo_mssql 
                            (  Zend_Db_Adapter_Pdo_Mssql  / Dependency )
                             pdo_mysql 
                            (  Zend_Db_Adapter_Pdo_Mysql  / Dependency )
                             pdo_oci 
                            (  Zend_Db_Adapter_Pdo_Oci  / Dependency )
                             pdo_pgsql 
                            (  Zend_Db_Adapter_Pdo_Pgsql  / Dependency )
                             pdo_sqlite 
                            (  Zend_Db_Adapter_Pdo_Sqlite  / Dependency )
                         Zend_Debug --- Zend_Exception --- Zend_Feed dom 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                             mbstring 
                            ( Dependency )
                             SimpleXML 
                            ( Dependency )
                         Zend_Filter Reflection 
                            ( Dependency )
                         Zend_Filter_Input Reflection 
                            ( Dependency )
                         Zend_Gdata ctype 
                            (  Zend_Gdata_App  / Dependency )
                             dom 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                         Zend_Http ctype 
                            (  Zend_Http_Client  / Dependency )
                             curl 
                            (  Zend_Http_Client_Adapter_Curl  / Dependency )
                             mime_magic 
                            (  Zend_Http_Client  / Dependency )
                         Zend_Json json 
                            ( Optional )
                             Reflection 
                            ( Dependency )
                         Zend_Loader --- Zend_Locale bcmath 
                            (  Zend_Locale_Math  / Optional )
                             iconv 
                            (  Zend_Locale_Format  / Dependency )
                         Zend_Log dom 
                            (  Zend_Log_Formatter_Xml  / Dependency )
                             libxml 
                            (  Zend_Log_Formatter_Xml  / Dependency )
                             Reflection 
                            ( Dependency )
                         Zend_Mail posix 
                            ( Optional )
                         Zend_Measure --- Zend_Memory --- Zend_Mime iconv 
                            (  Zend_Mime_Decode  / Dependency )
                         Zend_Pdf ctype 
                            ( Dependency )
                             gd 
                            ( Dependency )
                             iconv 
                            ( Dependency )
                             zlib 
                            ( Dependency )
                         Zend_Registry --- Zend_Request --- Zend_Rest ctype 
                            (  Zend_Rest_Client  / Dependency )
                            (  Zend_Rest_Server  / Dependency )
                             dom 
                            (  Zend_Rest_Server  / Dependency )
                             libxml 
                            (  Zend_Rest_Client  / Dependency )
                            (  Zend_Rest_Server  / Dependency )
                             Reflection 
                            (  Zend_Rest_Server  / Dependency )
                             SimpleXML 
                            (  Zend_Rest_Client  / Dependency )
                         Zend_Search_Lucene ctype 
                            ( Dependency )
                             bitset 
                            ( Optional )
                             dom 
                            ( Dependency )
                             iconv 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                         Zend_Server_Reflection Reflection 
                            ( Dependency )
                         Zend_Service_Akismet --- Zend_Service_Amazon dom 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                         Zend_Service_Audioscrobbler iconv 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                             SimpleXML 
                            ( Dependency )
                         Zend_Service_Delicious dom 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                         Zend_Service_Flickr dom 
                            ( Dependency )
                             iconv 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                         Zend_Service_Simpy dom 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                         Zend_Service_StrikeIron soap 
                            ( Dependency )
                         Zend_Service_Yahoo dom 
                            ( Dependency )
                             libxml 
                            ( Dependency )
                         Zend_Session session 
                            ( Dependency )
                         Zend_Translate xml 
                            (  Zend_Translate_Adapter_Qt  / Dependency )
                            (  Zend_Translate_Adapter_Tmx  / Dependency )
                            (  Zend_Translate_Adapter_Xliff  / Dependency )
                         Zend_Uri ctype 
                            ( Dependency )
                         Zend_Validate ctype 
                            ( Dependency )
                             Reflection 
                            ( Dependency )
                         Zend_Version --- Zend_View Reflection 
                            ( Dependency )
                         Zend_XmlRpc dom 
                            ( Dependency )
                             iconv 
                            (  Zend_XmlRpc_Client  / Dependency )
                             libxml 
                            ( Dependency )
                             Reflection 
                            (  Zend_XmlRpc_Server  / Dependency )
                             SimpleXML 
                            ( Dependency )
                         Advanced Use Storing ACL Data for Persistence 
        Zend_Acl was designed in such a way that it does not require any particular backend technology such
        as a database or cache server for storage of the ACL data. Its complete PHP implementation enables
        customized administration tools to be built upon Zend_Acl with relative ease and flexibility. Many
        situations require some form of interactive maintenance of the ACL, and Zend_Acl provides methods for
        setting up, and querying against, the access controls of an application.
         
        Storage of ACL data is therefore left as a task for the developer, since use cases are expected to
        vary widely for various situations. Because Zend_Acl is serializable, ACL objects may be serialized
        with PHP&#39;s  serialize()  function, and the
        results may be stored anywhere the developer should desire, such as a file, database, or caching
        mechanism.
         Writing Conditional ACL Rules with Assertions 
        Sometimes a rule for allowing or denying a Role access to a Resource should not be absolute but dependent
        upon various criteria. For example, suppose that certain access should be allowed, but only between the
        hours of 8:00am and 5:00pm. Another example would be denying access because a request comes from an
        IP address that has been flagged as a source of abuse. Zend_Acl has built-in support for implementing
        rules based on whatever conditions the developer needs.
         
        Zend_Acl provides support for conditional rules with  Zend_Acl_Assert_Interface . In order
        to use the rule assertion interface, a developer writes a class that implements the
         assert()  method of the interface:
         &lt;?php
require_once &#39;Zend/Acl/Assert/Interface.php&#39;;

class CleanIPAssertion implements Zend_Acl_Assert_Interface
{
    public function assert(Zend_Acl $acl, Zend_Acl_Role_Interface $role = null,
                           Zend_Acl_Resource_Interface $resource = null, $privilege = null)
    {
        return $this-&gt;_isCleanIP($_SERVER[&#39;REMOTE_ADDR&#39;]);
    }

    protected function _isCleanIP($ip)
    {
        // ...
    }
}
         
        Once an assertion class is available, the developer must supply an instance of the assertion class
        when assigning conditional rules. A rule that is created with an assertion only applies when the
        assertion method returns true.
         &lt;?php
require_once &#39;Zend/Acl.php&#39;;

$acl = new Zend_Acl();
$acl-&gt;allow(null, null, null, new CleanIPAssertion());
         
        The above code creates a conditional allow rule that allows access to all privileges on everything
        by everyone, except when the requesting IP is &quot;blacklisted.&quot; If a request comes in from an IP that
        is not considered &quot;clean,&quot; then the allow rule does not apply. Since the rule applies to all Roles,
        all Resources, and all privileges, an &quot;unclean&quot; IP would result in a denial of access. This is a special
        case, however, and it should be understood that in all other cases (i.e., where a specific Role,
        Resource, or privilege is specified for the rule), a failed assertion results in the rule not applying,
        and other rules would be used to determine whether access is allowed or denied.
         
        The  assert()  method of an assertion object is passed the ACL, Role, Resource, and privilege
        to which the authorization query (i.e.,  isAllowed() ) applies, in order to provide
        a context for the assertion class to determine its conditions where needed.
         Refining Access Controls Precise Access Controls 
        The basic ACL as defined in the  previous section  shows
        how various privileges may be allowed upon the entire ACL (all Resources). In practice, however, access
        controls tend to have exceptions and varying degrees of complexity. Zend_Acl allows to you accomplish
        these refinements in a straightforward and flexible manner.
         
        For the example CMS, it has been determined that whilst the &#39;staff&#39; group covers the needs of the
        vast majority of users, there is a need for a new &#39;marketing&#39; group that requires access to the
        newsletter and latest news in the CMS. The group is fairly self-sufficient and will have the ability
        to publish and archive both newsletters and the latest news.
         
        In addition, it has also been requested that the &#39;staff&#39; group be allowed to view news stories but
        not to revise the latest news. Finally, it should be impossible for anyone (administrators included)
        to archive any &#39;announcement&#39; news stories since they only have a lifespan of 1-2 days.
         
        First we revise the Role registry to reflect these changes. We have determined that the &#39;marketing&#39;
        group has the same basic permissions as &#39;staff&#39;, so we define &#39;marketing&#39; in such a way that it
        inherits permissions from &#39;staff&#39;:
         &lt;?php
// The new marketing group inherits permissions from staff
$acl-&gt;addRole(new Zend_Acl_Role(&#39;marketing&#39;), &#39;staff&#39;);
         
        Next, note that the above access controls refer to specific Resources (e.g., &quot;newsletter&quot;, &quot;latest news&quot;, &quot;announcement news&quot;). Now we add these Resources:
         &lt;?php
// Create Resources for the rules
require_once &#39;Zend/Acl/Resource.php&#39;;
$acl-&gt;add(new Zend_Acl_Resource(&#39;newsletter&#39;));           // newsletter
$acl-&gt;add(new Zend_Acl_Resource(&#39;news&#39;));                 // news
$acl-&gt;add(new Zend_Acl_Resource(&#39;latest&#39;), &#39;news&#39;);       // latest news
$acl-&gt;add(new Zend_Acl_Resource(&#39;announcement&#39;), &#39;news&#39;); // announcement news
         
        Then it is simply a matter of defining these more specific rules on the target areas of the ACL:
         &lt;?php
// Marketing must be able to publish and archive newsletters and the latest news
$acl-&gt;allow(&#39;marketing&#39;, array(&#39;newsletter&#39;, &#39;latest&#39;), array(&#39;publish&#39;, &#39;archive&#39;));

// Staff (and marketing, by inheritance), are denied permission to revise the latest news
$acl-&gt;deny(&#39;staff&#39;, &#39;latest&#39;, &#39;revise&#39;);

// Everyone (including administrators) are denied permission to archive news announcements
$acl-&gt;deny(null, &#39;announcement&#39;, &#39;archive&#39;);
         
        We can now query the ACL with respect to the latest changes:
         &lt;?php
echo $acl-&gt;isAllowed(&#39;staff&#39;, &#39;newsletter&#39;, &#39;publish&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;newsletter&#39;, &#39;publish&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed

echo $acl-&gt;isAllowed(&#39;staff&#39;, &#39;latest&#39;, &#39;publish&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;latest&#39;, &#39;publish&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;latest&#39;, &#39;archive&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;latest&#39;, &#39;revise&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied

echo $acl-&gt;isAllowed(&#39;editor&#39;, &#39;announcement&#39;, &#39;archive&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied

echo $acl-&gt;isAllowed(&#39;administrator&#39;, &#39;announcement&#39;, &#39;archive&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied
         Removing Access Controls 
        To remove one or more access rules from the ACL, simply use the available  removeAllow() 
        or  removeDeny()  methods. As with  allow()  and  deny() , you may
        provide a  null  value to indicate application to all Roles, Resources, and/or privileges:
         &lt;?php
// Remove the denial of revising latest news to staff (and marketing, by inheritance)
$acl-&gt;removeDeny(&#39;staff&#39;, &#39;latest&#39;, &#39;revise&#39;);

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;latest&#39;, &#39;revise&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed

// Remove the allowance of publishing and archiving newsletters to marketing
$acl-&gt;removeAllow(&#39;marketing&#39;, &#39;newsletter&#39;, array(&#39;publish&#39;, &#39;archive&#39;));

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;newsletter&#39;, &#39;publish&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;newsletter&#39;, &#39;archive&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied
         
        Privileges may be modified incrementally as indicated above, but a  null  value for the
        privileges overrides such incremental changes:
         &lt;?php
// Allow marketing all permissions upon the latest news
$acl-&gt;allow(&#39;marketing&#39;, &#39;latest&#39;);

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;latest&#39;, &#39;publish&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;latest&#39;, &#39;archive&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed

echo $acl-&gt;isAllowed(&#39;marketing&#39;, &#39;latest&#39;, &#39;anything&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed
         Introduction 
        Zend_Acl provides lightweight and flexible access control list (ACL) functionality
        and privileges management. In general, an application may utilize such functionality
        to control access to certain protected objects by other requesting objects.
     
        For the purposes of this documentation,

         
                    a  Resource  is an object
                    to which access is controlled.
                 
                    a  Role  is an object
                    that may request access to a Resource.
                 

        Put simply,  Roles request access to Resources .
        For example, if a person requests access to a car, then the person is the requesting Role,
        and the car is the Resource, since access to the car is under control.
     
        Through the specification and use of an access control list (ACL), an application may control
        how requesting objects (Roles) are granted access to protected objects (Resources).
     About Resources 
            In Zend_Acl, creating a Resource is very simple. Zend_Acl provides
             Zend_Acl_Resource_Interface  to facilitate developers&#39; creating Resources. A class need only
            implement this interface, which consists of a single method,  getResourceId() , in order
            for Zend_Acl to consider the object to be a Resource. Additionally,  Zend_Acl_Resource  is
            included with Zend_Acl as a basic Resource implementation for developers to extend where desirable.
         
            Zend_Acl provides a tree structure to which multiple Resources (or &quot;areas under access control&quot;)
            can be added. Since Resources are stored in such a tree structure, they can be organized from the
            general (toward the tree root) to the specific (toward the tree leaves). Queries upon
            a specific Resource will automatically search the Resource&#39;s hierarchy for rules assigned to ancestor
            Resources, allowing for simple inheritance of rules. For example, if a default rule is to be
            applied to each building in a city, one would simply assign the rule to the city, instead of
            assigning the same rule to each building. Some buildings may require exceptions to such a
            rule, however, and this is achieved easily in Zend_Acl by assigning such exception rules to
            each such building that requires an exception to the rule. A Resource may inherit from only one
            parent Resource, though this parent Resource can have its own parent Resource, and so on.
         
            Zend_Acl also supports privileges upon Resources (e.g., &quot;create&quot;, &quot;read&quot;, &quot;update&quot;, &quot;delete&quot;), and
            the developer can assign rules that affect all privileges or specific privileges upon a Resource.
         About Roles 
            Like with Resources, creating a Role is also very simple. Zend_Acl provides
             Zend_Acl_Role_Interface  to facilitate developers&#39; creating Roles. A class need only
            implement this interface, which consists of a single method,  getRoleId() , in order
            for Zend_Acl to consider the object to be a Role. Additionally,  Zend_Acl_Role  is
            included with Zend_Acl as a basic Role implementation for developers to extend where desirable.
         
            In Zend_Acl, a Role may inherit from one or more Roles. This is to support inheritance of rules
            among Roles. For example, a user Role, such as &quot;sally&quot;, may belong to one or more parent Roles,
            such as &quot;editor&quot; and &quot;administrator&quot;. The developer can assign rules to &quot;editor&quot; and
            &quot;administrator&quot; separately, and &quot;sally&quot; would inherit such rules from both, without having to
            assign rules directly to &quot;sally&quot;.
         
            Though the ability to inherit from multiple Roles is very useful, multiple inheritance also
            introduces some degree of complexity. The following example illustrates the ambiguity condition and how
            Zend_Acl solves it.
         Multiple inheritance between Roles 
                The following code defines three base Roles - &quot; guest &quot;, &quot; member &quot;, and
                &quot; admin &quot; - from which other Roles may inherit. Then, a Role identified by
                &quot; someUser &quot; is established and inherits from the three other Roles. The order in
                which these Roles appear in the  $parents  array is important. When necessary,
                Zend_Acl searches for access rules defined not only for the queried Role (herein,
                &quot; someUser &quot;), but also upon the Roles from which the queried Role inherits
                (herein, &quot; guest &quot;, &quot; member &quot;, and &quot; admin &quot;):
             &lt;?php
require_once &#39;Zend/Acl.php&#39;;
$acl = new Zend_Acl();

require_once &#39;Zend/Acl/Role.php&#39;;
$acl-&gt;addRole(new Zend_Acl_Role(&#39;guest&#39;))
    -&gt;addRole(new Zend_Acl_Role(&#39;member&#39;))
    -&gt;addRole(new Zend_Acl_Role(&#39;admin&#39;));

$parents = array(&#39;guest&#39;, &#39;member&#39;, &#39;admin&#39;);
$acl-&gt;addRole(new Zend_Acl_Role(&#39;someUser&#39;), $parents);

require_once &#39;Zend/Acl/Resource.php&#39;;
$acl-&gt;add(new Zend_Acl_Resource(&#39;someResource&#39;));

$acl-&gt;deny(&#39;guest&#39;, &#39;someResource&#39;);
$acl-&gt;allow(&#39;member&#39;, &#39;someResource&#39;);

echo $acl-&gt;isAllowed(&#39;someUser&#39;, &#39;someResource&#39;) ? &#39;allowed&#39; : &#39;denied&#39;;
             
                Since there is no rule specifically defined for the &quot; someUser &quot; Role and
                &quot; someResource &quot;, Zend_Acl must search for rules that may be defined for Roles that
                &quot; someUser &quot; inherits. First, the &quot; admin &quot; role is visited, and there
                is no access rule defined for it. Next, the &quot; member &quot; role is visited, and
                Zend_Acl finds that there is a rule specifying that &quot; member &quot; is allowed access to
                &quot; someResource &quot;.
             
                If Zend_Acl were to continue examining the rules defined for other parent Roles, however, it
                would find that &quot; guest &quot; is denied access to &quot; someResource &quot;. This
                fact introduces an ambiguity because now &quot; someUser &quot; is both denied and allowed
                access to &quot; someResource &quot;, by reason of having inherited conflicting rules from
                different parent Roles.
             
                Zend_Acl resolves this ambiguity by completing a query when it finds the first rule that is
                directly applicable to the query. In this case, since the &quot; member &quot; Role is
                examined before the &quot; guest &quot; Role, the example code would print
                &quot; allowed &quot;.
             
                When specifying multiple parents for a Role, keep in mind that the last parent listed is the
                first one searched for rules applicable to an authorization query.
             Creating the Access Control List (ACL) 
            An ACL can represent any set of physical or virtual objects that you wish.
            For the purposes of demonstration, however, we will create a basic Content Management System ACL
            that maintains several tiers of groups over a wide variety of areas. To create a new ACL object,
            we instantiate the ACL with no parameters:
         &lt;?php
require_once &#39;Zend/Acl.php&#39;;

$acl = new Zend_Acl();
         
                Until a developer specifies an &quot;allow&quot; rule, Zend_Acl denies access to every privilege upon every
                Resource by every Role.
             Registering Roles 
            Content Management Systems will nearly always require a hierarchy of permissions
            to determine the authoring capabilities of its users. There may be a &#39;Guest&#39; group to
            allow limited access for demonstrations, a &#39;Staff&#39; group for the majority of CMS users
            who perform most of the day-to-day operations, an &#39;Editor&#39; group for those responsible for publishing,
            reviewing, archiving and deleting content, and finally an &#39;Administrator&#39; group whose tasks may
            include all of those of the other groups as well as maintenance of sensitive information,
            user management, back-end configuration data and backup/export. This set of permissions can be
            represented in a Role registry, allowing each group to inherit privileges from &#39;parent&#39; groups,
            as well as providing distinct privileges for their unique group only.
            The permissions may be expressed as follows:
         Access Controls for an Example CMS Name Unique permissions Inherit permissions from Guest View N/A Staff Edit, Submit, Revise Guest Editor Publish, Archive, Delete Staff Administrator (Granted all access) N/A 
            For this example,  Zend_Acl_Role  is used, but any object that implements
             Zend_Acl_Role_Interface  is acceptable. These groups can be added to the
            Role registry as follows:
         &lt;?php
require_once &#39;Zend/Acl.php&#39;;

$acl = new Zend_Acl();

// Add groups to the Role registry using Zend_Acl_Role
require_once &#39;Zend/Acl/Role.php&#39;;

// Guest does not inherit access controls
$roleGuest = new Zend_Acl_Role(&#39;guest&#39;);
$acl-&gt;addRole($roleGuest);

// Staff inherits from guest
$acl-&gt;addRole(new Zend_Acl_Role(&#39;staff&#39;), $roleGuest);

/* alternatively, the above could be written:
$acl-&gt;addRole(new Zend_Acl_Role(&#39;staff&#39;), &#39;guest&#39;);
//*/

// Editor inherits from staff
$acl-&gt;addRole(new Zend_Acl_Role(&#39;editor&#39;), &#39;staff&#39;);

// Administrator does not inherit access controls
$acl-&gt;addRole(new Zend_Acl_Role(&#39;administrator&#39;));
         Defining Access Controls 
            Now that the ACL contains the relevant Roles, rules can be established that define how
            Resources may be accessed by Roles. You may have noticed that we have not defined any particular
            Resources for this example, which is simplified to illustrate that the rules apply to all Resources.
            Zend_Acl provides an implementation whereby rules need only be assigned from general to specific,
            minimizing the number of rules needed, because Resources and Roles inherit rules that are defined upon
            their ancestors.
         
                In general, Zend_Acl obeys a given rule if and only if a more specific rule does not apply.
             
            Consequently, we can define a reasonably complex set of rules with a minimum amount of code.
            To apply the base permissions as defined above:
         &lt;?php
require_once &#39;Zend/Acl.php&#39;;

$acl = new Zend_Acl();

require_once &#39;Zend/Acl/Role.php&#39;;

$roleGuest = new Zend_Acl_Role(&#39;guest&#39;);
$acl-&gt;addRole($roleGuest);
$acl-&gt;addRole(new Zend_Acl_Role(&#39;staff&#39;), $roleGuest);
$acl-&gt;addRole(new Zend_Acl_Role(&#39;editor&#39;), &#39;staff&#39;);
$acl-&gt;addRole(new Zend_Acl_Role(&#39;administrator&#39;));

// Guest may only view content
$acl-&gt;allow($roleGuest, null, &#39;view&#39;);

/* alternatively, the above could be written:
$acl-&gt;allow(&#39;guest&#39;, null, &#39;view&#39;);
//*/

// Staff inherits view privilege from guest, but also needs additional privileges
$acl-&gt;allow(&#39;staff&#39;, null, array(&#39;edit&#39;, &#39;submit&#39;, &#39;revise&#39;));

// Editor inherits view, edit, submit, and revise privileges from staff,
// but also needs additional privileges
$acl-&gt;allow(&#39;editor&#39;, null, array(&#39;publish&#39;, &#39;archive&#39;, &#39;delete&#39;));

// Administrator inherits nothing, but is allowed all privileges
$acl-&gt;allow(&#39;administrator&#39;);
         
            The  null  values in the above  allow()  calls are used to indicate
            that the allow rules apply to all Resources.
         Querying the ACL 
            We now have a flexible ACL that can be used to determine whether requesters have permission
            to perform functions throughout the web application. Performing queries is quite simple using
            the  isAllowed()  method:
         &lt;?php
echo $acl-&gt;isAllowed(&#39;guest&#39;, null, &#39;view&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed

echo $acl-&gt;isAllowed(&#39;staff&#39;, null, &#39;publish&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied

echo $acl-&gt;isAllowed(&#39;staff&#39;, null, &#39;revise&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed

echo $acl-&gt;isAllowed(&#39;editor&#39;, null, &#39;view&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed because of inheritance from guest

echo $acl-&gt;isAllowed(&#39;editor&#39;, null, &#39;update&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // denied because no allow rule for &#39;update&#39;

echo $acl-&gt;isAllowed(&#39;administrator&#39;, null, &#39;view&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed because administrator is allowed all privileges

echo $acl-&gt;isAllowed(&#39;administrator&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed because administrator is allowed all privileges

echo $acl-&gt;isAllowed(&#39;administrator&#39;, null, &#39;update&#39;) ?
     &quot;allowed&quot; : &quot;denied&quot;; // allowed because administrator is allowed all privileges
         Introduction 
        Zend_Auth provides an API for authentication and includes concrete authentication adapters for
        common use case scenarios.
     
        Zend_Auth is concerned only with  authentication  and not with
         authorization . Authentication is loosely defined as determining
        whether an entity actually is what it purports to be (i.e., identification), based on some set of
        credentials. Authorization, the process of deciding whether to allow an entity access to, or to
        perform operations upon, other entities is outside the scope of Zend_Auth. For more information about
        authorization and access control with the Zend Framework, please see
         Zend_Acl .
     
            The  Zend_Auth  class implements the Singleton pattern - only one instance of the class is
            available - through its static  getInstance()  method. This means that using the  new 
            operator and the  clone  keyword will not work with the  Zend_Auth  class; use
             Zend_Auth::getInstance()  instead.
         Adapters 
            A Zend_Auth adapter is used to authenticate against a particular type of authentication service,
            such as LDAP, RDBMS, or file-based storage. Different adapters are likely to have vastly different
            options and behaviors, but some basic things are common among authentication adapters. For example,
            accepting authentication credentials (including a purported identity), performing queries against the
            authentication service, and returning results are common to Zend_Auth adapters.
         
            Each Zend_Auth adapter class implements  Zend_Auth_Adapter_Interface . This interface defines one
            method,  authenticate() , that an adapter class must implement for performing an authentication
            query. Each adapter class must be prepared prior to calling  authenticate() . Such adapter
            preparation includes setting up credentials (e.g., username and password) and defining values for adapter-
            specific configuration options, such as database connection settings for a database table adapter.
         
            The following is an example authentication adapter that requires a username and password to be set
            for authentication. Other details, such as how the authentication service is queried, have been
            omitted for brevity:

             &lt;?php
require_once &#39;Zend/Auth/Adapter/Interface.php&#39;;

class MyAuthAdapter implements Zend_Auth_Adapter_Interface
{
    /**
     * Sets username and password for authentication
     *
     * @return void
     */
    public function __construct($username, $password)
    {
        // ...
    }

    /**
     * Performs an authentication attempt
     *
     * @throws Zend_Auth_Adapter_Exception If authentication cannot be performed
     * @return Zend_Auth_Result
     */
    public function authenticate()
    {
        // ...
    }
}
             

            As indicated in its docblock,  authenticate()  must return an instance of
             Zend_Auth_Result  (or of a class derived from  Zend_Auth_Result ). If for some
            reason performing an authentication query is impossible,  authenticate()  should throw
            an exception that derives from  Zend_Auth_Adapter_Exception .
         Results 
            Zend_Auth adapters return an instance of  Zend_Auth_Result  with
             authenticate()  in order to represent the results of an authentication attempt. Adapters
            populate the  Zend_Auth_Result  object upon construction, so that the following four methods
            provide a basic set of user-facing operations that are common to the results of Zend_Auth adapters:
             isValid()  - returns true if and only if the result represents a
                        successful authentication attempt
                     getCode()  - returns a  Zend_Auth_Result  constant identifier for
                        determining the type of authentication failure or whether success has occurred. This may be
                        used in situations where the developer wishes to distinguish among several authentication
                        result types. This allows developers to maintain detailed authentication result statistics,
                        for example. Another use of this feature is to provide specific, customized messages to
                        users for usability reasons, though developers are encouraged to consider the risks of
                        providing such detailed reasons to users, instead of a general authentication failure
                        message. For more information, see the notes below.
                     getIdentity()  - returns the identity of the authentication attempt
                     getMessages()  - returns an array of messages regarding a failed
                        authentication attempt
                     
         
            A developer may wish to branch based on the type of authentication result in order to perform more
            specific operations. Some operations developers might find useful are locking accounts after too many
            unsuccessful password attempts, flagging an IP address after too many nonexistent identities are
            attempted, and providing specific, customized authentication result messages to the user. The following
            result codes are available:

             Zend_Auth_Result::SUCCESS
Zend_Auth_Result::FAILURE
Zend_Auth_Result::FAILURE_IDENTITY_NOT_FOUND
Zend_Auth_Result::FAILURE_IDENTITY_AMBIGUOUS
Zend_Auth_Result::FAILURE_CREDENTIAL_INVALID
Zend_Auth_Result::FAILURE_UNCATEGORIZED
             

         
            The following example illustrates how a developer may branch on the result code:

             &lt;?php
// inside of AuthController / loginAction
$result = $this-&gt;_auth-&gt;authenticate($adapter);

switch ($result-&gt;getCode()) {

    case Zend_Auth_Result::FAILURE_IDENTITY_NOT_FOUND:
        /** do stuff for nonexistent identity **/
        break;

    case Zend_Auth_Result::FAILURE_CREDENTIAL_INVALID:
        /** do stuff for invalid credential **/
        break;

    case Zend_Auth_Result::SUCCESS:
        /** do stuff for successful authentication **/
        break;

    default:
        /** do stuff for other failure **/
        break;
}
             

         Identity Persistence 
            Authenticating a request that includes authentication credentials is useful per se, but it is also
            important to support maintaining the authenticated identity without having to present the
            authentication credentials with each request.
         
            HTTP is a stateless protocol, however, and techniques such as cookies and sessions have been
            developed in order to facilitate maintaining state across multiple requests in server-side web
            applications.
         Default Persistence in the PHP Session 
                 By default,  Zend_Auth  provides persistent storage of the identity from a successful
                 authentication attempt using the PHP session. Upon a successful authentication attempt,
                  Zend_Auth::authenticate()  stores the identity from the authentication result into
                 persistent storage. Unless configured otherwise,  Zend_Auth  uses a storage class named
                  Zend_Auth_Storage_Session , which, in turn, uses
                  Zend_Session . A custom class may instead be used by providing an
                 object that implements  Zend_Auth_Storage_Interface  to
                  Zend_Auth::setStorage() .
             
                    If automatic persistent storage of the identity is not appropriate for a particular use case, then
                    developers may forgo using the  Zend_Auth  class altogether, instead using an adapter
                    class directly.
                 Modifying the Session Namespace Zend_Auth_Storage_Session  uses a session namespace of  &#39;Zend_Auth&#39; . This
                    namespace may be overridden by passing a different value to the constructor of
                     Zend_Auth_Storage_Session , and this value is internally passed along to the constructor
                    of  Zend_Session_Namespace . This should occur before authentication is attempted, since
                     Zend_Auth::authenticate()  performs the automatic storage of the identity.

                     &lt;?php
// Save a reference to the Singleton instance of Zend_Auth
require_once &#39;Zend/Auth.php&#39;;
$auth = Zend_Auth::getInstance();

// Use &#39;someNamespace&#39; instead of &#39;Zend_Auth&#39;
require_once &#39;Zend/Auth/Storage/Session.php&#39;;
$auth-&gt;setStorage(new Zend_Auth_Storage_Session(&#39;someNamespace&#39;));

/**
 * @todo Set up the auth adapter, $authAdapter
 */

// Authenticate, saving the result, and persisting the identity upon success
$result = $auth-&gt;authenticate($authAdapter);
                     

                 Implementing Customized Storage 
                Sometimes developers may need to use different identity persistence behavior than that provided by
                 Zend_Auth_Storage_Session . For such cases developers may simply implement
                 Zend_Auth_Storage_Interface  and supply an instance of the class to
                 Zend_Auth::setStorage() .
             Using a Custom Storage Class 
                    In order to use an identity persistence storage class other than
                     Zend_Auth_Storage_Session , a developer implements
                     Zend_Auth_Storage_Interface :

                     &lt;?php
require_once &#39;Zend/Auth/Storage/Interface.php&#39;;

class MyStorage implements Zend_Auth_Storage_Interface
{
    /**
     * Returns true if and only if storage is empty
     *
     * @throws Zend_Auth_Storage_Exception If it is impossible to determine whether storage is empty
     * @return boolean
     */
    public function isEmpty()
    {
        /**
         * @todo implementation
         */
    }

    /**
     * Returns the contents of storage
     *
     * Behavior is undefined when storage is empty.
     *
     * @throws Zend_Auth_Storage_Exception If reading contents from storage is impossible
     * @return mixed
     */
    public function read()
    {
        /**
         * @todo implementation
         */
    }

    /**
     * Writes $contents to storage
     *
     * @param  mixed $contents
     * @throws Zend_Auth_Storage_Exception If writing $contents to storage is impossible
     * @return void
     */
    public function write($contents)
    {
        /**
         * @todo implementation
         */
    }

    /**
     * Clears contents from storage
     *
     * @throws Zend_Auth_Storage_Exception If clearing contents from storage is impossible
     * @return void
     */
    public function clear()
    {
        /**
         * @todo implementation
         */
    }

}
                     

                 
                    In order to use this custom storage class,  Zend_Auth::setStorage()  is invoked before an
                    authentication query is attempted:

                     &lt;?php
// Instruct Zend_Auth to use the custom storage class
Zend_Auth::getInstance()-&gt;setStorage(new MyStorage());

/**
 * @todo Set up the auth adapter, $authAdapter
 */

// Authenticate, saving the result, and persisting the identity upon success
$result = Zend_Auth::getInstance()-&gt;authenticate($authAdapter);
                     

                 Using Zend_Auth 
            There are two provided ways to use Zend_Auth adapters:
             
                    indirectly, through  Zend_Auth::authenticate() 
                 
                    directly, through the adapter&#39;s  authenticate()  method
                 
         
            The following example illustrates how to use a Zend_Auth adapter indirectly, through the use of
            the  Zend_Auth  class:

             &lt;?php
// Get a reference to the Singleton instance of Zend_Auth
require_once &#39;Zend/Auth.php&#39;;
$auth = Zend_Auth::getInstance();

// Set up the authentication adapter
$authAdapter = new MyAuthAdapter($username, $password);

// Attempt authentication, saving the result
$result = $auth-&gt;authenticate($authAdapter);

if (!$result-&gt;isValid()) {
    // Authentication failed; print the reasons why
    foreach ($result-&gt;getMessages() as $message) {
        echo &quot;$message\n&quot;;
    }
} else {
    // Authentication succeeded; the identity ($username) is stored in the session
    // $result-&gt;getIdentity() === $auth-&gt;getIdentity()
    // $result-&gt;getIdentity() === $username
}
             
         
            Once authentication has been attempted in a request, as in the above example, it is a simple
            matter to check whether a successfully authenticated identity exists:
             &lt;?php
$auth = Zend_Auth::getInstance();
if ($auth-&gt;hasIdentity()) {
    // Identity exists; get it
    $identity = $auth-&gt;getIdentity();
}
             
         
            To remove an identity from persistent storage, simply use the  clearIdentity()  method.
            This typically would be used for implementing an application &quot;logout&quot; operation:
             &lt;?php
Zend_Auth::getInstance()-&gt;clearIdentity();
             
         
            When the automatic use of persistent storage is inappropriate for a particular use case, a
            developer may simply bypass the use of the  Zend_Auth  class, using an adapter class
            directly. Direct use of an adapter class involves configuring and preparing an adapter object and
            then calling its  authenticate()  method. Adapter-specific details are discussed in the
            documentation for each adapter. The following example directly utilizes
             MyAuthAdapter :

             &lt;?php
// Set up the authentication adapter
$authAdapter = new MyAuthAdapter($username, $password);

// Attempt authentication, saving the result
$result = $authAdapter-&gt;authenticate();

if (!$result-&gt;isValid()) {
    // Authentication failed; print the reasons why
    foreach ($result-&gt;getMessages() as $message) {
        echo &quot;$message\n&quot;;
    }
} else {
    // Authentication succeeded
    // $result-&gt;getIdentity() === $username
}
             
         Database Table Authentication Introduction Zend_Auth_Adapter_DbTable  provides the ability to authenticate against credentials stored in a
            database table. Because  Zend_Auth_Adapter_DbTable  requires an instance of
             Zend_Db_Adapter_Abstract  to be passed to its constructor, each instance is bound to a
            particular database connection. Other configuration options may be set through the constructor and through
            instance methods, one for each option.
         
            The available configuration options include:
             tableName : This is the name of the database table that contains the authentication
                        credentials, and against which the database authentication query is performed.
                     identityColumn : This is the name of the database table column used to represent the
                        identity. The identity column must contain unique values, such as a username or e-mail address.
                     credentialColumn : This is the name of the database table column used to represent
                        the credential. Under a simple identity and password authentication scheme, the credential value
                        corresponds to the password. See also the  credentialTreatment  option.
                     credentialTreatment : In many cases, passwords and other sensitive data are
                        encrypted, hashed, encoded, obscured, or otherwise treated through some function or algorithm.
                        By specifying a parameterized treatment string with this method, such as  &#39;MD5(?)&#39; 
                        or  &#39;PASSWORD(?)&#39; , a developer may apply such arbitrary SQL upon input credential
                        data. Since these functions are specific to the underlying RDBMS, check the database manual for
                        the availability of such functions for your database system.
                     
         Basic Usage 
                As explained in the introduction, the  Zend_Auth_Adapter_DbTable  constructor requires an
                instance of  Zend_Db_Adapter_Abstract  that serves as the database connection to which the
                authentication adapter instance is bound. First, the database connection should be created.
             
                The following code creates an adapter for an in-memory database, creates a simple table schema, and
                inserts a row against which we can perform an authentication query later. This example requires the PDO
                SQLite extension to be available:

                 &lt;?php
// Create an in-memory SQLite database connection
require_once &#39;Zend/Db/Adapter/Pdo/Sqlite.php&#39;;
$dbAdapter = new Zend_Db_Adapter_Pdo_Sqlite(array(&#39;dbname&#39; =&gt; &#39;:memory:&#39;));

// Build a simple table creation query
$sqlCreate = &#39;CREATE TABLE [users] ( &#39;
           . &#39;[id] INTEGER  NOT NULL PRIMARY KEY, &#39;
           . &#39;[username] VARCHAR(50) UNIQUE NOT NULL, &#39;
           . &#39;[password] VARCHAR(32) NULL, &#39;
           . &#39;[real_name] VARCHAR(150) NULL)&#39;;

// Create the authentication credentials table
$dbAdapter-&gt;query($sqlCreate);

// Build a query to insert a row for which authentication may succeed
$sqlInsert = &#39;INSERT INTO users (username, password, real_name) &#39;
           . &#39;VALUES (&quot;my_username&quot;, &quot;my_password&quot;, &quot;My Real Name&quot;)&#39;;

// Insert the data
$dbAdapter-&gt;query($sqlInsert);
                 

             
                With the database connection and table data available, an instance of
                 Zend_Auth_Adapter_DbTable  may be created. Configuration option values may be passed to the
                constructor or deferred as parameters to setter methods after instantiation:

                 &lt;?php
require_once &#39;Zend/Auth/Adapter/DbTable.php&#39;;

// Configure the instance with constructor parameters...
$authAdapter = new Zend_Auth_Adapter_DbTable($dbAdapter, &#39;users&#39;, &#39;username&#39;, &#39;password&#39;);

// ...or configure the instance with setter methods
$authAdapter = new Zend_Auth_Adapter_DbTable($dbAdapter);
$authAdapter-&gt;setTableName(&#39;users&#39;)
            -&gt;setIdentityColumn(&#39;username&#39;)
            -&gt;setCredentialColumn(&#39;password&#39;);
                 

             
                At this point, the authentication adapter instance is ready to accept authentication queries. In order
                to formulate an authentication query, the input credential values are passed to the adapter prior to
                calling the  authenticate()  method:

                 &lt;?php
// Set the input credential values (e.g., from a login form)
$authAdapter-&gt;setIdentity(&#39;my_username&#39;)
            -&gt;setCredential(&#39;my_password&#39;);

// Perform the authentication query, saving the result
$result = $authAdapter-&gt;authenticate();
                 

             
                In addition to the availability of the  getIdentity()  method upon the authentication result
                object,  Zend_Auth_Adapter_DbTable  also supports retrieving the table row upon
                authentication success:

                 &lt;?php
// Print the identity
echo $result-&gt;getIdentity() . &quot;\n\n&quot;;

// Print the result row
print_r($authAdapter-&gt;getResultRowObject());

/* Output:
my_username

Array
(
    [id] =&gt; 1
    [username] =&gt; my_username
    [password] =&gt; my_password
    [real_name] =&gt; My Real Name
)
*/
                 

                Since the table row contains the credential value, it is important to secure the values against
                unintended access.
             Advanced Use: Persisting a DbTable Result Object 
            By default,  Zend_Auth_Adapter_DbTable  returns the identity supplied back to the auth object
            upon successful authentication. Another use case scenario, where developers want to store to the persistent
            storage mechanism of  Zend_Auth  an identity object containing other useful information, is
            solved by using the  getResultRowObject()  method to return a  stdClass  object. The
            following code snippet illustrates its use:

             &lt;?php
// authenticate with Zend_Auth_Adapter_DbTable
$result = $this-&gt;_auth-&gt;authenticate($adapter);

if ($result-&gt;isValid()) {

    // store the identity as an object where only the username and real_name have been returned
    $this-&gt;_auth-&gt;getStorage()-&gt;write($adapter-&gt;getResultRowObject(array(&#39;username&#39;, &#39;real_name&#39;)));

    // store the identity as an object where the password column has been omitted
    $this-&gt;_auth-&gt;getStorage()-&gt;write($adapter-&gt;getResultRowObject(null, &#39;password&#39;));

    /* ... */

} else {

    /* ... */

}
             

         Advanced Usage By Example 
            While the primary purpose of Zend_Auth (and consequently Zend_Auth_Adapter_DbTable) is primarily
             authentication  and not  authorization ,
            there exist a few instances and problems
            that toe the line upon which domain the fit within.  Depending on how you&#39;ve decided to explain
            your problem, it sometimes makes sense to solve what could look like an authorization problem
            within the authentication adapter.
         
            With that bit of a disclaimer out of the way, Zend_Auth_Adapter_DbTable has some built in
            mechanisms that can be leveraged to add additional checks at authentication time to solve
            some common user problems.

             &lt;?php
// The status field value of an account is not equal to &quot;compromised&quot;
$adapter = new Zend_Auth_Adapter_DbTable($db, &#39;users&#39;, &#39;username&#39;, &#39;password&#39;, &#39;MD5(?) AND status != &quot;compromised&quot;&#39;);

// The active field value of an account is equal to &quot;TRUE&quot;
$adapter = new Zend_Auth_Adapter_DbTable($db, &#39;users&#39;, &#39;username&#39;, &#39;password&#39;, &#39;MD5(?) AND active = &quot;TRUE&quot;&#39;);


             

         Digest Authentication Introduction Digest authentication 
            is a method of HTTP authentication that improves upon
             Basic authentication 
            by providing a way to authenticate without having to transmit the password in clear text across
            the network.
         
            This adapter allows authentication against text files containing lines having the basic elements
            of digest authentication:
             
                        username, such as &quot; joe.user &quot;
                     
                        realm, such as &quot; Administrative Area &quot;
                     
                        MD5 hash of the username, realm, and password, separated by colons
                     
            The above elements are separated by colons, as in the following example (in which the password is
            &quot; somePassword &quot;):
         someUser:Some Realm:fde17b91c3a510ecbaf7dbd37f59d4f8 Specifics 
            The digest authentication adapter,  Zend_Auth_Adapter_Digest , requires several input parameters:
             
                        filename - Filename against which authentication queries are performed
                     
                        realm - Digest authentication realm
                     
                        username - Digest authentication user
                     
                        password - Password for the user of the realm
                     
            These parameters must be set prior to calling  authenticate() .
         Identity 
            The digest authentication adapter returns a  Zend_Auth_Result  object, which has been
            populated with the identity as an array having keys of  realm  and
             username . The respective array values associated with these keys correspond to the
            values set before  authenticate()  is called.
         &lt;?php
require_once &#39;Zend/Auth/Adapter/Digest.php&#39;;

$adapter = new Zend_Auth_Adapter_Digest($filename, $realm, $username, $password);

$result = $adapter-&gt;authenticate();

$identity = $result-&gt;getIdentity();

print_r($identity);

/*
Array
(
    [realm] =&gt; Some Realm
    [username] =&gt; someUser
)
*/
         HTTP Authentication Adapter Introduction Zend_Auth_Adapter_Http  provides a mostly-compliant implementation of
             RFC-2617 ,
             Basic  and
             Digest  HTTP Authentication.
            Digest authentication is a method of HTTP authentication that improves upon Basic authentication by
            providing a way to authenticate without having to transmit the password in clear text across the network.
         Major Features: 
                        Supports both Basic and Digest authentication.
                     
                        Issues challenges in all supported schemes, so client can respond with any scheme it supports.
                     
                        Supports proxy authentication.
                     
                        Includes support for authenticating against text files and provides an interface for
                        authenticating against other sources, such as databases.
                     
            There are a few notable features of RFC-2617 that are not implemented yet:
             
                        Nonce tracking, which would allow for &quot;stale&quot; support, and increased replay attack protection.
                     
                        Authentication with integrity checking, or &quot;auth-int&quot;.
                     
                        Authentication-Info HTTP header.
                     
         Design Overview 
            This adapter consists of two sub-components, the HTTP authentication class itself, and the so-called
            &quot;Resolvers.&quot; The HTTP authentication class encapsulates the logic for carrying out both Basic and Digest
            authentication. It uses a Resolver to look up a client&#39;s identity in some data store (text file by default),
            and retrieve the credentials from the data store. The &quot;resolved&quot; credentials are then compared to the values
            submitted by the client to determine whether authentication is successful.
         Configuration Options 
            The  Zend_Auth_Adapter_Http  class requires a configuration array passed to its constructor.
            There are several configuration options available, and some are required:
             Configuration Options Option Name Required Description accept_schemes Yes 
                                Determines which authentication schemes the adapter will accept from the client. Must be
                                a space-separated list containing  &#39;basic&#39;  and/or  &#39;digest&#39; .
                             realm Yes 
                                Sets the authentication realm; usernames should be unique within a given realm.
                             digest_domains Yes, when  &#39;accept_schemes&#39;  contains  &#39;digest&#39; 
                                Space-separated list of URIs for which the same authentication information is valid. The
                                URIs need not all point to the same server.
                             nonce_timeout Yes, when  &#39;accept_schemes&#39;  contains  &#39;digest&#39; 
                                Sets the number of seconds for which the nonce is valid. See notes below.
                             proxy_auth No 
                                Disabled by default. Enable to perform Proxy authentication, instead of normal origin
                                server authentication.
                             
         
                The current implementation of the  nonce_timeout  has some interesting side effects. This
                setting is supposed to determine the valid lifetime of a given nonce, or effectively how long a client&#39;s
                authentication information is accepted. Currently, if it&#39;s set to 3600 (for example), it will cause the
                adapter to prompt the client for new credentials every hour, on the hour. This will be resolved in a
                future release, once nonce tracking and stale support are implemented.
             Resolvers 
            The resolver&#39;s job is to take a username and realm, and return some kind of credential value. Basic
            authentication expects to receive the Base64 encoded version of the user&#39;s password. Digest authentication
            expects to receive a hash of the user&#39;s username, the realm, and their password (each separated by colons).
            Currently, the only supported hash algorithm is MD5.
         Zend_Auth_Adapter_Http  relies on objects implementing
             Zend_Auth_Adapter_Http_Resolver_Interface . A text file resolver class is included with this
            adapter, but any other kind of resolver can be created simply by implementing the resolver interface.
         File Resolver 
                The file resolver is a very simple class. It has a single property specifying a filename, which can also
                be passed to the constructor. Its  resolve()  method walks through the text file, searching
                for a line with a matching username and realm. The text file format similar to Apache htpasswd files:
                 &lt;username&gt;:&lt;realm&gt;:&lt;credentials&gt;\n 
                Each line consists of three fields - username, realm, and credentials - each separated by a colon. The
                credentials field is opaque to the file resolver; it simply returns that value as-is to the caller.
                Therefore, this same file format serves both Basic and Digest authentication. In Basic authentication,
                the credentials field should be the Base64 encoding of the user&#39;s password. In Digest authentication, it
                should be the MD5 hash discribed above.
             
                There are two equally easy ways to create a File resolver:
                 &lt;?php
$path     = &#39;files/passwd.txt&#39;;
$resolver = new Zend_Auth_Adapter_Http_Resolver_File($path);
                 
                or
                 &lt;?php
$path     = &#39;files/passwd.txt&#39;;
$resolver = new Zend_Auth_Adapter_Http_Resolver_File();
$resolver-&gt;setFile($path);
                 
                If the given path is empty or not readable, an exception is thrown.
             Basic Usage 
            First, set up an array with the required configuration values:
             &lt;?php
$config = array(
    &#39;accept_schemes&#39; =&gt; &#39;basic digest&#39;,
    &#39;realm&#39;          =&gt; &#39;My Web Site&#39;,
    &#39;digest_domains&#39; =&gt; &#39;/members_only /my_account&#39;,
    &#39;nonce_timeout&#39;  =&gt; 3600,
);
             
            This array will cause the adapter to accept either Basic or Digest authentication, and will require
            authenticated access to all the areas of the site under  /members_only  and
             /my_account . The realm value is usually displayed by the browser in the password dialog box.
            The  nonce_timeout , of course, behaves as described above.
         
            Next, create the Zend_Auth_Adapter_Http object:
             &lt;?php
require_once &#39;Zend/Auth/Adapter/Http.php&#39;;
$adapter = new Zend_Auth_Adapter_Http($config);
             
         
            Since we&#39;re supporting both Basic and Digest authentication, we need two different resolver objects. Note
            that this could just as easily be two different classes:
             &lt;?php
require_once &#39;Zend/Auth/Adapter/Http/Resolver/File.php&#39;;

$basicResolver = new Zend_Auth_Adapter_Http_Resolver_File();
$basicResolver-&gt;setFile(&#39;files/basicPasswd.txt&#39;);

$digestResolver = new Zend_Auth_Adapter_Http_Resolver_File();
$digestResolver-&gt;setFile(&#39;files/digestPasswd.txt&#39;);

$adapter-&gt;setBasicResolver($basicResolver);
$adapter-&gt;setDigestResolver($digestResolver);
             
         
            Finally, we perform the authentication. The adapter needs a reference to both the Request and Response
            objects in order to do its job:
             &lt;?php
assert($request instanceof Zend_Controller_Request_Http);
assert($response instanceof Zend_Controller_Response_Http);

$adapter-&gt;setRequest($request);
$adapter-&gt;setResponse($response);

$result = $adapter-&gt;authenticate();
if (!$result-&gt;isValid()) {
    // Bad userame/password, or canceled password prompt
}
             
         LDAP Authentication Introduction Zend_Auth_Adapter_Ldap  supports web application authentication with LDAP services. Its
            features include username and domain name canonicalization, multi-domain authentication, and failover
            capabilities. It has been tested to work with
             Microsoft
            Active Directory  and  OpenLDAP , but it should also
            work with other LDAP service providers.
         
            This documentation includes a guide on using  Zend_Auth_Adapter_Ldap , an exploration of its
            API, an outline of the various available options, diagnostic information for troubleshooting authentication
            problems, and example options for both Active Directory and OpenLDAP servers.
         Usage 
            To incorporate  Zend_Auth_Adapter_Ldap  authentication into your application quickly, even if
            you&#39;re not using  Zend_Controller , the meat of your code should look something like the
            following:
             &lt;?php
$username = $this-&gt;_request-&gt;getParam(&#39;username&#39;);
$password = $this-&gt;_request-&gt;getParam(&#39;password&#39;);

$auth = Zend_Auth::getInstance();

require_once &#39;Zend/Config/Ini.php&#39;;
$config = new Zend_Config_Ini(&#39;../application/config/config.ini&#39;, &#39;production&#39;);
$log_path = $config-&gt;ldap-&gt;log_path;
$options = $config-&gt;ldap-&gt;toArray();
unset($options[&#39;log_path&#39;]);

require_once &#39;Zend/Auth/Adapter/Ldap.php&#39;;
$adapter = new Zend_Auth_Adapter_Ldap($options, $username, $password);

$result = $auth-&gt;authenticate($adapter);

if ($log_path) {
    $messages = $result-&gt;getMessages();

    require_once &#39;Zend/Log.php&#39;;
    require_once &#39;Zend/Log/Writer/Stream.php&#39;;
    require_once &#39;Zend/Log/Filter/Priority.php&#39;;
    $logger = new Zend_Log();
    $logger-&gt;addWriter(new Zend_Log_Writer_Stream($log_path));
    $filter = new Zend_Log_Filter_Priority(Zend_Log::DEBUG);
    $logger-&gt;addFilter($filter);

    foreach ($messages as $i =&gt; $message) {
        if ($i-- &gt; 1) { // $messages[2] and up are log messages
            $message = str_replace(&quot;\n&quot;, &quot;\n  &quot;, $message);
            $logger-&gt;log(&quot;Ldap: $i: $message&quot;, Zend_Log::DEBUG);
        }
    }
} 
            Of course the logging code is optional, but it is highly recommended that you use a logger.
             Zend_Auth_Adapter_Ldap  will record just about every bit of information anyone could want in
             $messages  (more below), which is a nice feature in itself for something that has a history of
            being notoriously difficult to debug.
         
            The  Zend_Config_Ini  code is used above to load the adapter options. It is also optional. A
            regular array would work equally well. The following is an example
             application/config/config.ini  file that has options for two separate servers. With multiple
            sets of server options the adapter will try each in order until the credentials are successfully
            authenticated. The names of the servers (e.g.,  server1  and  server2 ) are largely
            arbitrary. For details regarding the options array, see the  Server Options  section
            below. Note that  Zend_Config_Ini  requires that any values with equals characters
            ( = ) will need to be quoted (like the DNs shown below).
             [production]

ldap.log_path = /tmp/ldap.log

; Typical options for OpenLDAP
ldap.server1.host = s0.foo.net
ldap.server1.accountDomainName = foo.net
ldap.server1.accountDomainNameShort = FOO
ldap.server1.accountCanonicalForm = 3
ldap.server1.username = &quot;CN=user1,DC=foo,DC=net&quot;
ldap.server1.password = pass1
ldap.server1.baseDn = &quot;OU=Sales,DC=foo,DC=net&quot;
ldap.server1.bindRequiresDn = true

; Typical options for Active Directory
ldap.server2.host = dc1.w.net
ldap.server2.useSsl = true
ldap.server2.accountDomainName = w.net
ldap.server2.accountDomainNameShort = W
ldap.server2.accountCanonicalForm = 3
ldap.server2.baseDn = &quot;CN=Users,DC=w,DC=net&quot; 
            The above configuration will instruct  Zend_Auth_Adapter_Ldap  to attempt to authenticate users
            with the OpenLDAP server  s0.foo.net  first. If the authentication fails for any reason, the AD
            server  dc1.w.net  will be tried.
         
            With servers in different domains, this configuration illustrates multi-domain authentication. You can also
            have multiple servers in the same domain to provide redundancy.
         
            Note that in this case, even though OpenLDAP has no need for the short NetBIOS style domain name used by
            Windows we provide it here for name canonicalization purposes (described in the
             Username Canonicalization  section below).
         The API 
            The  Zend_Auth_Adapter_Ldap  constructor accepts three parameters.
         
            The  $options  parameter is required and must be an array containing one or more sets of
            options. Note that it is  an array of arrays  of
             Zend_Ldap  options. Even if you will be using only one LDAP server, the
            options must still be within another array.
         
            Below is  print_r()  output of an example options
            parameter containing two sets of server options for LDAP servers  s0.foo.net  and
             dc1.w.net  (same options as the above INI representation):
             Array
(
    [server2] =&gt; Array
        (
            [host] =&gt; dc1.w.net
            [useSsl] =&gt; 1
            [accountDomainName] =&gt; w.net
            [accountDomainNameShort] =&gt; W
            [accountCanonicalForm] =&gt; 3
            [baseDn] =&gt; CN=Users,DC=w,DC=net
        )

    [server1] =&gt; Array
        (
            [host] =&gt; s0.foo.net
            [accountDomainName] =&gt; foo.net
            [accountDomainNameShort] =&gt; FOO
            [accountCanonicalForm] =&gt; 3
            [username] =&gt; CN=user1,DC=foo,DC=net
            [password] =&gt; pass1
            [baseDn] =&gt; OU=Sales,DC=foo,DC=net
            [bindRequiresDn] =&gt; 1
        )

) 
            The information provided in each set of options above is different mainly because AD does not require a
            username be in DN form when binding (see the  bindRequiresDn  option in the
             Server Options  section below), which means we can omit the a number of options
            associated with retrieving the DN for a username being authenticated.
         What is a DN? 
                A DN or &quot;distinguished name&quot; is a string that represents the path to an object within the LDAP
                directory. Each comma separated component is an attribute and value representing a node. The components
                are evaluated in reverse. For example, the user account
                 CN=Bob Carter,CN=Users,DC=w,DC=net  is located directly within the
                 CN=Users,DC=w,DC=net container . This structure is best explored with an LDAP
                browser like the ADSI Edit MMC snap-in for Active Directory or phpLDAPadmin.
             
            The names of servers (e.g. &#39; server1 &#39; and &#39; server2 &#39; shown above) are largely
            arbitrary, but for the sake of using  Zend_Config , the identifiers should be present (as
            opposed to being numeric indexes) and should not contain any special characters used by the associated file
            formats (e.g. the &#39; . &#39; INI property separator, &#39; &amp; &#39; for XML entity references,
            etc).
         
            With multiple sets of server options, the adapter can authenticate users in multiple domains and provide
            failover so that if one server is not available, another will be queried.
         The Gory Details - What exactly happens in the authenticate method? 
                When the  authenticate()  method is called, the adapter iterates over each set of server
                options, sets them on the internal  Zend_Ldap  instance and calls the
                 Zend_Ldap::bind()  method with the username and password being authenticated. The
                 Zend_Ldap  class checks to see if the username is qualified with a domain (e.g., has a
                domain component like  alice@foo.net  or  FOO\alice ). If a
                domain is present, but it does not match either of the server&#39;s domain names
                ( foo.net  or  FOO ), a special exception is thrown and caught by
                 Zend_Auth_Adapter_Ldap  that causes that server to be ignored and the next set of server
                options is selected. If a domain  does  match, or if the user did not supply a
                qualified username,  Zend_Ldap  proceeds to try to bind with the supplied credentials. If
                the bind is not successful,  Zend_Ldap  throws a  Zend_Ldap_Exception  which is
                caught by  Zend_Auth_Adapter_Ldap  and the next set of server options is tried. If the bind
                is successful, the iteration stops, and the adapter&#39;s  authenticate()  method returns a
                successful result. If all server options have been tried without success, the authentication fails, and
                 authenticate()  returns a failure result with error messages from the last iteration.
             
            The username and password parameters of the  Zend_Auth_Adapter_Ldap  constructor represent the
            credentials being authenticated (i.e., the credentials supplied by the user through your HTML login form).
            Alternatively, they may also be set with the  setUsername()  and  setPassword() 
            methods.
         Server Options 
            Each set of server options  in the context of Zend_Auth_Adapter_Ldap  consists of the
            following options, which are passed, largely unmodifed, to  Zend_Ldap::setOptions() :

             Server Options Name Description host 
                        The hostname of LDAP server that these options represent. This option is required.
                     port 
                        The port on which the LDAP server is listening. If  useSsl  is
                         true , the default  port  value is 636. If
                         useSsl  is  false , the default
                         port  value is 389.
                     useSsl 
                        If  true , this value indicates that the LDAP client should use SSL / TLS encrypted
                        transport. A value of  true  is strongly favored in production environments to
                        prevent passwords from be transmitted in clear text. The default value is  false ,
                        as servers frequently require that a certificate be installed separately after installation.
                        This value also changes the default  port  value (see
                         port  description above).
                     username 
                        The DN of the account used to perform account DN lookups. LDAP servers that require the
                        username to be in DN form when performing the &quot;bind&quot; require this option. Meaning, if
                         bindRequiresDn  is  true , this option is
                        required. This account does not need to be a privileged account - a account with read-only
                        access to objects under the  baseDn  is all that is necessary
                        (and preferred based on the  Principle of Least Privilege ).
                     password 
                        The password of the account used to perform account DN lookups. If this option is not supplied,
                        the LDAP client will attempt an &quot;anonymous bind&quot; when performing account DN lookups.
                     bindRequiresDn 
                        Some LDAP servers require that the username used to bind be in DN form like
                         CN=Alice Baker,OU=Sales,DC=foo,DC=net  (basically all servers
                         except  AD). If this option is  true , this instructs
                         Zend_Ldap  to automatically retrieve the DN corresponding to the username being
                        authenticated, if it is not already in DN form, and then re-bind with the proper DN. The
                        default value is  false . Currently only Microsoft Active Directory Server (ADS) is
                        known  not  to require usernames to be in DN form when binding, and
                        therefore this option may be  false  with AD (and it should be, as retrieving the DN
                        requires an extra round trip to the server). Otherwise, this option must be set to
                         true  (e.g. for OpenLDAP). This option also controls the default
                         acountFilterFormat  used when searching for accounts. See the
                         accountFilterFormat  option.
                     baseDn 
                        The DN under which all accounts being authenticated are located. This option is required. If
                        you are uncertain about the correct  baseDn  value, it should
                        be sufficient to derive it from the user&#39;s DNS domain using  DC= 
                        components. For example, if the user&#39;s principal name is  alice@foo.net , a
                         baseDn  of  DC=foo,DC=net  should work. A
                        more precise location (e.g.,  OU=Sales,DC=foo,DC=net ) will be more
                        efficient, however.
                     accountCanonicalForm 
                        A value of 2, 3 or 4 indicating the form to which account names should be canonicalized after
                        successful authentication. Values are as follows: 2 for traditional username style names (e.g.,
                         alice ), 3 for backslash-style names (e.g.,  FOO\alice )
                        or 4 for principal style usernames (e.g.,  alice@foo.net ). The default
                        value is 4 (e.g.,  alice@foo.net ). For example, with a value of 3, the
                        identity returned by  Zend_Auth_Result::getIdentity()  (and
                         Zend_Auth::getIdentity() , if  Zend_Auth  was used) will always be
                         FOO\alice , regardless of what form Alice supplied, whether it be
                         alice ,  alice@foo.net ,  FOO\alice ,
                         FoO\aLicE ,  foo.net\alice , etc. See the
                         Account Name Canonicalization  section in the  Zend_Ldap 
                        documentation for details. Note that when using multiple sets of server options it is
                        recommended, but not required, that the same
                         accountCanonicalForm  be used with all server options so that
                        the resulting usernames are always canonicalized to the same form (e.g., if you canonicalize to
                         EXAMPLE\username  with an AD server but to
                         username@example.com  with an OpenLDAP server, that may be awkward for the
                        application&#39;s high-level logic).
                     accountDomainName 
                        The FQDN domain name for which the target LDAP server is an authority (e.g.,
                         example.com ). This option is used to canonicalize names so that the username
                        supplied by the user can be converted as necessary for binding. It is also used to determine if
                        the server is an authority for the supplied username (e.g., if
                         accountDomainName  is  foo.net  and the
                        user supplies  bob@bar.net , the server will not be queried, and a failure
                        will result). This option is not required, but if it is not supplied, usernames in principal
                        name form (e.g.,  alice@foo.net ) are not supported. It is strongly
                        recommended that you supply this option, as there are many use-cases that require generating
                        the principal name form.
                     accountDomainNameShort 
                        The &#39;short&#39; domain for which the target LDAP server is an authority (e.g.,
                         FOO ). Note that there is a 1:1 mapping between the
                         accountDomainName  and
                         accountDomainNameShort . This option should be used to
                        specify the NetBIOS domain name for Windows networks but may also be used by non-AD servers
                        (e.g., for consistency when multiple sets of server options with the backslash style
                         accountCanonicalForm ). This option is not required but if it
                        is not supplied, usernames in backslash form (e.g.,  FOO\alice ) are not
                        supported.
                     accountFilterFormat 
                        The LDAP search filter used to search for accounts. This string is a
                         printf() -style expression that must
                        contain one &#39; %s &#39; to accomodate the username. The default value is
                        &#39; (&amp;(objectClass=user)(sAMAccountName=%s)) &#39;, unless
                         bindRequiresDn  is set to  true , in which case
                        the default is &#39; (&amp;(objectClass=posixAccount)(uid=%s)) &#39;. For example, if for
                        some reason you wanted to use  bindRequiresDn = true  with AD you would need to set
                         accountFilterFormat = &#39;(&amp;(objectClass=user)(sAMAccountName=%s)) &#39;.
                     
         
                If you enable  useSsl = true  you may find that the LDAP client generates an error
                claiming that it cannot validate the server&#39;s certificate. Assuming the PHP LDAP extension is
                ultimately linked to the OpenLDAP client libraries, to resolve this issue you can set
                &quot; TLS_REQCERT never &quot; in the OpenLDAP client  ldap.conf  (and restart the web
                server) to indicate to the OpenLDAP client library that you trust the server. Alternatively if you are
                concerned that the server could be spoofed, you can export the LDAP server&#39;s root certificate and put
                it on the web server so that the OpenLDAP client can validate the server&#39;s identity.
             Collecting Debugging Messages Zend_Auth_Adapter_Ldap  collects debugging information within its  authenticate() 
            method. This information is stored in the  Zend_Auth_Result  object as messages. The array
            returned by  Zend_Auth_Result::getMessages()  is described as follows:

             Debugging Messages Messages Array Index Description Index 0 
                        A generic, user-friendly message that is suitable for displaying to users (e.g., &quot;Invalid
                        credentials&quot;). If the authentication is successful, this string is empty.
                     Index 1 
                        A more detailed error message that is not suitable to be displayed to users but should be
                        logged for the benefit of server operators. If the authentication is successful, this string is
                        empty.
                     Indexes 2 and higher 
                        All log messages in order starting at index 2.
                     

            In practice index 0 should be displayed to the user (e.g., using the FlashMessenger helper), index 1 should
            be logged and, if debugging information is being collected, indexes 2 and higher could be logged as well
            (although the final message always includes the string from index 1).
         Common Options for Specific Servers Options for Active Directory 
                For ADS, the following options are noteworthy:

                 Options for Active Directory Name Additional Notes host 
                            As with all servers, this option is required.
                         useSsl 
                            For the sake of security, this should be  true  if the server has the necessary
                            certificate installed.
                         baseDn 
                            As with all servers, this option is required. By default AD places all user accounts under
                            the  Users  container (e.g.,
                             CN=Users,DC=foo,DC=net ), but the default is not common in larger
                            organizations. Ask your AD administrator what the best DN for accounts for your application
                            would be.
                         accountCanonicalForm 
                            You almost certainly want this to be 3 for backslash style names (e.g.,
                             FOO\alice ), which are most familar to Windows users. You should
                             not  use the unqualified form 2 (e.g.,  alice ), as
                            this may grant access to your application to users with the same username in other trusted
                            domains (e.g.,  BAR\alice  and  FOO\alice  will be
                            treated as the same user). (See also note below.)
                         accountDomainName 
                            This is required with AD unless  accountCanonicalForm  2
                            is used, which, again, is discouraged.
                         accountDomainNameShort 
                            The NetBIOS name of the domain users are in and for which the AD server is an authority.
                            This is required if the backslash style
                             accountCanonicalForm  is used.
                         
             
                    Technically there should be no danger of accidental cross-domain authentication with the current
                     Zend_Auth_Adapter_Ldap  implementation, since server domains are explicitly checked,
                    but this may not be true of a future implementation that discovers the domain at runtime or if an
                    alternative adapter is used (e.g., Kerberos). In general, account name ambiguity is known to be the
                    source of security issues so always try to use qualified account names.
                 Options for OpenLDAP 
                For OpenLDAP or a generic LDAP server using a typical posixAccount style schema, the following options
                are noteworthy:

                 Options for OpenLDAP Name Additional Notes host 
                            As with all servers, this option is required.
                         useSsl 
                            For the sake of security, this should be  true  if the server has the necessary
                            certificate installed.
                         username 
                            Required and must be a DN, as OpenLDAP requires that usernames be in DN form when
                            performing a bind. Try to use an unprivileged account.
                         password 
                            The password corresponding to the username above, but this may be omitted if the LDAP
                            server permits an anonymous binding to query user accounts.
                         bindRequiresDn 
                            Required and must be  true , as OpenLDAP requires that usernames be in DN form
                            when performing a bind.
                         baseDn 
                            As with all servers, this option is required and indicates the DN under which all accounts
                            being authenticated are located.
                         accountCanonicalForm 
                            Optional but the default value is 4 (principal style names like
                             alice@foo.net ), which may not be ideal if your users are used to
                            backslash style names (e.g.,  FOO\alice ). For backslash style names use
                            value 3.
                         accountDomainName 
                            Required unless you&#39;re using  accountCanonicalForm  2,
                            which is not recommended.
                         accountDomainNameShort 
                            If AD is not also being used, this value is not required. Otherwise, if
                             accountCanonicalForm  3 is used, this option is required
                            and should be a short name that corresponds adequately to the
                             accountDomainName  (e.g., if your
                             accountDomainName  is
                             foo.net , a good
                             accountDomainNameShort  value might be
                             FOO ).
                         

             Open ID Authentication Introduction Zend_Auth_Adapter_OpenId  allows authenticate user using
            remote OpenID server. Such authentication process assumes that user
            submits to web application only their OpenID identity. Then they are
            redirected to their OpenID providers to prove the identity ownership
            using password or some other method. This password is never known
            to local web application.
         
            The OpenID identity is just an HTTP URL that points to some web page
            with suitable information about the user and special tags which
            describes which server to use and which identity to submit there.
            You can read more about OpenID at
             OpenID official site .
         
            The  Zend_Auth_Adapter_OpenId  class is a wrapper on top
            of  Zend_OpenId_Consumer  component which implements the
            OpenID authentication protocol itself.
         Zend_OpenId  takes advantage of the  GMP extension ,
                where available. Consider enabling the GMP extension for better performance when using
                 Zend_Auth_Adapter_OpenId .
             Specifics 
            As any other  Zend_Auth  adapter the  Zend_Auth_Adapter_OpenId 
            class implements  Zend_Auth_Adapter_Interface , which
            defines one method -  authenticate() . This method performs
            the authentication itself, but the object must be prepared prior to
            calling it. Such adapter preparation includes setting up OpenID
            identity and some other  Zend_OpenId  specific options.
         
            However in opposite to other  Zend_Auth  adapters it
            performs authentication on external server and it is done in two
            separate HTTP requests. So the  Zend_Auth_Adapter_OpenId::authenticate() 
            must be called twice. First time the method won&#39;t return, but will
            redirect user to their OpenID server. Then after authentication on
            server they will be redirected back and the script for this second
            request must call  Zend_Auth_Adapter_OpenId::authenticate() 
            again to verify signature which come with redirected request from the
            server and complete the authentication process. This time the
            method will return  Zend_Auth_Result  object as expected.
         
            The following example shows the usage of  Zend_Auth_Adapter_OpenId .
            As was said before the  Zend_Auth_Adapter_OpenId::authenticate() 
            is called two times. First time - after submitting of HTML form when
             $_POST[&#39;openid_action&#39;]  is set to  &quot;login&quot; ,
            and the second time after HTTP redirection from OpenID server when
             $_GET[&#39;openid_mode&#39;]  or  $_POST[&#39;openid_mode&#39;] 
            is set.
         &lt;?php
require_once &quot;Zend/Auth.php&quot;;
require_once &quot;Zend/Auth/Adapter/OpenId.php&quot;;

$status = &quot;&quot;;
$auth = Zend_Auth::getInstance();
if ((isset($_POST[&#39;openid_action&#39;]) &amp;&amp;
     $_POST[&#39;openid_action&#39;] == &quot;login&quot; &amp;&amp;
     !empty($_POST[&#39;openid_identifier&#39;])) ||
    isset($_GET[&#39;openid_mode&#39;]) ||
    isset($_POST[&#39;openid_mode&#39;])) {
    $result = $auth-&gt;authenticate(
        new Zend_Auth_Adapter_OpenId(@$_POST[&#39;openid_identifier&#39;]));
    if (!$result-&gt;isValid()) {
        $status = &quot;You are logged-in as &quot; . $auth-&gt;getIdentity() . &quot;&lt;br&gt;\n&quot;;
    } else {
        $auth-&gt;clearIdentity();
        foreach ($result-&gt;getMessages() as $message) {
            $status .= &quot;$message&lt;br&gt;\n&quot;;
        }
    }
} else if ($auth-&gt;hasIdentity()) {
    if (isset($_POST[&#39;openid_action&#39;]) &amp;&amp;
        $_POST[&#39;openid_action&#39;] == &quot;logout&quot;) {
        $auth-&gt;clearIdentity();
    } else {
        $status = &quot;You are logged-in as &quot; . $auth-&gt;getIdentity() . &quot;&lt;br&gt;\n&quot;;
    }
}
?&gt;
&lt;html&gt;&lt;body&gt;
&lt;?php echo &quot;$status&quot;;?&gt;
&lt;form method=&quot;post&quot;&gt;&lt;fieldset&gt;
&lt;legend&gt;OpenID Login&lt;/legend&gt;
&lt;input type=&quot;text&quot; name=&quot;openid_identifier&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;submit&quot; name=&quot;openid_action&quot; value=&quot;login&quot;&gt;
&lt;input type=&quot;submit&quot; name=&quot;openid_action&quot; value=&quot;logout&quot;&gt;
&lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
*/
         
            It is allowed customize the OpenID authentication process with:
            receiving redirection from the OpenID server on separate page,
            specifying the &quot;root&quot; of web site. In this case, using custom
             Zend_OpenId_Consumer_Storage  or custom
             Zend_Controller_Response . It is also possible to use
            Simple Registration Extension to retrieve information about
            user from the OpenID server. All these possibilities described
            in more details in  Zend_OpenId_Consumer 
            reference.
         Zend_Cache backends Zend_Cache_Backend_File 
            This backends stores cache records into files (in a choosen directory).
         
            Available options are :
         File backend options Option Data Type Default Value Description cache_dir string &#39;/tmp/&#39; 
                              Directory where to store cache files
                           file_locking boolean true 
                            Enable / disable file_locking : Can avoid cache corruption under
                            bad circumstances but it doesn&#39;t help on multithread webservers
                            or on NFS filesystems...
                           read_control boolean true 
                            Enable / disable read control : if enabled, a control key is
                            embeded in the cache file and this key is compared with the
                            one calculated after the reading.
                           read_control_type string &#39;crc32&#39; 
                            Type of read control (only if read control is enabled). Available values are :
                            &#39;md5&#39; (best but slowest), &#39;crc32&#39; (lightly less safe but faster, better choice),
                            &#39;adler32&#39; (new choice, faster than crc32),
                            &#39;strlen&#39; for a length only test (fastest).
                         hashed_directory_level int 0 
                            Hashed directory structure level :     0 means &quot;no hashed directory
                             structure&quot;, 1 means &quot;one level of directory&quot;, 2 means &quot;two levels&quot;...
                             This option can speed up the cache only when you have many thousands of
                             cache files. Only specific benchs can help you to choose the perfect
                             value for you. Maybe, 1 or 2 is a good start.
                           hashed_directory_umask int 0700 
                              Umask for the hashed directory structure
                         file_name_prefix string &#39;zend_cache&#39; 
                              prefix for cache files ; be really carefull with this option because
                              a too generic value in a system cache dir (like /tmp) can cause
                              disasters when cleaning the cache
                         cache_file_umask int 0700 
                              umask for cache files
                           metatadatas_array_max_size int 100 
                              internal max size for the metadatas array (don&#39;t change this value unless you
                              know what you are doing)
                           Zend_Cache_Backend_Sqlite 
            This backends stores cache records into a SQLite database.
         
            Available options are :
         Sqlite backend options Option Data Type Default Value Description cache_db_complete_path (mandatory) string null 
                              The complete path (filename included) of the SQLite database
                           automatic_vacuum_factor int 10 
                              Disable / Tune the automatic vacuum process.
                              The automatic vacuum process defragment the database file (and make it smaller)
                              when a clean() or delete() is called :
                              0 means no automatic vacuum ;
                              1 means systematic vacuum (when delete() or clean() methods are called) ;
                              x (integer) &gt; 1 =&gt; automatic vacuum randomly 1 times on x clean() or delete().
                           Zend_Cache_Backend_Memcached 
            This backends stores cache records into a memcached server.  memcached 
            is a high-performance, distributed memory object caching system. To use this backend,
            you need a memcached daemon and  the memcache PECL extension .
         
            Be careful : with this backend, &quot;tags&quot; are not supported for the moment as
            the &quot;doNotTestCacheValidity=true&quot; argument.
         
            Available options are :
         Memcached backend options Option Data Type Default Value Description servers array array(array(&#39;host&#39; =&gt; &#39;localhost&#39;,&#39;port&#39; =&gt; 11211, &#39;persistent&#39; =&gt; true)) 
                              An array of memcached servers ; each memcached server is described by an associative array :
                              &#39;host&#39; =&gt; (string) : the name of the memcached server,
                              &#39;port&#39; =&gt; (int) : the port of the memcached server,
                              &#39;persistent&#39; =&gt; (bool) : use or not persistent connections to this memcached server
                           compression boolean false 
                             true if you want to use on-the-fly compression
                           Zend_Cache_Backend_Apc 
            This backends stores cache records in shared memory through
            the  APC  (Alternative PHP Cache) extension
            (which is of course need for using this backend).
         
            Be careful : with this backend, &quot;tags&quot; are not supported for the moment as
            the &quot;doNotTestCacheValidity=true&quot; argument.
         
            There is no option for this backend.
         Zend_Cache_Backend_ZendPlatform 
            This backend uses content caching API of the  Zend Platform  product. Naturally, to use this backend you need to have Zend Platform installed.
         
    This backend supports tags, but does not support  CLEANING_MODE_NOT_MATCHING_TAG  cleaning mode.
         
            Specify this backend using a word separator -- &#39;-&#39;, &#39;.&#39;, &#39; &#39;, or &#39;_&#39;
            -- between the words &#39;Zend&#39; and &#39;Platform&#39; when using the
             Zend_Cache::factory()  method:
         &lt;?php
$cache = Zend_Cache::factory(&#39;Core&#39;, &#39;Zend Platform&#39;);
         
            There is no options for this backend.
         Zend_Cache frontends Zend_Cache_Core Introduction Zend_Cache_Core  is a special frontend because it is the core
                of the module. It is a generic cache frontend and is extended by other classes.
             
                All frontends inherit from  Zend_Cache_Core  so that its methods and options
                (described below) would also be available in other frontends, therefore they won&#39;t be
                documented there.
             Available options 
                These options are passed to the factory method as demonstrated in previous examples.
             Core frontend options Option Data Type Default Value Description caching boolean true 
                                  enable / disable caching (can be very useful for the debug of
                                  cached scripts)
                               cache_id_prefix string null 
                                A prefix for all cache ids, if set to  null , no
                                cache id prefix will be used. The cache id prefix essentially creates
                                a namespace in the cache, allowing multiple applications or websites
                                to use a shared cache. Each application or website can use a different
                                cache id prefix so specific cache ids can be used more than once.
                               lifetime int 3600 
                                cache lifetime (in seconds), if set to  null , the
                                cache is valid forever.
                               logging boolean false 
                                if set to true, logging through  Zend_Log  is activated
                                (but the system is slower)
                               write_control boolean true 
                                Enable / disable write control (the cache is read
                                just after writing to detect corrupt entries), enabling write_control
                                will lightly slow the cache writing but not the cache reading (it
                                can detect some corrupt cache files but it&#39;s not a perfect control)
                               automatic_serialization boolean false 
                                Enable / disable automatic serialization, it can be used to save directly datas
                                which aren&#39;t strings (but it&#39;s slower)
                               automatic_cleaning_factor int 10 
                                Disable / Tune the automatic cleaning process (garbage collector):
                                0 means no automatic cache cleaning, 1 means systematic cache cleaning
                                and x &gt; 1 means automatic random cleaning 1 times in x write operations.
                               ignore_user_abort boolean false 
                                if set to true, the core will set the ignore_user_abort PHP flag inside the
                                save() method to avoid cache corruptions in some cases
                               Examples 
                An example is given in the manual at the very beginning.
             
                If you store only strings into cache (because with &quot;automatic_serialization&quot; option, it&#39;s possible
                to store some booleans), you can use a more compact construction like:
             &lt;?php
// we assume you already have $cache

$id = &#39;myBigLoop&#39;; // cache id of &quot;what we want to cache&quot;

if (!($data = $cache-&gt;load($id))) {
    // cache miss

    $data = &#39;&#39;;
    for ($i = 0; $i &lt; 10000; $i++) {
        $data = $data . $i;
    }

    $cache-&gt;save($data);

}

// [...] do something with $data (echo it, pass it on etc.)
             
                If you want to cache multiple blocks or data instances, the idea is the same:
             &lt;?php
// make sure you use unique identifiers:
$id1 = &#39;foo&#39;;
$id2 = &#39;bar&#39;;

// block 1
if (!($data = $cache-&gt;load($id1))) {
    // cache missed

    $data = &#39;&#39;;
    for ($i=0;$i&lt;10000;$i++) {
        $data = $data . $i;
    }

    $cache-&gt;save($data);

}
echo($data);

// this isn&#39;t affected by caching
echo(&#39;NEVER CACHED! &#39;);

// block 2
if (!($data = $cache-&gt;load($id2))) {
    // cache missed

    $data = &#39;&#39;;
    for ($i=0;$i&lt;10000;$i++) {
        $data = $data . &#39;!&#39;;
    }

    $cache-&gt;save($data);

}
echo($data);
             Zend_Cache_Frontend_Output Introduction Zend_Cache_Frontend_Output  is an output-capturing frontend. It utilizes
                output buffering in PHP to capture everything between its  start()  and
                 end()  methods.
             Available options 
                This frontend doesn&#39;t have any specific options other than those of
                 Zend_Cache_Core .
             Examples 
                An example is given in the manual at the very beginning. Here it is with minor changes:
             &lt;?php
// if it is a cache miss, output buffering is triggered
if (!($cache-&gt;start(&#39;mypage&#39;))) {

    // output everything as usual
    echo &#39;Hello world! &#39;;
    echo &#39;This is cached (&#39;.time().&#39;) &#39;;

    $cache-&gt;end(); // output buffering ends

}

echo &#39;This is never cached (&#39;.time().&#39;).&#39;;
             
                Using this form it is fairly easy to set up output caching in your already working project
                with little or no code refactoring.
             Zend_Cache_Frontend_Function Introduction Zend_Cache_Frontend_Function  caches the results of function calls. It has
                a single main method named  call()  which takes a function name and parameters
                for the call in an array.
             Available options Function frontend options Option Data Type Default Value Description cache_by_default boolean true 
                                  if true, function calls will be cached by default
                               cached_functions array 
                                  function names which will always be cached
                               non_cached_functions array 
                                  function names which must never be cached
                               Examples 
                Using the  call()  function is the same as using
                 call_user_func_array()  in PHP:
             &lt;?php
$cache-&gt;call(&#39;veryExpensiveFunc&#39;, $params);

# $params is an array
# for example to call (with caching) veryExpensiveFunc(1, &#39;foo&#39;, &#39;bar&#39;), you will use
# $cache-&gt;call(&#39;veryExpensiveFunc&#39;, array(1, &#39;foo&#39;, &#39;bar&#39;))
             Zend_Cache_Frontend_Function  is smart enough to cache both the
                return value of the function and its internal output.
             
                You can pass any builtin or user defined function with the exception of
                 array() ,  echo() ,  empty() ,  eval() ,
                 exit() ,  isset() ,  list() ,  print() 
                and  unset() .
             Zend_Cache_Frontend_Class Introduction Zend_Cache_Frontend_Class  is different from  Zend_Cache_Frontend_Function 
                because it allows caching of object and static method calls.
             Available options Class frontend options Option Data Type Default Value Description cached_entity  (required) mixed 
                                  if set to a class name, we will cache an abstract class and will use
                                  only static calls; if set to an object, we will cache this object methods
                               cache_by_default boolean true 
                                  if true, calls will be cached by default
                               cached_methods array 
                                  method names which will always be cached
                               non_cached_methods array 
                                  method names which must never be cached
                               Examples 
                For example, to cache static calls :
             &lt;?php
class test {

    # Static method
    public static function foobar($param1, $param2) {
        echo &quot;foobar_output($param1, $param2)&quot;;
        return &quot;foobar_return($param1, $param2)&quot;;
    }

}

// [...]
$frontendOptions = array(
    &#39;cached_entity&#39; =&gt; &#39;test&#39; // The name of the class
);
// [...]

# The cached call
$res = $cache-&gt;foobar(&#39;1&#39;, &#39;2&#39;);
             
                To cache classic method calls :
             &lt;?php
class test {

    private $_string = &#39;hello !&#39;;

    public function foobar2($param1, $param2) {
        echo($this-&gt;_string);
        echo &quot;foobar2_output($param1, $param2)&quot;;
        return &quot;foobar2_return($param1, $param2)&quot;;
    }

}

// [...]
$frontendOptions = array(
    &#39;cached_entity&#39; =&gt; new test() // An instance of the class
);
// [...]

# The cached call
$res = $cache-&gt;foobar2(&#39;1&#39;, &#39;2&#39;);
             Zend_Cache_Frontend_File Introduction Zend_Cache_Frontend_File  is a frontend driven by the
                modification time of a &quot;master file&quot;. It&#39;s really interesting for examples
                in configuration or templates issues.
             
                For instance, you have an XML configuration file which is parsed by a function
                which returns a &quot;config object&quot; (like with  Zend_Config ). With
                 Zend_Cache_Frontend_File , you can store the &quot;config object&quot; into
                cache (to avoid the parsing of the XML config file at each time) but with a
                sort of strong dependency on the &quot;master file&quot;. So, if the XML config file
                is modified, the cache is immediatly invalidated.
             Available options File frontend options Option Data Type Default Value Description master_file (mandatory) string 
                                  the complete path and name of the master file
                               Examples 
                Use of this frontend is the same than of  Zend_Cache_Core . There
                is no need of a specific example - the only thing to do is to
                define the  master_file  when using the factory.
             Zend_Cache_Frontend_Page Introduction Zend_Cache_Frontend_Page  is like  Zend_Cache_Frontend_Output 
                but designed for a complete page. It&#39;s impossible to use  Zend_Cache_Frontend_Page 
                for caching only a single block.
             
                On the other hand, the &quot;cache id&quot; is calculated automatically with
                 $_SERVER[&#39;REQUEST_URI&#39;]  and (depending on options)
                 $_GET ,  $_POST ,  $_SESSION ,  $_COOKIE ,  $_FILES .
                More over, you have only one method to call ( start() ) because the
                 end()  call is fully automatic when the page is ended.
             
                For the moment, it&#39;s not implemented but we plan to add a HTTP conditional system
                to save bandwith (the system will send a HTTP 304 Not Modified if the cache is hit
                and if the browser has already the good version).
             Available options (for this frontend in Zend_Cache factory) Page frontend options Option Data Type Default Value Description http_conditional boolean false 
                                  use the http_conditional system (not implemented for the moment)
                               debug_header boolean false 
                                  if true, a debug text is added before each cached pages
                               default_options array array(...see below...) 
                                  an associative array of default options :
                                   (boolean, true by default) cache  :
                                              cache is on if true
                                           (boolean, false by default) cache_with_get_variables  :
                                              if true, cache is still on even if there are some variables in
                                               $_GET  array
                                           (boolean, false by default) cache_with_post_variables  :
                                              if true, cache is still on even if there are some variables in
                                               $_POST  array
                                           (boolean, false by default) cache_with_session_variables  :
                                              if true, cache is still on even if there are some variables in
                                               $_SESSION  array
                                           (boolean, false by default) cache_with_files_variables  :
                                              if true, cache is still on even if there are some variables in
                                               $_FILES  array
                                           (boolean, false by default) cache_with_cookie_variables  :
                                              if true, cache is still on even if there are some variables in
                                               $_COOKIE  array
                                           (boolean, true by default) make_id_with_get_variables  :
                                              if true, the cache id will be dependent of the content of the
                                               $_GET  array
                                           (boolean, true by default) make_id_with_post_variables  :
                                              if true, the cache id will be dependent of the content of the
                                               $_POST  array
                                           (boolean, true by default) make_id_with_session_variables  :
                                              if true, the cache id will be dependent of the content of the
                                               $_SESSION  array
                                           (boolean, true by default) make_id_with_files_variables  :
                                              if true, the cache id will be dependent of the content of the
                                               $_FILES  array
                                           (boolean, true by default) make_id_with_cookie_variables  :
                                              if true, the cache id will be dependent of the content of the
                                               $_COOKIE  array
                                           
                               regexps array array() 
                                    an associative array to set options only for some REQUEST_URI, keys are (PCRE) regexps, values are
                                    associative arrays with specific options to set if the regexp matchs on $_SERVER[&#39;REQUEST_URI&#39;]
                                  (see default_options for the list of available options) ; if several regexps match the $_SERVER[&#39;REQUEST_URI&#39;],
                                  only the last one will be used
                               Examples 
                Use of Zend_Cache_Frontend_Page is really trivial :
             &lt;?php
// [...] // require, configuration and factory

$cache-&gt;start();
// if the cache is hit, the result is sent to the browser and the script stop here

// rest of the page ...
             
                a more complex example which shows a way to get a centralized cache management in a bootstrap file
                (for using with Zend_Controller for example)
             &lt;?php

// [...] you should avoid to put too much lines before the cache section
// [...] for example, for optimal performances, &quot;require_once&quot; or &quot;Zend_Loader::loadClass&quot; should be
// [...] after the cache section

require_once &#39;Zend/Cache.php&#39;;

$frontendOptions = array(
   &#39;lifetime&#39; =&gt; 7200,
   &#39;debug_header&#39; =&gt; true, // for debugging
   &#39;regexps&#39; =&gt; array(
       &#39;^/$&#39; =&gt; array(&#39;cache&#39; =&gt; true),         // cache the whole IndexController
       &#39;^/index/&#39; =&gt; array(&#39;cache&#39; =&gt; true),    // cache the whole IndexController
       &#39;^/article/&#39; =&gt; array(&#39;cache&#39; =&gt; false), // we don&#39;t cache the ArticleController...
       &#39;^/article/view/&#39; =&gt; array(              // ...but we cache the &quot;view&quot; action of
           &#39;cache&#39; =&gt; true,                     // this ArticleController
           &#39;cache_with_post_variables&#39; =&gt; true,    // and we cache even there are some variables in $_POST
           &#39;make_id_with_post_variables&#39; =&gt; true,   // (but the cache will be dependent of the $_POST array)
       )
   )
);
$backendOptions = array(
    &#39;cache_dir&#39; =&gt; &#39;/tmp/&#39;
);

// getting a Zend_Cache_Frontend_Page object
$cache = Zend_Cache::factory(&#39;Page&#39;, &#39;File&#39;, $frontendOptions, $backendOptions);

$cache-&gt;start();
// if the cache is hit, the result is sent to the browser and the script stop here

// [...] the end of the bootstrap file (these lines won&#39;t be executed if the cache is hit)
             Introduction Zend_Cache  provides a generic way to cache any data.
     
      Caching in Zend Framework is operated by frontends while cache records are stored through backend adapters
      ( File ,  Sqlite ,  Memcache ...) through a flexible
      system of IDs and tags. Using those, it is easy to delete specific types of records afterwards
      (for example: &quot;delete all cache records marked with a given tag&quot;).
     
        The core of the module ( Zend_Cache_Core ) is generic, flexible and configurable.
        Yet, for your specific needs there are cache frontends that extend  Zend_Cache_Core 
        for convinience:  Output ,  File ,  Function  and  Class .
     Getting a frontend with  Zend_Cache::factory() Zend_Cache::factory()  instantiates correct objects and ties them together.
            In this first example, we will use  Core  frontend together with  File 
            backend.
         &lt;?php
require_once &#39;Zend/Cache.php&#39;;

$frontendOptions = array(
   &#39;lifetime&#39; =&gt; 7200, // cache lifetime of 2 hours
   &#39;automatic_serialization&#39; =&gt; true
);

$backendOptions = array(
    &#39;cache_dir&#39; =&gt; &#39;./tmp/&#39; // Directory where to put the cache files
);

// getting a Zend_Cache_Core object
$cache = Zend_Cache::factory(&#39;Core&#39;, &#39;File&#39;, $frontendOptions, $backendOptions);
         Frontends and Backends consisting of multiple words 
            Some frontends and backends are named using multiple words, such
            as &#39;ZendPlatform&#39;. When specifying them to the factory, separate
            them using a word separator, such as a space (&#39; &#39;), hyphen
            (&#39;-&#39;), or period (&#39;.&#39;).
         Caching a database query result 
            Now that we have a frontend, we can cache any type of data (we turned on serialization). For
            example, we can cache a result from a very expensive database query. After it is cached, there
            is no need to even connect to the database; records are fetched from cache and unserialized.
         &lt;?php
// $cache initialized in previous example

// see if a cache already exists:
if(!$result = $cache-&gt;load(&#39;myresult&#39;)) {

    // cache miss; connect to the database

    $db = Zend_Db::factory( [...] );

    $result = $db-&gt;fetchAll(&#39;SELECT * FROM huge_table&#39;);

    $cache-&gt;save($result, &#39;myresult&#39;);

} else {

    // cache hit! shout so that we know
    echo &quot;This one is from cache!\n\n&quot;;

}

print_r($result);
         Caching output with  Zend_Cache  output frontend 
            We &#39;mark up&#39; sections in which we want to cache output by adding some conditional logic,
            encapsulating the section within  start()  and  end()  methods (this
            resembles the first example and is the core strategy for caching).
         
            Inside, output your data as usual - all output will be cached when execution hits the  end() 
            method. On the next run, the whole section will be skipped in favor of fetching data from cache
            (as long as the cache record is valid).
         &lt;?php
$frontendOptions = array(
   &#39;lifetime&#39; =&gt; 30,                  // cache lifetime of half a minute
   &#39;automatic_serialization&#39; =&gt; false  // this is default anyway
);

$backendOptions = array(&#39;cache_dir&#39; =&gt; &#39;./tmp/&#39;);

$cache = Zend_Cache::factory(&#39;Output&#39;, &#39;File&#39;, $frontendOptions, $backendOptions);

// we pass a unique identifier to the start() method
if(!$cache-&gt;start(&#39;mypage&#39;)) {
    // output as usual:

    echo &#39;Hello world! &#39;;
    echo &#39;This is cached (&#39;.time().&#39;) &#39;;

    $cache-&gt;end(); // the output is saved and sent to the browser
}

echo &#39;This is never cached (&#39;.time().&#39;).&#39;;
        
           Notice that we output the result of  time()  twice; this is something dynamic
           for demonstration purposes. Try running this and then refreshing several times; you will notice
           that the first number doesn&#39;t change while second changes as time passes. That is because the first
           number was output in the cached section and is saved among other output.
           After half a minute (we&#39;ve set lifetime to 30 seconds) the
           numbers should match again because the cache record expired -- only to be cached again. You
           should try this in your brower or console.
        
        When using Zend_Cache, pay attention to the important cache identifier (passed to  save() 
        and  start() ). It must be unique for every resource you cache, otherwise unrelated
        cache records may wipe each other or, even worse, be displayed in place of the other.
     The theory of caching 
        There are three key concepts in Zend_Cache. One is the unique indentifier (a string) that is used
        to identify cache records. The second one is the  &#39;lifetime&#39;  directive as seen in the
        examples; it defines for how long the cached resource is considered &#39;fresh&#39;. The third key concept
        is conditional execution so that parts of your code can be skipped entirely, boosting performance.
        The main frontend function (eg.  Zend_Cache_Core::get() ) is always designed to return
        false for a cache miss if that makes sense for the nature of a frontend. That enables end-users to
        wrap parts of the code they would like to cache (and skip) in  if(){ ... }  statements where
        the condition is a Zend_Cache method itself. On the end if these blocks you must save what you&#39;ve
        generated, however (eg.  Zend_Cache_Core::save() ).
     
        The conditional execution design of your generating code is not necessary in some frontends
        ( Function , for an example) when the whole logic is implemented inside the frontend.
     
        &#39;Cache hit&#39; is a term for a condition when a cache record is found, is valid and is &#39;fresh&#39; (in other
        words hasn&#39;t expired yet). &#39;Cache miss&#39; is everything else. When a cache miss happens, you must
        generate your data (as you would normally do) and have it cached. When you have a cache hit, on the
        other hand, the backend automatically fetches the record from cache transparently.
     The  Zend_Cache  factory method 
            A good way to build a usable instance of a  Zend_Cache  Frontend is given
            in the following example :
         &lt;?php
# We &quot;load&quot; the Zend_Cache factory
require &#39;Zend/Cache.php&#39;;

# We choose a backend (for example &#39;File&#39; or &#39;Sqlite&#39;...)
$backendName = &#39;[...]&#39;;

# We choose a frontend (for example &#39;Core&#39;, &#39;Output&#39;, &#39;Page&#39;...)
$frontendName = &#39;[...]&#39;;

# We set an array of options for the choosen frontend
$frontendOptions = array([...]);

# We set an array of options for the choosen backend
$backendOptions = array([...]);

# We make the good instance
# (of course, the two last arguments are optional)
$cache = Zend_Cache::factory($frontendName, $backendName, $frontendOptions, $backendOptions);
         
            In the following examples we will assume that the  $cache  variable holds a
            valid, instantiated frontend as shown and that you understand how to pass parametres
            to your chosen backends.
         
            Always use  Zend_Cache::factory()  to get frontend instances. Instantiating
            frontends and backends yourself will not work as expected.
         Tagging records 
            Tags are a way to categorize cache records. When you save a cache with the  save() 
            method, you can set an array of tags to apply for this record. Then you will be
            able to clean all cache records tagged with a given tag (or tags):
         &lt;?php
$cache-&gt;save($huge_data, &#39;myUniqueID&#39;, array(&#39;tagA&#39;, &#39;tagB&#39;, &#39;tagC&#39;));
         
            note than the  save()  method accepts an optional fourth argument :  $specificLifetime 
            (if != false, it sets a specific lifetime for this particular cache record)
         Cleaning the cache 
            To remove/invalidate in particular cache id, you can use the  remove() 
            method :
         &lt;?php
$cache-&gt;remove(&#39;idToRemove&#39;);
         
            To remove/invalidate several cache ids in one operation, you can use the  clean() 
            method. For example to remove all cache records :
         &lt;?php
// clean all records
$cache-&gt;clean(Zend_Cache::CLEANING_MODE_ALL);

// clean only outdated
$cache-&gt;clean(Zend_Cache::CLEANING_MODE_OLD);
         
            If you want to remove cache entries matching the tags &#39;tagA&#39; and &#39;tagC&#39;:
         &lt;?php
$cache-&gt;clean(Zend_Cache::CLEANING_MODE_MATCHING_TAG, array(&#39;tagA&#39;, &#39;tagC&#39;));
         
            Available cleaning modes are:  CLEANING_MODE_ALL ,  CLEANING_MODE_OLD ,
             CLEANING_MODE_MATCHING_TAG  and  CLEANING_MODE_NOT_MATCHING_TAG . The
            latter are, as their names suggest, combined with an array of tags in cleaning operations.
         Introduction Zend_Config  is designed to simplify access to and use of configuration data within applications.
        It provides a nested object property based user interface for accessing such configuration data within
        application code. The configuration data may come from a variety of media supporting hierarchical data storage.
        Currently  Zend_Config  provides adapters for configuration data that are stored in text files with
         Zend_Config_Ini  and
         Zend_Config_Xml .
     Using Zend_Config Per Se 
            Normally it is expected that users would use one of the adapter classes such as
             Zend_Config_Ini  or
             Zend_Config_Xml , but if configuration data are
            available in a PHP array, one may simply pass the data to the  Zend_Config  constructor in order
            to utilize a simple object-oriented interface:
         &lt;?php
// Given an array of configuration data
$configArray = array(
    &#39;webhost&#39;  =&gt; &#39;www.example.com&#39;,
    &#39;database&#39; =&gt; array(
        &#39;adapter&#39; =&gt; &#39;pdo_mysql&#39;,
        &#39;params&#39;  =&gt; array(
            &#39;host&#39;     =&gt; &#39;db.example.com&#39;,
            &#39;username&#39; =&gt; &#39;dbuser&#39;,
            &#39;password&#39; =&gt; &#39;secret&#39;,
            &#39;dbname&#39;   =&gt; &#39;mydatabase&#39;
        )
    )
);

// Create the object-oriented wrapper upon the configuration data
require_once &#39;Zend/Config.php&#39;;
$config = new Zend_Config($configArray);

// Print a configuration datum (results in &#39;www.example.com&#39;)
echo $config-&gt;webhost;

// Use the configuration data to connect to the database
$db = Zend_Db::factory($config-&gt;database-&gt;adapter,
                       $config-&gt;database-&gt;params-&gt;toArray());

// Alternative usage: simply pass the Zend_Config object.
// The Zend_Db factory knows how to interpret it.
$db = Zend_Db::factory($config-&gt;database);
         
        As illustrated in the example above,  Zend_Config  provides nested object property syntax to access
        configuration data passed to its constructor.
     
        Along with the object oriented access to the data values,  Zend_Config  also has  get() 
        which will return the supplied default value if the data element doesn&#39;t exist. For example:
     &lt;?php
$host = $config-&gt;database-&gt;get(&#39;host&#39;, &#39;localhost&#39;);
     Using Zend_Config with a PHP Configuration File 
            It is often desirable to use a pure PHP-based configuration file. The following code illustrates how easily
            this can be accomplished:
         &lt;?php
// config.php
return array(
    &#39;webhost&#39;  =&gt; &#39;www.example.com&#39;,
    &#39;database&#39; =&gt; array(
        &#39;adapter&#39; =&gt; &#39;pdo_mysql&#39;,
        &#39;params&#39;  =&gt; array(
            &#39;host&#39;     =&gt; &#39;db.example.com&#39;,
            &#39;username&#39; =&gt; &#39;dbuser&#39;,
            &#39;password&#39; =&gt; &#39;secret&#39;,
            &#39;dbname&#39;   =&gt; &#39;mydatabase&#39;
        )
    )
); &lt;?php
// Configuration consumption
require_once &#39;Zend/Config.php&#39;;
$config = new Zend_Config(require &#39;config.php&#39;);

// Print a configuration datum (results in &#39;www.example.com&#39;)
echo $config-&gt;webhost; Theory of Operation 
        Configuration data are made accessible to the  Zend_Config  constructor
        through an associative array, which may be multidimensional, in order to support
        organizing the data from general to specific. Concrete adapter classes function
        to adapt configuration data from storage to produce the associative array for the
         Zend_Config  constructor. User scripts may provide such arrays directly
        to the  Zend_Config  constructor, without using an adapter class, since
        it may be appropriate to do so in certain situations.
     
        Each configuration data array value becomes a property of the  Zend_Config  object. The key is used
        as the property name. If a value is itself an array, then the resulting object property is created as a new
         Zend_Config  object, loaded with the array data. This occurs recursively, such that a hierarchy of
        configuration data may be created with any number of levels.
     Zend_Config  implements the  Countable  and  Iterator 
        interfaces in order to facilitate simple access to configuration data.
        Thus, one may use the  count() 
        function and PHP constructs such as
         foreach  upon
         Zend_Config  objects.
     
        By default, configuration data made available through  Zend_Config 
        are read-only, and an assignment (e.g.,
         $config-&gt;database-&gt;host = &#39;example.com&#39; )
        results in a thrown exception. This default behavior may be overridden through the constructor,
        however, to allow modification of data values. Also, when modifications are allowed,  Zend_Config 
        supports unsetting of values (i.e.  unset($config-&gt;database-&gt;host); ).
         
                It is important not to confuse such in-memory modifications with saving configuration
                data out to specific storage media. Tools for creating and modifying configuration
                data for various storage media are out of scope with respect to  Zend_Config .
                Third-party open source solutions are readily available for the purpose of creating and
                modifying configuration data for various storage media.
             
     
        Adapter classes inherit from the  Zend_Config  class since they utilize its functionality.
     
        The  Zend_Config  family of classes enables configuration data to be
        organized into sections.  Zend_Config  adapter objects may be loaded
        with a single specified section, multiple specified sections, or all sections
        (if none are specified).
     Zend_Config  adapter classes support a single inheritance model that
        enables configuration data to be inherited from one section of configuration data
        into another. This is provided in order to reduce or eliminate the need for
        duplicating configuration data for different purposes. An inheriting section
        may also override the values that it inherits through its parent section.
        Like PHP class inheritance, a section may inherit from a parent section,
        which may inherit from a grandparent section, and so on, but multiple inheritance
        (i.e., section C inheriting directly from parent sections A and B) is not supported.
     
        If you have two  Zend_Config  objects, you can merge them into a single
        object using the  merge()  function. For example, given  $config  and
         $localConfig , you can merge data from  $localConfig  to  $config  using
         $config-&gt;merge($localConfig); . The items in  $localConfig  will override
        any items with the same name in  $config .
     Zend_Config_Ini Zend_Config_Ini  enables developers to store configuration data in a familiar INI format and read
        them in the application by using nested object property syntax. The INI format is specialized to provide both
        the ability to have a hierarchy of configuration data keys and inheritance between configuration data sections.
        Configuration data hierarchies are supported by separating the keys with the dot or period character
        ( . ). A section may extend or inherit from another section by following the section name with a
        colon character ( : ) and the name of the section from which data are to be inherited.
     parse_ini_file Zend_Config_Ini  utilizes the
             parse_ini_file() 
            PHP function. Please review this documentation to be aware of its specific behaviors,
            which propagate to  Zend_Config_Ini , such as how the special values of
             true ,  false ,  yes ,  no ,
            and  null  are handled.
         Key Separator 
            By default, the key separator character is the period character ( . ). This can be changed,
            however, by changing the  $options  key  &#39;nestSeparator&#39;  when constructing the
             Zend_Config_Ini  object. For example:
             &lt;?php
require_once &#39;Zend/Config/Ini.php&#39;;
$options[&#39;nestSeparator&#39;] = &#39;:&#39;;
$config = new Zend_Config_Ini(&#39;/path/to/config.ini&#39;, &#39;staging&#39;, $options);
             
         Using Zend_Config_Ini 
            This example illustrates a basic use of  Zend_Config_Ini  for loading configuration data from an
            INI file. In this example there are configuration data for both a production system and for a staging
            system. Because the staging system configuration data are very similar to those for production, the staging
            section inherits from the production section. In this case, the decision is arbitrary and could have been
            written conversely, with the production section inheriting from the staging section, though this may not be
            the case for more complex situations. Suppose, then, that the following configuration data are contained in
             /path/to/config.ini :
         ; Production site configuration data
[production]
webhost                  = www.example.com
database.adapter         = pdo_mysql
database.params.host     = db.example.com
database.params.username = dbuser
database.params.password = secret
database.params.dbname   = dbname

; Staging site configuration data inherits from production and
; overrides values as necessary
[staging : production]
database.params.host     = dev.example.com
database.params.username = devuser
database.params.password = devsecret
         
            Next, assume that the application developer needs the staging configuration data from the INI file. It is a
            simple matter to load these data by specifying the INI file and the staging section:
         &lt;?php
require_once &#39;Zend/Config/Ini.php&#39;;

$config = new Zend_Config_Ini(&#39;/path/to/config.ini&#39;, &#39;staging&#39;);

echo $config-&gt;database-&gt;params-&gt;host;   // prints &quot;dev.example.com&quot;
echo $config-&gt;database-&gt;params-&gt;dbname; // prints &quot;dbname&quot;
         Zend_Config_Ini Constructor parameters Parameter Notes $filename The INI file to load. $section The [section] within the ini file that is to be loaded. Setting
                        this parameter to null will load all sections. Alternatively, an
                        array of section names may be supplied to load multiple sections. $options = false Options array. The following keys are supported:
                         allowModifications : Set to true to allow subsequent modification of loaded file. Defaults to false nestSeparator : Set to the character to be used as the nest separator. Defaults to &quot;.&quot; 
                     Zend_Config_Xml Zend_Config_Xml  enables developers to store configuration data in a simple XML format and read them
        via nested object property syntax. The root element of the XML file is irrelevant and may be named arbitrarily.
        The first level of XML elements correspond with configuration data sections. The XML format supports
        hierarchical organization through nesting of XML elements below the section-level elements. The content of a
        leaf-level XML element corresponds to the value of a configuration datum. Section inheritance is supported by a
        special XML attribute named  extends , and the value of this attribute corresponds with the section
        from which data are to be inherited by the extending section.
     Return type 
            Configuration data read into  Zend_Config_Xml  are always returned as strings.
            Conversion of data from strings to other types is left to developers to suit their particular needs.
         Using Zend_Config_Xml 
            This example illustrates a basic use of  Zend_Config_Xml  for loading configuration data from an
            XML file. In this example there are configuration data for both a production system and for a staging
            system. Because the staging system configuration data are very similar to those for production, the staging
            section inherits from the production section. In this case, the decision is arbitrary and could have been
            written conversely, with the production section inheriting from the staging section, though this may not be
            the case for more complex situations. Suppose, then, that the following configuration data are contained in
             /path/to/config.xml :
         &lt;?xml version=&quot;1.0&quot;?&gt;
&lt;configdata&gt;
    &lt;production&gt;
        &lt;webhost&gt;www.example.com&lt;/webhost&gt;
        &lt;database&gt;
            &lt;adapter&gt;pdo_mysql&lt;/adapter&gt;
            &lt;params&gt;
                &lt;host&gt;db.example.com&lt;/host&gt;
                &lt;username&gt;dbuser&lt;/username&gt;
                &lt;password&gt;secret&lt;/password&gt;
                &lt;dbname&gt;dbname&lt;/dbname&gt;
            &lt;/params&gt;
        &lt;/database&gt;
    &lt;/production&gt;
    &lt;staging extends=&quot;production&quot;&gt;
        &lt;database&gt;
            &lt;params&gt;
                &lt;host&gt;dev.example.com&lt;/host&gt;
                &lt;username&gt;devuser&lt;/username&gt;
                &lt;password&gt;devsecret&lt;/password&gt;
            &lt;/params&gt;
        &lt;/database&gt;
    &lt;/staging&gt;
&lt;/configdata&gt;
         
            Next, assume that the application developer needs the staging configuration data from the XML file. It is a
            simple matter to load these data by specifying the XML file and the staging section:
         &lt;?php
require_once &#39;Zend/Config/Xml.php&#39;;

$config = new Zend_Config_Xml(&#39;/path/to/config.xml&#39;, &#39;staging&#39;);

echo $config-&gt;database-&gt;params-&gt;host;   // prints &quot;dev.example.com&quot;
echo $config-&gt;database-&gt;params-&gt;dbname; // prints &quot;dbname&quot;
         Configuring Zend_Console_Getopt Adding Option Rules 
            You can add more option rules in addition to those you specified
            in the  Zend_Console_Getopt  constructor, using the
             addRules()  method.  The argument to
             addRules()  is the same as the first argument to the
            class constructor.  It is either a string in the format of the
            short syntax options specification, or else an associative array
            in the format of a long syntax options specification.
            See  Declaring Getopt Rules 
            for details on the syntax for specifying options.
         Using addRules() &lt;?php
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
$opts-&gt;addRules(
  array(
    &#39;verbose|v&#39; =&gt; &#39;Print verbose output&#39;
  )
);
             
            The example above shows adding the &quot; --verbose &quot; option
            with an alias of &quot; -v &quot; to a set of options
            defined in the call to the constructor.  Notice that you can mix
            short format options and long format options in the same instance
            of  Zend_Console_Getopt .
         Adding Help Messages 
            In addition to specifying the help strings when declaring option
            rules in the long format, you can associate help strings
            with option rules using the  setHelp() 
            method.  The argument to the  setHelp()  method is an
            associative array, in which the key is a flag, and the value is a
            corresponding help string.
         Using setHelp() &lt;?php
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
$opts-&gt;setHelp(
    array(
        &#39;a&#39; =&gt; &#39;This option chooses apple, with no parameter&#39;,
        &#39;b&#39; =&gt; &#39;This option chooses banana, with required integer parameter&#39;,
        &#39;p&#39; =&gt; &#39;This option chooses pear, with optional string parameter&#39;
    )
);
             
            If you declared options with aliases, you can use any of the
            aliases as the key of the associative array.
         
            The  setHelp()  method is the only way to define help
            strings if you declared the options using the short syntax.
         Adding Option Aliases 
            You can declare aliases for options using the  setAliases 
            method.  The argument is an associative array, whose key is
            a flag string declared previously, and whose value is a new
            alias for that flag.  These aliases are merged with any existing
            aliases.  In other words, aliases you declared earlier are
            still in effect.
         
            An alias may be declared only once.  If you try to redefine
            an alias, a  Zend_Console_Getopt_Exception  is thrown.
         Using setAliases() &lt;?php
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
$opts-&gt;setAliases(
    array(
        &#39;a&#39; =&gt; &#39;apple&#39;,
        &#39;a&#39; =&gt; &#39;apfel&#39;,
        &#39;p&#39; =&gt; &#39;pear&#39;
    )
);
             
            In the example above, after declaring these aliases,
            &quot; -a &quot;, &quot; --apple &quot; and
            &quot; --apfel &quot; are aliases for each other.
            Also &quot; -p &quot; and &quot; --pear &quot; are aliases
            for each other.
         
            The  setAliases()  method is the only way to define aliases
            if you declared the options using the short syntax.
         Adding Argument Lists 
            By default,  Zend_Console_Getopt  uses
             $_SERVER[&#39;argv&#39;]  for the array of command-line
            arguments to parse.  You can alternatively specify the array of
            arguments as the second constructor argument.  Finally, you
            can append more arguments to those already used using the
             addArguments()  method, or you can replace the current
            array of arguments using the  setArguments()  method.
            In both cases, the parameter to these methods is a simple array of
            strings.  The former method appends the array to the current
            arguments, and the latter method substitutes the array for the
            current arguments.
         Using addArguments() and setArguments() &lt;?php
// By default, the constructor uses $_SERVER[&#39;argv&#39;]
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);

// Append an array to the existing arguments
$opts-&gt;addArguments(array(&#39;-a&#39;, &#39;-p&#39;, &#39;p_parameter&#39;, &#39;non_option_arg&#39;));

// Substitute a new array for the existing arguments
$opts-&gt;setArguments(array(&#39;-a&#39;, &#39;-p&#39;, &#39;p_parameter&#39;, &#39;non_option_arg&#39;));
             Adding Configuration 
            The third parameter to the  Zend_Console_Getopt 
            constructor is an array of configuration options that affect
            the behavior of the object instance returned. You can also
            specify configuration options using the  setOptions() 
            method, or you can set an individual option using the
             setOption()  method.
         Clarifying the term &quot;option&quot; 
                The term &quot;option&quot; is used for configuration of the
                 Zend_Console_Getopt  class to match terminology
                used elsewhere in the Zend Framework.  These are not the same
                things as the command-line options that are parsed by
                the  Zend_Console_Getopt  class.
             
            The currently supported
            options have const definitions in the class.  The options,
            their const identifiers (with literal values in parentheses)
            are listed below:
         Zend_Console_Getopt::CONFIG_DASHDASH  (&quot;dashDash&quot;),
                    if true, enables the special flag &quot; -- &quot; to
                    signify the end of flags.  Command-line arguments following
                    the double-dash signifier are not interpreted as options,
                    even if the arguments start with a dash.  This configuration
                    option is true by default.
                 Zend_Console_Getopt::CONFIG_IGNORECASE  (&quot;ignoreCase&quot;),
                    if true, makes flags aliases of each other if they differ
                    only in their case.  That is, &quot; -a &quot; and
                    &quot; -A &quot; will be considered to be synonymous flags.
                    This configuration option is false by default.
                 Zend_Console_Getopt::CONFIG_RULEMODE 
                    (&quot;ruleMode&quot;) may have values  Zend_Console_Getopt::MODE_ZEND 
                    (&quot;zend&quot;) and  Zend_Console_Getopt::MODE_GNU 
                    (&quot;gnu&quot;).  It should not be necessary to use this option
                    unless you extend the class with additional syntax forms.
                    The two modes supported in the base  Zend_Console_Getopt 
                    class are unambiguous.  If the specifier is a string, the
                    class assumes  MODE_GNU , otherwise it assumes
                     MODE_ZEND .  But if you extend the class and
                    add more syntax forms, you may need to specify the mode
                    using this option.
                 
            More configuration options may be added as future enhancements
            of this class.
         
            The two arguments to the  setOption()  method are
            a configuration option name and an option value.
         Using setOption() &lt;?php
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
$opts-&gt;setOption(&#39;ignoreCase&#39;, true);
             
            The argument to the  setOptions()  method is
            an associative array.  The keys of this array are the configuration
            option names, and the values are configuration values.
            This is also the array format used in the class constructor.
            The configuration values you specify are merged with the current
            configuration; you don&#39;t have to list all options.
         Using setOptions() &lt;?php
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
$opts-&gt;setOptions(
    array(
        &#39;ignoreCase&#39; =&gt; true,
        &#39;dashDash&#39;   =&gt; false
    )
);
             Fetching Options and Arguments 
        After you have declared the options that the
         Zend_Console_Getopt  object should recognize, and supply
        arguments from the command-line or an array, you can
        query the object to find out which options were specified by a user in
        a given command-line invocation of your program.  The class implements
        magic methods so you can query for options by name.
     
        The parsing of the data is deferred until the first query you make
        against the  Zend_Console_Getopt  object to find out if an
        option was given, the object performs its parsing.  This allows you to
        use several method calls to configure the options, arguments, help
        strings, and configuration options before parsing takes place.
     Handling Getopt Exceptions 
            If the user gave any invalid options on the command-line,
            the parsing function throws a  Zend_Console_Getopt_Exception .
            You should catch this exception in your application code.
            You can use the  parse()  method to force the object
            to parse the arguments.  This is useful because you can invoke
             parse()  in a  try  block.  If it passes,
            you can be sure that the parsing won&#39;t throw an exception again.
            The exception thrown has a custom method  getUsageMessage() ,
            which returns as a string the formatted set of usage messages for
            all declared options.
         Catching Getopt Exceptions &lt;?php
try {
    $opts = new Zend_Console_Getopt(&#39;abp:&#39;);
    $opts-&gt;parse();
} catch (Zend_Console_Getopt_Exception $e) {
    echo $e-&gt;getUsageMessage();
    exit;
}
             
            Cases where parsing throws an exception include:
         
                    Option given is not recognized.
                 
                    Option requires a parameter but none was given.
                 
                    Option parameter is of the wrong type.
                    E.g. a non-numeric string when an integer
                    was required.
                 Fetching Options by Name 
            You can use the  getOption()  method to query the value
            of an option.  If the option had a parameter, this method returns
            the value of the parameter.  If the option had no parameter but
            the user did specify it on the command-line, the method returns
             true .  Otherwise the method returns  null .
         Using getOption() &lt;?php
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
$b = $opts-&gt;getOption(&#39;b&#39;);
$p_parameter = $opts-&gt;getOption(&#39;p&#39;);
             
            Alternatively, you can use the magic  __get()  function
            to retrieve the value of an option as if it were a class member
            variable.  The  __isset()  magic method is also
            implemented.
         Using __get() and __isset() magic methods &lt;?php
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
if (isset($opts-&gt;b)) {
    echo &quot;I got the b option.\n&quot;;
}
$p_parameter = $opts-&gt;p; // null if not set
             
            If your options are declared with aliases, you may use any of the
            aliases for an option in the methods above.
         Reporting Options 
            There are several methods to report the full set of
            options given by the user on the current command-line.
         
                    As a string: use the  toString()  method.  The options
                    are returned as a space-separated string of &quot; flag=value &quot;
                    pairs.  The value of an option that does not have a parameter
                    is the literal string &quot; true &quot;.
                 
                    As an array: use the  toArray()  method.  The options
                    are returned in a simple integer-indexed array of strings, the flag
                    strings followed by parameter strings, if any.
                 
                    As a string containing JSON data: use the  toJson()  method.
                 
                    As a string containing XML data: use the  toXml()  method.
                 
            In all of the above dumping methods, the flag string is the
            first string in the corresponding list of aliases.  For example,
            if the option aliases were declared like &quot; verbose|v &quot;,
            then the first string, &quot; verbose &quot;, is used as the
            canonical name of the option.  The name of the option flag does not
            include any preceding dashes.
         Fetching Non-option Arguments 
            After option arguments and their parameters have been
            parsed from the command-line, there may be additional arguments
            remaining.  You can query these arguments using the
             getRemainingArgs()  method.  This method returns
            an array of the strings that were not part of any options.
         Using getRemainingArgs() &lt;?php
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
$opts-&gt;setArguments(array(&#39;-p&#39;, &#39;p_parameter&#39;, &#39;filename&#39;));
$args = $opts-&gt;getRemainingArgs(); // returns array(&#39;filename&#39;)
             Zend_Console_Getopt  supports the GNU convention that
            an argument consisting of a double-dash signifies the end of
            options.  Any arguments following this signifier must be treated as
            non-option arguments.  This is useful if you might have a non-option
            argument that begins with a dash.
            For example: &quot; rm -- -filename-with-dash &quot;.
         Introduction to Getopt 
        The  Zend_Console_Getopt  class helps command-line
        applications to parse their options and arguments.
     
        Users may specify command-line arguments when
        they execute your application.  These arguments have meaning to the
        application, to change the behavior in some way, or choose resources,
        or specify parameters.  Many options have developed customary meaning,
        for example &quot; --verbose &quot; enables extra output from many
        applications.  Other options may have a meaning that is different for
        each application.  For example, &quot; -c &quot; enables different
        features in  grep ,  ls , and
         tar .
     
        Below are a few definitions of terms.  Common usage of the terms
        varies, but this documentation will use the definitions below.
     
                &quot;argument&quot;: a string that occurs on the command-line
                following the name of the command.  Arguments may be
                options or else may appear without an option, to name
                resources on which the command operates.
             
                &quot;option&quot;: an argument that signifies that the command
                should change its default behavior in some way.
             
                &quot;flag&quot;: the first part of an option, identifies
                the purpose of the option.  A flag is preceded
                conventionally by one or two dashes
                (&quot; - &quot; or &quot; -- &quot;).
                A single dash precedes a single-character flag
                or a cluster of single-character flags.
                A double-dash precedes a multi-character flag.
                Long flags cannot be clustered.
             
                &quot;parameter&quot;: the secondary part of an option; a data value
                that may accompany a flag, if it is applicable to the
                given option.  For example, many commands accept a
                &quot; --verbose &quot; option, but typically
                this option has no parameter.  However, an option like
                &quot; --user &quot; almost always requires
                a following parameter.
             
                A parameter may be given as a separate argument following a
                flag argument, or as part of the same argument string,
                separated from the flag by an equals symbol (&quot; = &quot;).
                The latter form is supported only by long flags.
                For example,
                 -u username ,  --user username ,
                and  --user=username  are forms supported
                by  Zend_Console_Getopt .
             
                &quot;cluster&quot;: multiple single-character flags combined
                in a single string argument and preceded by a single
                dash.  For example, &quot; ls -1str &quot;
                uses a cluster of four short flags.  This command is
                equivalent to &quot; ls -1 -s -t -r &quot;.
                Only single-character flags can be clustered.
                You cannot make a cluster of long flags.
             
        For example, in &quot; mysql --user=root mydatabase &quot;,
        &quot; mysql &quot; is a  command ,
        &quot; --user=root &quot; is an  option ,
        &quot; --user &quot; is a  flag ,
        &quot; root &quot; is a  parameter  to the option,
        and &quot; mydatabase &quot; is an argument but not an option
        by our definition.
     Zend_Console_Getopt  provides an interface to declare
        which flags are valid for your application, output an error and usage
        message if they use an invalid flag, and report to your application
        code which flags the user specified.
     Getopt is not an application framework Zend_Console_Getopt  does  not 
            interpret the meaning of flags and parameters, nor does this class
            implement application workflow or invoke application code.
            You must implement those actions in your own application code.
            You can use the  Zend_Console_Getopt  class to parse
            the command-line and provide object-oriented methods for querying
            which options were given by a user, but code to use this
            information to invoke parts of your application should be in
            another PHP class.
         
        The following sections describe usage of  Zend_Console_Getopt .
     Declaring Getopt Rules 
        The constructor for the  Zend_Console_Getopt  class takes
        from one to three arguments.  The first argument
        declares which options are supported by your application.
        This class supports alternative syntax forms for declaring the options.
        See the sections below for the format and usage of these syntax forms.
     
        The constructor takes two more arguments, both of which are optional.
        The second argument may contain the command-line arguments.
        This defaults to  $_SERVER[&#39;argv&#39;] .
     
        The third argument of the constructor may contain an
        configuration options to customize the behavior of
         Zend_Console_Getopt .
        See  Adding Configuration 
        for reference on the options available.
     Declaring Options with the Short Syntax Zend_Console_Getopt  supports a compact syntax similar
            to that used by GNU Getopt (see
             http://www.gnu.org/software/libc/manual/html_node/Getopt.html .
            This syntax supports only single-character flags.  In a single
            string, you type each of the letters that correspond to flags
            supported by your application.  A letter followed by a colon
            character (&quot; : &quot;) indicates a flag that requires a
            parameter.
         Using the Short Syntax &lt;?php
require_once &#39;Zend/Console/Getopt.php&#39;;
$opts = new Zend_Console_Getopt(&#39;abp:&#39;);
             
            The example above shows using  Zend_Console_Getopt 
            to declare that options may be given as &quot; -a &quot;,
            &quot; -b &quot;, or &quot; -p &quot;.  The latter flag
            requires a parameter.
         
            The short syntax is limited to flags of a single character.
            Aliases, parameter types, and help strings are not supported
            in the short syntax.
         Declaring Options with the Long Syntax 
            A different syntax with more features is also available.  This
            syntax allows you to specify aliases for flags, types of option
            parameters, and also help strings to describe usage to the user.
            Instead of the single string used in the short syntax to declare
            the options, the long syntax uses an associative array as the
            first argument to the constructor.
         
            The key of each element of the associative array is a string with
            a format that names the flag, with any aliases, separated by the
            pipe symbol (&quot; | &quot;).  Following this series of flag
            aliases, if the option requires a parameter, is an equals symbol
            (&quot; = &quot;) with a letter that stands for the
             type  of the parameter:
         
                    &quot; =s &quot; for a string parameter
                 
                    &quot; =w &quot; for a word parameter
                    (a string containing no whitespace)
                 
                    &quot; =i &quot; for an integer parameter
                 
            If the parameter is optional, use a dash (&quot; - &quot;)
            instead of the equals symbol.
         
            The value of each element in the associative array is a help string
            to describe to a user how to use your program.
         Using the Long Syntax &lt;?php
require_once &#39;Zend/Console/Getopt.php&#39;;
$opts = new Zend_Console_Getopt(
  array(
    &#39;apple|a&#39;    =&gt; &#39;This option chooses apple, with no parameter&#39;,
    &#39;banana|b=i&#39; =&gt; &#39;This option chooses banana, with required integer parameter&#39;,
    &#39;pear|p-s&#39;   =&gt; &#39;This option chooses pear, with optional string parameter&#39;
  )
);
             
            In the example declaration above, there are three options.
            &quot; --apple &quot; and &quot; -a &quot; are aliases for each
            other, and the option takes no parameter.
            &quot; --banana &quot; and &quot; -b &quot; are aliases for each
            other, and the option takes a mandatory integer parameter.
            Finally, &quot; --pear &quot; and &quot; -p &quot; are aliases
            for each other, and the option may take an optional string parameter.
         Action Controllers Introduction Zend_Controller_Action  is an abstract class you may use
            for implementing Action Controllers for use with the Front
            Controller when building a website based on the
            Model-View-Controller (MVC) pattern.
         
            To use  Zend_Controller_Action , you will need to
            subclass it in your actual action controller classes (or subclass it
            to create your own base class for action controllers). The most
            basic operation is to subclass it, and create action methods that
            correspond to the various actions you wish the controller to handle
            for your site.  Zend_Controller&#39;s routing and dispatch handling will
            autodiscover any methods ending in &#39;Action&#39; in your class as
            potential controller actions.
         
            For example, let&#39;s say your class is defined as follows:
         
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // do something
    }

    public function bazAction()
    {
        // do something
    }
}

         
            The above  FooController  class (controller
             foo ) defines two actions,  bar  and
             baz .
         
            There&#39;s much more that can be accomplished than this, such as custom
            initialization actions, default actions to call should no action (or
            an invalid action) be specified, pre- and post-dispatch hooks, and a
            variety of helper methods. This chapter serves as an overview of the
            action controller functionality
         Default Behaviour 
                By default, the  front
                    controller  enables the  ViewRenderer 
                action helper. This helper takes care of injecting the view
                object into the controller, as well as automatically rendering
                views. You may disable it within your action controller via one
                of the following methods:
             &lt;?php
class FooController extends Zend_Controller_Action
{
    public function init()
    {
        // Local to this controller only; affects all actions, as loaded in init:
        $this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender(true);

        // Globally:
        $this-&gt;_helper-&gt;removeHelper(&#39;viewRenderer&#39;);

        // Also globally, but would need to be in conjunction with the local
        // version in order to propagate for this controller:
        Zend_Controller_Front::getInstance()-&gt;setParam(&#39;noViewRenderer&#39;, true);
    }
}
             initView() ,  getViewScript() ,
                 render() , and  renderScript()  each
                proxy to the  ViewRenderer  unless the helper is not
                in the helper broker or the  noViewRenderer  flag has
                been set.
             
                You can also simply disable rendering for an invididual view by
                setting the  ViewRenderer &#39;s  noRender 
                flag:
             &lt;?php
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // disable autorendering for this action only:
        $this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender();
    }
}
             
                The primary reasons to disable the  ViewRenderer  are
                if you simply do not need a view object or if you are not
                rendering via view scripts (for instance, when using an action
                controller to serve web service protocols such as SOAP, XML-RPC,
                or REST). In most cases, you will never need to globally disable
                the  ViewRenderer , only selectively within
                individual controllers or actions.
             Object initialization 
            While you can always override the action controller&#39;s constructor,
            we do not recommend this. Zend_Controller_Action::__construct()
            performs some important tasks, such as registering the request and
            response objects, as well as any custom invocation arguments passed
            in from the front controller. If you must override the constructor,
            be sure to call  parent::__construct($request, $response,
            $invokeArgs) .
         
            The more appropriate way to customize instantiation is to use the
             init()  method, which is called as the last task of
             __construct() .  For example, if you want to connect to
            a database at instantiation:
         
class FooController extends Zend_Controller_Action
{
    public function init()
    {
        $this-&gt;db = Zend_Db::factory(&#39;Pdo_Mysql&#39;, array(
            &#39;host&#39;     =&gt; &#39;myhost&#39;,
            &#39;username&#39; =&gt; &#39;user&#39;,
            &#39;password&#39; =&gt; &#39;XXXXXXX&#39;,
            &#39;dbname&#39;   =&gt; &#39;website&#39;
        ));
    }
}

         Pre- and Post-Dispatch Hooks Zend_Controller_Action  specifies two methods that may
            be called to bookend a requested action,  preDispatch() 
            and  postDispatch() . These can be useful in a variety of
            ways: verifying authentication and ACLs prior to running an action
            (by calling  _forward()  in  preDispatch() ,
            the action will be skipped), for instance, or placing generated
            content in a sitewide template ( postDispatch() ).
         Accessors 
            A number of objects and variables are registered with the object,
            and each has accessor methods.
         Request Object :  getRequest() 
                may be used to retrieve the request object used to call the
                action.
             Response Object :
                     getResponse()  may be used to retrieve the
                    response object aggregating the final response. Some typical
                    calls might look like:
                 
$this-&gt;getResponse()-&gt;setHeader(&#39;Content-Type&#39;, &#39;text/xml&#39;);
$this-&gt;getResponse()-&gt;appendBody($content);

                 Invocation Arguments : the front
                    controller may push parameters into the router, dispatcher,
                    and action controller. To retrieve these, use
                     getInvokeArg($key) ; alternatively, fetch the
                    entire list using  getInvokeArgs() .
                 Request parameters : The request object
                    aggregates request parameters, such as any _GET or _POST
                    parameters, or user parameters specified in the URL&#39;s path
                    information. To retrieve these, use
                     _getParam($key)  or
                     _getAllParams() . You may also set request
                    parameters using  _setParam() ; this is useful
                    when forwarding to additional actions.
                 
                    To test whether or not a parameter exists (useful for
                    logical branching), use  _hasParam($key) .
                 _getParam()  may take an optional second
                        argument containing a default value to use if the
                        parameter is not set or is empty. Using it eliminates
                        the need to call  _hasParam()  prior to
                        retrieving a value:
                     &lt;?php
// Use default value of 1 if id is not set
$id = $this-&gt;_getParam(&#39;id&#39;, 1);

// Instead of:
if ($this-&gt;_hasParam(&#39;id&#39;) {
    $id = $this-&gt;_getParam(&#39;id&#39;);
} else {
    $id = 1;
}
                     View Integration Zend_Controller_Action  provides a rudimentary and
            flexible mechanism for view integration. Two methods accomplish
            this,  initView()  and  render() ; the former
            method lazy-loads the  $view  public property, and the
            latter renders a view based on the current requested action, using
            the directory hierarchy to determine the script path.
         View Initialization initView()  initializes the view object.
                 render()  calls  initView()  in order to
                retrieve the view object, but it may be initialized at any time;
                by default it populates the  $view  property with a
                 Zend_View  object, but any class implementing
                 Zend_View_Interface  may be used. If
                 $view  is already initialized, it simply returns
                that property.
             
                The default implementation makes the following assumption of
                the directory structure:
             
applicationOrModule/
    controllers/
        IndexController.php
    views/
        scripts/
            index/
                index.phtml
        helpers/
        filters/

             
                In other words, view scripts are assumed to be in the
                 views/scripts/  subdirectory, and the
                 views  subdirectory is assumed to contain sibling
                functionality (helpers, filters). When determining the view
                script name and path, the  views/scripts/  directory
                will be used as the base path, with a directories named after the
                individual controllers providing a hierarchy of view scripts.
             Rendering Views render()  has the following signature:
             &lt;?php
string render(string $action = null, string $name = null, bool $noController = false);
             render()  renders a view script. If no arguments are
                passed, it assumes that the script requested is
                 [controller]/[action].phtml  (where
                 .phtml  is the value of the  $viewSuffix 
                property). Passing a value for  $action  will render
                that template in the  [controller]  subdirectory. To
                override using the  [controller]  subdirectory, pass
                a true value for  $noController . Finally, templates
                are rendered into the response object; if you wish to render to
                a specific  named
                    segment  in the response object, pass a value to
                 $name .
             
                    Since controller and action names may contain word delimiter
                    characters such as &#39;_&#39;, &#39;.&#39;, and &#39;-&#39;, render() normalizes
                    these to &#39;-&#39; when determining the script name. Internally,
                    it uses the dispatcher&#39;s word and path delimiters to do this
                    normalization. Thus, a request to
                     /foo.bar/baz-bat  will render the script
                     foo-bar/baz-bat.phtml . If your action method
                    contains camelCasing, please remember that this will result
                    in &#39;-&#39; separated words when determining the view script
                    file name.
             
                Some examples:
             &lt;?php
class MyController extends Zend_Controller_Action
{
    public function fooAction()
    {
        // Renders my/foo.phtml
        $this-&gt;render();

        // Renders my/bar.phtml
        $this-&gt;render(&#39;bar&#39;);

        // Renders baz.phtml
        $this-&gt;render(&#39;baz&#39;, null, true);

        // Renders my/login.phtml to the &#39;form&#39; segment of the response object
        $this-&gt;render(&#39;login&#39;, &#39;form&#39;);

        // Renders site.phtml to the &#39;page&#39; segment of the response object; does
        // not use the &#39;my/&#39; subirectory
        $this-&gt;render(&#39;site&#39;, &#39;page&#39;, true);
    }

    public function bazBatAction()
    {
        // Renders my/baz-bat.phtml
        $this-&gt;render();
    }
}
             Utility Methods 
            Besides the accessors and view integration methods,
             Zend_Controller_Action  has several utility methods for
            performing common tasks from within your action methods (or from
            pre-/post-dispatch).
         _forward($action, $controller = null, $module = null,
                        array $params = null) : perform another action. If
                    called in  preDispatch() , the currently
                    requested action will be skipped in favor of the new one.
                    Otherwise, after the current action is processed, the action
                    requested in _forward() will be executed.
                 _redirect($url, array $options =
                        array()) : redirect to another location. This
                    method takes a URL and an optional set of options. By
                    default, it performs an HTTP 302 redirect.
                 
                    The options may include one or more of the following:
                 exit:  whether or not to exit
                            immediately. If requested, it will cleanly close any
                            open sessions and perform the redirect.
                         
                            You may set this option globally within the
                            controller using the  setRedirectExit() 
                            accessor.
                         prependBase:  whether or not to
                            prepend the base URL registered with the request
                            object to the URL provided.
                         
                            You may set this option globally within the
                            controller using the
                             setRedirectPrependBase()  accessor.
                         code:  what HTTP code to utilize
                            in the redirect. By default, an HTTP 302 is
                            utilized; any code between 301 and 306 may be used.
                         
                            You may set this option globally within the
                            controller using the
                             setRedirectCode()  accessor.
                         Subclassing the Action Controller 
            By design,  Zend_Controller_Action  must be subclassed
            in order to create an action controller. At the minimum, you will
            need to define action methods that the controller may call.
         
            Besides creating useful functionality for your web applications, you
            may also find that you&#39;re repeating much of the same setup or
            utility methods in your various controllers; if so, creating a
            common base controller class that extends
             Zend_Controller_Action  could solve such redundancy.
         How to Handle Non-Existent Actions 
                If a request to a controller is made that includes an undefined
                action method,  Zend_Controller_Action::__call() 
                will be invoked.  __call()  is, of course, PHP&#39;s
                magic method for method overloading.
             
                By default, this method throws a
                 Zend_Controller_Action_Exception  indicating the
                requested method was not found in the controller. If the method
                requested ends in &#39;Action&#39;, the assumption is that an action was
                requested and does not exist; such errors result in an exception
                with a code of 404. All other methods result in an exception
                with a code of 500. This allows you to easily differentiate
                between page not found and application errors in your error
                handler.
             
                You should override this functionality if you wish to perform
                other operations.  For instance, if you wish to display an error
                message, you might write something like this:
             &lt;?php
class MyController extends Zend_Controller_Action
{
    public function __call($method, $args)
    {
        if (&#39;Action&#39; == substr($method, -6)) {
            // If the action method was not found, render the error template
            return $this-&gt;render(&#39;error&#39;);
        }

        // all other methods throw an exception
        throw new Exception(&#39;Invalid method &quot;&#39; . $method . &#39;&quot; called&#39;, 500);
    }
}
             
                Another possibility is that you may want to forward on to a
                default controller page:
             &lt;?php
class MyController extends Zend_Controller_Action
{
    public function indexAction()
    {
        $this-&gt;render();
    }

    public function __call($method, $args)
    {
        if (&#39;Action&#39; == substr($method, -6)) {
            // If the action method was not found, forward to the index action
            return $this-&gt;_forward(&#39;index&#39;);
        }

        // all other methods throw an exception
        throw new Exception(&#39;Invalid method &quot;&#39; . $method . &#39;&quot; called&#39;, 500);
    }
}
             
            Besides overriding  __call() , each of the
            initialization, utility, accessor, view, and dispatch hook methods
            mentioned previously in this chapter may be overridden in order to
            customize your controllers. As an example, if you are storing your
            view object in a registry, you may want to modify your
             initView()  method with code resembling the following:
         &lt;?php
abstract class My_Base_Controller extends Zend_Controller_Action
{
    public function initView()
    {
        if (null === $this-&gt;view) {
            if (Zend_Registry::isRegistered(&#39;view&#39;)) {
                $this-&gt;view = Zend_Registry::get(&#39;view&#39;);
            } else {
                $this-&gt;view = new Zend_View();
                $this-&gt;view-&gt;setBasePath(dirname(__FILE__) . &#39;/../views&#39;);
            }
        }

        return $this-&gt;view;
    }
}
         
            Hopefully, from the information in this chapter, you can see the
            flexibility of this particular component and how you can shape it to
            your application&#39;s or site&#39;s needs.
         ActionStack 
        The  ActionStack  helper allows you to push requests to the
         ActionStack 
        front controller plugin, effectively helping you create a queue of
        actions to execute during the request.  The helper allows you to add
        actions either by specifying new request objects or
        action/controller/module sets.
     Invoking ActionStack helper initializees ActionStack Plugin 
            Invoking the  ActionStack  helper implicitly registers
            the  ActionStack  plugin -- which means you do not need
            to explicitly register the  ActionStack  plugin to use
            this functionality.
         Adding a task using action, controller and module names 
            Often, it&#39;s simplest to simply specify the action, controller, and
            module (and optional request parameters), much as you would when
            calling  Zend_Controller_Action::_forward() :
         &lt;?php
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // Add two actions to the stack
        // Add call to /foo/baz/bar/baz
        // (FooController::bazAction() with request var bar == baz)
        $this-&gt;_helper-&gt;actionStack(&#39;baz&#39;, &#39;foo&#39;, &#39;default&#39;, array(&#39;bar&#39; =&gt; &#39;baz&#39;));

        // Add call to /bar/bat
        // (BarController::batAction())
        $this-&gt;_helper-&gt;actionStack(&#39;bat&#39;, &#39;bar&#39;);
    }
}
?&gt; Adding a task using a request object 
            Sometimes the OOP nature of a request object makes most sense; you
            can pass such an object to the  ActionStack  helper as
            well.
         &lt;?php
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // Add two actions to the stack
        // Add call to /foo/baz/bar/baz
        // (FooController::bazAction() with request var bar == baz)
        $request = clone $this-&gt;getRequest();
        $request-&gt;setActionName(&#39;baz&#39;)              // don&#39;t set controller or 
                -&gt;setParams(array(&#39;bar&#39; =&gt; &#39;baz&#39;)); // module; use current values
        $this-&gt;_helper-&gt;actionStack($request);

        // Add call to /bar/bat
        // (BarController::batAction())
        $request = clone $this-&gt;getRequest();
        $request-&gt;setActionName(&#39;bat&#39;)      // don&#39;t set module; use current
                -&gt;setControllerName(&#39;bar&#39;); // value
        $this-&gt;_helper-&gt;actionStack($request);
    }
}
?&gt; AutoComplete 
        Many AJAX javascript libraries offer functionality for providing
        autocompletion whereby a selectlist of potentially matching results is
        displayed as the user types.  The  AutoComplete  helper aims
        to simplify returning acceptable responses to such methods.
     
        Since not all JS libraries implement autocompletion in the same way, the
         AutoComplete  helper provides some abstract base
        functionality necessary to many libraries, and concrete implementations
        for individual libraries. Return types are generally either JSON arrays
        of strings, JSON arrays of arrays (with each member array being an
        associative array of metadata used to create the selectlist), or HTML.
     
        Basic usage for each implementation is the same:
     &lt;?php
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // Perform some logic...

        // Encode and send response;
        $this-&gt;_helper-&gt;autoCompleteDojo($data);

        // Or explicitly:
        $response = $this-&gt;_helper-&gt;autoCompleteDojo-&gt;sendAutoCompletion($data);

        // Or simply prepare autocompletion response:
        $response = $this-&gt;_helper-&gt;autoCompleteDojo-&gt;prepareAutoCompletion($data);
    }
}
?&gt; 
        By default, autocompletion does the following:
     
                Disables layouts and ViewRenderer.
         
                Sets appropriate response headers.
         
                Sets response body with encoded/formatted autocompletion data.
         
                Sends response.
         
        Available methods of the helper include:
     disableLayouts()  can be used to disable layouts and
                the ViewRenderer. Typically, this is called within
                 prepareAutoCompletion() .
         encodeJson($data, $keepLayouts = false)  will encode
                data to JSON, optionally enabling or disabling layouts.
                Typically, this is called within
                 prepareAutoCompletion() .
         prepareAutoCompletion($data, $keepLayouts = false) 
                is used to prepare data in the response format necessary for the
                concrete implementation, optionally enabling or disabling
                layouts. The return value will vary based on the implementation.
         sendAutoCompletion($data, $keepLayouts = false) 
                is used to send data in the response format necessary for the
                concrete implementation. It calls
                 prepareAutoCompletion() , and then sends the
                response.
         direct($data, $sendNow = true, $keepLayouts =
                    false)  is used when calling the helper as a method of
                the helper broker. The  $sendNow  flag is used to
                determine whether to call  sendAutoCompletion()  or
                 prepareAutoCompletion() , respectively.
         
        Currently,  AutoComplete  supports the Dojo and Scriptaculous
        AJAX libraries.
     AutoCompletion with Dojo 
            Dojo does not have an AutoCompletion widget per se, but has two
            widgets that can perform AutoCompletion: ComboBox and
            FilteringSelect. In both cases, they require a data store that
            implements the QueryReadStore; for more information on these topics,
            see the  dojo.data 
            documentation.
         
            In Zend Framework, you can pass a simple indexed array to the
            AutoCompleteDojo helper, and it will return a JSON response suitable
            for use with such a store:
         &lt;?php
// within a controller action:
$this-&gt;_helper-&gt;autoCompleteDojo($data);
 AutoCompletion with Dojo Using Zend MVC 
                AutoCompletion with Dojo via the Zend MVC requires several
                things: generating a form object for the ComboBox on which you
                want AutoCompletion, a controller action for serving the
                AutoCompletion results, creating a custom QueryReadStore to connect
                to the AutoCompletion action, and generation of the javascript
                to use to initialize AutoCompletion on the server side.
             
                First, let&#39;s look at the javascript necessary. Dojo offers a
                complete framework for creating OOP javascript, much as Zend
                Framework does for PHP. Part of that is the ability to create
                pseudo-namespaces using the directory hierarchy. We&#39;ll create a
                &#39;custom&#39; directory at the same level as the Dojo directory
                that&#39;s part of the Dojo distribution. Inside that directory,
                we&#39;ll create a javascript file, TestNameReadStore.js, with the
                following contents:
             
dojo.provide(&quot;custom.TestNameReadStore&quot;);
dojo.declare(&quot;custom.TestNameReadStore&quot;, dojox.data.QueryReadStore, {
    fetch:function (request) {
        request.serverQuery = { test:request.query.name };
        return this.inherited(&quot;fetch&quot;, arguments);
    }
});
 
                This class is simply an extenstion of Dojo&#39;s own QueryReadStore,
                which is itself an abstract class. We simply define a method by
                which to request, and assigning it to the &#39;test&#39; element.
             
                Next, let&#39;s create the form element for which we want
                AutoCompletion:
             &lt;?php
class TestController extends Zend_Controller_Action
{
    protected $_form;

    public function getForm()
    {   
        if (null === $this-&gt;_form) {
            require_once &#39;Zend/Form.php&#39;;
            $this-&gt;_form = new Zend_Form();
            $this-&gt;_form-&gt;setMethod(&#39;get&#39;)
                -&gt;setAction($this-&gt;getRequest()-&gt;getBaseUrl() . &#39;/test/process&#39;)
                -&gt;addElements(array(
                    &#39;test&#39; =&gt; array(&#39;type&#39; =&gt; &#39;text&#39;, &#39;options&#39; =&gt; array(
                        &#39;filters&#39;        =&gt; array(&#39;StringTrim&#39;),
                        &#39;dojoType&#39;       =&gt; array(&#39;dijit.form.ComboBox&#39;),
                        &#39;store&#39;          =&gt; &#39;testStore&#39;,
                        &#39;autoComplete&#39;   =&gt; &#39;false&#39;,
                        &#39;hasDownArrow&#39;   =&gt; &#39;true&#39;,
                        &#39;label&#39; =&gt; &#39;Your input:&#39;,
                    )),
                    &#39;go&#39; =&gt; array(&#39;type&#39; =&gt; &#39;submit&#39;, &#39;options&#39; =&gt; array(&#39;label&#39; =&gt; &#39;Go!&#39;))
                ));
        }
        return $this-&gt;_form;
    }
}
 
                Here, we simply create a form with &#39;test&#39; and &#39;go&#39; methods. The
                &#39;test&#39; method adds several special, Dojo-specific attributes:
                dojoType, store, autoComplete, and hasDownArrow. The dojoType is
                used to indicate that we are creating a ComboBox, and we will
                link it to a data store (key &#39;store&#39;) of &#39;testStore&#39; -- more on
                that later. Specifying &#39;autoComplete&#39; as false tells Dojo not to
                automatically select the first match, but instead show a list of
                matches. Finally, &#39;hasDownArrow&#39; creates a down arrow similar to
                a select box so we can show and hide the matches.
             
                Let&#39;s add a method to display the form, as well as an end point
                for processing AutoCompletion:
             &lt;?php
class TestController extends Zend_Controller_Action
{
    // ...

    /**
     * Landing page
     */
    public function indexAction()
    {
        $this-&gt;view-&gt;form = $this-&gt;getForm();
    }

    public function autocompleteAction()
    {
        if (&#39;ajax&#39; != $this-&gt;_getParam(&#39;format&#39;, false)) {
            return $this-&gt;_helper-&gt;redirector(&#39;index&#39;);
        }
        if ($this-&gt;getRequest()-&gt;isPost()) {
            return $this-&gt;_helper-&gt;redirector(&#39;index&#39;);
        }

        $match = trim($this-&gt;getRequest()-&gt;getQuery(&#39;test&#39;, &#39;&#39;));

        $matches = array();
        foreach ($this-&gt;getData() as $datum) {
            if (0 === strpos($datum, $match)) {
                $matches[] = $datum;
            }
        }
        $this-&gt;_helper-&gt;autoCompleteDojo($matches);
    }
}
 
                In our  autocompleteAction()  we do a number of
                things. First, we look to make sure we have a post request, and
                that there is a &#39;format&#39; parameter set to the value &#39;ajax&#39;;
                these are simply to help reduce spurious queries to the action.
                Next, we check for a &#39;test&#39; parameter, and compare it against
                our data. (I purposely leave out the implementation of
                 getData()  here -- it could be any sort of data
                source.) Finally, we send our matches to our AutoCompletion
                helper.
             
                Now that we have all the pieces on the backend, let&#39;s look at
                what we need to deliver in our view script for the landing page.
                First, we need to setup our data store, then render our form,
                and finally ensure that the appropriate Dojo libraries --
                including our custom data store -- get loaded. Let&#39;s look at the
                view script, which comments the steps:
             
&lt;? // setup our data store: ?&gt;
&lt;div dojoType=&quot;custom.TestNameReadStore&quot; jsId=&quot;testStore&quot;
    url=&quot;&lt;?= $this-&gt;baseUrl() ?&gt;/unit-test/autocomplete/format/ajax&quot; requestMethod=&quot;get&quot;&gt;&lt;/div&gt;

&lt;? // render our form: ?&gt;
&lt;?= $this-&gt;form ?&gt;

&lt;? // setup Dojo-related CSS to load in HTML head: ?&gt;
&lt;? $this-&gt;headStyle()-&gt;captureStart() ?&gt;
@import &quot;&lt;?= $this-&gt;baseUrl() ?&gt;/javascript/dijit/themes/tundra/tundra.css&quot;;
@import &quot;&lt;?= $this-&gt;baseUrl() ?&gt;/javascript/dojo/resources/dojo.css&quot;;
&lt;? $this-&gt;headStyle()-&gt;captureEnd() ?&gt;

&lt;? // setup javascript to load in HTML head, including all required Dojo
   // libraries: ?&gt;
&lt;? $this-&gt;headScript()
        -&gt;setAllowArbitraryAttributes(true)
        -&gt;appendFile($this-&gt;baseUrl() . &#39;/javascript/dojo/dojo.js&#39;, 
            &#39;text/javascript&#39;, 
            array(&#39;djConfig&#39; =&gt; &#39;parseOnLoad: true&#39;))
        -&gt;captureStart() ?&gt;
djConfig.usePlainJson=true;
dojo.registerModulePath(&quot;custom&quot;,&quot;../custom&quot;);
dojo.require(&quot;dojo.parser&quot;);
dojo.require(&quot;dojox.data.QueryReadStore&quot;);
dojo.require(&quot;dijit.form.ComboBox&quot;);
dojo.require(&quot;custom.TestNameReadStore&quot;);
&lt;? $this-&gt;headScript()-&gt;captureEnd() ?&gt;
 
                Note the calls to view helpers such as headStyle and headScript;
                these are placeholders, which we can then render in the HTML
                head section of our layout view script.
             
                We now have all the pieces to get Dojo AutoCompletion working.
             AutoCompletion with Scriptaculous Scriptaculous 
            expects an HTML response in a specific format.
         
            The helper to use with this library is &#39;AutoCompleteScriptaculous&#39;.
            Simply provide it an array of data, and the helper will create an
            HTML response compatible with Ajax.Autocompleter.
         ContextSwitch and AjaxContext 
        The  ContextSwitch  action helper is intended for
        facilitating returning different response formats on request.
        The  AjaxContext  helper is a specialized version of
         ContextSwitch  that facilitates returning responses
        to XmlHttpRequests.
     
        To enable either one, you must provide hinting in your controller as to
        what actions can respond to which contexts. If an incoming request
        indicates a valid context for the given action, the helper will then:
     
                Disable layouts, if enabled.
         
                Set an alternate view suffix, effectively requiring a separate
                view script for the context.
         
                Send approprite response headers for the context desired.
         
                Optionally, call specified callbacks to setup the context and/or
                perform post-processing.
         
        As an example, let&#39;s consider the following controller:
     &lt;?php
class NewsController extends Zend_Controller_Action
{
    /**
     * Landing page; forwards to listAction()
     */
    public function indexAction()
    {
        $this-&gt;_forward(&#39;list&#39;);
    }

    /**
     * List news items
     */
    public function listAction()
    {
    }

    /**
     * View a news item
     */
    public function viewAction()
    {
    }
}
?&gt; 
        Let&#39;s say that we want the  listAction()  to also be
        available in an XML format. Instead of creating a different action, we
        can hint that it can return an XML response:
     &lt;?php
class NewsController extends Zend_Controller_Action
{
    public function init()
    {
        $contextSwitch = $this-&gt;_helper-&gt;getHelper(&#39;contextSwitch&#39;);
        $contextSwitch-&gt;addActionContext(&#39;list&#39;, &#39;xml&#39;)
                      -&gt;initContext();
    }

    // ...
}
?&gt; 
        What this will do is:
     
                Set the &#39;Content-Type&#39; response header to &#39;text/xml&#39;.
         
                Change the view suffix to &#39;xml.phtml&#39; (or, if you use an
                alternate view suffix, &#39;xml.[your suffix]&#39;).
         
        Now, you&#39;ll need to create a new view script, &#39;news/list.xml.phtml&#39;,
        which will create and render the XML.
     
        To determine if a request should initiate a context switch, the helper
        checks for a token in the request object. By default, it looks for the
        &#39;format&#39; parameter, though this may be configured. This means that, in
        most cases, to trigger a context switch, you can add a &#39;format&#39;
        parameter to your request:
     
                Via URL parameter:  /news/list/format/xml  (recall,
                the default routing schema allows for arbitrary key/value pairs
                following the action)
         
                Via GET parameter:  /news/list?format=xml 
         ContextSwitch  allows you to specify arbitrary contexts,
        including what suffix change will occur (if any), any response headers
        that should be sent, and arbitrary callbacks for initialization and post
        processing.
     Default Contexts Available 
            By default, two contexts are available to the
             ContextSwitch  helper: json and xml.
         JSON . The JSON context sets the
                    &#39;Content-Type&#39; response header to &#39;application/json&#39;, and
                    the view script suffix to &#39;json.phtml&#39;.
                 
                    By default, however, no view script is required. It will
                    simply serialize all view variables, and emit the JSON
                    response immediately.
                 
                    This behaviour can be disabled by turning off auto-JSON
                    serialization:
                 &lt;?php
$this-&gt;_helper-&gt;contextSwitch()-&gt;setAutoJsonSerialization(false);
?&gt; XML . The XML context sets the
                    &#39;Content-Type&#39; response header to &#39;text/xml&#39;, and the view
                    script suffix to &#39;xml.phtml&#39;. You will need to create a new
                    view script for the context.
                 Creating Custom Contexts 
            Sometimes, the default contexts are not enough. For instance, you
            may wish to return YAML, or serialized PHP, an RSS or ATOM feed,
            etc.  ContextSwitch  allows you to do so.
         
            The easiest way to add a new context is via the
             addContext()  method. This method takes two arguments,
            the name of the context, and an array specification. The
            specification should include one or more of the following:
         suffix : the suffix to prepend to the
                default view suffix as registered in the ViewRenderer. headers : an array of header/value
                    pairs you wish sent as part of the response. callbacks : an array containing one or
                more of the keys &#39;init&#39; or &#39;post&#39;, pointing to valid PHP
                callbacks that can be used for context initialization and post
                processing. Initialization callbacks occur when the context is
                detected by  ContextSwitch . You can use it to
                perform arbitrary logic that should occur. As an example,
                the JSON context uses a callback to disable the ViewRenderer
                when auto-JSON serialization is on. Post processing occurs during the action&#39;s
                 postDispatch()  routine, and can be used to perform
                arbitrary logic. As an example, the JSON context uses a callback
                to determine if auto-JSON serialization is on; if so, it
                serializes the view variables to JSON and sends the response,
                but if not, it re-enables the ViewRenderer. 
            There are a variety of methods for interacting with contexts:
         addContext($context, array $spec) : add a new
                context. Throws an exception if the context already exists.
             setContext($context, array $spec) : add a new
                context or overwrite an existing context. Uses the same
                specification as  addContext() .
             addContexts(array $contexts) : add many contexts at
                once. The  $contexts  array should be an array of
                context/specification pairs.  If any of the contexts already
                exists, it will throw an exception.
             setContexts(array $contexts) : add new contexts and
                overwrite existing ones. Uses the same specification as
                 addContexts() .
             hasContext($context) : returns true if the context
                exists, false otherwise.  
             getContext($context) : retrieve a
                    single context by name. Returns an array following the
                    specification used in  addContext() .
             getContexts() : retrieve all contexts. Returns an
                array of context/specification pairs.
             removeContext($context) : remove a single context by
                name. Returns true if successful, false if the context was not
                found.
             clearContexts() : remove all contexts.
             Setting Contexts Per Action 
            There are two mechanisms for setting available contexts. You can
            either manually create arrays in your controller, or use several
            methods in  ContextSwitch  to assemble them.
         
            The principle method for adding action/context relations is
             addActionContext() . It expects two arguments, the
            action to which the context is being added, and either the name of a
            context or an array of contexts. As an example, consider the
            following controller class:
         &lt;?php
class FooController extends Zend_Controller_Action
{
    public function listAction()
    {
    }

    public function viewAction()
    {
    }

    public function commentsAction()
    {
    }

    public function updateAction()
    {
    }
}
?&gt; 
            Let&#39;s say we wanted to add an XML context to the &#39;list&#39; action, and
            XML and JSON contexts to the &#39;comments&#39; action. We could do so in
            the  init()  method:
         &lt;?php
class FooController extends Zend_Controller_Action
{
    public function init()
    {
        $this-&gt;_helper-&gt;contextSwitch()
             -&gt;addActionContext(&#39;list&#39;, &#39;xml&#39;)
             -&gt;addActionContext(&#39;comments&#39;, array(&#39;xml&#39;, &#39;json&#39;))
             -&gt;initContext();
    }
}
?&gt; 
            Alternately, you could simply define the array property
             $contexts :
         &lt;?php
class FooController extends Zend_Controller_Action
{
    public $contexts = array(
        &#39;list&#39;     =&gt; array(&#39;xml&#39;),
        &#39;comments&#39; =&gt; array(&#39;xml&#39;, &#39;json&#39;)
    );

    public function init()
    {
        $this-&gt;_helper-&gt;contextSwitch()-&gt;initContext();
    }
}
?&gt; 
            The above is less overhead, but also prone to potential errors.
         
            The following methods can be used to build the context mappings:
         addActionContext($action, $context) : marks one
                    or more contexts as available to an action. If mappings
                    already exists, simply appends to those mappings.
                     $context  may be a single context, or an array
                    of contexts.
                 
                    A value of  true  for the context will mark
                    all available contexts as available for the action.
                 
                    An empty value for $context will disable all contexts for
                    the given action.
                 setActionContext($action, $context) : marks one
                    or more contexts as available to an action. If mappings
                    already exists, it replaces them with those specified.
                     $context  may be a single context, or an array
                    of contexts.
             addActionContexts(array $contexts) : add several
                    action/context pairings at once.  $contexts 
                    should be an associative array of action/context pairs. It
                    proxies to  addActionContext() , meaning that if
                    pairings already exist, it appends to them.
             setActionContexts(array $contexts) : acts like
                     addActionContexts() , but overwrites existing
                    action/context pairs.
             hasActionContext($action, $context) : determine
                    if a particular action has a give context.
             getActionContexts($action = null) : returns
                    either all contexts for a given action, or all
                    action/context pairs.
             removeActionContext($action, $context) : remove
                    one or more contexts from a given action.
                     $context  may be a single context or an array of
                    contexts.
             clearActionContexts($action = null) : remove all
                    contexts from a given action, or from all actions with
                    contexts.
             Initializizing Context Switching 
            To initialize context switching, you need to call
             initContext()  in your action controller:
         &lt;?php
class NewsController extends Zend_Controller_Action
{
    public function init()
    {
        $this-&gt;_helper-&gt;contextSwitch()-&gt;initContext();
    }
}
?&gt; 
            In some cases, you may want to force the context used; for instance,
            you may only want to allow the XML context if context switching is
            activated. You can do so by passing the context to
             initContext() :
         &lt;?php
$contextSwitch-&gt;initContext(&#39;xml&#39;);
?&gt; Additional Functionality 
            A variety of methods can be used to alter the behaviour of the
             ContextSwitch  helper. These include:
         setAutoJsonSerialization($flag) : By default,
                    JSON contexts will serialize any view variables to JSON
                    notation and return this as a response. If you wish to
                    create your own response, you should turn this off; this
                    needs to be done prior to the call to
                     initContext() .
                 &lt;?php
$contextSwitch-&gt;setAutoJsonSerialization(false);
$contextSwitch-&gt;initContext();
?&gt; 
                    You can retrieve the value of the flag with
                     getAutoJsonSerialization() .
                 setSuffix($context, $suffix,
                        $prependViewRendererSuffix) : With this method,
                    you can specify a different suffix to use for a given
                    context. The third argument is used to indicate whether or
                    not to prepend the current ViewRenderer suffix with the new
                    suffix; this flag is enabled by default.
                 
                    Passing an empty value to the suffix will cause only the
                    ViewRenderer suffix to be used.
                 addHeader($context, $header, $content) : Add a
                    response header for a given context.  $header  is
                    the header name, and  $content  is the value to
                    pass for that header.
                 
                    Each context can have multiple headers;
                     addHeader()  adds additional headers to the
                    context&#39;s header stack.
                 
                    If the  $header  specified already exists for the
                    context, an exception will be thrown.
                 setHeader($context, $header, $content) :
                     setHeader()  acts just like
                     addHeader() , except it allows you to overwrite
                    existing context headers.
                 addHeaders($context, array $headers) : Add
                    multiple headers at once to a given context. Proxies to
                     addHeader() , so if the header already exists,
                    an exception will be thrown.  $headers  is an
                    array of header/context pairs.
                 setHeaders($context, array $headers.) : like
                     addHeaders() , except it proxies to
                     setHeader() , allowing you to overwrite existing
                    headers.
                 getHeader($context, $header) : retrieve the
                    value of a header for a given context. Returns null if not
                    found.
                 removeHeader($context, $header) : remove a
                    single header for a given context.
                 clearHeaders($context, $header) : remove all
                    headers for a given context.
                 setCallback($context, $trigger, $callback) : set
                    a callback at a given trigger for a given context. Triggers
                    may be either &#39;init&#39; or &#39;post&#39; (indicating callback will be
                    called at either context initialization or postDispatch).
                     $callback  should be a valid PHP callback.
                 setCallbacks($context, array $callbacks) : set
                    multiple callbacks for a given context.  $callbacks  
                    should be trigger/callback pairs. In actuality, the most callbacks
                    that can be registered are two, one for initialization and
                    one for post processing.
                 getCallback($context, $trigger) : retrieve a
                    callback for a given trigger in a given context.
                 getCallbacks($context) : retrieve all callbacks
                    for a given context. Returns an array of trigger/callback
                    pairs.
                 removeCallback($context, $trigger) : remove a
                    callback for a given trigger and context.
                 clearCallbacks($context) : remove all
                    callbacks for a given context.
                 setContextParam($name) : set the request
                    parameter to check when determining if a context switch has
                    been requested. The value defaults to &#39;format&#39;, but this
                    accessor can be used to set an alternate value.
                 getContextParam()  can be used to retrieve the
                    current value.
                 setAutoDisableLayout($flag) : By default,
                    layouts are disabled when a context switch occurs; this is
                    because typically layouts will only be used for returning
                    normal responses, and have no meaning in alternate contexts.
                    However, if you wish to use layouts (perhaps you may have a
                    layout for the new context), you can change this behaviour
                    by passing a true value to
                     setAutoDisableLayout() . You should do this
                     before  calling
                     initContext() .
                 
                    To get the value of this flag, use the accessor
                     getAutoDisableLayout() .
                 getCurrentContext()  can be used to determine
                    what context was detected, if any. This returns null if no
                    context switch occurred, or if called before
                     initContext()  has been invoked.
                 AjaxContext Functionality 
            The  AjaxContext  helper extends
             ContextSwitch , so all of the functionality listed for
             ContextSwitch  is available to it. There are a few key
            differences, however.
         
            First, it uses a different action controller property for
            determining contexts,  $ajaxable . This is so you can
            have different contexts used for AJAX versus normal HTTP requests.
            The various  *ActionContext*()  methods of
             AjaxContext  will write to this property.
         
            Second, it will only trigger if an XmlHttpRequest has occurred, as
            determined by the request object&#39;s  isXmlHttpRequest() 
            method. Thus, if the context parameter (&#39;format&#39;) is passed in the
            request, but the request was not made as an XmlHttpRequest, no
            context switch will trigger.
         
            Third,  AjaxContext  adds an additional context, HTML. In
            this context, it sets the suffix to &#39;ajax.phtml&#39; in order to
            differentiate the context from a normal request. No additional
            headers are returned.
         Allowing Actions to Respond To Ajax Requests 
                In this following example, we&#39;re allowing requests to the
                actions &#39;view&#39;, &#39;form&#39;, and &#39;process&#39; to respond to AJAX
                requests. In the first two cases, &#39;view&#39; and &#39;form&#39;, we&#39;ll
                return HTML snippets with which to update the page; in the
                latter, we&#39;ll return JSON.
             &lt;?php
class CommentController extends Zend_Controller_Action
{
    public function init()
    {
        $ajaxContext = $this-&gt;_helper-&gt;getHelper(&#39;AjaxContext&#39;);
        $ajaxContext-&gt;addActionContext(&#39;view&#39;, &#39;html&#39;)
                    -&gt;addActionContext(&#39;form&#39;, &#39;html&#39;)
                    -&gt;addActionContext(&#39;process&#39;, &#39;json&#39;)
                    -&gt;initContext();
    }

    public function viewAction()
    {
        // Pull a single comment to view.
        // When AjaxContext detected, uses the comment/view.ajax.phtml 
        // view script.
    }

    public function formAction()
    {
        // Render the &quot;add new comment&quot; form.
        // When AjaxContext detected, uses the comment/form.ajax.phtml 
        // view script.
    }

    public function processAction()
    {
        // Process a new comment
        // Return the results as JSON; simply assign the results as view
        // variables, and JSON will be returned.
    }
}
?&gt; 
                On the client end, your AJAX library will simply request the
                endpoints &#39;/comment/view&#39;, &#39;/comment/form&#39;, and
                &#39;/comment/process&#39;, and pass the &#39;format&#39; parameter:
                &#39;/comment/view/format/html&#39;, &#39;/comment/form/format/html&#39;,
                &#39;/comment/process/format/json&#39;. (Or you can pass the parameter
                via query string: e.g., &quot;?format=json&quot;.)
             
                Assuming your library passes the &#39;X-Requested-With:
                XmlHttpRequest&#39; header, these actions will then return the
                appropriate response format.
             FlashMessenger Introduction 
            The  FlashMessenger  helper allows you to pass messages
            that the user may need to see on the next request.  To accomplish
            this,  FlashMessenger  uses
             Zend_Session_Namespace  to store messages for future or
            next request retrieval.  It is generally a good idea that if you
            plan on using  Zend_Session  or
             Zend_Session_Namespace , that you initialize with
             Zend_Session::start()  in your bootstrap file.  (See the
             Zend_Session 
            documentation for more details on its usage.)
         Basic Usage Example 
            The usage example below shows the use of the flash messenger at its
            most basic. When the action  /some/my  is called, it adds
            the flash message &quot;Record Saved!&quot; A subsequent request to the action
             /some/my-next-request  will retrieve it (and thus delete
            it as well).
         &lt;?php
class SomeController extends Zend_Controller_Action
{
    /**
     * FlashMessenger
     *
     * @var Zend_Controller_Action_Helper_FlashMessenger
     */
    protected $_flashMessenger = null;

    public function init()
    {
        $this-&gt;_flashMessenger = $this-&gt;_helper-&gt;getHelper(&#39;FlashMessenger&#39;);
        $this-&gt;initView();
    }

    public function myAction()
    {
        /**
         * default method of getting Zend_Controller_Action_Helper_FlashMessenger
         * instance on-demand
         */
        $this-&gt;_flashMessenger-&gt;addMessage(&#39;Record Saved!&#39;);
    }

    public function myNextRequestAction()
    {
        $this-&gt;view-&gt;messages = $this-&gt;_flashMessenger-&gt;getMessages();
        $this-&gt;render();
    }
}
         JSON 
        JSON responses are rapidly becoming the response of choice when dealing
        with AJAX requests that expect dataset responses; JSON can be
        immediately parsed on the client-side, leading to quick execution.
     
        The JSON action helper does several things:
     
                Disables layouts if currently enabled.
         
                Disables the ViewRenderer if currently enabled.
         
                Sets the &#39;Content-Type&#39; response header to &#39;application/json&#39;.
         
                By default, immediately returns the response, without waiting
                for the action to finish execution.
         
        Usage is simple: either call it as a method of the helper broker, or
        call one of the methods  encodeJson()  or
         sendJson() :
     &lt;?php
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // do some processing...
        // Send the JSON response:
        $this-&gt;_helper-&gt;json($data);

        // or...
        $this-&gt;_helper-&gt;json-&gt;sendJson($data);

        // or retrieve the json:
        $json = $this-&gt;_helper-&gt;json-&gt;encodeJson($data);
    }
}
?&gt; Keeping Layouts 
            If you have a separate layout for JSON responses -- perhaps to wrap
            the JSON response in some sort of context -- each method in the JSON
            helper accepts a second, optional argument: a flag to enable or
            disable layouts. Passing a boolean  true  value will keep
            layouts enabled:
         &lt;?php
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // Retrieve the json, keeping layouts:
        $json = $this-&gt;_helper-&gt;json-&gt;encodeJson($data, true);
    }
}
?&gt; Redirector Introduction 
            The  Redirector  helper allows you to use a redirector
            object to fufill your application&#39;s needs for redirecting to a new
            URL. It provides numerous benefits over the
             _redirect()  method, such as being able to preconfigure
            sitewide behavior into the redirector object or using the built in
             goto($action, $controller, $module, $params)  interface
            similar to that of  Zend_Controller_Action::_forward() .
         
            The  Redirector  has a number of methods that can be used
            to affect the behaviour at redirect:
         setCode()  can be used to set the HTTP response
                    code to use during the redirect.
                 setExit()  can be used to force an
                     exit()  following a redirect. By default this is
                    true.
                 setGoto()  can be used to set a default URL to
                    use if none is passed to  goto() . Uses the API
                    of  Zend_Controller_Action::_forward() :
                    setgoto($action, $controller = null, $module = null, array
                    $params = array());
                 setGotoRoute()  can be used to set a URL
                    based on a registered route. Pass in an array of key/value
                    pairs and a route name, and it will assemble the URL
                    according to the route type and definition.
                 setGotoUrl()  can be used to set a default URL to
                    use if none is passed to  gotoUrl() . Accepts a
                    single URL string.
                 setPrependBase()  can be used to prepend the
                    request object&#39;s base URL to a URL specified with
                     setGotoUrl() ,  gotoUrl() , or
                     gotoUrlAndExit() .
                 setUseAbsoluteUri()  can be used to force the
                     Redirector  to use absolute URIs when
                    redirecting. When this option is set, it uses the value of
                     $_SERVER[&#39;HTTP_HOST&#39;] ,
                     $_SERVER[&#39;SERVER_PORT&#39;] , and
                     $_SERVER[&#39;HTTPS&#39;]  to form a full URI to the URL
                    specified by one of the redirect methods. This option is off
                    by default, but may be enabled by default in later releases.
                 
            Additionally, there are a variety of methods in the redirector for
            performing the actual redirects:
         goto()  uses  setGoto() 
                    ( _forward()-like API ) to build a URL and
                    perform a redirect.
                 gotoRoute()  uses  setGotoRoute() 
                    ( route-assembly ) to build a URL and
                    perform a redirect.
                 gotoUrl()  uses  setGotoUrl() 
                    ( URL string ) to build a URL and
                    perform a redirect.
                 
            Finally, you can determine the current redirect URL at any time
            using  getRedirectUrl() .
         Basic Usage Examples Setting Options 
                This example overrides several options, including setting the
                HTTP status code to use in the redirect (&#39;303&#39;), not defaulting
                to exit on redirect, and defining a default URL to use when
                redirecting.
             &lt;?php
class SomeController extends Zend_Controller_Action
{
    /**
     * Redirector - defined for code completion
     *
     * @var Zend_Controller_Action_Helper_Redirector
     */
    protected $_redirector = null;

    public function init()
    {
        $this-&gt;_redirector = $this-&gt;_helper-&gt;getHelper(&#39;Redirector&#39;);

        // Set the default options for the redirector
        // Since the object is registered in the helper broker, these become
        // relevant for all actions from this point forward
        $this-&gt;_redirector-&gt;setCode(&#39;303&#39;)
                          -&gt;setExit(false)
                          -&gt;setGoto(&quot;this-action&quot;, &quot;some-controller&quot;);
    }

    public function myAction()
    {
        /* do some stuff */

        // Redirect to a previously registered URL, and force an exit to occur
        // when done:
        $this-&gt;_redirector-&gt;redirectAndExit();
        return; // never reached
    }
}
             Using Defaults 
                This example assumes that the defaults are used, which means
                that any redirect will result in an immediate
                 exit() .
             &lt;?php
// ALTERNATIVE EXAMPLE
class AlternativeController extends Zend_Controller_Action
{
    /**
     * Redirector - defined for code completion
     *
     * @var Zend_Controller_Action_Helper_Redirector
     */
    protected $_redirector = null;

    public function init()
    {
        $this-&gt;_redirector = $this-&gt;_helper-&gt;getHelper(&#39;Redirector&#39;);
    }

    public function myAction()
    {
        /* do some stuff */

        $this-&gt;_redirector-&gt;gotoUrl(&#39;/my-controller/my-action/param1/test/param2/test2&#39;);
        return; // never reached since default is to goto and exit
    }
}
             Using goto()&#39;s _forward() API goto() &#39;s API mimics that of
                 Zend_Controller_Action::_forward() . The primary
                difference is that it builds a URL from the parameters passed,
                and using the default  :module/:controller/:action/* 
                format of the default router. It then redirects instead of
                chaining the action.
             &lt;?php
class ForwardController extends Zend_Controller_Action
{
    /**
     * Redirector - defined for code completion
     *
     * @var Zend_Controller_Action_Helper_Redirector
     */
    protected $_redirector = null;

    public function init()
    {
        $this-&gt;_redirector = $this-&gt;_helper-&gt;getHelper(&#39;Redirector&#39;);
    }

    public function myAction()
    {
        /* do some stuff */

        // Redirect to &#39;my-action&#39; of &#39;my-controller&#39; in the current module,
        // using the params param1 =&gt; test and param2 =&gt; test2
        $this-&gt;_redirector-&gt;goto(&#39;my-action&#39;, &#39;my-controller&#39;, null, array(&#39;param1&#39; =&gt; &#39;test&#39;, &#39;param2&#39; =&gt; &#39;test2&#39;));
    }
}
             Using route assembly with gotoRoute() 
                The following example uses the  router&#39;s 
                 assemble()  method to create a URL based on an
                associative array of parameters passed. It assumes the following
                route has been registered:
             &lt;?php
$route = new Zend_Controller_Router_Route(
    &#39;blog/:year/:month/:day/:id&#39;,
    array(&#39;controller&#39; =&gt; &#39;archive&#39;, &#39;module&#39; =&gt; &#39;blog&#39;, &#39;action&#39; =&gt; &#39;view&#39;)
);
$router-&gt;addRoute(&#39;blogArchive&#39;, $route);
             
                Given an array with year set to 2006, month to 4, day to 24, and
                id to 42, it would then build the URL
                 /blog/2006/4/24/42 .
             &lt;?php
class BlogAdminController extends Zend_Controller_Action
{
    /**
     * Redirector - defined for code completion
     *
     * @var Zend_Controller_Action_Helper_Redirector
     */
    protected $_redirector = null;

    public function init()
    {
        $this-&gt;_redirector = $this-&gt;_helper-&gt;getHelper(&#39;Redirector&#39;);
    }

    public function returnAction()
    {
        /* do some stuff */

        // Redirect to blog archive. Builds the following URL:
        // /blog/2006/4/24/42
        $this-&gt;_redirector-&gt;gotoRoute(
            array(&#39;year&#39; =&gt; 2006, &#39;month&#39; =&gt; 4, &#39;day&#39; =&gt; 24, &#39;id&#39; =&gt; 42),
            &#39;blogArchive&#39;
        );
    }
}
             ViewRenderer Introduction 
            The  ViewRenderer  helper is designed to satisfy the
            following goals:
         
                    Eliminate the need to instantiate view objects within
                    controllers; view objects will be automatically registered
                    with the controller.
                 
                    Automatically set view script, helper, and filter paths
                    based on the current module, and automatically associate
                    the current module name as a class prefix for helper and
                    filter classes.
                 
                    Create a globally available view object for all dispatched
                    controllers and actions.
                 
                    Allow the developer to set default view rendering options
                    for all controllers.
                 
                    Add the ability to automatically render a view script with
                    no intervention.
                 
                    Allow the developer to create her own specifications for
                    the view base path and for view script paths.
                 
                If you perform a  _forward() , redirect, or
                 render  manually, autorendering will not occur, as
                by performing any of these actions you are telling the
                 ViewRenderer  that you are determining your own
                output.
             
                The  ViewRenderer  is enabled by default. You may
                disable it via the front controller  noViewRenderer 
                param ( $front-&gt;setParam(&#39;noViewRenderer&#39;, true) ) or
                removing the helper from the helper broker stack
                ( Zend_Controller_Action_HelperBroker::removeHelper(&#39;viewRenderer&#39;) ).
             
                If you wish to modify settings of the  ViewRenderer 
                prior to dispatching the front controller, you may do so in one
                of two ways:
             
                        Instantiate and register your own
                         ViewRenderer  object and pass it to the
                        helper broker:
                     &lt;?php
$viewRenderer = new Zend_Controller_Action_Helper_ViewRenderer();
$viewRenderer-&gt;setView($view)
             -&gt;setViewSuffix(&#39;php&#39;);
Zend_Controller_Action_HelperBroker::addHelper($viewRenderer);
                     
                        Initialize and/or retrieve a  ViewRenderer 
                        object on demand via the helper broker:
                     &lt;?php
$viewRenderer = Zend_Controller_Action_HelperBroker::getStaticHelper(&#39;viewRenderer&#39;);
$viewRenderer-&gt;setView($view)
             -&gt;setViewSuffix(&#39;php&#39;);
                     API 
            At its most basic usage, you simply instantiate the
             ViewRenderer  and pass it to the action helper broker.
            The easiest way to instantiate it and register in one go is to use
            the helper broker&#39;s  getStaticHelper()  method:
         &lt;?php
Zend_Controller_Action_HelperBroker::getStaticHelper(&#39;viewRenderer&#39;);
         
            The first time an action controller is instantiated, it will trigger
            the  ViewRenderer  to instantiate a view object. Each
            time a controller is instantiated, the  ViewRenderer &#39;s
             init()  method is called, which will cause it to set the
            view property of the action controller, and call
             addScriptPath()  with a path relative to the current
            module; this will be called with a class prefix named after the
            current module, effectively namespacing all helper and filter
            classes you define for the module.
         
            Each time  postDispatch()  is called, it will call
             render()  for the current action.
         
            As an example, consider the following class:
         &lt;?php
// A controller class, foo module:
class Foo_BarController extends Zend_Controller_Action
{
    // Render bar/index.phtml by default; no action required
    public function indexAction()
    {
    }

    // Render bar/populate.phtml with variable &#39;foo&#39; set to &#39;bar&#39;.
    // Since view object defined at preDispatch(), it&#39;s already available.
    public function populateAction()
    {
        $this-&gt;view-&gt;foo = &#39;bar&#39;;
    }
}

...

// in one of your view scripts:
&lt;?php $this-&gt;foo(); // call Foo_View_Helper_Foo::foo()
         
            The  ViewRenderer  also defines a number of accessors to
            allow setting and retrieving view options:
         setView($view)  allows you to set the view
                    object for the  ViewRenderer . It gets set as
                    the public class property  $view .
                 setNeverRender($flag = true)  can be used to
                    disable or enable autorendering globally, i.e., for all
                    controllers. If set to true,  postDispatch() 
                    will not automatically call  render()  in the
                    current controller.   getNeverRender()  retrieves
                    the current value.
                 setNoRender($flag = true)  can be used to
                    disable or enable autorendering. If set to true,
                     postDispatch()  will not automatically call
                     render()  in the current controller. This
                    setting is reset each time  preDispatch()  is
                    called (i.e., you need to set this flag for each controller
                    for which you don&#39;t want autorenderering to occur).
                     getNoRender()  retrieves the current value.
                 setNoController($flag = true)  can be used to
                    tell  render()  not to look for the action script
                    in a subdirectory named after the controller (which is the
                    default behaviour).  getNoController()  retrieves
                    the current value.
                 setNeverController($flag = true)  is analogous
                    to  setNoController() , but works on a global
                    level -- i.e., it will not be reset for each dispatched
                    action.  getNeverController()  retrieves
                    the current value.
                 setScriptAction($name)  can be used to
                    specify the action script to render.  $name 
                    should be the name of the script minus the file suffix (and
                    without the controller subdirectory, unless
                     noController  has been turned on). If not
                    specified, it looks for a view script named after the action
                    in the request object.  getScriptAction() 
                    retrieves the current value.
                 setResponseSegment($name)  can be used to
                    specify which response object named segment to render into.
                    If not specified, it renders into the default segment.
                     getResponseSegment()  retrieves the current
                    value.
                 initView($path, $prefix, $options)  may be called
                    to specify the base view path, class prefix for helper and
                    filter scripts, and  ViewRenderer  options. You
                    may pass any of the following flags:
                     neverRender ,  noRender ,
                     noController ,  scriptAction , and
                     responseSegment .
                 setRender($action = null, $name = null, $noController
                        = false)  allows you to set any of
                     scriptAction ,  responseSegment , and
                     noController  in one pass.  direct() 
                    is an alias to this method, allowing you to call this method
                    easily from your controller:
                 
// Render &#39;foo&#39; instead of current action script
$this-&gt;_helper-&gt;viewRenderer(&#39;foo&#39;);

// render form.phtml to the &#39;html&#39; response segment, without using a
// controller view script subdirectory:
$this-&gt;_helper-&gt;viewRenderer(&#39;form&#39;, &#39;html&#39;, true);

                 setRender()  and  direct()  don&#39;t
                        actually render the view script, but instead set hints
                        that  postDispatch()  and
                         render()  will use to render the view.
                 
            The constructor allows you to optionally pass the view object and
             ViewRenderer  options; it accepts the same flags as
             initView() :
         
$view    = new Zend_View(array(&#39;encoding&#39; =&gt; &#39;UTF-8&#39;));
$options = array(&#39;noController&#39; =&gt; true, &#39;neverRender&#39; =&gt; true);
$viewRenderer = new Zend_Controller_Action_Helper_ViewRenderer($view, $options);

         
            There are several additional methods for customizing path
            specifications used for determining the view base path to add to the
            view object, and the view script path to use when autodetermining
            the view script to render. These methods each take one or more of
            the following placeholders:
         :moduleDir  refers to the current module&#39;s base
                    directory (by convention, the parent directory of the
                    module&#39;s controller directory).
                 :module  refers to the current module name.
                 :controller  refers to the current controller name.
                 :action  refers to the current action name.
                 :suffix  refers to the view script suffix (which
                    may be set via  setViewSuffix() ).
                 
            The methods for controlling path specifications are:
         setViewBasePathSpec($spec)  allows you to change
                    the path specification used to determine the base path to
                    add to the view object. The default specification is
                     :moduleDir/views . You may retrieve the current
                    specification at any time using
                     getViewBasePathSpec() .
                 setViewScriptPathSpec($spec)  allows you to
                    change the path specification used to determine the path to
                    an individual view script (minus the base view script path).
                    The default specification is
                     :controller/:action.:suffix . You may retrieve
                    the current specification at any time using
                     getViewScriptPathSpec() .
                 setViewScriptPathNoControllerSpec($spec)  allows
                    you to change the path specification used to determine the
                    path to an individual view script when
                     noController  is in effect (minus the base view
                    script path).  The default specification is
                     :action.:suffix . You may retrieve the current
                    specification at any time using
                     getViewScriptPathNoControllerSpec() .
                 
            For fine-grained control over path specifications, you may use
             Zend_Filter_Inflector .
            Under the hood, the  ViewRenderer  uses an inflector to
            perform path mappings already. To interact with the inflector --
            either to set your own for use, or to modify the default inflector,
            the following methods may be used:
         getInflector()  will retrieve the inflector. If
                    none exists yet in the  ViewRenderer , it creates
                    one using the default rules.
                 
                    By default, it uses static rule references for the suffix
                    and module directory, as well as a static target; this
                    allows various  ViewRenderer  properties the
                    ability to dynamically modify the inflector.
                 setInflector($inflector, $reference)  allows you
                    to set a custom inflector for use with the
                     ViewRenderer . If  $reference  is
                    true, it will set the suffix and module directory as static
                    references to  ViewRenderer  properties, as well
                    as the target.
             Default Lookup Conventions 
                The  ViewRenderer  does some path normalization to
                make view script lookups easier. The default rules are as
                follows:
             :module : MixedCase and camelCasedWords are separated by
                        dashes, and the entire string cast to lowercase. E.g.:
                        &quot;FooBarBaz&quot; becomes &quot;foo-bar-baz&quot;.
                     
                        Internally, the inflector uses the filters
                         Zend_Filter_Word_CamelCaseToDash  and
                         Zend_Filter_StringToLower .
                     :controller : MixedCase and camelCasedWords are separated
                        by dashes; underscores are converted to directory
                        separators, and the entire string cast to lower case.
                        Examples: &quot;FooBar&quot; becomes &quot;foo-bar&quot;; &quot;FooBar_Admin&quot;
                        becomes &quot;foo-bar/admin&quot;.
                     
                        Internally, the inflector uses the filters
                         Zend_Filter_Word_CamelCaseToDash ,
                         Zend_Filter_Word_UnderscoreToSeparator , and
                         Zend_Filter_StringToLower .
                     :action : MixedCase and camelCasedWords are separated
                        by dashes; non-alphanumeric characters are translated to
                        dashes, and the entire string cast to lower case.
                        Examples: &quot;fooBar&quot; becomes &quot;foo-bar&quot;; &quot;foo-barBaz&quot;
                        becomes &quot;foo-bar-baz&quot;.
                     
                        Internally, the inflector uses the filters
                         Zend_Filter_Word_CamelCaseToDash ,
                         Zend_Filter_PregReplace , and
                         Zend_Filter_StringToLower .
                     
            The final items in the  ViewRenderer  API are the methods
            for actually determining view script paths and rendering views.
            These include:
         renderScript($script, $name)  allows you to
                    render a script with a path you specify, optionally to a
                    named path segment. When using this method, the
                     ViewRenderer  does no autodetermination of the
                    script name, but instead directly passes the
                     $script  argument directly to the view object&#39;s
                     render()  method.
                 
                    Once the view has been rendered to the response object, it
                    sets the  noRender  to prevent accidentally
                    rendering the same view script multiple times.
                 
                        By default,
                         Zend_Controller_Action::renderScript() 
                        proxies to the  ViewRenderer &#39;s
                         renderScript()  method.
                     getViewScript($action, $vars)  creates the path
                    to a view script based on the action passed and/or any
                    variables passed in  $vars . Keys for this array
                    may include any of the path specification keys (&#39;moduleDir&#39;,
                    &#39;module&#39;, &#39;controller&#39;, &#39;action&#39;, and &#39;suffix&#39;). Any
                    variables passed will be used; otherwise, values based on
                    the current request will be utlized.
                 getViewScript()  will use either the
                     viewScriptPathSpec  or
                     viewScriptPathNoControllerSpec  based on the
                    setting of the  noController  flag.
                 
                    Word delimiters occurring in module, controller, or action
                    names will be replaced with dashes (&#39;-&#39;). Thus, if you have
                    the controller name &#39;foo.bar&#39; and the action &#39;baz:bat&#39;,
                    using the default path specification will result in a view
                    script path of &#39;foo-bar/baz-bat.phtml&#39;.
                 
                        By default,
                         Zend_Controller_Action::getViewScript() 
                        proxies to the  ViewRenderer &#39;s
                         getViewScript()  method.
                     render($action, $name, $noController)  checks
                    first to see if either  $name  or
                     $noController  have been passed, and if so, sets
                    the appropriate flags (responseSegment and noController,
                    respectively) in the ViewRenderer. It then passes the
                     $action  argument, if any, on to
                     getViewScript() . Finally, it passes the
                    calculated view script path to  renderScript() .
                 
                        Be aware of the side-effects of using render(): the
                        values you pass for the response segment name and for
                        the noController flag will persist in the object.
                        Additionally, noRender will be set after rendering is
                        completed.
                     
                        By default,
                         Zend_Controller_Action::render()  proxies to
                        the  ViewRenderer &#39;s  render() 
                        method.
                     renderBySpec($action, $vars, $name)  allows you
                    to pass path specification variables in order to determine
                    the view script path to create. It passes
                     $action  and  $vars  to
                     getScriptPath() , and then passes the resulting
                    script path and  $name  on to
                     renderScript() .
                 Basic Usage Examples Basic Usage 
                At its most basic, you simply initialize and register the
                 ViewRenderer  helper with the helper broker in your
                bootstrap, and then set variables in your action methods.
             &lt;?php
// In your bootstrap:
Zend_Controller_Action_HelperBroker::getStaticHelper(&#39;viewRenderer&#39;);

...

&lt;?php
// &#39;foo&#39; module, &#39;bar&#39; controller:
class Foo_BarController extends Zend_Controller_Action
{
    // Render bar/index.phtml by default; no action required
    public function indexAction()
    {
    }

    // Render bar/populate.phtml with variable &#39;foo&#39; set to &#39;bar&#39;.
    // Since view object defined at preDispatch(), it&#39;s already available.
    public function populateAction()
    {
        $this-&gt;view-&gt;foo = &#39;bar&#39;;
    }

    // Renders nothing as it forwards to another action; the new action
    // will perform any rendering
    public function bazAction()
    {
        $this-&gt;_forward(&#39;index&#39;);
    }

    // Renders nothing as it redirects to another location
    public function batAction()
    {
        $this-&gt;_redirect(&#39;/index&#39;);
    }
}
             Naming Conventions: Word delimiters in controller and action names 
                If your controller or action name is composed of several
                words, the dispatcher requires that these are separated on
                the URL by specific path and word delimiter characters. The
                 ViewRenderer  replaces any path delimiter found
                in the controller name with an actual path delimiter (&#39;/&#39;),
                and any word delimiter found with a dash (&#39;-&#39;) when creating
                paths. Thus, a call to the action
                 /foo.bar/baz.bat  would dispatch to
                 FooBarController::bazBatAction()  in
                FooBarController.php, which would render
                 foo-bar/baz-bat.phtml ; a call to the action
                 /bar_baz/baz-bat  would dispatch to
                 Bar_BazController::bazBatAction()  in
                 Bar/BazController.php  (note the path
                separation) and render  bar/baz/baz-bat.phtml .
             
                Note that the in the second example, the module is still the
                default module, but that, because of the existence of a path
                separator, the controller receives the name
                 Bar_BazController , in
                 Bar/BazController.php . The ViewRenderer mimics
                the controller directory hierarchy.
             Disabling autorender 
                For some actions or controllers, you may want to turn off the
                autorendering -- for instance, if you&#39;re wanting to emit a
                different type of output (XML, JSON, etc), or if you simply want
                to emit nothing. You have two options: turn off all cases of
                autorendering ( setNeverRender() ), or simply turn it
                off for the current action ( setNoRender() ).
             &lt;?php
// Baz controller class, bar module:
class Bar_BazController extends Zend_Controller_Action
{
    public function fooAction()
    {
        // Don&#39;t auto render this action
        $this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender();
    }
}

// Bat controller class, bar module:
class Bar_BatController extends Zend_Controller_Action
{
    public function preDispatch()
    {
        // Never auto render this controller&#39;s actions
        $this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender();
    }
}
             
                In most cases, it makes no sense to turn off autorendering
                globally (ala  setNeverRender() ), as the only thing
                you then gain from  ViewRenderer  is the autosetup of
                the view object.
             Choosing a different view script 
                Some situations require that you render a different script than
                one named after the action. For instance, if you have a
                controller that has both add and edit actions, they may both
                display the same &#39;form&#39; view, albeit with different values set.
                You can easily change the script name used with either
                 setScriptAction() ,  setRender() , or
                calling the helper as a method, which will invoke
                 setRender() .
             &lt;?php
// Bar controller class, foo module:
class Foo_BarController extends Zend_Controller_Action
{
    public function addAction()
    {
        // Render &#39;bar/form.phtml&#39; instead of &#39;bar/add.phtml&#39;
        $this-&gt;_helper-&gt;viewRenderer(&#39;form&#39;);
    }

    public function editAction()
    {
        // Render &#39;bar/form.phtml&#39; instead of &#39;bar/edit.phtml&#39;
        $this-&gt;_helper-&gt;viewRenderer-&gt;setScriptAction(&#39;form&#39;);
    }

    public function processAction()
    {
        // do some validation...
        if (!$valid) {
            // Render &#39;bar/form.phtml&#39; instead of &#39;bar/process.phtml&#39;
            $this-&gt;_helper-&gt;viewRenderer-&gt;setRender(&#39;form&#39;);
            return;
        }

        // otherwise continue processing...
    }

}
             Modifying the registered view 
                What if you need to modify the view object -- for instance,
                change the helper paths, or the encoding? You can do so either
                by modifying the view object set in your controller, or by
                grabbing the view object out of the  ViewRenderer ;
                both are references to the same object.
             &lt;?php
// Bar controller class, foo module:
class Foo_BarController extends Zend_Controller_Action
{
    public function preDispatch()
    {
        // change view encoding
        $this-&gt;view-&gt;setEncoding(&#39;UTF-8&#39;);
    }

    public function bazAction()
    {
        // Get view object and set escape callback to &#39;htmlspecialchars&#39;
        $view = $this-&gt;_helper-&gt;viewRenderer-&gt;view;
        $view-&gt;setEscape(&#39;htmlspecialchars&#39;);
    }
}
             Advanced Usage Examples Changing the path specifications 
                In some circumstances, you may decide that the default path
                specifications do not fit your site&#39;s needs. For instance, you
                may want to have a single template tree to which you may then
                give access to your designers (this is very typical when using
                 Smarty , for
                instance). In such a case, you may want to hardcode the view
                base path specification, and create an alternate specification
                for the action view script paths themselves.
             
                For purposes of this example, let&#39;s assume that the base path to
                views should be &#39;/opt/vendor/templates&#39;, and that you wish for
                view scripts to be referenced by
                &#39;:moduleDir/:controller/:action.:suffix&#39;; if the noController
                flag has been set, you want to render out of the top level
                instead of in a subdirectory (&#39;:action.:suffix&#39;). Finally, you
                want to use &#39;tpl&#39; as the view script filename suffix.
             &lt;?php
/**
 * In your bootstrap:
 */

// Different view implementation
$view = new ZF_Smarty();

$viewRenderer = new Zend_Controller_Action_Helper_ViewRenderer($view);
$viewRenderer-&gt;setViewBasePathSpec(&#39;/opt/vendor/templates&#39;)
             -&gt;setViewScriptPathSpec(&#39;:module/:controller/:action.:suffix&#39;)
             -&gt;setViewScriptPathNoControllerSpec(&#39;:action.:suffix&#39;)
             -&gt;setViewSuffix(&#39;tpl&#39;);
Zend_Controller_Action_HelperBroker::addHelper($viewRenderer);
             Rendering multiple view scripts from a single action 
                At times, you may need to render multiple view scripts from a
                single action. This is very straightforward -- simply make
                multiple calls to  render() :
             &lt;?php
class SearchController extends Zend_Controller_Action
{
    public function resultsAction()
    {
        // Assume $this-&gt;model is the current model
        $this-&gt;view-&gt;results = $this-&gt;model-&gt;find($this-&gt;_getParam(&#39;query&#39;, &#39;&#39;);

        // render() by default proxies to the ViewRenderer
        // Render first the search form and then the results
        $this-&gt;render(&#39;form&#39;);
        $this-&gt;render(&#39;results&#39;);
    }

    public function formAction()
    {
        // do nothing; ViewRenderer autorenders the view script
    }
}
             Action Helpers Introduction 
            Action Helpers allow developers to inject runtime and/or on-demand
            functionality into any Action Controllers that extend
            Zend_Controller_Action.  Action Helpers aim to minimize the
            necessity to extend the abstract Action Controller in order to
            inject common Action Controller functionality.
         
            There are a number of ways to use Action Helpers.  Action Helpers
            employ the use of a brokerage system, similar to the types of
            brokerage you see in  Zend_View_Helper , and that
            of  Zend_Controller_Plugin .
            Action Helpers (like  Zend_View_Helper ) may be
            loaded and called on demand, or they may be instantiated at
            request time (bootstrap) or action controller creation time
            (init()).  To understand this more fully, please see the usage
            section below.
         Helper Initialization 
            A helper can be initialized in several different ways, based on
            your needs as well as the functionality of that helper.
         
            The helper broker is stored as the  $_helper  member of
             Zend_Controller_Action ; use the broker to retrieve or
            call on helpers. Some methods for doing so include:
         
                    Explicitly using  getHelper() . Simply pass it a
                    name, and a helper object is returned:
                 &lt;?php
$flashMessenger = $this-&gt;_helper-&gt;getHelper(&#39;FlashMessenger&#39;);
$flashMessenger-&gt;addMessage(&#39;We did something in the last request&#39;);
                 
                    Use the helper broker&#39;s  __get()  functionality
                    and retrieve the helper as if it were a member property of
                    the broker:
                 &lt;?php
$flashMessenger = $this-&gt;_helper-&gt;FlashMessenger;
$flashMessenger-&gt;addMessage(&#39;We did something in the last request&#39;);
                 
                    Finally, most action helpers implement the method
                     direct()  which will call a specific, default
                    method in the helper. In the example of the
                     FlashMessenger , it calls
                     addMessage() :
                 &lt;?php
$this-&gt;_helper-&gt;FlashMessenger(&#39;We did something in the last request&#39;);
                 All of the above examples are functionally equivalent. 
            You may also instantiate helpers explicitly. You may wish to do this
            if using the helper outside of an action controller, or if you wish
            to pass a helper to the helper broker for use by any action.
            Instantiation is as per any other PHP class.
         The Helper Broker Zend_Controller_Action_HelperBroker  handles the details
            of registering helper objects and helper paths, as well as
            retrieving helpers on-demand.
         
            To register a helper with the broker, use  addHelper :
         &lt;?php
Zend_Controller_Action_HelperBroker::addHelper($helper);
         
            Of course, instantiating and passing helpers to the broker is a bit
            time and resource intensive, so two methods exists to automate
            things slightly:  addPrefix()  and
             addPath() .
         addPrefix()  takes a class prefix and uses it
                    to determine a path where helper classes have been defined.
                    It assumes the prefix follows Zend Framework class naming
                    conventions.
                 &lt;?php
// Add helpers prefixed with My_Action_Helpers in My/Action/Helpers/
Zend_Controller_Action_HelperBroker::addPrefix(&#39;My_Action_Helpers&#39;);
                 addPath()  takes a directory as its first
                    argument and a class prefix as the second argument
                    (defaulting to &#39;Zend_Controller_Action_Helper&#39;). This allows
                    you to map your own class prefixes to specific directories.
                 &lt;?php
// Add helpers prefixed with Helper in Plugins/Helpers/
Zend_Controller_Action_HelperBroker::addPath(&#39;./Plugins/Helpers&#39;, &#39;Helper&#39;);
                 
            Since these methods are static, they may be called at any point in
            the controller chain in order to dynamically add helpers as needed.
         
            To determine if a helper exists in the helper broker, use
             hasHelper($name) , where  $name  is the short
            name of the helper (minus the prefix):
         &lt;?php
// Check if &#39;redirector&#39; helper is registered with the broker:
if (Zend_Controller_Action_HelperBroker::hasHelper(&#39;redirector&#39;)) {
    echo &#39;Redirector helper registered&#39;;
}
         
            There are also two static methods for retrieving helpers from the helper
            broker:  getExistingHelper()  and
             getStaticHelper() .  getExistingHelper() 
            will retrieve a helper only if it has previously been invoked by or
            explicitly registered with the helper broker; it will throw an
            exception if not.  getStaticHelper()  does the same as
             getExistingHelper() , but will attempt to instantiate
            the helper if has not yet been registered with the helper stack.
             getStaticHelper()  is a good choice for retrieving
            helpers which you wish to configure.
         
            Both methods take a single argument,  $name , which is
            the short name of the helper (minus the prefix).
         &lt;?php
// Check if &#39;redirector&#39; helper is registered with the broker, and fetch:
if (Zend_Controller_Action_HelperBroker::hasHelper(&#39;redirector&#39;)) {
    $redirector = Zend_Controller_Action_HelperBroker::getExistingHelper(&#39;redirector&#39;);
}

// Or, simply retrieve it, not worrying about whether or not it was previously
// registered:
$redirector = Zend_Controller_Action_HelperBroker::getStaticHelper(&#39;redirector&#39;);
} 
            Finally, to delete a registered helper from the broker, use
             removeHelper($name) , where  $name  is the
            short name of the helper (minus the prefix):
         &lt;?php
// Conditionally remove the &#39;redirector&#39; helper from the broker:
if (Zend_Controller_Action_HelperBroker::hasHelper(&#39;redirector&#39;)) {
    Zend_Controller_Action_HelperBroker::removeHelper(&#39;redirector&#39;)
}
         Built-in Action Helpers 
            Zend Framework includes several action helpers by default:
             AutoComplete  for automating responses for AJAX
            autocompletion;  ContextSwitch  and
             AjaxContext  for serving alternate response formats for
            your actions; a  FlashMessenger  for handling session
            flash messages;  Json  for encoding and sending JSON
            responses; a  Redirector , to provide different
            implementations for redirecting to internal and external pages from
            your application; and a  ViewRenderer  to automate the
            process of setting up the view object in your controllers and
            rendering views.
         Writing Your Own Helpers 
            Action helpers extend
             Zend_Controller_Action_Helper_Abstract , an abstract
            class that provides the basic interface and functionality required
            by the helper broker. These include the following methods:
         setActionController()  is used to set the current
                    action controller.
                 init() , triggered by the helper broker at
                    instantiation, can be used to trigger initialization in the
                    helper; this can be useful for resetting state when multiple
                    controllers use the same helper in chained actions.
                 preDispatch() , is triggered prior to a
                    dispatched action.
                 postDispatch()  is triggered when a dispatched
                    action is done -- even if a  preDispatch() 
                    plugin has skipped the action. Mainly useful for cleanup.
                 getRequest()  retrieves the current request
                    object.
                 getResponse()  retrieves the current response
                    object.
                 getName()  retrieves the helper name. It
                    retrieves the portion of the class name following the last
                    underscore character, or the full class name otherwise. As
                    an example, if the class is named
                     Zend_Controller_Action_Helper_Redirector , it
                    will return  Redirector ; a class named
                     FooMessage  will simply return itself.
                 
            You may optionally include a  direct()  method in your
            helper class. If defined, it allows you to treat the helper as a
            method of the helper broker, in order to allow easy, one-off usage
            of the helper. As an example, the  redirector 
            defines  direct()  as an alias of  goto() ,
            allowing use of the helper like this:
         &lt;?php
// Redirect to /blog/view/item/id/42
$this-&gt;_helper-&gt;redirector(&#39;item&#39;, &#39;view&#39;, &#39;blog&#39;, array(&#39;id&#39; =&gt; 42));
         
            Internally, the helper broker&#39;s  __call()  method looks
            for a helper named  redirector , then checks to see if
            that helper has a defined  direct  class, and calls it
            with the arguments provided.
         
            Once you have created your own helper class, you may provide access
            to it as described in the sections above.
         Zend_Controller Basics 
        The  Zend_Controller  system is designed to be
        lightweight, modular, and extensible.  It is a minimalist design to
        permit flexibility and some freedom to users while providing enough
        structure so that systems built around  Zend_Controller 
        share some common conventions and similar code layout.
     
        The following diagram depicts the workflow, and the narrative following
        describes in detail the interactions:
     
        The  Zend_Controller  workflow is implemented by several
        components.  While it is not necessary to completely understand the
        underpinnings of all of these components to use the system, having a
        working knowledge of the process is helpful.
     Zend_Controller_Front  orchestrates the entire
                    workflow of the  Zend_Controller  system.  It is
                    an interpretation of the FrontController pattern.
                     Zend_Controller_Front  processes all requests
                    received by the server and is ultimately responsible for
                    delegating requests to ActionControllers
                    ( Zend_Controller_Action ).
                 Zend_Controller_Request_Abstract  (often
                    referred to as the  Request Object ) represents
                    the request environment and provides methods for setting and
                    retrieving the controller and action names and any request
                    parameters. Additionally it keeps track of whether or not
                    the action it contains has been dispatched by
                     Zend_Controller_Dispatcher .  Extensions to the
                    abstract request object can be used to encapsulate the
                    entire request environment, allowing routers to pull
                    information from the request environment in order to set the
                    controller and action names.
                 
                    By default,  Zend_Controller_Request_Http  is
                    used, which provides access to the entire HTTP request
                    environment.
                 Zend_Controller_Router_Interface  is used to
                    define routers.  Routing is the process of examining the
                    request environment to determine which controller, and
                    action of that controller, should receive the request.  This
                    controller, action, and optional parameters are then set in
                    the request object to be processed by
                     Zend_Controller_Dispatcher_Standard .  Routing
                    occurs only once: when the request is initially received and
                    before the first controller is dispatched.
                 
                    The default router,
                     Zend_Controller_Router_Rewrite , takes a URI
                    endpoint as specified in
                     Zend_Controller_Request_Http  and decomposes it
                    into a controller, action, and parameters based on the path
                    information in the url. As an example, the URL
                     http://localhost/foo/bar/key/value  would be
                    decoded to use the  foo  controller,
                     bar  action, and specify a parameter
                     key  with a value of  value .
                 Zend_Controller_Router_Rewrite  can also be used
                    to match arbitrary paths; see  the router
                        documentation  for more information.
                 Zend_Controller_Dispatcher_Interface  is used to
                    define dispatchers.  Dispatching is the process of pulling
                    the controller and action from the request object and
                    mapping them to a controller file/class and action method in
                    the controller class. If the controller or action do not
                    exist, it handles determining default controllers and
                    actions to dispatch.
                 
                    The actual dispatching process consists of instantiating the
                    controller class and calling the action method in that
                    class. Unlike routing, which occurs only once, dispatching
                    occurs in a loop. If the request object&#39;s dispatched status
                    is reset at any point, the loop will be repeated, calling
                    whatever action is currently set in the request object. The
                    first time the loop finishes with the request object&#39;s
                    dispatched status set (boolean true), it will finish
                    processing.
                 
                    The default dispatcher is
                     Zend_Controller_Dispatcher_Standard . It defines
                    controllers as MixedCasedClasses ending in the word
                    Controller, and action methods as camelCasedMethods ending
                    in the word Action:
                     FooController::barAction() . In this case, the
                    controller would be referred to as  foo  and
                    the action as  bar .
                 CaseNamingConventions 
                        Since humans are notoriously inconsistent at
                        maintaining case sensitivity when typing links, Zend
                        Framework actually normalizes path information to
                        lowercase. This, of course, will affect how you name
                        your controller and actions... or refer to them in
                        links.
                     
                        If you wish to have your controller class or action
                        method name have multiple MixedCasedWords or
                        camelCasedWords, you will need to separate those words
                        on the url with either a &#39;-&#39; or &#39;.&#39; (though you can
                        configure the character used).
                     
                        As an example, if you were going to the action in
                         FooBarController::bazBatAction() , you&#39;d
                        refer to it on the url as  /foo-bar/baz-bat 
                        or  /foo.bar/baz.bat .
                     Zend_Controller_Action  is the base action
                    controller component.  Each controller is a single class
                    that extends the  Zend_Controller_Action class 
                    and should contain one or more action methods.
                 Zend_Controller_Response_Abstract  defines a
                    base response class used to collect and return responses
                    from the action controllers. It collects both headers and
                    body content.
                 
                    The default response class is
                     Zend_Controller_Response_Http , which is
                    suitable for use in an HTTP environment.
                 
        The workflow of  Zend_Controller  is relatively simple.  A
        request is received by  Zend_Controller_Front , which in turn
        calls  Zend_Controller_Router_Rewrite  to determine which
        controller (and action in that controller) to dispatch.
         Zend_Controller_Router_Rewrite  decomposes the URI in order
        to set the controller and action names in the request.
         Zend_Controller_Front  then enters a dispatch loop.  It
        calls  Zend_Controller_Dispatcher_Standard , passing it the
        request, to dispatch to the controller and action specified in the
        request (or use defaults).  After the controller has finished, control
        returns to  Zend_Controller_Front .  If the controller has
        indicated that another controller should be dispatched by resetting the
        dispatched status of the request, the loop continues and another
        dispatch is performed.  Otherwise, the process ends.
     The Dispatcher Overview 
            Dispatching is the process of taking the request object,
             Zend_Controller_Request_Abstract , extracting the module
            name, controller name, action name, and optional parameters
            contained in it, and then instantiating a controller and calling an
            action of that controller. If any of the module, controller, or
            action are not found, it will use default values for them.
             Zend_Controller_Dispatcher_Standard  specifies
             index  for each of the controller and action defaults
            and  default  for the module default value, but allows
            the developer to change the default values for each using the
             setDefaultController() ,
             setDefaultAction() , and  setDefaultModule() 
            methods, respectively.
         Default Module 
                When creating modular applications, you may find that you want
                your default module namespaced as well (the default
                configuration is that the default module is
                 not  namespaced). As of 1.5.0, you can now
                do so by specifying the  prefixDefaultModule  as true
                in either the front controller or your dispatcher:
             &lt;?php 
// In your front controller:
$front-&gt;setParam(&#39;prefixDefaultModule&#39;, true);

// In your dispatcher:
$dispatcher-&gt;setParam(&#39;prefixDefaultModule&#39;, true);
?&gt; 
                This allows you to re-purpose an existing module to be the
                default module for an application.
             
            Dispatching happens in a loop in the front controller. Before
            dispatching occurs, the front controller routes the request to find
            user specified values for the module, controller, action, and optional
            parameters. It then enters a dispatch loop, dispatching the request.
         
            At the beginning of each iteration, it sets a flag in the request
            object indicating that the action has been dispatched. If an action
            or pre/postDispatch plugin resets that flag, the dispatch loop will
            continue and attempt to dispatch the new request. By changing the
            controller and/or action in the request and resetting the dispatched
            flag, the developer may define a chain of requests to perform.
         
            The action controller method that controlls such dispatching is
             _forward() ; call this method from any of the
            pre/postDispatch() or action methods, providing an action, controller,
            module, and optionally any additional parameters you may wish to
            send to the new action:
         &lt;?php
public function fooAction()
{
    // forward to another action in the current controller and module:
    $this-&gt;_forward(&#39;bar&#39;, null, null, array(&#39;baz&#39; =&gt; &#39;bogus&#39;));
}

public function barAction()
{
    // forward to an action in another controller, FooController::bazAction(),
    // in the current module:
    $this-&gt;_forward(&#39;baz&#39;, &#39;foo&#39;, null, array(&#39;baz&#39; =&gt; &#39;bogus&#39;));
}

public function bazAction()
{
    // forward to an action in another controller in another module,
    // Foo_BarController::bazAction():
    $this-&gt;_forward(&#39;baz&#39;, &#39;bar&#39;, &#39;foo&#39;, array(&#39;baz&#39; =&gt; &#39;bogus&#39;));
}
         Subclassing the Dispatcher Zend_Controller_Front  will first call the router to
            determine the first action in the request. It then enters a dispatch
            loop, which calls on the dispatcher to dispatch the action.
         
            The dispatcher needs a variety of data in order to do its work - it
            needs to know how to format controller and action names, where to
            look for controller class files, whether or not a provided module
            name is valid, and an API for determining if a given request is even
            dispatchable based on the other information available.
         Zend_Controller_Dispatcher_Interface  defines the
            following methods as required for any dispatcher implementation:
         
interface Zend_Controller_Dispatcher_Interface
{
    /**
     * Format a string into a controller class name.
     *
     * @param string $unformatted
     * @return string
     */
    public function formatControllerName($unformatted);

    /**
     * Format a string into an action method name.
     *
     * @param string $unformatted
     * @return string
     */
    public function formatActionName($unformatted);

    /**
     * Determine if a request is dispatchable
     *
     * @param  Zend_Controller_Request_Abstract $request
     * @return boolean
     */
    public function isDispatchable(Zend_Controller_Request_Abstract $request);

    /**
     * Set a user parameter (via front controller, or for local use)
     *
     * @param string $name
     * @param mixed $value
     * @return Zend_Controller_Dispatcher_Interface
     */
    public function setParam($name, $value);

    /**
     * Set an array of user parameters
     *
     * @param array $params
     * @return Zend_Controller_Dispatcher_Interface
     */
    public function setParams(array $params);

    /**
     * Retrieve a single user parameter
     *
     * @param string $name
     * @return mixed
     */
    public function getParam($name);

    /**
     * Retrieve all user parameters
     *
     * @return array
     */
    public function getParams();

    /**
     * Clear the user parameter stack, or a single user parameter
     *
     * @param null|string|array single key or array of keys for params to clear
     * @return Zend_Controller_Dispatcher_Interface
     */
    public function clearParams($name = null);

    /**
     * Set the response object to use, if any
     *
     * @param Zend_Controller_Response_Abstract|null $response
     * @return void
     */
    public function setResponse(Zend_Controller_Response_Abstract $response = null);

    /**
     * Retrieve the response object, if any
     *
     * @return Zend_Controller_Response_Abstract|null
     */
    public function getResponse();

    /**
     * Add a controller directory to the controller directory stack
     *
     * @param string $path
     * @param string $args
     * @return Zend_Controller_Dispatcher_Interface
     */
    public function addControllerDirectory($path, $args = null);

    /**
     * Set the directory (or directories) where controller files are stored
     *
     * @param string|array $dir
     * @return Zend_Controller_Dispatcher_Interface
     */
    public function setControllerDirectory($path);

    /**
     * Return the currently set directory(ies) for controller file lookup
     *
     * @return array
     */
    public function getControllerDirectory();

    /**
     * Dispatch a request to a (module/)controller/action.
     *
     * @param  Zend_Controller_Request_Abstract $request
     * @param  Zend_Controller_Response_Abstract $response
     * @return Zend_Controller_Request_Abstract|boolean
     */
    public function dispatch(Zend_Controller_Request_Abstract $request, Zend_Controller_Response_Abstract $response);

    /**
     * Whether or not a given module is valid
     *
     * @param string $module
     * @return boolean
     */
    public function isValidModule($module);
}
         
            In most cases, however, you should simply extend the abstract class
             Zend_Controller_Dispatcher_Abstract , in which each of
            these have already been defined, or
             Zend_Controller_Dispatcher_Standard  to modify
            functionality of the standard dispatcher.
         
            Possible reasons to subclass the dispatcher include a desire to
            use a different class or method naming schema in your action
            controllers, or a desire to use a different dispatching paradigm
            such as dispatching to action files under controller directories
            (instead of dispatching to class methods).
         MVC Exceptions Introduction 
            The MVC components in Zend Framework utilize a Front Controller,
            which means that all requests to a given site will go through a
            single entry point. As a result, all exceptions bubble up to the
            Front Controller eventually, allowing the developer to handle them
            in a single location.
         
            However, exception messages and backtrace information often contain
            sensitive system information, such as SQL statements, file
            locations, and more. To help protect your site, by default
             Zend_Controller_Front  catches all exceptions and
            registers them with the response object; in turn, by default, the
            response object does not display exception messages.
         How can you handle exceptions? 
            Several mechanisms are built in to the MVC components already to
            allow you to handle exceptions.
         
                    By default, the  error
                    handler plugin  is registered and active. This plugin
                    was designed to handle:
                 Errors due to missing controllers or actions Errors occurring within action controllers 
                    It operates as a  postDispatch()  plugin, and
                    checks to see if a dispatcher, action controller, or
                    other exception has occurred. If so, it forwards to an error
                    handler controller.
                 
                    This handler will cover most exceptional situations, and
                    handle missing controllers and actions gracefully.
                 Zend_Controller_Front::throwExceptions() 
                    By passing a boolean true value to this method, you can tell
                    the front controller that instead of aggregating exceptions
                    in the response object or using the error handler plugin,
                    you&#39;d rather handle them yourself.  As an example:
                 &lt;?php
$front-&gt;throwExceptions(true);
try {
    $front-&gt;dispatch();
} catch (Exception $e) {
    // handle exceptions yourself
}
                 
                    This method is probably the easiest way to add custom
                    exception handling covering the full range of possible
                    exceptions to your front controller application.
                 Zend_Controller_Response_Abstract::renderExceptions() 
                    By passing a boolean true value to this method, you tell the
                    response object that it should render an exception message
                    and backtrace when rendering itself. In this scenario, any
                    exception raised by your application will be displayed. This
                    is only recommended for non-production environments.
                 Zend_Controller_Front::returnResponse()  and
                     Zend_Controller_Response_Abstract::isException() .
                 
                    By passing a boolean true to
                     Zend_Controller_Front::returnResponse() ,
                     Zend_Controller_Front::dispatch()  will not render the
                    response, but instead return it. Once you have the response,
                    you may then test to see if any exceptions were trapped using
                    its  isException()  method, and retrieving the exceptions via
                    the  getException()  method. As an example:
                 &lt;?php
$front-&gt;returnResponse(true);
$response = $front-&gt;dispatch();
if ($response-&gt;isException()) {
    $exceptions = $response-&gt;getException();
    // handle exceptions ...
} else {
    $response-&gt;sendHeaders();
    $response-&gt;outputBody();
}
                 
                    The primary advantage this method offers over
                     Zend_Controller_Front::throwExceptions()  is to
                    allow you to conditionally render the response after
                    handling the exception. This will catch any exception in the
                    controller chain, unlike the error handler plugin.
                 MVC Exceptions You May Encounter 
            The various MVC components -- request, router, dispatcher, action
            controller, and response objects -- may each throw exceptions on
            occasion. Some exceptions may be conditionally overridden, and
            others are used to indicate the developer may need to consider
            their application structure.
         As some examples: Zend_Controller_Dispatcher::dispatch()  will,
                    by default, throw an exception if an invalid controller is
                    requested.  There are two recommended ways to deal with
                    this.
                 Set the  useDefaultControllerAlways  parameter. 
                            In your front controller, or your dispatcher, add
                            the following directive:
                         &lt;?php
$front-&gt;setParam(&#39;useDefaultControllerAlways&#39;, true);

// or
$dispatcher-&gt;setParam(&#39;useDefaultControllerAlways&#39;, true);
                         
                            When this flag is set, the dispatcher will use the
                            default controller and action instead of throwing an
                            exception. The disadvantage to this method is that
                            any typos a user makes when accessing your site will
                            still resolve and display your home page, which can
                            wreak havoc with search engine optimization.
                         
                            The exception thrown by  dispatch()  is
                            a  Zend_Controller_Dispatcher_Exception 
                            containing the text &#39;Invalid controller specified&#39;.
                            Use one of the methods outlined in  the
                                previous section  to catch the exception,
                            and then redirect to a generic error page or the
                            home page.
                         Zend_Controller_Action::__call()  will throw a
                     Zend_Controller_Action_Exception  if it cannot
                    dispatch a non-existent action to a method. Most likely,
                    you will want to use some default action in the controller
                    in cases like this. Ways to achieve this include:
                 
                            Subclass  Zend_Controller_Action  and
                            override the  __call()  method. As an
                            example:
                         &lt;?php
class My_Controller_Action extends Zend_Controller_Action
{
    public function __call($method, $args)
    {
        if (&#39;Action&#39; == substr($method, -6)) {
            $controller = $this-&gt;getRequest()-&gt;getControllerName();
            $url = &#39;/&#39; . $controller . &#39;/index&#39;;
            return $this-&gt;_redirect($url);
        }

        throw new Exception(&#39;Invalid method&#39;);
    }
}
                         
                            The example above intercepts any undefined action
                            method called and redirects it to the default action
                            in the controller.
                         
                            Subclass  Zend_Controller_Dispatcher 
                            and override the  getAction()  method to
                            verify the action exists.  As an example:
                         &lt;?php
class My_Controller_Dispatcher extends Zend_Controller_Dispatcher
{
    public function getAction($request)
    {
        $action = $request-&gt;getActionName();
        if (empty($action)) {
            $action = $this-&gt;getDefaultAction();
            $request-&gt;setActionName($action);
            $action = $this-&gt;formatActionName($action);
        } else {
            $controller = $this-&gt;getController();
            $action     = $this-&gt;formatActionName($action);
            if (!method_exists($controller, $action)) {
                $action = $this-&gt;getDefaultAction();
                $request-&gt;setActionName($action);
                $action = $this-&gt;formatActionName($action);
            }
        }

        return $action;
    }
}
                         
                            The above code checks to see that the requested
                            action exists in the controller class; if not, it
                            resets the action to the default action.
                         
                            This method is nice becauase you can transparently
                            alter the action prior to final dispatch. However,
                            it also means that typos in the URL may still
                            dispatch correctly, which is not great for search
                            engine optimization.
                         
                            Use
                             Zend_Controller_Action::preDispatch() 
                            or
                             Zend_Controller_Plugin_Abstract::preDispatch() 
                            to identify invalid actions.
                         
                            By subclassing  Zend_Controller_Action 
                            and modifying  preDispatch() , you can
                            modify all of your controllers to forward to
                            another action or redirect prior to actually
                            dispatching the action. The code for this will look
                            similar to the code for overriding
                             __call() , above.
                         
                            Alternatively, you can check this information in a
                            global plugin. This has the advantage of being
                            action controller independent; if your application
                            consists of a variety of action controllers, and not
                            all of them inherit from the same class, this method
                            can add consistency in handling your various
                            classes.
                         
                            As an example:
                         &lt;?php
class My_Controller_PreDispatchPlugin extends Zend_Controller_Plugin_Abstract
{
    public function preDispatch(Zend_Controller_Request_Abstract $request)
    {
        $dispatcher = Zend_Controller_Front::getInstance()-&gt;getDispatcher();
        $controller = $dispatcher-&gt;getController($request);
        if (!$controller) {
            $controller = $dispatcher-&gt;getDefaultControllerName($request);
        }
        $action     = $dispatcher-&gt;getAction($request);

        if (!method_exists($controller, $action)) {
            $defaultAction = $dispatcher-&gt;getDefaultAction();
            $controllerName = $request-&gt;getControllerName();
            $response = Zend_Controller_Front::getInstance()-&gt;getResponse();
            $response-&gt;setRedirect(&#39;/&#39; . $controllerName . &#39;/&#39; . $defaultAction);
            $response-&gt;sendHeaders();
            exit;
        }
    }
}
                         
                            In this example, we check to see if the action
                            requested is available in the controller. If not, we
                            redirect to the default action in the controller,
                            and exit script execution immediately.
                         The Front Controller Overview Zend_Controller_Front  implements a  Front
                Controller pattern  used in  Model-View-Controller
                (MVC)  applications. Its purpose is to initialize the
            request environment, route the incoming request, and then dispatch
            any discovered actions; it aggregates any responses and returns them
            when the process is complete.
         Zend_Controller_Front  also implements the  Singleton
            pattern , meaning only a single instance of it may be available at
            any given time. This allows it to also act as a registry on which
            the other objects in the dispatch process may draw.
         Zend_Controller_Front  registers a  plugin broker  with
            itself, allowing various events it triggers to be observed by
            plugins. In most cases, this gives the developer the opportunity to
            tailor the dispatch process to the site without the need to extend
            the front controller to add functionality.
         
            At a bare minimum, the front controller needs one or more paths to
            directories containing  action
                controllers  in order to do its work. A variety of methods
            may also be invoked to further tailor the front controller
            environment and that of its helper classes.
         Default Behaviour 
                By default, the front controller loads the  ErrorHandler 
                plugin, as well as the  ViewRenderer 
                action helper plugin. These are to simplify error handling and
                view renderering in your controllers, respectively.
             
                To disable the  ErrorHandler , perform the following
                at any point prior to calling  dispatch() :
             &lt;?php
// Disable the ErrorHandler plugin:
$front-&gt;setParam(&#39;noErrorHandler&#39;, true);
             
                To disable the  ViewRenderer , do the following prior
                to calling  dispatch() :
             &lt;?php
// Disable the ViewRenderer helper:
$front-&gt;setParam(&#39;noViewRenderer&#39;, true);
             Primary Methods 
            The front controller has several accessors for setting up its
            environment. However, there are three primary methods key to the
            front controller&#39;s functionality:
         getInstance() getInstance()  is used to retrieve a front
                controller instance. As the front controller implements a
                Singleton pattern, this is also the only means possible for
                instantiating a front controller object.
             &lt;?php
$front = Zend_Controller_Front::getInstance();
             setControllerDirectory() and addControllerDirectory setControllerDirectory()  is used to tell  the dispatcher 
                where to look for  action controller 
                class files.  It accepts either a single path or an associative
                array of module/path pairs.
             
                As some examples:
             
// Set the default controller directory:
$front-&gt;setControllerDirectory(&#39;../application/controllers&#39;);

// Set several module directories at once:
$front-&gt;setControllerDirectory(array(
    &#39;default&#39; =&gt; &#39;../application/controllers&#39;,
    &#39;blog&#39;    =&gt; &#39;../modules/blog/controllers&#39;,
    &#39;news&#39;    =&gt; &#39;../modules/news/controllers&#39;,
));

// Add a &#39;foo&#39; module directory:
$front-&gt;addControllerDirectory(&#39;../modules/foo/controllers&#39;, &#39;foo&#39;);
             
                    If you use  addControllerDirectory()  without a
                    module name, it will set the directory for the
                     default  module -- overwriting it if it already
                    exists.
                 
                You can get the current settings for the controller directory
                using  getControllerDirectory() ; this will return an
                array of module/directory pairs.
             dispatch() dispatch(Zend_Controller_Request_Abstract $request = null,
                    Zend_Controller_Response_Abstract $response = null) 
                does the heavy work of the front controller. It may optionally
                take a  request
                    object  and/or a  response object ,
                allowing the developer to pass in custom objects for each.
             
                If no request or response object are passed in,
                 dispatch()  will check for previously registered
                objects and use those or instantiate default versions to use in
                its process (in both cases, the HTTP flavor will be used as the
                default).
             
                Similarly,  dispatch()  checks for registered  router  and  dispatcher 
                objects, instantiating the default versions of each if none is
                found.
             
                The dispatch process has three distinct events:
             Routing Dispatching Response 
                Routing takes place exactly once, using the values in the
                request object when  dispatch()  is called.
                Dispatching takes place in a loop; a request may either indicate
                multiple actions to dispatch, or the controller or a plugin may
                reset the request object to force additional actions to
                dispatch. When all is done, the front controller returns a
                response.
             run() Zend_Controller_Front::run($path)  is a static
                method taking simply a path to a directory containing
                controllers. It fetches a front controller instance (via
                 getInstance() ,
                registers the path provided via  setControllerDirectory() ,
                and finally  dispatches .
             
                Basically,  run()  is a convenience method that can
                be used for site setups that do not require customization of the
                front controller environment.
             &lt;?php
// Instantiate front controller, set controller directory, and dispatch in one
// easy step:
Zend_Controller_Front::run(&#39;../application/controllers&#39;);
             Environmental Accessor Methods 
            In addition to the methods listed above, there are a number of
            accessor methods that can be used to affect the front controller
            environment -- and thus the environment of the classes to which the
            front controller delegates.
         resetInstance()  can be used to clear all
                    current settings. Its primary purpose is for testing, but it
                    can also be used for instances where you wish to chain
                    together multiple front controllers.
                 (set|get)DefaultControllerName()  let you
                    specify a different name to use for the default controller
                    (&#39;index&#39; is used otherwise) and retrieve the current value.
                    They proxy to  the
                        dispatcher .
                 (set|get)DefaultActionName()  let you specify a
                    different name to use for the default action (&#39;index&#39; is
                    used otherwise) and retrieve the current value.  They proxy
                    to  the
                        dispatcher .
                 (set|get)Request()  let you specify  the request 
                    class or object to use during the dispatch process and to
                    retrieve the current object. When setting the request
                    object, you may pass in a request class name, in which case
                    the method will load the class file and instantiate it.
                 (set|get)Router()  let you specify  the router 
                    class or object to use during the dispatch process and to
                    retrieve the current object. When setting the router
                    object, you may pass in a router class name, in which case
                    the method will load the class file and instantiate it.
                 
                    When retrieving the router object, it first checks to see if
                    one is present, and if not, instantiates the default router
                    (rewrite router).
                 (set|get)BaseUrl()  let you specify  the base
                        URL  to strip when routing requests and to
                    retrieve the current value. The value is provided to the
                    request object just prior to routing.
                 (set|get)Dispatcher()  let you specify  the
                        dispatcher  class or object to use during the
                    dispatch process and retrieve the current object. When
                    setting the dispatcher object, you may pass in a dispatcher
                    class name, in which case the method will load the class
                    file and instantiate it.
                 
                    When retrieving the dispatcher object, it first checks to see if
                    one is present, and if not, instantiates the default
                    dispatcher.
                 (set|get)Response()  let you specify  the response 
                    class or object to use during the dispatch process and to
                    retrieve the current object. When setting the response
                    object, you may pass in a response class name, in which case
                    the method will load the class file and instantiate it.
                 registerPlugin(Zend_Controller_Plugin_Abstract $plugin, $stackIndex = null) 
                    allows you to register a  plugin objects .
                    By setting the optional  $stackIndex , you can
                    control the order in which plugins will execute.
                 unregisterPlugin($plugin)  let you 
                    unregister  plugin objects .
                     $plugin  may be either a plugin object or a
                    string denoting the class of plugin to unregister.
                 throwExceptions($flag)  is used to turn on/off
                    the ability to throw exceptions during the dispatch process.
                    By default, exceptions are caught and placed in the  response
                        object ; turning on  throwExceptions() 
                    will override this behaviour.
                 
                    For more information, read  .
                 returnResponse($flag)  is used to tell the front
                    controller whether to return the response
                    ( true ) from  dispatch() , or if the
                    response should be automatically emitted
                    ( false ).  By default, the response is
                    automatically emitted (by calling
                     Zend_Controller_Response_Abstract::sendResponse() );
                    turning on  returnResponse()  will override this
                    behaviour.
                 
                    Reasons to return the response include a desire to check for
                    exceptions prior to emitting the response, needing to log
                    various aspects of the response (such as headers), etc.
                 Front Controller Parameters 
            In the introduction, we indicated that the front controller also
            acts as a registry for the various controller components. It does so
            through a family of &quot;param&quot; methods. These methods allow you to
            register arbitrary data -- objects and variables -- with the front
            controller to be retrieved at any time in the dispatch chain. These
            values are passed on to the router, dispatcher, and action
            controllers. The methods include:
         setParam($name, $value)  allows you to set a
                    single parameter of  $name  with value
                     $value .
                 setParams(array $params)  allows you to set
                    multiple parameters at once using an associative array.
                 getParam($name)  allows you to retrieve a single
                    parameter at a time, using  $name  as the
                    identifier.
                 getParams()  allows you to retrieve the entire
                    list of parameters at once.
                 clearParams()  allows you to clear a single
                    parameter (by passing a string identifier), multiple named
                    parameters (by passing an array of string identifiers), or the
                    entire parameter stack (by passing nothing).
                 
            There are several pre-defined parameters that may be set that have
            specific uses in the dispatch chain:
         useDefaultControllerAlways  is used to hint to
                     the
                        dispatcher  to use the default controller in the
                    default module for any request that is not dispatchable
                    (i.e., the module, controller, and/or action do not exist).
                    By default, this is off.
                 
                    See  
                    for more detailed information on using this setting.
                 disableOutputBuffering  is used to hint to  the
                        dispatcher  that it should not use output
                    buffering to capture output generated by action controllers.
                    By default, the dispatcher captures any output and appends
                    it to the response object body content.
                 noViewRenderer  is used to disable the  ViewRenderer .
                    Set this parameter to true to disable it.
                 noErrorHandler  is used to disable the  Error
                        Handler plugin . Set this parameter to true to
                    disable it.
                 Subclassing the Front Controller 
            To subclass the Front Controller, at the very minimum you will need
            to override the  getInstance()  method:
         
class My_Controller_Front extends Zend_Controller_Front
{
    public static function getInstance()
    {
        if (null === self::$_instance) {
            self::$_instance = new self();
        }

        return self::$_instance;
    }
}

         
            Overriding the  getInstance()  method ensures that
            subsequent calls to
             Zend_Controller_Front::getInstance()  will return an
            instance of your new subclass instead of a
             Zend_Controller_Front  instance -- this is particularly
            useful for some of the alternate routers and view helpers.
         
            Typically, you will not need to subclass the front controller unless
            you need to add new functionality (for instance, a plugin
            autoloader, or a way to specify action helper paths). Some points
            where you may want to alter behaviour may include modifying how
            controller directories are stored, or what default router or
            dispatcher are used.
         Migrating from Previous Versions 
        The API of the MVC components has changed over time. If you started
        using Zend Framework in an early version, follow the guidelines below to
        migrate your scripts to use the new architecture.
     Migrating from 1.0.x to 1.5.0 or newer 
            Though most basic functionality remains the same, and all documented
            functionality remains the same, there is one particular
             undocumented  &quot;feature&quot; that has changed.
         
            When writing URLs, the documented way to write camelCased action
            names is to use a word separator; these are &#39;.&#39; or &#39;-&#39; by default,
            but may be configured in the dispatcher. The dispatcher internally
            lowercases the action name, and uses these word separators to
            re-assemble the action method using camelCasing. However, because PHP
            functions are not case sensitive, you  could 
            still write URLs using camelCasing, and the dispatcher would resolve
            these to the same location. For example, &#39;camel-cased&#39; would become
            &#39;camelCasedAction&#39; by the dispatcher, whereas &#39;camelCased&#39; would
            become &#39;camelcasedAction&#39;; however, due to the case insensitivity of
            PHP, both will execute the same method.
         
            This causes issues with the ViewRenderer when resolving view
            scripts. The canonical, documented way is that all word separators
            are converted to dashes, and the words lowercased. This creates
            a semantic tie between the actions and view scripts, and the
            normalization ensures that the scripts can be found. However, if the
            action &#39;camelCased&#39; is called and actually resolves, the word
            separator is no longer present, and the ViewRenderer attempts to
            resolve to a different location -- &#39;camelcased.phtml&#39; instead of
            &#39;camel-cased.phtml&#39;.
         
            Some developers relied on this &quot;feature&quot;, which was never intended.
            Several changes in the 1.5.0 tree, however, made it so that the
            ViewRenderer no longer resolves these paths; the semantic tie is now
            enforced. First among these, the dispatcher now enforces case
            sensitivity in action names. What this means is that referring to
            your actions on the url using camelCasing will no longer resolve to
            the same method as using word separators (i.e., &#39;camel-casing&#39;).
            This leads to the ViewRenderer now only honoring the word-separated
            actions when resolving view scripts.
         
            If you find that you were relying on this &quot;feature&quot;, you have several
            options:
         
                    Best option: rename your view scripts. Pros: forward
                    compatibility. Cons: if you have many view scripts that
                    relied on the former, unintended behavior, you will have a
                    lot of renaming to do.
             
                    Second best option: The ViewRenderer now delegates view
                    script resolution to  Zend_Filter_Inflector ; you
                    can modify the rules of the inflector to no longer separate
                    the words of an action with a dash:
                 &lt;?php
$viewRenderer = Zend_Controller_Action_HelperBroker::getStaticHelper(&#39;viewRenderer&#39;);
$inflector = $viewRenderer-&gt;getInflector();
$inflector-&gt;setFilterRule(&#39;:action&#39;, array(
    new Zend_Filter_PregReplace(
        &#39;#[^a-z0-9&#39; . preg_quote(DIRECTORY_SEPARATOR, &#39;#&#39;) . &#39;]+#i&#39;,
        &#39;&#39;
    ),
    &#39;StringToLower&#39;
));
?&gt; 
                    The above code will modify the inflector to no longer
                    separate the words with dash; you may also want to remove
                    the &#39;StringToLower&#39; filter if you  do 
                    want the actual view script names camelCased as well.
                 
                    If renaming your view scripts would be too tedious or time
                    consuming, this is your best option until you can find the
                    time to do so.
                 
                    Least desirable option: You can force the dispatcher to
                    dispatch camelCased action names with a new front controller
                    flag, &#39;useCaseSensitiveActions&#39;:
                 &lt;?php
$front-&gt;setParam(&#39;useCaseSensitiveActions&#39;, true);
?&gt; 
                    This will allow you to use camelCasing on the url and still
                    have it resolve to the same action as when you use word
                    separators. However, this will mean that the original issues
                    will cascade on through; you will likely need to use the
                    second option above in addition to this for things to work
                    at all reliably.
                 
                    Note, also, that usage of this flag will raise a notice that
                    this usage is deprecated.
                 Migrating from 0.9.3 to 1.0.0RC1 or newer 
            The principal changes introduced in 1.0.0RC1 are the introduction of
            and default enabling of the
             ErrorHandler 
            plugin and the  ViewRenderer 
            action helper. Please read the documentation to each thoroughly to
            see how they work and what effect they may have on your
            applications.
         
            The  ErrorHandler  plugin runs during
             postDispatch()  checking for exceptions, and forwarding
            to a specified error handler controller. You should include such a
            controller in your application. You may disable it by setting the
            front controller parameter  noErrorHandler :
         &lt;?php
$front-&gt;setParam(&#39;noErrorHandler&#39;, true);
         
            The  ViewRenderer  action helper automates view injection
            into action controllers as well as autorendering of view scripts
            based on the current action. The primary issue you may encounter is
            if you have actions that do not render view scripts and neither
            forward or redirect, as the  ViewRenderer  will attempt
            to render a view script based on the action name.
         
            There are several strategies you can take to update your code. In
            the short term, you can globally disable the
             ViewRenderer  in your front controller bootstrap prior
            to dispatching:
         &lt;?php
// Assuming $front is an instance of Zend_Controller_Front
$front-&gt;setParam(&#39;noViewRenderer&#39;, true);
         
            However, this is not a good long term strategy, as it means most
            likely you&#39;ll be writing more code.
         
            When you&#39;re ready to start using the  ViewRenderer 
            functionality, there are several things to look for in your
            controller code. First, look at your action methods (the methods
            ending in &#39;Action&#39;), and determine what each is doing. If none of
            the following is happening, you&#39;ll need to make changes:
         Calls to  $this-&gt;render() Calls to  $this-&gt;_forward() Calls to  $this-&gt;_redirect() Calls to the  Redirector  action helper 
            The easiest change is to disable auto-rendering for that method:
         
$this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender();
         
            If you find that none of your action methods are rendering,
            forwarding, or redirecting, you will likely want to put the above
            line in your  preDispatch()  or  init() 
            methods:
         
public function preDispatch()
{
    // disable view script autorendering
    $this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender()
    // .. do other things...
}
         
            If you are calling  render() , and you&#39;re using  the Conventional Modular
                directory structure , you&#39;ll want to change your code to
            make use of autorendering:
         
                    If you&#39;re rendering multiple view scripts in a single
                    action, you don&#39;t need to change a thing.
                 
                    If you&#39;re simply calling  render()  with no
                    arguments, you can remove such lines.
                 
                    If you&#39;re calling  render()  with arguments, and
                    not doing any processing afterwards or rendering multiple
                    view scripts, you can change these calls to read
                     $this-&gt;_helper-&gt;viewRenderer() .
                 
            If you&#39;re not using the conventional modular directory structure,
            there are a variety of methods for setting the view base path and
            script path specifications so that you can make use of the
             ViewRenderer . Please read the  ViewRenderer
                documentation  for information on these methods.
         
            If you&#39;re using a view object from the registry, or customizing your
            view object, or using a different view implementation, you&#39;ll want
            to inject the  ViewRenderer  with this object. This can
            be done easily at any time.
         
                    Prior to dispatching a front controller instance:
                 &lt;?php
// Assuming $view has already been defined
$viewRenderer = new Zend_Controller_Action_Helper_ViewRenderer($view);
Zend_Controller_Action_HelperBroker::addHelper($viewRenderer);
                 
                    Any time during the bootstrap process:
                 &lt;?php
$viewRenderer = Zend_Controller_Action_HelperBroker::getStaticHelper(&#39;viewRenderer&#39;);
$viewRenderer-&gt;setView($view);
                 
            There are many ways to modify the  ViewRenderer ,
            including setting a different view script to render, specifying
            replacements for all replaceable elements of a view script path
            (including the suffix), choosing a response named segment to
            utilize, and more. If you aren&#39;t using the conventional modular
            directory structure, you can even associate different path
            specifications with the  ViewRenderer .
         
            We encourage you to adapt your code to use the
             ErrorHandler  and  ViewRenderer  as they are
            now core functionality.
         Migrating from 0.9.2 to 0.9.3 or newer 
            0.9.3 introduces  action helpers .
            As part of this change, the following methods have been removed as
            they are now encapsulated in the  redirector
                action helper :
         setRedirectCode() ; use
                     Zend_Controller_Action_Helper_Redirector::setCode() .
                 setRedirectPrependBase() ; use
                     Zend_Controller_Action_Helper_Redirector::setPrependBase() .
                 setRedirectExit() ; use
                     Zend_Controller_Action_Helper_Redirector::setExit() .
                 
            Read the  action
                helpers documentation  for more information on how to
            retrieve and manipulate helper objects, and the  redirector
                helper documentation  for more information on setting
            redirect options (as well as alternate methods for redirecting).
         Migrating from 0.6.0 to 0.8.0 or newer 
            Per previous changes, the most basic usage of the MVC components
            remains the same:
         
require_once &#39;Zend/Controller/Front.php&#39;;
Zend_Controller_Front::run(&#39;/path/to/controllers&#39;);
         
            However, the directory structure underwent an overhaul, several
            components were removed, and several others either renamed or added.
            Changes include:
         Zend_Controller_Router  was removed in favor of
                    the rewrite router.
                 Zend_Controller_RewriteRouter  was renamed to
                     Zend_Controller_Router_Rewrite , and promoted to
                    the standard router shipped with the framework;
                     Zend_Controller_Front  will use it by default if
                    no other router is supplied.
                 
                    A new route class for use with the rewrite router was
                    introduced,
                     Zend_Controller_Router_Route_Module ; it covers
                    the default route used by the MVC, and has support for  controller
                        modules .
                 Zend_Controller_Router_StaticRoute  was renamed
                    to  Zend_Controller_Router_Route_Static .
                 Zend_Controller_Dispatcher  was renamed
                     Zend_Controller_Dispatcher_Standard .
                 Zend_Controller_Action::_forward() &#39;s arguments
                    have changed. The signature is now:
                 
final protected function _forward($action, $controller = null, $module = null, array $params = null);
                 $action  is always required; if no controller is
                    specified, an action in the current controller is assumed.
                     $module  is always ignored unless
                     $controller  is specified. Finally, any
                     $params  provided will be appended to the
                    request object. If you do not require the controller or
                    module, but still need to pass parameters, simply specify
                    null for those values.
                 Migrating from 0.2.0 or before to 0.6.0 
            The most basic usage of the MVC components has not changed; you can
            still do each of the following:
         
require_once &#39;Zend/Controller/Front.php&#39;;
Zend_Controller_Front::run(&#39;/path/to/controllers&#39;);
         
/* -- create a router -- */
$router = new Zend_Controller_RewriteRouter();
$router-&gt;addRoute(&#39;user&#39;, &#39;user/:username&#39;, array(&#39;controller&#39; =&gt; &#39;user&#39;,
&#39;action&#39; =&gt; &#39;info&#39;));

/* -- set it in a controller -- */
$ctrl = Zend_Controller_Front::getInstance();
$ctrl-&gt;setRouter($router);

/* -- set controller directory and dispatch -- */
$ctrl-&gt;setControllerDirectory(&#39;/path/to/controllers&#39;);
$ctrl-&gt;dispatch();
         
            We encourage use of the Response object to aggregate content and
            headers. This will allow for more flexible output format switching
            (for instance, JSON or XML instead of XHTML) in your applications.
            By default,  dispatch()  will render the response, sending both
            headers and rendering any content. You may also have the front
            controller return the response using  returnResponse() ,
            and then render the response using your own logic. A future version
            of the front controller may enforce use of the response object via
            output buffering.
         
            There are many additional features that extend the existing API,
            and these are noted in the documentation.
         
            The main changes you will need to be aware of will be found when
            subclassing the various components. Key amongst these are:
         Zend_Controller_Front::dispatch()  by default
                    traps exceptions in the response object, and does not render
                    them, in order to prevent sensitive system information from
                    being rendered. You can override this in several ways:
                 
                            Set  throwExceptions()  in the front
                            controller:
                         
$front-&gt;throwExceptions(true);
                         
                            Set  renderExceptions()  in the response
                            object:
                         
$response-&gt;renderExceptions(true);
$front-&gt;setResponse($response);
$front-&gt;dispatch();

// or:
$front-&gt;returnResponse(true);
$response = $front-&gt;dispatch();
$response-&gt;renderExceptions(true);
echo $response;
                         Zend_Controller_Dispatcher_Interface::dispatch() 
                now accepts and returns a  
                object instead of a dispatcher token.
             Zend_Controller_Router_Interface::route() 
                now accepts and returns a  
                object instead of a dispatcher token.
             Zend_Controller_Action  changes include: 
                        The constructor now accepts exactly three arguments,
                         Zend_Controller_Request_Abstract $request ,
                         Zend_Controller_Response_Abstract $response ,
                        and  array $params (optional) .
                         Zend_Controller_Action::__construct()  uses
                        these to set the request, response, and invokeArgs
                        properties of the object, and if overriding the
                        constructor, you should do so as well. Better yet, use
                        the  init()  method to do any instance
                        configuration, as this method is called as the final
                        action of the constructor.
                     run()  is no longer defined as final, but is
                        also no longer used by the front controller; it&#39;s sole
                        purpose is for using the class as a page controller. It
                        now takes two optional arguments, a
                         Zend_Controller_Request_Abstract $request 
                        and a  Zend_Controller_Response_Abstract $response .
                     indexAction()  no longer needs to be
                        defined, but is encouraged as the default action. This
                        allows using the RewriteRouter and action controllers to
                        specify different default action methods.
                     __call()  should be overridden to handle any
                        undefined actions automatically.
                     _redirect()  now takes an optional second
                        argument, the HTTP code to return with the redirect, and
                        an optional third argument,  $prependBase ,
                        that can indicate that the base URL registered with the
                        request object should be prepended to the url specified.
                     
                            The  _action  property is no longer set.
                            This property was a  Zend_Controller_Dispatcher_Token ,
                            which no longer exists in the current incarnation.
                            The sole purpose of the token was to provide
                            information about the requested controller, action,
                            and URL parameters. This information is now
                            available in the request object, and can be accessed
                            as follows:
                         
// Retrieve the requested controller name
// Access used to be via: $this-&gt;_action-&gt;getControllerName().
// The example below uses getRequest(), though you may also directly access the
// $_request property; using getRequest() is recommended as a parent class may
// override access to the request object.
$controller = $this-&gt;getRequest()-&gt;getControllerName();

// Retrieve the requested action name
// Access used to be via: $this-&gt;_action-&gt;getActionName().
$action = $this-&gt;getRequest()-&gt;getActionName();

// Retrieve the request parameters
// This hasn&#39;t changed; the _getParams() and _getParam() methods simply proxy to
// the request object now.
$params = $this-&gt;_getParams();
$foo = $this-&gt;_getParam(&#39;foo&#39;, &#39;default&#39;); // request &#39;foo&#39; parameter, using
                                           // &#39;default&#39; as default value if not found
                         noRouteAction()  has been removed. The
                            appropriate way to handle non-existent action
                            methods should you wish to route them to a default
                            action is using  __call() :
                         
public function __call($method, $args)
{
    // If an unmatched &#39;Action&#39; method was requested, pass on to the default
    // action method:
    if (&#39;Action&#39; == substr($method, -6)) {
        return $this-&gt;defaultAction();
    }

    throw new Zend_Controller_Exception(&#39;Invalid method called&#39;);
}
                         Zend_Controller_RewriteRouter::setRewriteBase()  has
                been removed. Use  Zend_Controller_Front::setBaseUrl() 
                instead (or Zend_Controller_Request_Http::setBaseUrl(), if using
                that request class).
             Zend_Controller_Plugin_Interface  was replaced
                by  Zend_Controller_Plugin_Abstract . All methods now
                accept and return a  
                object instead of a dispatcher token.
             Using a Conventional Modular Directory Structure Introduction 
            The Conventional Modular directory structure allows you to separate
            different MVC applications into self-contained units, and re-use
            them with different front controllers. To illustrate such a
            directory structure:
         
docroot/
    index.php
application/
    default/
        controllers/
            IndexController.php
            FooController.php
        models/
        views/
            scripts/
                index/
                foo/
            helpers/
            filters/
    blog/
        controllers/
            IndexController.php
        models/
        views/
            scripts/
                index/
            helpers/
            filters/
    news/
        controllers/
            IndexController.php
            ListController.php
        models/
        views/
            scripts/
                index/
                list/
            helpers/
            filters/
         
            In this paradigm, the module name serves as a prefix to the
            controllers it contains. The above example contains three
            module controllers, &#39;Blog_IndexController&#39;, &#39;News_IndexController&#39;, and
            &#39;News_ListController&#39;. Two global controllers, &#39;IndexController&#39; and
            &#39;FooController&#39; are also defined; neither of these will be
            namespaced. This directory structure will be used for examples in
            this chapter.
         No namespacing in the default module 
                Note that in the default module, controllers do not need a
                namespace prefix. Thus, in the example above, the controllers in
                the default module do not need a prefix of &#39;Default_&#39; -- they
                are simply dispatched according to their base controller name:
                &#39;IndexController&#39; and &#39;FooController&#39;. A namespace prefix is
                used in all other modules, however.
             
            So, how do you implement such a directory layout using the Zend
            Framework MVC components?
         Specifying Module Controller Directories 
            The first step to making use of modules is to modify how you specify
            the controller directory list in the front controller. In the basic
            MVC series, you pass either an array or a string to
             setControllerDirectory() , or a path to
             addControllerDirectory() .  When using modules, you need
            to alter your calls to these methods slightly.
         
            With  setControllerDirectory() , you will need to pass an
            associative array and specify key/value pairs of module
            name/directory paths.  The special key  default  will be
            used for global controllers (those not needing a module namespace).
            All entries should contain a string key pointing to a single path,
            and the  default  key must be present. As an example:
         &lt;?php
$front-&gt;setControllerDirectory(array(
      &#39;default&#39; =&gt; &#39;/path/to/application/controllers&#39;,
      &#39;blog&#39;    =&gt; &#39;/path/to/application/blog/controllers&#39;
));
         addControllerDirectory()  will take an optional second
            argument. When using modules, pass the module name as the second
            argument; if not specified, the path will be added to the
             default  namespace. As an example:
         &lt;?php
$front-&gt;addControllerDirectory(&#39;/path/to/application/news/controllers&#39;, &#39;news&#39;);
         
            Saving the best for last, the easiest way to specify module
            directories is to do so en masse, with all modules under a common
            directory and sharing the same structure. This can be done with
             addModuleDirectory() :
         &lt;?php
/**
 * Assuming the following directory structure:
 * application/
 *     modules/
 *         default/
 *             controllers/
 *         foo/
 *             controllers/
 *         bar/
 *             controllers/
 */
$front-&gt;addModuleDirectory(&#39;/path/to/application/modules&#39;);
         
            The above example will define the  default ,
             foo , and  bar  modules, each pointing to the
             controllers  subdirectory of their respective module.
         
            You may customize the controller subdirectory to use within your
            modules by using  setModuleControllerDirectoryName() :
         &lt;?php
/**
 * Change the controllers subdirectory to be &#39;con&#39;
 * application/
 *     modules/
 *         default/
 *             con/
 *         foo/
 *             con/
 *         bar/
 *             con/
 */
$front-&gt;setModuleControllerDirectoryName(&#39;con&#39;);
$front-&gt;addModuleDirectory(&#39;/path/to/application/modules&#39;);
         
            You can indicate that no controller subdirectory be used for your
            modules by passing an empty value to
             setModuleControllerDirectoryName() .
         Routing to modules 
            The default route in  Zend_Controller_Router_Rewrite  is
            an object of type  Zend_Controller_Router_Route_Module .
            This route expects one of the following routing schemas:
         :module/:controller/:action/* :controller/:action/* 
            In other words, it will match a controller and action by themselves
            or with a preceding module. The rules for matching specify that a
            module will only be matched if a key of the same name exists in the
            controller directory array passed to the front controller and
            dispatcher.
         Module or Global Default Controller 
            In the default router, if a controller was not specified in the URL,
            a default controller is used ( IndexController , unless
            otherwise requested). With modular controllers, if a module has been
            specified but no controller, the dispatcher first looks for this
            default controller in the module path, and then falls back on the
            default controller found in the &#39;default&#39;, global, namespace.
         
            If you wish to always default to the global namespace, set the
             useDefaultControllerAlways  parameter in the front controller:
         &lt;?php
$front-&gt;setParam(&#39;useDefaultControllerAlways&#39;, true);
         ActionStack 
        The  ActionStack  plugin allows you to manage a stack of
        requests, and operates as a  postDispatch  plugin. If a
        forward (i.e., a call to another action) is already detected in the
        current request object, it does nothing. However, if not, it checks its
        stack and pulls the topmost item off it and forwards to the action
        specified in that request. The stack is processed in LIFO order.
     
        You can retrieve the plugin from the front controller at any time using
         Zend_Controller_Front::getPlugin(&#39;Zend_Controller_Plugin_ActionStack&#39;) .
        Once you have the plugin object, there are a variety of mechanisms you
        can use to manipulate it.
     getRegistry()  and  setRegistry() .
                Internally,  ActionStack  uses a
                 Zend_Registry  instance to store the stack. You can
                substitute a different registry instance or retrieve it with
                these accessors.
         getRegistryKey()  and  setRegistryKey() .
                These can be used to indicate which registry key to use when
                pulling the stack. Default value is
                &#39;Zend_Controller_Plugin_ActionStack&#39;.
         getStack()  allows you to retrieve the stack of
                actions in its entirety.
         pushStack()  and  popStack()  allow you
                to add to and pull from the stack, respectively.
                 pushStack()  accepts a request object.
         
        An additional method,  forward() , expects a request object,
        and sets the state of the current request object in the front controller
        to the state of the provided request object, and markes it as
        undispatched (forcing another iteration of the dispatch loop).
     Zend_Controller_Plugin_ErrorHandler Zend_Controller_Plugin_ErrorHandler  provides a drop-in
        plugin for handling exceptions thrown by your application, including
        those resulting from missing controllers or actions; it is an
        alternative to the methods listed in the  MVC Exceptions section .
     
        The primary targets of the plugin are:
     Intercept exceptions raised due to missing controllers or
                action methods Intercept exceptions raised within action controllers 
        In other words, the  ErrorHandler  plugin is designed to
        handle HTTP 404-type errors (page missing) and 500-type errors (internal
        error). It is not intended to catch exceptions raised in other plugins
        or routing.
     
        By default,  Zend_Controller_Plugin_ErrorHandler  will
        forward to  ErrorController::errorAction()  in the default
        module. You may set alternate values for these by using the various
        accessors available to the plugin:
     setErrorHandlerModule()  sets the controller module
                to use.
             setErrorHandlerController()  sets the controller
                to use.
             setErrorHandlerAction()  sets the controller action
                to use.
             setErrorHandler()  takes an associative array, which
                may contain any of the keys &#39;module&#39;, &#39;controller&#39;, or &#39;action&#39;,
                with which it will set the appropriate values.
             
        Additionally, you may pass an optional associative array to the
        constructor, which will then proxy to  setErrorHandler() .
     Zend_Controller_Plugin_ErrorHandler  registers a
         postDispatch()  hook and checks for exceptions registered in
         the response object . If
        any are found, it attempts to forward to the registered error handler
        action.
     
        If an exception occurs dispatching the error handler, the plugin will
        tell the front controller to throw exceptions, and rethrow the last
        exception registered with the response object.
     Using the ErrorHandler as a 404 Handler 
            Since the  ErrorHandler  plugin captures not only
            application errors, but also errors in the controller chain arising
            from missing controller classes and/or action methods, it can be
            used as a 404 handler. To do so, you will need to have your error
            controller check the exception type.
         
            Exceptions captured are logged in an object registered in the
            request. To retrieve it, use
             Zend_Controller_Action::_getParam(&#39;error_handler&#39;) :
         &lt;?php
class ErrorController extends Zend_Controller_Action
{
    public function errorAction()
    {
        $errors = $this-&gt;_getParam(&#39;error_handler&#39;);
    }
}
         
            Once you have the error object, you can get the type via
             $errors-&gt;type . It will be one of the following:
         Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_CONTROLLER ,
                    indicating the controller was not found.
                 Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_ACTION ,
                    indicating the requested action was not found.
                 Zend_Controller_Plugin_ErrorHandler::EXCEPTION_OTHER ,
                    indicating other exceptions.
                 
            You can then test for either of the first two types, and, if so,
            indicate a 404 page:
         &lt;?php
class ErrorController extends Zend_Controller_Action
{
    public function errorAction()
    {
        $errors = $this-&gt;_getParam(&#39;error_handler&#39;);

        switch ($errors-&gt;type) {
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_CONTROLLER:
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_ACTION:
                // 404 error -- controller or action not found
                $this-&gt;getResponse()-&gt;setRawHeader(&#39;HTTP/1.1 404 Not Found&#39;);

                // ... get some output to display...
                break;
            default:
                // application error; display error page, but don&#39;t change
                // status code
                break;
        }
    }
}
         
            Finally, you can retrieve the exception that triggered the error
            handler by grabbing the  exception  property of the
             error_handler  object:
         &lt;?php
public function errorAction()
{
        $errors = $this-&gt;_getParam(&#39;error_handler&#39;);


        switch ($errors-&gt;type) {
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_CONTROLLER:
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_ACTION:
                // 404 error -- controller or action not found
                $this-&gt;getResponse()-&gt;setRawHeader(&#39;HTTP/1.1 404 Not Found&#39;);

                // ... get some output to display...
                break;
            default:
                // application error; display error page, but don&#39;t change
                // status code

                // ...

                // Log the exception:
                $exception = $errors-&gt;exception;
                $log = new Zend_Log(new Zend_Log_Writer_Stream(&#39;/tmp/applicationException.log&#39;));
                $log-&gt;debug($exception-&gt;getMessage() . &quot;\n&quot; .  $exception-&gt;getTraceAsString());
                break;
        }
}
         Handling Previously Rendered Output 
            If you dispatch multiple actions in a request, or if your action
            makes multiple calls to  render() , its possible that the
            response object already has content stored within it. This can lead
            to rendering a mixture of expected content and error content.
         
            If you wish to render errors inline in such pages, no changes will
            be necessary. If you do not wish to render such content, you should
            clear the response body prior to rendering any views:
         &lt;?php
$this-&gt;getResponse()-&gt;clearBody();
         Plugin Usage Examples Standard usage &lt;?php
require_once &#39;Zend/Controller/Front.php&#39;;
require_once &#39;Zend/Controller/Plugin/ErrorHandler.php&#39;;

$front = Zend_Controller_Front::getInstance();
$front-&gt;registerPlugin(new Zend_Controller_Plugin_ErrorHandler());
             Setting a different error handler &lt;?php
require_once &#39;Zend/Controller/Front.php&#39;;
require_once &#39;Zend/Controller/Plugin/ErrorHandler.php&#39;;

$front = Zend_Controller_Front::getInstance();
$front-&gt;registerPlugin(new Zend_Controller_Plugin_ErrorHandler(array(
    &#39;module&#39;     =&gt; &#39;mystuff&#39;,
    &#39;controller&#39; =&gt; &#39;static&#39;,
    &#39;action&#39;     =&gt; &#39;error&#39;
)));
             Using accessors &lt;?php
require_once &#39;Zend/Controller/Front.php&#39;;
require_once &#39;Zend/Controller/Plugin/ErrorHandler.php&#39;;

$plugin = new Zend_Controller_Plugin_ErrorHandler();
$plugin-&gt;setErrorHandlerModule(&#39;mystuff&#39;)
       -&gt;setErrorHandlerController(&#39;static&#39;)
       -&gt;setErrorHandlerAction(&#39;error&#39;);

$front = Zend_Controller_Front::getInstance();
$front-&gt;registerPlugin($plugin);
             Error Controller Example 
            In order to use the Error Handler plugin, you need an error
            controller. Below is a simple example.
         &lt;?php
class ErrorController extends Zend_Controller_Action
{
    public function errorAction()
    {
        $errors = $this-&gt;_getParam(&#39;error_handler&#39;);

        switch ($errors-&gt;type) {
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_CONTROLLER:
            case Zend_Controller_Plugin_ErrorHandler::EXCEPTION_NO_ACTION:
                // 404 error -- controller or action not found
                $this-&gt;getResponse()-&gt;setRawHeader(&#39;HTTP/1.1 404 Not Found&#39;);

                $content =&lt;&lt;&lt;EOH
&lt;h1&gt;Error!&lt;/h1&gt;
&lt;p&gt;The page you requested was not found.&lt;/p&gt;
EOH;
                break;
            default:
                // application error
                $content =&lt;&lt;&lt;EOH
&lt;h1&gt;Error!&lt;/h1&gt;
&lt;p&gt;An unexpected error occurred with your request. Please try again later.&lt;/p&gt;
EOH;
                break;
        }

        // Clear previous content
        $this-&gt;getResponse()-&gt;clearBody();

        $this-&gt;view-&gt;content = $content;
    }
}
         Plugins Introduction 
            The controller architecture includes a plugin system that allows
            user code to be called when certain events occur in the controller
            process lifetime.  The front controller uses a plugin broker as a
            registry for user plugins, and the plugin broker ensures that event
            methods are called on each plugin registered with the front
            controller.
         
            The event methods are defined in the abstract class
             Zend_Controller_Plugin_Abstract , from which user plugin
            classes inherit:
         routeStartup()  is called before
                     Zend_Controller_Front  calls on  the router 
                    to evaluate the request against the registered routes.
                 routeShutdown()  is called after  the router 
                    finishes routing the request.
                 dispatchLoopStartup()  is called before
                     Zend_Controller_Front  enters its dispatch loop.
                 preDispatch()  is called before an action is
                    dispatched by  the
                        dispatcher . This callback allows for proxy or
                    filter behavior. By altering the request and resetting its
                    dispatched flag (via
                     Zend_Controller_Request_Abstract::setDispatched(false) ),
                    the current action may be skipped and/or replaced.
                 postDispatch()  is called after an action is
                    dispatched by  the
                        dispatcher . This callback allows for proxy or
                    filter behavior. By altering the request and resetting its
                    dispatched flag (via
                     Zend_Controller_Request_Abstract::setDispatched(false) ),
                    a new action may be specified for dispatching.
                 dispatchLoopShutdown()  is called after
                     Zend_Controller_Front  exits its dispatch loop.
                 Writing Plugins 
            In order to write a plugin class, simply include and extend the
            abstract class  Zend_Controller_Plugin_Abstract :
         &lt;?php
require_once &#39;Zend/Controller/Plugin/Abstract.php&#39;;

class MyPlugin extends Zend_Controller_Plugin_Abstract
{
    // ...
}
         
            None of the methods of  Zend_Controller_Plugin_Abstract 
            are abstract, and this means that plugin classes are not forced to
            implement any of the available event methods listed above. Plugin
            writers may implement only those methods required by their
            particular needs.
         Zend_Controller_Plugin_Abstract  also makes the request
            and response objects available to controller plugins via the
             getRequest()  and  getResponse()  methods,
            respectively.
         Using Plugins 
            Plugin classes are registered with
             Zend_Controller_Front::registerPlugin() , and may be
            registered at any time.  The following snippet illustrates how a
            plugin may be used in the controller chain:
         &lt;?php
require_once &#39;Zend/Controller/Front.php&#39;;
require_once &#39;Zend/Controller/Router.php&#39;;
require_once &#39;Zend/Controller/Plugin/Abstract.php&#39;;

class MyPlugin extends Zend_Controller_Plugin_Abstract
{
    public function routeStartup(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody(&quot;&lt;p&gt;routeStartup() called&lt;/p&gt;\n&quot;);
    }

    public function routeShutdown(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody(&quot;&lt;p&gt;routeShutdown() called&lt;/p&gt;\n&quot;);
    }

    public function dispatchLoopStartup(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody(&quot;&lt;p&gt;dispatchLoopStartup() called&lt;/p&gt;\n&quot;);
    }

    public function preDispatch(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody(&quot;&lt;p&gt;preDispatch() called&lt;/p&gt;\n&quot;);
    }

    public function postDispatch(Zend_Controller_Request_Abstract $request)
    {
        $this-&gt;getResponse()-&gt;appendBody(&quot;&lt;p&gt;postDispatch() called&lt;/p&gt;\n&quot;);
    }

    public function dispatchLoopShutdown()
    {
        $this-&gt;getResponse()-&gt;appendBody(&quot;&lt;p&gt;dispatchLoopShutdown() called&lt;/p&gt;\n&quot;);
    }
}

$front = Zend_Controller_Front::getInstance();
$front-&gt;setControllerDirectory(&#39;/path/to/controllers&#39;)
      -&gt;setRouter(new Zend_Controller_Router_Rewrite())
      -&gt;registerPlugin(new MyPlugin());
$front-&gt;dispatch();
         
            Assuming that no actions called emit any output, and only one action
            is called, the functionality of the above plugin would still create
            the following output:
         
&lt;p&gt;routeStartup() called&lt;/p&gt;
&lt;p&gt;routeShutdown() called&lt;/p&gt;
&lt;p&gt;dispatchLoopStartup() called&lt;/p&gt;
&lt;p&gt;preDispatch() called&lt;/p&gt;
&lt;p&gt;postDispatch() called&lt;/p&gt;
&lt;p&gt;dispatchLoopShutdown() called&lt;/p&gt;
         
                Plugins may be registered at any time during the front
                controller execution. However, if an event has passed for which
                the plugin has a registered event method, that method will not
                be triggered.
             Retrieving and Manipulating Plugins 
            On occasion, you may need to unregister or retrieve a plugin. The
            following methods of the front controller allow you to do so:
         getPlugin($class)  allows you to retrieve a
                    plugin by class name. If no plugins match, it returns false.
                    If more than one plugin of that class is registered, it
                    returns an array.
             getPlugins()  retrieves the entire plugin stack.
             unregisterPlugin($plugin)  allows you to remove
                    a plugin from the stack. You may pass a plugin object, or
                    the class name of the plugin you wish to unregister. If you
                    pass the class name, any plugins of that class will be
                    removed.
             Plugins Included in the Standard Distribution 
            Zend Framework includes a plugin for error handling in its standard
            distribution.
         Zend_Controller Quick Start Introduction Zend_Controller  is the heart of Zend Framework&#39;s MVC
            system. MVC stands for  Model-View-Controller 
            and is a design pattern targeted at separating application logic
            from display logic.  Zend_Controller_Front  implements a
             Front
                Controller  pattern, in which all requests are
            intercepted by the front controller and dispatched to individual
            Action Controllers based on the URL requested.
         
            The  Zend_Controller  system was built with extensibility
            in mind, either by subclassing the existing classes, writing new
            classes that implement the various interfaces and abstract classes
            that form the foundation of the controller family of classes, or
            writing plugins or action helpers to augment or manipulate the
            functionality of the system.
         Quick Start 
            If you need more in-depth information, see the following sections.
            If you just want to get up and running quickly, read on.
         Create your filesystem layout 
                The first step is to create your file system layout. The typical
                layout is as follows:
             
application/
    controllers/
        IndexController.php
    models/
    views/
        scripts/
            index/
                index.phtml
        helpers/
        filters/
html/
    .htaccess
    index.php
             Set your document root 
                In your web server, point your document root to the
                 html  directory of the above file system layout.
             Create your rewrite rules 
                Edit the  html/.htaccess  file above to read as
                follows:
             
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php
             
                The above rules will route any non-resource (images,
                stylesheets) requests to the front controller. If there are
                other extensions you wish to exclude from the front controller
                (PDFs, text files, etc), add their extensions to the switch, or
                create your own rewrite rules.
             
                    The above rewrite rules are for Apache; for examples of
                    rewrite rules for other web servers, see the  router
                        documentation .
                 Create your bootstrap file 
                The bootstrap file is the page all requests are routed through
                --  html/index.php  in this case. Open up
                 html/index.php  in the editor of your choice and add
                the following:
             &lt;?php
require_once &#39;Zend/Controller/Front.php&#39;;
Zend_Controller_Front::run(&#39;/path/to/app/controllers&#39;);
             
                This will instantiate and dispatch the front controller, which
                will route requests to action controllers.
             Create your default action controller 
                Before discussing action controllers, you should first
                understand how requests are routed in Zend Framework. By
                default, the first segment of a URL path maps to a controller,
                and the second to an action. For example, given the URL
                 http://framework.zend.com/roadmap/components , the
                path is  /roadmap/components , which will map to the
                controller  roadmap  and the action
                 components . If no action is provided, the action
                 index  is assumed, and if no controller is provided,
                the controller  index  is assumed (following the
                Apache convention that maps a  DirectoryIndex 
                automatically).
             Zend_Controller &#39;s dispatcher then takes the
                controller value and maps it to a class. By default, it
                Title-cases the controller name and appends the word
                 Controller . Thus, in our example above, the
                controller  roadmap  is mapped to the class
                 RoadmapController .
             
                Similarly, the action value is mapped to a method of the
                controller class. By default, the value is lower-cased, and the
                word  Action  is appended. Thus, in our example
                above, the action  components  becomes
                 componentsAction , and the final method called is
                 RoadmapController::componentsAction() .
             
                So, moving on, let&#39;s now create a default action controller and
                action method. As noted earlier, the default controller and
                action called are both  index . Open the file
                 application/controllers/IndexController.php , and
                enter the following:
             &lt;?php
/** Zend_Controller_Action */
require_once &#39;Zend/Controller/Action.php&#39;;

class IndexController extends Zend_Controller_Action
{
    public function indexAction()
    {
    }
}
             
                By default, the  ViewRenderer 
                action helper is enabled. What this means is that by simply
                defining an action method and a corresponding view script, you
                will immediately get content rendered.  By default,
                 Zend_View  is used as the View layer in the MVC. The
                 ViewRenderer  does some magic, and uses the
                controller name (e.g.,  index ) and the current
                action name (e.g.,  index ) to determine what
                template to pull. By default, templates end in the
                 .phtml  extension, so this means that, in the above
                example, the template  index/index.phtml  will be
                rendered. Additionally, the  ViewRenderer 
                automatically assumes that the directory  views  at
                the same level as the controller directory will be the base view
                directory, and that the actual view scripts will be in the
                 views/scripts/  subdirectory. Thus, the template
                rendered will be found in
                 application/views/scripts/index/index.phtml .
             Create your view script 
                As mentioned  in the
                    previous section , view scripts are found in
                 application/views/scripts/ ; the view script for the
                default controller and action is in
                 application/views/scripts/index/index.phtml . Create
                this file, and type in some HTML:
             
&lt;!DOCTYPE html
PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;title&gt;My first Zend Framework App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello, World!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
             Create your error controller 
                By default,  the
                error handler plugin  is registered. This plugin expects
                that a controller exists to handle errors. By default, it
                assumes an  ErrorController  in the default module
                with an  errorAction  method:
             &lt;?php
/** Zend_Controller_Action */
require_once &#39;Zend/Controller/Action.php&#39;;

class ErrorController extends Zend_Controller_Action
{
    public function errorAction()
    {
    }
}
             
                Assuming the already discussed directory layout, this file will
                go in  application/controllers/ErrorController.php .
                You will also need to create a view script in
                 application/views/scripts/error/error.phtml ; sample
                content might look like:
             
&lt;!DOCTYPE html
PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;
&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
  &lt;title&gt;Error&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;An error occurred&lt;/h1&gt;
    &lt;p&gt;An error occurred; please try again later.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
             View the site! 
                With your first controller and view under your belt, you can now
                fire up your browser and browse to the site. Assuming
                 example.com  is your domain, any of the following
                URLs will get to the page we&#39;ve just created:
             http://example.com/ http://example.com/index http://example.com/index/index 
                You&#39;re now ready to start creating more controllers and action
                methods. Congratulations!
             The Request Object Introduction 
            The request object is a simple value object that is passed between
             Zend_Controller_Front  and the router, dispatcher, and
            controller classes.  It packages the names of the requested module,
            controller, action, and optional parameters, as well as the rest of
            the request environment, be it HTTP, the CLI, or PHP-GTK.
         
                The module name is accessed by
                 getModuleName()  and
                 setModuleName() .
             
                The controller name is accessed by
                 getControllerName()  and
                 setControllerName() .
             
                The name of the action to call within that controller is
                accessed by  getActionName()  and
                 setActionName() .
             
                Parameters to be accesible by the action are an associative array
                of key/value pairs that are retrieved by  getParams() 
                and set with  setParams() , or individually by
                 getParam()  and  setParam() .
             
            Based on the type of request, there may be more methods available.
            The default request used,  Zend_Controller_Request_Http ,
            for instance, has methods for retrieving the request URI, path
            information,  $_GET  and  $_POST  parameters,
            etc.
         
            The request object is passed to the front controller, or if none is
            provided, it is instantiated at the beginning of the dispatch
            process, before routing occurs. It is passed through to every object
            in the dispatch chain.
         
            Additionally, the request object is particularly useful in testing.
            The developer may craft the request environment, including module,
            controller, action, parameters, URI, etc, and pass the request
            object to the front controller to test application flow. When paired
            with the  response
                object , elaborate and precise unit testing of MVC
            applications becomes possible.
         HTTP Requests Accessing Request Data Zend_Controller_Request_Http  encapsulates access to
                relevant values such as the key name and value for the
                controller and action router variables, and all additional
                parameters parsed from the URI. It additionally allows access to
                values contained in the superglobals as public members, and
                manages the current Base URL and Request URI.  Superglobal
                values cannot be set on a request object, instead use the
                setParam/getParam methods to set or retrieve user parameters.
             Superglobal data 
                    When accessing superglobal data through
                     Zend_Controller_Request_Http  as public member
                    properties, it is necessary to keep in mind that the
                    property name (superglobal array key) is matched to a
                    superglobal in a specific order of precedence: 1. GET, 2.
                    POST, 3. COOKIE, 4. SERVER, 5. ENV.
                 
                Specific superglobals can be accessed using a public method as
                an alternative. For example, the raw value of
                 $_POST[&#39;user&#39;]  can be accessed by calling
                 getPost(&#39;user&#39;)  on the request object. These
                include  getQuery()  for retrieving
                 $_GET  elements, and  getHeader()  for
                retrieving request headers.
             GET and POST data 
                    Be cautious when accessing data from the request object as
                    it is not filtered in any way. The router and dispatcher
                    validate and filter data for use with their tasks, but leave
                    the data untouched in the request object.
                 Retrieve the Raw POST Data, Too! 
                    As of 1.5.0, you can also retrieve the raw post data via the
                     getRawBody()  method. This method returns false
                    if no data was submitted in that fashion, but the full body
                    of the post otherwise.
                 
                    This is primarily useful for accepting content when
                    developing a RESTful MVC application.
                 
                You may also set user parameters in the request object using
                 setParam()  and retrieve these later using
                 getParam() . The router makes use of this
                functionality to set parameters matched in the request URI into
                the request object.
             getParam() retrieves more than user params 
                    In order to do some of its work,  getParam()  actually
                    retrieves from several sources. In order of priority, these
                    include: user parameters set via  setParam() ,
                     GET  parameters, and finally  POST 
                    parameters.  Be aware of this when pulling data via this
                    method.
                 
                    If you wish to pull only from parameters you set via
                     setParam() , use the  getUserParam() .
                 
                    Additionally, as of 1.5.0, you can lock down which parameter
                    sources will be searched.  setParamSources() 
                    allows you to specify an empty array or an array with one or
                    more of the values &#39;_GET&#39; or &#39;_POST&#39; indicating which
                    parameter sources are allowed (by default, both are
                    allowed); if you wish to restrict access to only &#39;_GET&#39;
                    specify  setParamSources(array(&#39;_GET&#39;)) .
                 Apache Quirks 
                    If you are using Apache&#39;s 404 handler to pass incoming
                    requests to the front controller, or using a PT flag with
                    rewrite rules,  $_SERVER[&#39;REDIRECT_URL&#39;] 
                    contains the URI you need, not
                     $_SERVER[&#39;REQUEST_URI&#39;] . If you are using such
                    a setup and getting invalid routing, you should use the
                     Zend_Controller_Request_Apache404  class instead
                    of the default Http class for your request object:
                 &lt;?php
require_once &#39;Zend/Controller/Request/Apache404.php&#39;;
$request = new Zend_Controller_Request_Apache404();
$front-&gt;setRequest($request);
                 
                    This class extends the
                     Zend_Controller_Request_Http  class and simply
                    modifies the autodiscovery of the request URI. It can be
                    used as a drop-in replacement.
                 Base Url and Subdirectories Zend_Controller_Request_Http  allows
                Zend_Controller_Router_Rewrite to be used in subdirectories.
                Zend_Controller_Request_Http will attempt to automatically
                detect your base URL and set it accordingly.
             
                For example, if you keep your  index.php  in a
                webserver subdirectory named
                 /projects/myapp/index.php , base URL (rewrite base)
                should be set to  /projects/myapp . This string will
                then be stripped from the beginning of the path before
                calculating any route matches. This frees one from the necessity
                of prepending it to any of your routes. A route of
                 &#39;user/:username&#39;  will match URIs like
                 http://localhost/projects/myapp/user/martel  and
                 http://example.com/user/martel .
             URL detection is case sensitive 
                    Automatic base URL detection is case sensitive, so make sure your URL
                    will match a subdirectory name in a filesystem (even on Windows
                    machines). If it doesn&#39;t, an exception will be raised.
                 
                Should base URL be detected incorrectly you can override it
                with your own base path with the help of the
                 setBaseUrl()  method of either the
                 Zend_Controller_Request_Http  class, or the
                 Zend_Controller_Front  class. The easiest
                method is to set it in  Zend_Controller_Front ,
                which will proxy it into the request object. Example usage to
                set a custom base URL:
             &lt;?php
/**
 * Dispatch Request with custom base URL with Zend_Controller_Front.
 */
$router     = new Zend_Controller_Router_Rewrite();
$controller = Zend_Controller_Front::getInstance();
$controller-&gt;setControllerDirectory(&#39;./application/controllers&#39;)
           -&gt;setRouter($router)
           -&gt;setBaseUrl(&#39;/projects/myapp&#39;); // set the base url!
$response   = $controller-&gt;dispatch();
             Determining the Request Method getMethod()  allows you to determine the HTTP
                request method used to request the current resource.
                Additionally, a variety of methods exist that allow you to get
                boolean responses when asking if a specific type of request has
                been made:
             isGet() isPost() isPut() isDelete() isHead() isOptions() 
                The primary use case for these is for creating RESTful MVC
                architectures.
             Detecting AJAX Requests Zend_Controller_Request_Http  has a rudimentary
                method for detecting AJAX requests:
                 isXmlHttpRequest() . This method looks for an
                HTTP request header  X-Requested-With  with the value
                &#39;XMLHttpRequest&#39;; if found, it returns true.
             
                Currently, this header is known to be passed by default with the
                following JS libraries:
             Prototype/Scriptaculous (and libraries derived
                        from Prototype) Yahoo! UI Library jQuery MochiKit 
                Most AJAX libraries allow you to send custom HTTP request
                headers; if your library does not send this header, simply add
                it as a request header to ensure the
                 isXmlHttpRequest()  method works for you.
             Subclassing the Request Object 
            The base request class used for all request objects is the abstract
            class  Zend_Controller_Request_Abstract . At its most
            basic, it defines the following methods:
         
abstract class Zend_Controller_Request_Abstract
{
    /**
     * @return string
     */
    public function getControllerName();

    /**
     * @param string $value
     * @return self
     */
    public function setControllerName($value);

    /**
     * @return string
     */
    public function getActionName();

    /**
     * @param string $value
     * @return self
     */
    public function setActionName($value);

    /**
     * @return string
     */
    public function getControllerKey();

    /**
     * @param string $key
     * @return self
     */
    public function setControllerKey($key);

    /**
     * @return string
     */
    public function getActionKey();

    /**
     * @param string $key
     * @return self
     */
    public function setActionKey($key);

    /**
     * @param string $key
     * @return mixed
     */
    public function getParam($key);

    /**
     * @param string $key
     * @param mixed $value
     * @return self
     */
    public function setParam($key, $value);

    /**
     * @return array
     */
     public function getParams();

    /**
     * @param array $array
     * @return self
     */
    public function setParams(array $array);

    /**
     * @param boolean $flag
     * @return self
     */
    public function setDispatched($flag = true);

    /**
     * @return boolean
     */
    public function isDispatched();
}
         
            The request object is a container for the request environment. The
            controller chain really only needs to know how to set and retrieve the
            controller, action, optional parameters, and dispatched status. By
            default, the request will search its own parameters using the
            controller or action keys in order to determine the controller and
            action.
         
            Extend this class, or one of its derivatives, when you need the
            request class to interact with a specific environment in order to
            retrieve data for use in the above tasks. Examples include  the HTTP
                environment , a CLI environment, or a PHP-GTK environment.
         The Response Object Usage 
            The response object is the logical counterpart to the  request object . Its
            purpose is to collate content and/or headers so that they may be
            returned en masse. Additionally, the front controller will pass any
            caught exceptions to the response object, allowing the developer to
            gracefully handle exceptions. This functionality may be overridden
            by setting
             Zend_Controller_Front::throwExceptions(true) :
         
$front-&gt;throwExceptions(true);
         
            To send the response output, including headers, use
             sendResponse() .
         
$response-&gt;sendResponse();
         
                By default, the front controller calls  sendResponse() 
                when it has finished dispatching the request; typically you will
                never need to call it. However, if you wish to manipulate the
                response or use it in testing, you can override this
                behaviour by setting the  returnResponse  flag with
                 Zend_Controller_Front::returnResponse(true) :
             &lt;?php
$front-&gt;returnResponse(true);
$response = $front-&gt;dispatch();

// do some more processing, such as logging...
// and then send the output:
$response-&gt;sendResponse();
             
            Developers should make use of the response object in their action
            controllers. Instead of directly rendering output and sending
            headers, push them to the response object:
         
// Within an action controller action:
// Set a header
$this-&gt;getResponse()
    -&gt;setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;)
    -&gt;appendBody($content);
         
            By doing this, all headers get sent at once, just prior to
            displaying the content.
         
                If using the action controller  view
                    integration , you do not need to set the rendered view
                script content in the response object, as
                 Zend_Controller_Action::render()  does this by default.
             
            Should an exception occur in an application, check the response object&#39;s
             isException()  flag, and retrieve the exception using
             getException() . Additionally, one may create custom
            response objects that redirect to error pages, log exception messages,
            do pretty formatting of exception messages (for development
            environments), etc.
         
            You may retrieve the response object following the front controller
            dispatch(), or request the front controller to return the response
            object instead of rendering output.
         
// retrieve post-dispatch:
$front-&gt;dispatch();
$response = $front-&gt;getResponse();
if ($response-&gt;isException()) {
    // log, mail, etc...
}

// Or, have the front controller dispatch() process return it
$front-&gt;returnResponse(true);
$response = $front-&gt;dispatch();

// do some processing...

// finally, echo the response
$response-&gt;sendResponse();
         
            By default, exception messages are not displayed. This behaviour may be
            overridden by calling  renderExceptions() , or enabling the
            front controller to throwExceptions(), as shown above:
         
$response-&gt;renderExceptions(true);
$front-&gt;dispatch($request, $response);

// or:
$front-&gt;returnResponse(true);
$response = $front-&gt;dispatch();
$response-&gt;renderExceptions();
$response-&gt;sendResponse();

// or:
$front-&gt;throwExceptions(true);
$front-&gt;dispatch();
         Manipulating Headers 
            As stated previously, one aspect of the response object&#39;s duties is
            to collect and emit HTTP response headers.  A variety of methods
            exist for this:
         canSendHeaders()  is used to determine if
                    headers have already been sent. It takes an optional flag
                    indicating whether or not to throw an exception if headers
                    have already been sent. This can be overridden by setting
                    the property  headersSentThrowsException  to
                     false .
                 setHeader($name, $value, $replace = false)  is
                    used to set an individual header. By default, it does not
                    replace existing headers of the same name in the object;
                    however, setting  $replace  to true will force it
                    to do so.
                 
                    Before setting the header, it checks with
                     canSendHeaders()  to see if this operation is
                    allowed at this point, and requests that an exception be
                    thrown.
                 setRedirect($url, $code = 302)  sets an HTTP
                    Location header for a redirect. If an HTTP status code has
                    been provided, it will use that status code.
                 
                    Internally, it calls  setHeader()  with the
                     $replace  flag on to ensure only one such header
                    is ever sent.
                 getHeaders()  returns an array of all headers.
                    Each array element is an array with the keys &#39;name&#39; and
                    &#39;value&#39;.
                 clearHeaders()  clears all registered headers.
                 setRawHeader()  can be used to set headers that
                    are not key/value pairs, such as an HTTP status header.
                 getRawHeaders()  returns any registered raw
                    headers.
                 clearRawHeaders()  clears any registered raw
                    headers.
                 clearAllHeaders()  clears both regular key/value
                    headers as well as raw headers.
                 
            In addition to the above methods, there are accessors for setting
            and retrieving the HTTP response code for the current request,
             setHttpResponseCode()  and
             getHttpResponseCode() .
         Named Segments 
            The response object has support for &quot;named segments&quot;. This allows
            you to segregate body content into different segments and order
            those segments so output is returned in a specific order.
            Internally, body content is saved as an array, and the various
            accessor methods can be used to indicate placement and names within
            that array.
         
            As an example, you could use a  preDispatch()  hook to
            add a header to the response object, then have the action controller
            add body content, and a  postDispatch()  hook add a
            footer:
         &lt;?php
// Assume that this plugin class is registered with the front controller
class MyPlugin extends Zend_Controller_Plugin_Abstract
{
    public function preDispatch(Zend_Controller_Request_Abstract $request)
    {
        $response = $this-&gt;getResponse();
        $view = new Zend_View();
        $view-&gt;setBasePath(&#39;../views/scripts&#39;);

        $response-&gt;prepend(&#39;header&#39;, $view-&gt;render(&#39;header.phtml&#39;));
    }

    public function postDispatch(Zend_Controller_Request_Abstract $request)
    {
        $response = $this-&gt;getResponse();
        $view = new Zend_View();
        $view-&gt;setBasePath(&#39;../views/scripts&#39;);

        $response-&gt;append(&#39;footer&#39;, $view-&gt;render(&#39;footer.phtml&#39;));
    }
}

// a sample action controller
class MyController extends Zend_Controller_Action
{
    public function fooAction()
    {
        $this-&gt;render();
    }
}
         
            In the above example, a call to  /my/foo  will cause the
            final body content of the response object to have the following
            structure:
         &lt;?php
array(
    &#39;header&#39;  =&gt; ..., // header content
    &#39;default&#39; =&gt; ..., // body content from MyController::fooAction()
    &#39;footer&#39;  =&gt; ...  // footer content
);
         
            When this is rendered, it will render in the order in which elements
            are arranged in the array.
         
            A variety of methods can be used to manipulate the named segments:
         setBody()  and  appendBody()  both
                    allow you to pass a second value,  $name ,
                    indicating a named segment. In each case, if you provide
                    this, it will overwrite that specific named segment or
                    create it if it does not exist (appending to the array by
                    default). If no named segment is passed to
                     setBody() , it resets the entire body content
                    array. If no named segment is passed to appendBody(), the
                    content is appended to the value in the &#39;default&#39; name
                    segment.
                 prepend($name, $content)  will create a segment
                    named  $name  and place it at the beginning of
                    the array. If the segment exists already, it will be removed
                    prior to the operation (i.e., overwritten and replaced).
                 append($name, $content)  will create a segment
                    named  $name  and place it at the end of
                    the array. If the segment exists already, it will be removed
                    prior to the operation (i.e., overwritten and replaced).
                 insert($name, $content, $parent = null, $before =
                        false)  will create a segment named
                     $name . If provided with a  $parent 
                    segment, the new segment will be placed either before or
                    after that segment (based on the value of
                     $before ) in the array. If the segment exists
                    already, it will be removed prior to the operation (i.e.,
                    overwritten and replaced).
                 clearBody($name = null)  will remove a single
                    named segment if a  $name  is provided (and the
                    entire array otherwise).
                 getBody($spec = false)  can be used to retrieve a single
                    array segment if  $spec  is the name of a named
                    segment. If  $spec  is false, it returns a string
                    formed by concatenating all named segments in order. If
                     $spec  is true, it returns the body content
                    array.
                 Testing for Exceptions in the Response Object 
            As mentioned earlier, by default, exceptions caught during dispatch
            are registered with the response object. Exceptions are registered
            in a stack, which allows you to keep all exceptions thrown --
            application exceptions, dispatch exceptions, plugin exceptions, etc.
            Should you wish to check for particular exceptions or to log
            exceptions, you&#39;ll want to use the response object&#39;s exception API:
         setException(Exception $e)  allows you to
                    register an exception.
                 isException()  will tell you if an exception has
                    been registered.
                 getException()  returns the entire
                    exception stack.
                 hasExceptionOfType($type)  allows you to
                    determine if an exception of a particular class is in the
                    stack.
                 hasExceptionOfMessage($message)  allows you to
                    determine if an exception with a specific message is in the
                    stack.
                 hasExceptionOfCode($code)  allows you to
                    determine if an exception with a specific code is in the
                    stack.
                 getExceptionByType($type)  allows you to
                    retrieve all exceptions of a specific class from the stack.
                    It will return false if none are found, and an array of
                    exceptions otherwise.
                 getExceptionByMessage($message)  allows you to
                    retrieve all exceptions with a specific message from the stack.
                    It will return false if none are found, and an array of
                    exceptions otherwise.
                 getExceptionByCode($code)  allows you to
                    retrieve all exceptions with a specific code from the stack.
                    It will return false if none are found, and an array of
                    exceptions otherwise.
                 renderExceptions($flag)  allows you to set a
                    flag indicating whether or not exceptions should be emitted
                    when the response is sent.
                 Subclassing the Response Object 
            The purpose of the response object is to collect headers and content
            from the various actions and plugins and return them to the client;
            secondarily, it also collects any errors (exceptions) that occur in
            order to process them, return them, or hide them from the end user.
         
            The base response class is
             Zend_Controller_Response_Abstract , and any subclass you
            create should extend that class or one of its derivatives. The
            various methods available have been listed in the previous sections.
         
            Reasons to subclass the response object include modifying how output
            is returned based on the request environment (e.g., not sending
            headers for CLI or PHP-GTK requests), adding functionality to return
            a final view based on content stored in named segments, etc.
         Zend_Controller_Router_Route_Regex 
        In addition to the default and static route types, a Regular
        Expression route type is available. This route offers more power and
        flexibility over the others, but at a slight cost of complexity. At the
        same time, it should be faster than the standard Route.
     
        Like the standard route, this route has to be initialized with a route
        definition and some defaults. Let&#39;s create an archive route as an
        example, similar to the previoulsy defined one, only using the Regex
        route this time:
     
$route = new Zend_Controller_Router_Route_Regex(
    &#39;archive/(\d+)&#39;,
    array(
        &#39;controller&#39; =&gt; &#39;archive&#39;,
        &#39;action&#39;     =&gt; &#39;show&#39;
    )
);
$router-&gt;addRoute(&#39;archive&#39;, $route);
     
        Every defined regex subpattern will be injected to the request
        object. With our above example, after successful matching
         http://domain.com/archive/2006 , the resulting value
        array may look like:
     
$values = array(
    1            =&gt; &#39;2006&#39;,
    &#39;controller&#39; =&gt; &#39;archive&#39;,
    &#39;action&#39;     =&gt; &#39;show&#39;
);
     
            Leading and trailing slashes are trimmed from the URL in the Router
            prior to a match. As a result, matching the URL
             http://domain.com/foo/bar/ , would involve a regex of
             foo/bar , and not  /foo/bar .
         
            Line start and line end anchors (&#39;^&#39; and &#39;$&#39;, respectively) are
            automatically pre- and appended to all expressions.  Thus, you
            should not use these in your regular expressions, and you should
            match the entire string.
         
            This route class uses the  #  character for a delimiter.
            This means that you will need to escape hash characters (&#39;#&#39;) but
            not forward slashes (&#39;/&#39;) in your route definitions.  Since the &#39;#&#39;
            character (named anchor) is rarely passed to the webserver, you will
            rarely need to use that character in your regex.
         
        You can get the contents of the defined subpatterns the usual way:
     
public function showAction()
{
    $request = $this-&gt;getRequest();
    $year    = $request-&gt;getParam(1); // $year = &#39;2006&#39;;
}
     Notice the key is an integer (1) instead of a string (&#39;1&#39;). 
        This route will not yet work exactly the same as its standard route
        counterpart since the default for &#39;year&#39; is not yet set. And what may
        not yet be evident is that we will have a problem with a trailing slash
        even if we declare a default for the year and make the subpattern
        optional. The solution is to make the whole year part optional along
        with the slash but catch only the numeric part:
     
$route = new Zend_Controller_Router_Route_Regex(
    &#39;archive(?:/(\d+))?&#39;,
    array(
        1            =&gt; &#39;2006&#39;,
        &#39;controller&#39; =&gt; &#39;archive&#39;,
        &#39;action&#39;     =&gt; &#39;show&#39;
    )
);
$router-&gt;addRoute(&#39;archive&#39;, $route);
     
        Now let&#39;s get to the problem you have probably noticed on your own by
        now. Using integer based keys for parameters is not an easily manageable
        solution and may be potentially problematic in the long run. And that&#39;s
        where the third parameter comes in. This parameter is an associative
        array that represents a map of regex subpatterns to parameter named
        keys. Let&#39;s work on our easier example:
     
$route = new Zend_Controller_Router_Route_Regex(
    &#39;archive/(\d+)&#39;,
    array(
        &#39;controller&#39; =&gt; &#39;archive&#39;,
        &#39;action&#39; =&gt; &#39;show&#39;
    ),
    array(
        1 =&gt; &#39;year&#39;
    )
);
$router-&gt;addRoute(&#39;archive&#39;, $route);
     
        This will result in following values injected into Request:
     
$values = array(
    &#39;year&#39;       =&gt; &#39;2006&#39;,
    &#39;controller&#39; =&gt; &#39;archive&#39;,
    &#39;action&#39;     =&gt; &#39;show&#39;
);
     
        The map may be defined in either direction to make it work in any
        environment. Keys may contain variable names or subpattern indexes:
     
$route = new Zend_Controller_Router_Route_Regex(
    &#39;archive/(\d+)&#39;,
    array( ... ),
    array(1 =&gt; &#39;year&#39;)
);

// OR

$route = new Zend_Controller_Router_Route_Regex(
    &#39;archive/(\d+)&#39;,
    array( ... ),
    array(&#39;year&#39; =&gt; 1)
);
     
            Subpattern keys have to be represented by integers.
         
        Notice that the numeric index in Request values is now gone and a named
        variable is shown in its place. Of course you can mix numeric and named
        variables if you wish:
     
$route = new Zend_Controller_Router_Route_Regex(
    &#39;archive/(\d+)/page/(\d+)&#39;,
    array( ... ),
    array(&#39;year&#39; =&gt; 1)
);
     
        Which will result in mixed values available in the Request.  As an
        example, the URL  http://domain.com/archive/2006/page/10 
        will result in following values:
     
$values = array(
    &#39;year&#39;       =&gt; &#39;2006&#39;,
    2            =&gt; 10,
    &#39;controller&#39; =&gt; &#39;archive&#39;,
    &#39;action&#39;     =&gt; &#39;show&#39;
);
     
        Since regex patterns are not easily reversed, you will need to prepare
        a reverse URL if you wish to use a URL helper or even an assemble method
        of this class. This reversed path is represented by a string parsable by
        sprintf() and is defined as a fourth construct parameter:
     
$route = new Zend_Controller_Router_Route_Regex(
    &#39;archive/(\d+)&#39;,
    array( ... ),
    array(&#39;year&#39; =&gt; 1),
    &#39;archive/%s&#39;
);
     
        All of this is something which was already possible by the means of a
        standard route object, so where&#39;s the benefit in using the Regex route,
        you ask?  Primarily, it allows you to describe any type of URL without
        any restrictions.  Imagine you have a blog and wish to create URLs like:
         http://domain.com/blog/archive/01-Using_the_Regex_Router.html ,
        and have it decompose the last path element,
         01-Using_the_Regex_Router.html , into an article ID and
        article title/description; this is not possible with the standard route.
        With the Regex route, you can do something like the following solution:
     
$route = new Zend_Controller_Router_Route_Regex(
    &#39;blog/archive/(\d+)-(.+)\.html&#39;,
    array(
        &#39;controller&#39; =&gt; &#39;blog&#39;,
        &#39;action&#39;     =&gt; &#39;view&#39;
    ),
    array(
        1 =&gt; &#39;id&#39;,
        2 =&gt; &#39;description&#39;
    ),
    &#39;blog/archive/%d-%s.html&#39;
);
$router-&gt;addRoute(&#39;blogArchive&#39;, $route);
     
        As you can see, this adds a tremendous amount of flexibility over the
        standard route.
     Zend_Controller_Router_Route_Static 
        The examples above all use dynamic routes -- routes that contain
        patterns to match against. Sometimes, however, a particular route is
        set in stone, and firing up the regular expression engine would be
        an overkill. The answer to this situation is to use static routes:
     &lt;?php
$route = new Zend_Controller_Router_Route_Static(
    &#39;login&#39;,
    array(&#39;controller&#39; =&gt; &#39;auth&#39;, &#39;action&#39; =&gt; &#39;login&#39;)
);
$router-&gt;addRoute(&#39;login&#39;, $route);
     
        Above route will match a URL of  http://domain.com/login ,
        and dispatch to  AuthController::loginAction() .
     Zend_Controller_Router_Route Zend_Controller_Router_Route  is the standard framework
        route. It combines ease of use with flexible route definition.  Each
        route consists primarily of URL mapping (of static and dynamic parts
        (variables)) and may be initialized with defaults as well as with
        variable requirements.
     
        Let&#39;s imagine our fictional application will need some informational
        page about the content authors. We want to be able to point our web
        browsers to  http://domain.com/author/martel  to see the
        information about this &quot;martel&quot; guy. And the route for such
        functionality could look like:
     &lt;?php
$route = new Zend_Controller_Router_Route(
    &#39;author/:username&#39;,
    array(
        &#39;controller&#39; =&gt; &#39;profile&#39;,
        &#39;action&#39;     =&gt; &#39;userinfo&#39;
    )
);

$router-&gt;addRoute(&#39;user&#39;, $route);
     
        The first parameter in the  Zend_Controller_Router_Route 
        constructor is a route definition that will be matched to a URL.  Route
        definitions consist of static and dynamic parts separated by the slash
        (&#39;/&#39;) character.  Static parts are just simple text:
         author .  Dynamic parts, called variables, are marked by
        prepending a colon to the variable name:  :username .
     Character usage 
            The current implementation allows you to use any character (except a
            slash) as a variable identifier, but it is strongly recommended that
            one uses only characters that are valid for PHP variable
            identifiers. Future implementations may alter this behaviour, which
            could result in hidden bugs in your code.
         
        This example route should be matched when you point your browser to
         http://domain.com/author/martel , in which case all its
        variables will be injected to the  Zend_Controller_Request 
        object and will be accessible in your  ProfileController .
        Variables returned by this example may be represented as an array of
        the following key and value pairs:
     &lt;?php
$values = array(
    &#39;username&#39;   =&gt; &#39;martel&#39;,
    &#39;controller&#39; =&gt; &#39;profile&#39;,
    &#39;action&#39;     =&gt; &#39;userinfo&#39;
);
     
        Later on,  Zend_Controller_Dispatcher_Standard  should invoke
        the  userinfoAction()  method of your
         ProfileController  class (in the default module) based on
        these values. There you will be able to access all variables by means of
        the  Zend_Controller_Action::_getParam()  or
         Zend_Controller_Request::getParam()  methods:
     &lt;?php
public function userinfoAction()
{
    $request = $this-&gt;getRequest();
    $username = $request-&gt;getParam(&#39;username&#39;);

    $username = $this-&gt;_getParam(&#39;username&#39;);
}
     
        Route definition can contain one more special character - a wildcard
        - represented by &#39;*&#39; symbol. It is used to gather parameters similarly
        to the default Module route (var =&gt; value pairs defined in the URI).  The
        following route more-or-less mimics the Module route behavior:
     &lt;?php
$route = new Zend_Controller_Router_Route(
    &#39;:module/:controller/:action/*&#39;,
    array(&#39;module&#39; =&gt; &#39;default&#39;)
);
$router-&gt;addRoute(&#39;default&#39;, $route);
     Variable defaults 
            Every variable in the route can have a default and this is what the
            second parameter of the  Zend_Controller_Router_Route 
            constructor is used for. This parameter is an array with keys
            representing variable names and with values as desired defaults:
         &lt;?php
$route = new Zend_Controller_Router_Route(
    &#39;archive/:year&#39;,
    array(&#39;year&#39; =&gt; 2006)
);
$router-&gt;addRoute(&#39;archive&#39;, $route);
         
            The above route will match URLs like
             http://domain.com/archive/2005  and
             http://example.com/archive . In the latter case the
            variable year will have an initial default value of 2006.
         
            This example will result in injecting a year variable to the request
            object.  Since no routing information is present (no controller and
            action parameters are defined), the application will be dispatched
            to the default controller and action method (which are both defined
            in  Zend_Controller_Dispatcher_Abstract ).  To make it
            more usable, you have to provide a valid controller and a valid
            action as the route&#39;s defaults:
         &lt;?php
$route = new Zend_Controller_Router_Route(
    &#39;archive/:year&#39;,
    array(
        &#39;year&#39;       =&gt; 2006,
        &#39;controller&#39; =&gt; &#39;archive&#39;,
        &#39;action&#39;     =&gt; &#39;show&#39;
    )
);
$router-&gt;addRoute(&#39;archive&#39;, $route);
         
            This route will then result in dispatching to the method
             showAction()  of the class
             ArchiveController .
         Variable requirements 
            One can add a third parameter to the
             Zend_Controller_Router_Route  constructor where variable
            requirements may be set. These are defined as parts of a regular
            expression:
         &lt;?php
$route = new Zend_Controller_Router_Route(
    &#39;archive/:year&#39;,
    array(
        &#39;year&#39;       =&gt; 2006,
        &#39;controller&#39; =&gt; &#39;archive&#39;,
        &#39;action&#39;     =&gt; &#39;show&#39;
    ),
    array(&#39;year&#39; =&gt; &#39;\d+&#39;)
);
$router-&gt;addRoute(&#39;archive&#39;, $route);
         
            With a route defined like above, the router will match it only when
            the year variable will contain numeric data, eg.
             http://domain.com/archive/2345 . A URL like
             http://example.com/archive/test  will not be matched and
            control will be passed to the next route in the chain instead.
         The Standard Router: Zend_Controller_Router_Rewrite Introduction Zend_Controller_Router_Rewrite  is the standard
            framework router. Routing is the process of taking a URI endpoint
            (that part of the URI which comes after the base URL) and
            decomposing it into parameters to determine which module,
            controller, and action of that controller should receive the
            request. This values of the module, controller, action and other
            parameters are packaged into a
             Zend_Controller_Request_Http  object which is then
            processed by  Zend_Controller_Dispatcher_Standard .
            Routing occurs only once: when the request is initially received and
            before the first controller is dispatched.
         Zend_Controller_Router_Rewrite  is designed to allow for
            mod_rewrite-like functionality using pure php structures. It is very
            loosely based on Ruby on Rails routing and does not require any
            prior knowledge of webserver URL rewriting. It is designed to work
            with a single Apache mod_rewrite rule (one of):
         
RewriteEngine on
RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php
         
            or:
         
RewriteEngine on
RewriteCond %{SCRIPT_FILENAME} !-f
RewriteCond %{SCRIPT_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 
         
            The rewrite router can also be used with the IIS webserver if  Isapi_Rewrite  has been
            installed as an Isapi extension with the following rewrite rule:
         
RewriteRule ^[\w/\%]*(?:\.(?!(?:js|ico|gif|jpg|png|css)$)[\w\%]*$)? /index.php [I]
         IIS Isapi_Rewrite 
                When using IIS,  $_SERVER[&#39;REQUEST_URI&#39;]  will either
                not exist, or be set as an empty string. In this case,
                 Zend_Controller_Request_Http  will attempt to use
                the  $_SERVER[&#39;HTTP_X_REWRITE_URL&#39;]  value set by the
                Isapi_Rewrite extension.
             
            If using Lighttpd, the following rewrite rule is valid:
         
url.rewrite-once = ( &quot;.*\.(js|ico|gif|jpg|png|css)$&quot; =&gt; &quot;$0&quot;, &quot;&quot; =&gt; &quot;/index.php&quot;)
         Using a router 
            To properly use the rewrite router you have to instantiate it, add
            some user defined routes and inject it into the controller.  The
            following code illustrates the procedure:
         &lt;?php
/* Create a router */

$router = $ctrl-&gt;getRouter(); // returns a rewrite router by default
$router-&gt;addRoute(
    &#39;user&#39;,
    new Zend_Controller_Router_Route(&#39;user/:username&#39;, array(&#39;controller&#39; =&gt; &#39;user&#39;, &#39;action&#39; =&gt; &#39;info&#39;))
);
         Basic Rewrite Router operation 
            The heart of the RewriteRouter is the definition of user defined
            routes. Routes are added by calling the addRoute method of
            RewriteRouter and passing in a new instance of a class implementing
             Zend_Controller_Router_Route_Interface . Eg.:
         &lt;?php
$router-&gt;addRoute(&#39;user&#39;, new Zend_Controller_Router_Route(&#39;user/:username&#39;));
         
            Rewrite Router comes with four basic types of routes (one of which
            is special):
          * 
            Routes may be used numerous times to create a chain or user defined
            application routing schema. You may use any number of routes in any
            configuration, with the exception of the Module route, which should
            rather be used once and probably as the most generic route (i.e., as a
            default). Each route will be described in greater detail later on.
         
            The first parameter to addRoute is the name of the route. It is used
            as a handle for getting the routes out of the router (e.g., for URL
            generation purposes). The second parameter being the route itself.
         
                The most common use of the route name is through the means of
                Zend_View url helper:
             
&lt;a href=&quot;&lt;?= $this-&gt;url(array(&#39;username&#39; =&gt; &#39;martel&#39;), &#39;user&#39;) ?&gt;&quot;&gt;Martel&lt;/a&gt;
             
                Which would result in the href:  user/martel .
             
            Routing is a simple process of iterating through all provided routes
            and matching its definitions to current request URI. When a positive
            match is found, variable values are returned from the Route instance
            and are injected into the  Zend_Controller_Request 
            object for later use in the dispatcher as well as in user created
            controllers. On a negative match result, the next route in the chain
            is checked.
         Reverse matching 
                Routes are matched in reverse order so make sure your most
                generic routes are defined first.
             Returned values 
                Values returned from routing come from URL parameters or user
                defined route defaults. These variables are later accessible
                through the  Zend_Controller_Request::getParam()  or
                 Zend_Controller_Action::_getParam()  methods.
             
            There are three special variables which can be used in your routes
            - &#39;module&#39;, &#39;controller&#39; and &#39;action&#39;. These special variables are
            used by Zend_Controller_Dispatcher to find a controller and action
            to dispatch to.
         Special variables 
                The names of these special variables may be different if you
                choose to alter the defaults in
                 Zend_Controller_Request_Http  by means of the
                 setControllerKey  and  setActionKey 
                methods.
             Default routes 
            Zend_Controller_Router_Rewrite comes preconfigured with a default
            route, which will match URIs in the shape of
             controller/action .  Additionally, a module name may be
            specified as the first path element, allowing URIs of the form
             module/controller/action .  Finally, it will also match
            any additional parameters appended to the URI by default -
             controller/action/var1/value1/var2/value2 .
         
            Some examples of how such routes are matched:
         
// Assuming the following:
$ctrl-&gt;setControllerDirectory(
    array(
        &#39;default&#39; =&gt; &#39;/path/to/default/controllers&#39;,
        &#39;news&#39;    =&gt; &#39;/path/to/news/controllers&#39;,
        &#39;blog&#39;    =&gt; &#39;/path/to/blog/controllers&#39;
    )
);

Module only:
http://example/news
    module == news

Invalid module maps to controller name:
http://example/foo
    controller == foo

Module + controller:
http://example/blog/archive
    module     == blog
    controller == archive

Module + controller + action:
http://example/blog/archive/list
    module     == blog
    controller == archive
    action     == list

Module + controller + action + params:
http://example/blog/archive/list/sort/alpha/date/desc
    module     == blog
    controller == archive
    action     == list
    sort       == alpha
    date       == desc

         
            The default route is simply a
             Zend_Controller_Router_Route_Module  object stored under
            the name (index) of &#39;default&#39; in RewriteRouter. It&#39;s created
            more-or-less like below:
         &lt;?php
$compat = new Zend_Controller_Router_Route_Module(array(), $dispatcher, $request);
$this-&gt;addRoute(&#39;default&#39;, $compat);
         
            If you do not want this particular default route in your routing
            schema, you may override it by creating your own &#39;default&#39; route
            (i.e., storing it under the name of &#39;default&#39;) or removing it
            altogether by using  removeDefaultRoutes() :
         &lt;?php
// Remove any default routes
$router-&gt;removeDefaultRoutes();
         Base URL and subdirectories 
            The rewrite router can be used in subdirectories (e.g.,
             http://domain.com/~user/application-root/ ) in which
            case the base URL of the application
            ( /~user/application-root ) should be automatically
            detected by  Zend_Controller_Request_Http  and used
            accordingly.
         
            Should the base URL be detected incorrectly you can override it with
            your own base path by using
             Zend_Controller_Request_Http  and calling the
             setBaseUrl()  method (see  ):
         &lt;?php
$request-&gt;setBaseUrl(&#39;/~user/application-root/&#39;);
         Route Types Using Zend_Config with the RewriteRouter 
            Sometimes it is more convenient to update a configuration file with
            new routes than to change the code. This is possible via the
             addConfig()  method. Basically, you create a
            Zend_Config-compatible configuration, and in your code read it in
            and pass it to the RewriteRouter.
         
            As an example, consider the following INI file:
         
[production]
routes.archive.route = &quot;archive/:year/*&quot;
routes.archive.defaults.controller = archive
routes.archive.defaults.action = show
routes.archive.defaults.year = 2000
routes.archive.reqs.year = &quot;\d+&quot;

routes.news.type = &quot;Zend_Controller_Router_Route_Static&quot;
routes.news.route = &quot;news&quot;
routes.news.defaults.controller = &quot;news&quot;
routes.news.defaults.action = &quot;list&quot;

routes.archive.type = &quot;Zend_Controller_Router_Route_Regex&quot;
routes.archive.route = &quot;archive/(\d+)&quot;
routes.archive.defaults.controller = &quot;archive&quot;
routes.archive.defaults.action = &quot;show&quot;
routes.archive.map.1 = &quot;year&quot;
; OR: routes.archive.map.year = 1
         
            The above INI file can then be read into a  Zend_Config 
            object as follows:
         
$config = new Zend_Config_Ini(&#39;/path/to/config.ini&#39;, &#39;production&#39;);
$router = new Zend_Controller_Router_Rewrite();
$router-&gt;addConfig($config, &#39;routes&#39;);
         
            In the above example, we tell the router to use the &#39;routes&#39; section
            of the INI file to use for its routes. Each first-level key under
            that section will be used to define a route name; the above example
            defines the routes &#39;archive&#39; and &#39;news&#39;. Each route then requires,
            at minimum, a &#39;route&#39; entry and one or more &#39;defaults&#39; entries;
            optionally one or more &#39;reqs&#39; (short for &#39;required&#39;) may be
            provided. All told, these correspond to the three arguments provided
            to a  Zend_Controller_Router_Route_Interface  object. An
            option key, &#39;type&#39;, can be used to specify the route class type to
            use for that particular route; by default, it uses
             Zend_Controller_Router_Route . In the example above, the
            &#39;news&#39; route is defined to use
             Zend_Controller_Router_Route_Static .
         Subclassing the Router 
            The standard rewrite router should provide most functionality you
            may need; most often, you will only need to create a new route type
            in order to provide new or modified functionality over the provided
            routes.
         
            That said, you may at some point find yourself wanting to use a
            different routing paradigm.  The interface
             Zend_Controller_Router_Interface  provides the minimal
            information required to create a router, and consists of a single
            method.
         &lt;?php
interface Zend_Controller_Router_Interface
{
  /**
   * @param  Zend_Controller_Request_Abstract $request
   * @throws Zend_Controller_Router_Exception
   * @return Zend_Controller_Request_Abstract
   */
  public function route(Zend_Controller_Request_Abstract $request);
}
         
            Routing only occurs once: when the request is first received into
            the system.  The purpose of the router is to determine the
            controller, action, and optional parameters based on the request
            environment, and then set them in the request.  The request object
            is then passed to the dispatcher.  If it is not possible to map a
            route to a dispatch token, the router should do nothing to the
            request object.
         Introduction to Zend_Currency Zend_Currency  is part of the I18N core of the Zend_Framework. It handles all issues
        related to currency, money representation and formating. And it also provides additional informational
        methods which include localized informations on currencies, informations about which currency is used
        in which region and more.
     Why should  Zend_Currency  be used ? Zend_Currency  offers the following functions for handling currency and money related work.
         Complete Locale support Zend_Currency  works with all available locales and has therefor the ability to
                    know about over 100 different localized currency informations. This includes for example
                    currency names, abbreviations, money signs and more.
                 Reuseable currency definitions Zend_Currency  does not include the value of the currency. This is the reason why
                    it&#39;s functionallity is not included in  Zend_Locale_Format . But this gives the
                    advantage that already defined currency representations can be reused.
                 Fluid interface Zend_Currency  includes the fluid interface where possible.
                 Additional informational methods Zend_Currency  includes additional methods which offers informations about
                    in which regions a currency is used or which currency is known to be used in a defined region.
                 Migrating from Previous Versions 
        The API of  Zend_Currency  has changed in the past to increase
        the usability. If you started using  Zend_Currency  with a
        version which is mentioned in this chapter follow the guidelines below
        to migrate your scripts to the new API.
     Migrating from 1.0.2 to 1.0.3 or newer 
            Creating an object of  Zend_Currency  has become simpler.
            You now do not longer have to give a script or set it to null. The optional
            script parameter is now an option which can be set through the
             setFormat()  method.
         &lt;?php
$currency = new Zend_Currency($currency, $locale);
         
            The  setFormat()  method takes now an array of options which
            can be set. These options are set permanent and override all previous
            set values. Also a new option &#39;precision&#39; has been integrated. The
            following options has been integrated:

             position :
                        Replacement for the old &#39;rules&#39; parameter.
                     script :
                        Replacement for the old &#39;script&#39; parameter.
                     format :
                        Replacement for the old &#39;locale&#39; parameter which does not
                        set new currencies but only the number format.
                     display :
                        Replacement for the old &#39;rules&#39; parameter.
                     precision :
                        New parameter.
                     name :
                        Replacement for the ole &#39;rules&#39; parameter. Sets the full
                        currencies name.
                     currency :
                        New parameter.
                     symbol :
                        New parameter.
                     

         &lt;?php
$currency-&gt;setFormat(array $options);
         
            The  toCurrency()  method does no longer support the optional
            &#39;script&#39; and &#39;locale&#39; parameters. Instead it takes an options array which
            can contain the same keys as for the  setFormat  method. 
         &lt;?php
$currency-&gt;toCurrency($value, array $options);
         
            The methods  getSymbol() ,  getShortName() ,
             getName() ,  getRegionList()  and
             getCurrencyList()  are no longer static and can be called
            from within the object. They return the set values of the object if no
            parameter has been set.
         How to work with currencies 
        To use  Zend_Currency  within the own application just create an instance of it without any
        parameter. This will create an instance of  Zend_Currency  with the actual locale, and defines
        the currency which has to be used for this locale.
     Creating an instance of Zend_Currency from the actual locale 
            Expect you have &#39;en_US&#39; set as actual locale through the users or your environment. By using no
            parameter while creating the instance you say  Zend_Currency  to use the actual currency
            from the locale &#39;en_US&#39;. This leads to an instance with US Dollar set as actual currency with the
            formatting rules from &#39;en_US&#39;.
         &lt;?php
require_once &#39;Zend/Currency.php&#39;;

$currency = new Zend_Currency();
         
                Be aware, that if your system has no default locale, or if the locale of your system can not be
                detected automatically,  Zend_Currency  will throw an exception. If you have this
                behaviour you should set the locale you manually.
             
        Of course, depending on your needs, several parameters can be given at creation. Each of this parameters
        is optional and can be supressed. Even the order of the parameters can be switched. The meaning of each
        parameter is described in this list:
     currency :
             
                A locale can include several currencies. Therefor the first parameter
                 &#39;currency&#39;  can define which currency should be used by giving
                the short name or full name of that currency. If that currency in not known in any locale an
                exception will be thrown. Currency short names are always 3 lettered and written uppercase.
                Well known currency shortnames are for example  USD  or  EUR .
                For a list of all known currencies see the informational methods of  Zend_Currency .
             locale :
             
                The third parameter  &#39;locale&#39;  defines which locale should be
                used for formatting the currency. The given locale will also be used to get the standard script
                and currency of this currency if these parameters are not given.
             
                    Note that Zend_Currency only accepts locales which include a region. This means that all
                    given locale which only include the language will throw an exception. For example the locale
                     en  will throw an exception whereas the locale
                     en_US  will return  USD 
                    as currency.
                 Other examples for creating an instance of Zend_Currency &lt;?php
// expect standard locale &#39;de_AT&#39;
require_once &#39;Zend/Currency.php&#39;;

// creates an instance from &#39;en_US&#39; using &#39;USD&#39; which is default currency for &#39;en_US&#39;
$currency = new Zend_Currency(&#39;en_US&#39;);

// creates an instance from the actual locale (&#39;de_AT&#39;) using &#39;EUR&#39; as currency
$currency = new Zend_Currency();

// creates an instance using &#39;EUR&#39; as currency, &#39;en_US&#39; for number formating
$currency = new Zend_Currency(&#39;en_US&#39;, &#39;EUR&#39;);
         
        So you can supress any of these parameters if you want to use the default ones. This has no negative effect
        on handling the currencies. It can be useful f.e. if you dont know the default currency for a region.
     
            For many countries there are several known currencies. One currency will actually be used and
            maybe several ancient currencies. If the &#39; currency &#39; parameter
            is supressed the actual currency will be used. The region &#39; de &#39; for
            example knows the currencies &#39; EUR &#39; and
            &#39; DEM &#39;... &#39; EUR &#39; is the actual one
            and will be used if the parameter is supressed.
         Create output from an currency 
            To get an existing value converted to a currency formatted output the method
             toCurrency()  can be used. It takes a value which should be converted.
            The value itself can be any normalized number.
         
            If you have a localized number you will have to convert it first to an normalized number with
             Zend_Locale_Format::getNumber() . Afterwards it can
            be used with  toCurrency()  to create an currency output.
         toCurrency(array $options)  accepts an array with options which can be used to temporary set another
            format or currency represenation. For details about which options can be used see 
             Changing the format of a currency .
         Creating output for an currency &lt;?php
require_once &#39;Zend/Currency.php&#39;;

// creates an instance with &#39;en_US&#39; using &#39;USD&#39; which is the default values for &#39;en_US&#39;
$currency = new Zend_Currency(&#39;en_US&#39;);

// prints &#39;$ 1,000.00&#39;
echo $currency-&gt;toCurrency(1000);

// prints &#39;$ 1.000,00&#39;
echo $currency-&gt;toCurrency(1000, array(&#39;format&#39; =&gt; &#39;de_AT&#39;));

// prints &#39;$ Ù¡Ù¬Ù Ù Ù Ù«Ù Ù &#39;
echo $currency-&gt;toCurrency(1000, array(&#39;script&#39; =&gt; &#39;Arab&#39;));
             Changing the format of a currency 
            The format which is used by creation of a  Zend_Currency  instance is of course the
            standard format. But sometimes it is necessary to change this format for own purposes.
         
            The format of an currency output includes the following parts:
         Currency symbol, shortname or name :
                 
                    The symbol of the currency is normally displayed within an currency output. It can be supressed
                    when needed or even overwritten.
                 Currency position :
                 
                    The position of the currency sign is normally automatically defined by the locale. It can be
                    changed if necessary.
                 Script :
                 
                    The script which shall be used to display digits. Detailed information about scripts and their
                    usage can be found in the documentation of  Zend_Locale  in
                     supported number scripts .
                 Number formatting :
                 
                    The amount of currency (formally known as value of money) is formatted by the usage of
                    formatting rules within the locale. For example is in english the &#39;,&#39; sign used as seperator for
                    thousands, and in german the &#39;.&#39; sign.
                 
            So if you are in need to change the format, you can use the
             setFormat()  method. It takes an array which includes all
            options which you want to change. The  options  array supports the following
            settings:
         position : Defines the position at which the currency
                    description should be displayed. The supported position can be found in
                     this table .
                 script : Defined which script has to be used for
                    displaying digits. The default script for most locales is
                     &#39;Latn&#39; , which includes the digits 0 to 9. Also other
                    scripts like &#39;Arab&#39; (arabian) can be used. All supported scripts can be found in
                     this table .
                 format : Defines which locale has to be used for displaying
                    numbers. This number-format includes for example the thousand seperator. If no format is set
                    the locale from the  Zend_Currency  object will be used. 
                 display : Defines which part of the currency has to be
                    used for displaying the currency representation. There are 4 representations which can be
                    used and which are all described in
                     this table .
                 precision : Defines the precision which has to be used for
                    the currency represenation. The default value is  2 .
                 name : Defines the full currency name which has to be
                    displayed. This option overwrites any currency name which is set through
                    the creation of  Zend_Currency .
                 currency : Defines the international abbreviation which
                    has to be displayed. This option overwrites any abbreviation which is set through
                    the creation of  Zend_Currency .
                 symbol : Defines the currency symbol which has to be
                    displayed. This option overwrites any symbol which is set through
                    the creation of  Zend_Currency .
                 Constants for the selecting the currency description constant description NO_SYMBOL Do not display any currency representation USE_SYMBOL Display the currency symbol USE_SHORTNAME Display the 3 lettered international currency abbreviation USE_NAME Display the full currency name Constants for the selecting the currency position constant description STANDARD Set the standard position as defined within the locale RIGHT Display the currency represenation at the right side of the value LEFT Display the currency represenation at the left side of the value Changing the displayed format of a currency &lt;?php
require_once &#39;Zend/Currency.php&#39;;

// creates an instance with &#39;en_US&#39; using &#39;USD&#39;, &#39;Latin&#39; and &#39;en_US&#39; as these are the default values from &#39;en_US&#39;
$currency = new Zend_Currency(&#39;en_US&#39;);

// prints &#39;US$ 1,000.00&#39;
echo $currency-&gt;toCurrency(1000);

$currency-&gt;setFormat(Zend_Currency::USE_NAME&amp;Zend_Currency::RIGHT);
// prints &#39;1.000,00 US Dollar&#39;
echo $currency-&gt;toCurrency(1000);

$currency-&gt;setFormat(&quot;American Dollar&quot;);
// prints &#39;1.000,00 American Dollar&#39;
echo $currency-&gt;toCurrency(1000);
             Informational methods for Zend_Currency 
            Of course,  Zend_Currency  supports also methods to get informations about any existing
            and many ancient currencies from  Zend_Locale . The supported
            methods are:
         getSymbol() :
                 
                    Returns the known sign of the actual currency or a given currency. For example
                     $  for the US Dollar within the locale
                    &#39; en_US .
                 getShortName() :
                 
                    Returns the abbreviation of the actual currency or a given currency.  For example
                     USD  for the US Dollar within the locale
                    &#39; en_US .
                 getName() :
                 
                    Returns the full name of the actual currency of a given currency. For example
                     US Dollar  for the US Dollar within the locale
                    &#39; en_US .
                 getRegionList() :
                 
                    Returns a list of regions where the actual currency or a given one is known to be used.
                    It is possible that a currency is used within several regions therefor the return value
                    is always an array.
                 getCurrencyList() :
                 
                    Returns a list of currencies which are known to be used in the given region.
                 
            The function  getSymbol() ,  getShortName()  and  getName()  accept
            two optional parameters. If no parameter is given the expected data will be returned from the actual
            set currency. The first parameter takes the shortname of a currency. Short names are always three
            lettered, for example EUR for euro or USD for US Dollar. The second parameter defines from which
            locale the data should be read. If no locale is given, the actual set locale is used.
         Getting informations from currencies &lt;?php
require_once &#39;Zend/Currency.php&#39;;

// creates an instance with &#39;en_US&#39; using &#39;USD&#39;, &#39;Latin&#39; and &#39;en_US&#39; as these are the default values from &#39;en_US&#39;
$currency = new Zend_Currency(&#39;en_US&#39;);

// prints &#39;$&#39;
echo $currency-&gt;getSymbol();

// prints &#39;EUR&#39;
echo $currency-&gt;getShortName(&#39;EUR&#39;);

// prints &#39;Ã–sterreichische Schilling&#39;
echo $currency-&gt;getName(&#39;ATS&#39;, &#39;de_AT&#39;);

// returns an array with all regions where USD is used
print_r($currency-&gt;getRegionList();

// returns an array with all currencies which were ever used in this region
print_r($currency-&gt;getCurrencyList(&#39;de_AT&#39;);
             Settings new default values 
            The method  setLocale  allows to set a new locale for
             Zend_Currency . When calling this function also all default
            values for the currency will be overwritten. This includes currency name,
            abbreviation and symbol.
         Setting a new locale &lt;?php
require_once &#39;Zend/Currency.php&#39;;

// get the currency for US
$currency = new Zend_Currency(&#39;en_US&#39;);
print $currency-&gt;toCurrency(1000);

// get the currency for AT
$currency-&gt;setLocale(&#39;de_AT&#39;);
print $currency-&gt;toCurrency(1000);

             Speed up Zend_Currency 
            The work of  Zend_Currency  can be speed up by the usage of  Zend_Cache .
            By using the static method  Zend_Currency::setCache($cache)  which accepts one option, an
             Zend_Cache  adapter. When you set it, the localization data of the methods from
            Zend_Currency are cached.
         Caching currencies &lt;?php
require_once &#39;Zend/Currency.php&#39;;
require_once &#39;Zend/Cache.php&#39;;

// creating a cache object
$cache = Zend_Cache::factory(&#39;Core&#39;, &#39;File&#39;,
             array(&#39;lifetime&#39; =&gt; 120, &#39;automatic_serialization&#39; =&gt; true),
             array(&#39;cache_dir&#39; =&gt; dirname(__FILE__) . &#39;/_files/&#39;));
Zend_Currency::setCache($cache);
             Working examples 
        Within this chapter, we will describe several additional functions which are also available through
         Zend_Date . Of course all described functions have additional examples to show the
        expexted working and the simple API for the proper using of them.
     Checking dates 
            Probably most dates you will get as input are strings. But the problem with strings is that
            you can not be sure if the string is a real date. Therefor  Zend_Date  has spent
            an own static function to check date strings.  Zend_Locale  has an own function
             getDate($date, $locale);  which parses a date and returns the proper and normalized
            date parts. A monthname for example will be recognised and returned just a month number.
            But as  Zend_Locale  does not know anything about dates because it is a
            normalizing and localizing class we have integrated an own function  isDate($date); 
            which checks this.
         isDate($date, $format, $locale);  can take up to 3 parameters and needs minimum one
            parameter. So what we need to verify a date is, of course, the date itself as string.
            The second parameter can be the format which the date is expected to have. If no format is given
            the standard date format from your locale is used. For details about how formats should look like
            see the chapter about  self defined formats 
            .
         
            The third parameter is also optional as the second parameter and can be used to give a locale.
            We need the locale to normalize monthnames and daynames. So with the third parameter we are able
            to recognise dates like &#39;01.JÃ¤nner.2000&#39; or &#39;01.January.2000&#39; depending on the given locale.
         isDate();  of course checks if a date does exist.  Zend_Date  itself does not
            check a date. So it is possible to create a date like &#39;31.February.2000&#39; with  Zend_Date 
            because  Zend_Date  will automatically correct the date and return the proper date.
            In our case &#39;03.March.2000&#39;.  isDate()  on the other side does this check and will return
            false on &#39;31.February.2000&#39; because it knows that this date is impossible.
         Checking dates &lt;?php
require_once &#39;Zend/Date.php&#39;;

// Checking dates
$date = &#39;01.03.2000&#39;;
if (Zend_Date::isDate($date)) {
    print &quot;String $date is a date&quot;;
} else {
    print &quot;String $date is NO date&quot;;
}

// Checking localized dates
$date = &#39;01 February 2000&#39;;
if (Zend_Date::isDate($date,&#39;dd MMMM yyyy&#39;, &#39;en&#39;)) {
    print &quot;String $date is a date&quot;;
} else {
    print &quot;String $date is NO date&quot;;
}

// Checking impossible dates
$date = &#39;30 February 2000&#39;;
if (Zend_Date::isDate($date,&#39;dd MMMM yyyy&#39;, &#39;en&#39;)) {
    print &quot;String $date is a date&quot;;
} else {
    print &quot;String $date is NO date&quot;;
}
             Sunrise and Sunset Zend_Date  has also functions integrated for getting informations from the sun. Often it is
            necessary to get the time for sunrise or sunset within a particulary day. This is quite easy with
             Zend_Date  as just the expected day has to be given and additionally location for which
            the sunrise or sunset has to be calculated.
         
            As most people do not know the location of their city we have also spent a helper class which provides
            the location data for about 250 capital and other big cities around the whole world. Most people could
            use cities near themself as the difference for locations situated to each other can only be measured
            within some seconds.
         
            For creating a listbox and choosing a special city the function  Zend_Date_Cities::getCityList 
            can be used. It returns the names of all available predefined cities for the helper class.
         Getting all available cities &lt;?php
require_once &#39;Zend/Date/Cities.php&#39;;

// Output the complete list of available cities
print_r (Zend_Date_Cities::getCityList());
             
            The location itself can be received with the  Zend_Date_Cities::City()  function.
            It accepts the name of the city as returned by the  Zend_Date_Cities::getCityList() 
            function and optional as second parameter the horizon to set.
         
            There are 4 defined horizons which can be used with locations to receive the exact time of sunset and
            sunrise. The &#39; horizon &#39; parameter is always optional in all functions. If it is not set, the
            &#39; effective &#39; horizon is used.
         Types of supported horizons for sunset and sunrise Horizon Description Usage effective Standard horizon Expects the world to be a ball. This horizon is always used if non is defined. civil Common horizon Often used in common medias like TV or radio nautic Nautic horizon Often used in sea navigation astronomic Astronomic horizon Often used for calculation with stars 
            Of course also a self-defined location can be given and calculated with. Therefor a &#39; latitude &#39;
            and a &#39; longitude &#39; has to be given and optional the &#39; horizon &#39;.
         Getting the location for a city &lt;?php
require_once &#39;Zend/Date/Cities.php&#39;;

// Get the location for a defined city
// uses the effective horizon as no horizon is defined
print_r (Zend_Date_Cities::City(&#39;Vienna&#39;));

// use the nautic horizon
print_r (Zend_Date_Cities::City(&#39;Vienna&#39;, &#39;nautic&#39;));

// self definition of a location
$mylocation = array(&#39;latitude&#39; =&gt; 41.5, &#39;longitude&#39; =&gt; 13.2446);
             
            As now all needed data can be set the next is to create a  Zend_Date  object with the day where
            sunset or sunrise should be calculated. For the calculation there are 3 functions available. It is possible
            to calculate sunset with &#39; getSunset() &#39;, sunrise with &#39; getSunrise() &#39; and all
            available informations related to the sun with &#39; getSunInfo() &#39;. After the calculation the
             Zend_Date  object will be returned with the calculated time.
         Calculating sun informations &lt;?php
require_once &#39;Zend/Date.php&#39;;
require_once &#39;Zend/Date/Cities.php&#39;;

// Get the location for a defined city
$city = Zend_Date_Cities::City(&#39;Vienna&#39;);

// create a date object for the day for which the sun has to be calculated
$date = new Zend_Date(&#39;10.03.2007&#39;, Zend_Date::ISO_8601, &#39;de&#39;);

// calculate sunset
$sunset = $date-&gt;getSunset($city);
print $sunset-&gt;get(Zend_Date::ISO_8601);

// calculate all sun informations
$info = $date-&gt;getSunInfo($city);
foreach ($info as $sun) {
    print &quot;\n&quot; . $sun-&gt;get(Zend_Date::ISO_8601);
}
             Timezones 
            Timezones are as important as dates themselves. There are several timezones depending on where
            in the world a user lives. So working with dates also means to set the proper timezone.
            This may sound complicated but it&#39;s easier as expected. As already mentioned in the first chapter
            of  Zend_Date  the default timezone has to be set. Eigther by  php.ini  or
            by definition within the bootstrap file.
         
            A  Zend_Date  object of course also stores the actual timezone. Even if the timezone
            is changed after the creation of the object it remembers the original timezone and works with it.
            It is also not necessary to change the timezone within the code with php functions.
             Zend_Date  has two built-in functions which makes it possible to handle this.
         getTimezone()  returns the actual set timezone of within the  Zend_Date 
            object. Remember that  Zend_Date  is not coupled with php internals. So the returned
            timezone is not the timezone of the php script but the timezone of the object.
             setTimezone($zone)  is the second function and makes it possible to set new timezone for
             Zend_Date . A given timezone is always checked. If it does not exist an exception will
            be thrown. Additionally the actual scripts or systems timezone can be set to the date object by
            calling   setTimezone()  without the zone parameter. This is also done automatically
            when the date object is created.
         Working with timezones &lt;?php
require_once &#39;Zend/Date.php&#39;;

// Set a default timezone... this has to be done within the bootstrap file or php.ini
// We do this here just for having a complete example
date_default_timezone_set(&#39;Europe/Vienna&#39;);

// create a date object
$date = new Zend_Date(&#39;10.03.2007&#39;, Zend_Date::ISO_8601, &#39;de&#39;);

// view our date object
print $date-&gt;getIso();

// what timezone do we have ?
print $date-&gt;getTimezone();

// set another timezone
$date-&gt;setTimezone(&#39;America/Chicago&#39;);

// what timezone do we now have ?
print $date-&gt;getTimezone();

// see the changed date object
print $date-&gt;getIso();
             Zend_Date  always takes the actual timezone for object creation as shown in the first
            lines of the example. Changing the timezone within the created object also has an effect to the
            date itself. Dates are always related to a timezone. Changing the timezone for a  Zend_Date 
            object does not change the time of  Zend_Date . Remember that internally dates are always
            stored as timestamps and in GMT. So the timezone means how much hours should be substracted or added
            to get the actual global time for the own timezone and region.
         
            Having the timezone coupled within  Zend_Date  has another positive effect. It is possible
            to have several dates with different timezones.
         Multiple timezones &lt;?php
require_once &#39;Zend/Date.php&#39;;

// Set a default timezone... this has to be done within the bootstrap file or php.ini
// We do this here just for having a complete example
date_default_timezone_set(&#39;Europe/Vienna&#39;);

// create a date object
$date = new Zend_Date(&#39;10.03.2007 00:00:00&#39;, Zend_Date::ISO_8601, &#39;de&#39;);

// view our date object
print $date-&gt;getIso();

// the date stays unchanged even after changeing the timezone
date_default_timezone_set(&#39;America/Chicago&#39;);
print $date-&gt;getIso();

$otherdate = clone $date;
$otherdate-&gt;setTimezone(&#39;Brazil/Acre&#39;);

// view our date object
print $otherdate-&gt;getIso();

// set the object to the actual systems timezone
$lastdate = clone $date;
$lastdate-&gt;setTimezone();

// view our date object
print $lastdate-&gt;getIso();
             Basic Methods 
        The following sections show basic usage of  Zend_Date  primarily by example. For this manual, &quot;dates&quot;
        always imply a calendar date with a time, even when not explicitly mentioned, and vice-versa. The part not
        specified defaults to an internal representation of &quot;zero&quot;. Thus, adding a date having no calendar date and a
        time value of 12 hours to another date consisting only of a calendar date would result in a date having that
        calendar date and a time of &quot;noon&quot;.
     
        Setting only a specific date, with no time part, implies a time set to 00:00:00. Conversely, setting only a
        specific time implies a date internally set to 01.01.1970 plus the number of seconds equal to the elapsed hours,
        minutes, and seconds identified by the time. Normally, people measure things from a starting point, such as the
        year 0 A.D. However, many software systems use the first second of the year 1970 as the starting point, and
        denote times as a timestamp offset counting the number of seconds elapsed from this starting point.
     The current date 
            Without any arguments, constructing an instance returns an object in the default locale with the current,
            local date using PHP&#39;s  time()  function to obtain the
             UNIX timestamp 
            for the object. Make sure your PHP environment has the correct
             default timezone 
            .
         Creating the current date &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date();

// Output of the current timestamp
print $date;
             Zend_Date by Example 
            Reviewing basic methods of  Zend_Date  is a good place to start for those unfamiliar with date
            objects in other languages or frameworks. A small example will be provided for each method below.
         Ouput a Date 
                The date in a  Zend_Date  object may be obtained as a localized integer or string using the
                 get()  method. There are many available options, which will be explained in later sections.
             get() - output a date &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date();

// Output of the desired date
print $date-&gt;get();
                 Setting a Date 
                The  set()  method alters the date stored in the object, and returns the final date value as
                a timestamp (not an object). Again, there are many options which will be explored in later sections.
             set() - set a date &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date();

// Setting of a new time
$date-&gt;set(&#39;13:00:00&#39;,Zend_Date::TIMES);
print $date-&gt;get(Zend_Date::W3C);
                 Adding and Subtracting Dates 
                Adding two dates with  add()  usually involves adding a real date in time with an artificial
                timestramp representing a date part, such as 12 hours, as shown in the example below. Both
                 add()  and  sub()  use the same set of options as  set() , which will
                be explained later.
             add() - adding dates &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date();

// changes $date by adding 12 hours
$date-&gt;add(&#39;12:00:00&#39;, Zend_Date::TIMES);

echo &quot;Date via get() = &quot;, $date-&gt;get(Zend_Date::W3C), &quot;\n&quot;;

// use magic __toString() method to call Zend_Date&#39;s toString()
echo &quot;Date via toString() = &quot;, $date, &quot;\n&quot;;
                 Comparation of dates 
                All basic  Zend_Date  methods can operate on entire dates contained in the objects, or can
                operate on date parts, such as comparing the minutes value in a date to an absolute value. For example,
                the current minutes in the current time may be compared with a specific number of minutes using
                 compare() , as in the example below.
             compare() - compare dates &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date();

// Comparation of both times
if ($date-&gt;compare(10, Zend_Date::MINUTE) == -1) {
    print &quot;This hour is less than 10 minutes old&quot;;
} else {
    print &quot;This hour is at least 10 minutes old&quot;;
}
                 
                For simple equality comparisons, use  equals() , which returns a boolean.
             equals() - identify a date or date part &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date();

// Comparation of the two dates
if ($date-&gt;equals(10, Zend_Date::HOUR)) {
    print &quot;It&#39;s 10 o&#39;clock. Time to get to work.&quot;;
} else {
    print &quot;It is not 10 o&#39;clock. You can keep sleeping.&quot;;
}
                 Constants for General Date Functions 
        Whenever a  Zend_Date  method has a  $parts  parameter, one of the constants below can be
        used as the argument for that parameter, in order to select a specific part of a date or indicate the date
        format used or desired (e.g. RFC 822).
     Using Constants 
            For example, the constant  Zend_Date::HOUR  can be used in the ways shown below. When working
            with days of the week, calendar dates, hours, minutes, seconds, and any other date parts that are expressed
            differently when in different parts of the world, the object&#39;s timezone will automatically be used to
            compute the correct value, even though the internal timestamp is the same for the same moment in time,
            regardless of the user&#39;s physical location in the world. Regardless of the units involved, output must be
            expressed either as GMT/UTC or localized to a locale. The example output below reflects localization to
            Europe/GMT+1 hour (e.g. Germany, Austria, France).
         Operations involving Zend_Date::HOUR Function/input Description Original date Effect/output get(Zend_Date::HOUR) Output of the hour 2009-02-13T14:53:27+01:00 14 set(12, Zend_Date::HOUR) Set new hour 2009-02-13T14:53:27+01:00 2009-02-13T12:53:27+01:00 add(12, Zend_Date::HOUR) Add hours 2009-02-13T14:53:27+01:00 2009-02-14T02:53:27+01:00 sub(12, Zend_Date::HOUR) Subtract hours 2009-02-13T14:53:27+01:00 2009-02-13T02:53:27+01:00 compare(12, Zend_Date::HOUR) Compare hour, returns 0, 1 or -1 2009-02-13T14:53:27+01:00 1 (if object &gt; argument) copy(Zend_Date::HOUR) Copies only the hour part 2009-02-13T14:53:27+01:00 1970-01-01T14:00:00+01:00 equals(14, Zend_Date::HOUR) Compares the hour, returns TRUE or FALSE 2009-02-13T14:53:27+01:00 TRUE isEarlier(12, Zend_Date::HOUR) Compares the hour, returns TRUE or FALSE 2009-02-13T14:53:27+01:00 TRUE isLater(12, Zend_Date::HOUR) Compares the hour, returns TRUE or FALSE 2009-02-13T14:53:27+01:00 FALSE List of All Constants 
            Each part of a date/time has a unique constant in  Zend_Date . All constants supported by
             Zend_Date  are listed below.
         Day Constants Constant Description Date Affected part/example Zend_Date::DAY Day (as a number, two digit) 2009-02-06T14:53:27+01:00 2009-02- 06 T14:53:27+01:00 (06) Zend_Date::DAY_SHORT Day (as a number, one or two digit) 2009-02-06T14:53:27+01:00 2009-02-0 6 T14:53:27+01:00 (6) Zend_Date::WEEKDAY Weekday (Name of the day, localized, complete) 2009-02-06T14:53:27+01:00 Friday Zend_Date::WEEKDAY_SHORT Weekday (Name of the day, localized, abbreviated, the first three digits) 2009-02-06T14:53:27+01:00 Fre  for Friday Zend_Date::WEEKDAY_NAME Weekday (Name of the day, localized, abbreviated, the first two digits) 2009-02-06T14:53:27+01:00 Fr  for Friday Zend_Date::WEEKDAY_NARROW Weekday (Name of the day, localized, abbreviated, only the first digit) 2009-02-06T14:53:27+01:00 F  for Friday Zend_Date::WEEKDAY_DIGIT Weekday (0 = Sunday, 6 = Saturday) 2009-02-06T14:53:27+01:00 5  for Friday Zend_Date::WEEKDAY_8601 Weekday according to ISO 8601 (1 = Monday, 7 = Sunday) 2009-02-06T14:53:27+01:00 5  for Friday Zend_Date::DAY_OF_YEAR Day (as a number, one or two digit) 2009-02-06T14:53:27+01:00 43 Zend_Date::DAY_SUFFIX English addendum for the day (st, nd, rd, th) 2009-02-06T14:53:27+01:00 th Week Constants Constant Description Date Affected part/example Zend_Date::WEEK Week (as a number, 1-53) 2009-02-06T14:53:27+01:00 7 Month Constants Constant Description Date Affected part/example Zend_Date::MONTH_NAME Month (Name of the month, localized, complete) 2009-02-06T14:53:27+01:00 February Zend_Date::MONTH_NAME_SHORT Month (Name of the month, localized, abbreviated, three digit) 2009-02-06T14:53:27+01:00 Feb Zend_Date::MONTH_NAME_NARROW Month (Name of the month, localized, abbreviated, one digit) 2009-02-06T14:53:27+01:00 F Zend_Date::MONTH Month (Number of the month, two digit) 2009-02-06T14:53:27+01:00 2009- 02 -06T14:53:27+01:00 (02) Zend_Date::MONTH_SHORT Month (Number of the month, one or two digit) 2009-02-06T14:53:27+01:00 2009-0 2 -06T14:53:27+01:00 (2) Zend_Date::MONTH_DAYS Number of days for this month (number) 2009-02-06T14:53:27+01:00 28 Year Constants Constant Description Date Affected part/example Zend_Date::YEAR Year (number) 2009-02-06T14:53:27+01:00 2009 -02-06T14:53:27+01:00 Zend_Date::YEAR_8601 Year according to ISO 8601 (number) 2009-02-06T14:53:27+01:00 2009 Zend_Date::YEAR_SHORT Year (number, two digit) 2009-02-06T14:53:27+01:00 20 09 -02-06T14:53:27+01:00 Zend_Date::YEAR_SHORT_8601 Year according to ISO 8601 (number, two digit) 2009-02-06T14:53:27+01:00 09 Zend_Date::LEAPYEAR Is the year a leap year? (TRUE or FALSE) 2009-02-06T14:53:27+01:00 FALSE Time Constants Constant Description Date Affected part/example Zend_Date::HOUR Hour (00-23, two digit) 2009-02-06T14:53:27+01:00 14 Zend_Date::HOUR_SHORT Hour (0-23, one or two digit) 2009-02-06T14:53:27+01:00 14 Zend_Date::HOUR_SHORT_AM Hour (1-12, one or two digit) 2009-02-06T14:53:27+01:00 2 Zend_Date::HOUR_AM Hour (01-12, two digit) 2009-02-06T14:53:27+01:00 02 Zend_Date::MINUTE Minute (00-59, two digit) 2009-02-06T14:53:27+01:00 2009-02-06T14: 53 :27+01:00 Zend_Date::MINUTE_SHORT Minute (0-59, one or two digit) 2009-02-06T14:03:27+01:00 2009-02-06T14:0 3 :27+01:00 Zend_Date::SECOND Second (00-59, two digit) 2009-02-06T14:53:27+01:00 2009-02-06T14:53: 27 +01:00 Zend_Date::SECOND_SHORT Second (0-59, one or two digit) 2009-02-06T14:53:07+01:00 2009-02-06T14:53:0 7 +01:00 Zend_Date::MILLISECOND Millisecond (theoretically infinite) 2009-02-06T14:53:27.20546 2009-02-06T14:53:27. 20546 
                         Zend_Date::MERIDIEM Time of day (forenoon/afternoon) 2009-02-06T14:53:27+01:00 afternoon Zend_Date::SWATCH Swatch Internet Time 2009-02-06T14:53:27+01:00 620 Timezone Constants Constant Description Date Affected part/example Zend_Date::TIMEZONE Name der time zone (string, abbreviated) 2009-02-06T14:53:27+01:00 CET Zend_Date::TIMEZONE_NAME Name of the time zone (string, complete) 2009-02-06T14:53:27+01:00 Europe/Paris Zend_Date::TIMEZONE_SECS Difference of the time zone to GMT in seconds (integer) 2009-02-06T14:53:27+01:00 3600  seconds to GMT Zend_Date::GMT_DIFF Difference to GMT in seconds (string) 2009-02-06T14:53:27+01:00 +0100 Zend_Date::GMT_DIFF_SEP Difference to GMT in seconds (string, separated) 2009-02-06T14:53:27+01:00 +01:00 Zend_Date::DAYLIGHT Summer time or Winter time? (TRUE or FALSE) 2009-02-06T14:53:27+01:00 FALSE Date Format Constants (formats include timezone) Constant Description Date Affected part/example Zend_Date::ISO_8601 Date according to ISO 8601 (string, complete) 2009-02-13T14:53:27+01:00 2009-02-13T14:53:27+01:00 Zend_Date::RFC_2822 Date according to RFC 2822 (string) 2009-02-13T14:53:27+01:00 Fri, 13 Feb 2009 14:53:27 +0100 Zend_Date::TIMESTAMP Unix time  (seconds since 1.1.1970, mixed) 2009-02-13T14:53:27+01:00 1234533207 Zend_Date::ATOM Date according to ATOM (string) 2009-02-13T14:53:27+01:00 2009-02-13T14:53:27+01:00 Zend_Date::COOKIE Date for Cookies (string, for Cookies) 2009-02-13T14:53:27+01:00 Friday, 13-Feb-09 14:53:27 Europe/Paris Zend_Date::RFC_822 Date according to RFC 822 (string) 2009-02-13T14:53:27+01:00 Fri, 13 Feb 09 14:53:27 +0100 Zend_Date::RFC_850 Date according to RFC 850 (string) 2009-02-13T14:53:27+01:00 Friday, 13-Feb-09 14:53:27 Europe/Paris Zend_Date::RFC_1036 Date according to RFC 1036 (string) 2009-02-13T14:53:27+01:00 Fri, 13 Feb 09 14:53:27 +0100 Zend_Date::RFC_1123 Date according to RFC 1123 (string) 2009-02-13T14:53:27+01:00 Fri, 13 Feb 2009 14:53:27 +0100 Zend_Date::RSS Date for RSS Feeds (string) 2009-02-13T14:53:27+01:00 Fri, 13 Feb 2009 14:53:27 +0100 Zend_Date::W3C Date for HTML/HTTP according to W3C (string) 2009-02-13T14:53:27+01:00 2009-02-13T14:53:27+01:00 
            Especially note  Zend_Date::DATES , since this format specifier has a unique property within
             Zend_Date  as an  input  format specifier. When used as an
            input format for  $part , this constant provides the most flexible acceptance of a variety of
            similar date formats. Heuristics are used to automatically extract dates from an input string and then &quot;fix&quot;
            simple errors in dates (if any), such as swapping of years, months, and days, when possible.
         Date and Time Formats (format varies by locale) Constant Description Date Affected part/example Zend_Date::ERA Epoch (string, localized, abbreviated) 2009-02-06T14:53:27+01:00 AD  (anno Domini) Zend_Date::ERA_NAME Epoch (string, localized, complete) 2009-02-06T14:53:27+01:00 anno domini  (anno Domini) Zend_Date::DATES Standard date (string, localized, default value). 2009-02-13T14:53:27+01:00 13.02.2009 Zend_Date::DATE_FULL Complete date (string, localized, complete) 2009-02-13T14:53:27+01:00 Friday, 13. February 2009 Zend_Date::DATE_LONG Long date (string, localized, long) 2009-02-13T14:53:27+01:00 13. February 2009 Zend_Date::DATE_MEDIUM Normal date (string, localized, normal) 2009-02-13T14:53:27+01:00 13.02.2009 Zend_Date::DATE_SHORT Abbreviated Date (string, localized, abbreviated) 2009-02-13T14:53:27+01:00 13.02.09 Zend_Date::TIMES Standard time (string, localized, default value) 2009-02-13T14:53:27+01:00 14:53:27 Zend_Date::TIME_FULL Complete time (string, localized, complete) 2009-02-13T14:53:27+01:00 14:53 Uhr CET Zend_Date::TIME_LONG Long time (string, localized, Long) 2009-02-13T14:53:27+01:00 14:53:27 CET Zend_Date::TIME_MEDIUM Normal time (string, localized, normal) 2009-02-13T14:53:27+01:00 14:53:27 Zend_Date::TIME_SHORT Abbreviated time (string, localized, abbreviated) 2009-02-13T14:53:27+01:00 14:53 Self-Defined OUTPUT Formats with ISO 
            If you need a date format not shown above, then use a self-defined format composed from the ISO format token
            specifiers below. The following examples illustrate the usage of constants from the table below to create
            self-defined ISO formats. The format length is unlimited. Also, multiple usage of format constants is
            allowed.
         
            The accepted format specifiers can be changed from ISO Format to PHP&#39;s date format if you are more
            comfortable with it. However, not all formats defined in the ISO norm are supported with PHP&#39;s date format
            specifiers. Use the  Zend_Date::setOptions(array(&#39;format_type&#39; =&gt; &#39;php&#39;))  method to switch
            Zend_Date methods from supporting ISO format specifiers to PHP date() type specifiers (see
             
            below).
         Example usage for self-defined ISO formats &lt;?php
require_once &#39;Zend/Date.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$date = new Zend_Date(1234567890, false, $locale);
print $date-&gt;toString(&quot;&#39;Era:GGGG=&#39;GGGG, &#39; Date:yy.MMMM.dd&#39;yy.MMMM.dd&quot;);
             Constants for  ISO 8601 date output 
             Constant Description Corresponds best to Affected part/example G Epoch, localized, abbreviated Zend_Date::ERA AD GG Epoch, localized, abbreviated Zend_Date::ERA AD GGG Epoch, localized, abbreviated Zend_Date::ERA AD GGGG Epoch, localized, complete Zend_Date::ERA_NAME anno domini GGGGG Epoch, localized, abbreviated Zend_Date::ERA a y Year, at least one digit Zend_Date::YEAR 9 yy Year, at least two digit Zend_Date::YEAR_SHORT 09 yyy Year, at least three digit Zend_Date::YEAR 2009 yyyy Year, at least four digit Zend_Date::YEAR 2009 yyyyy Year, at least five digit Zend_Date::YEAR 02009 Y Year according to ISO 8601, at least one digit Zend_Date::YEAR_8601 9 YY Year according to ISO 8601, at least two digit Zend_Date::YEAR_SHORT_8601 09 YYY Year according to ISO 8601, at least three digit Zend_Date::YEAR_8601 2009 YYYY Year according to ISO 8601, at least four digit Zend_Date::YEAR_8601 2009 YYYYY Year according to ISO 8601, at least five digit Zend_Date::YEAR_8601 02009 M Month, one or two digit Zend_Date::MONTH_SHORT 2 MM Month, two digit Zend_Date::MONTH 02 MMM Month, localized, abbreviated Zend_Date::MONTH_NAME_SHORT Feb MMMM Month, localized, complete Zend_Date::MONTH_NAME February MMMMM Month, localized, abbreviated, one digit Zend_Date::MONTH_NAME_NARROW F w Week, one or two digit Zend_Date::WEEK 5 ww Week, two digit Zend_Date::WEEK 05 d Day of the month, one or two digit Zend_Date::DAY_SHORT 9 dd Day of the month, two digit Zend_Date::DAY 09 D Day of the year, one, two or three digit Zend_Date::DAY_OF_YEAR 7 DD Day of the year, two or three digit Zend_Date::DAY_OF_YEAR 07 DDD Day of the year, three digit Zend_Date::DAY_OF_YEAR 007 E Day of the week, localized, abbreviated, one char Zend_Date::WEEKDAY_NARROW M EE Day of the week, localized, abbreviated, two char Zend_Date::WEEKDAY_NAME Mo EEE Day of the week, localized, abbreviated, three char Zend_Date::WEEKDAY_SHORT Mon EEEE Day of the week, localized, complete Zend_Date::WEEKDAY Monday EEEEE Day of the week, localized, abbreviated, one digit Zend_Date::WEEKDAY_NARROW M e Number of the day, one digit Zend_Date::WEEKDAY_NARROW 4 ee Number of the day, two digit Zend_Date::WEEKDAY_NARROW 04 a Time of day, localized Zend_Date::MERIDIEM vorm. h Hour, (1-12), one or two digit Zend_Date::HOUR_SHORT_AM 2 hh Hour, (01-12), two digit Zend_Date::HOUR_AM 02 H Hour, (0-23), one or two digit Zend_Date::HOUR_SHORT 2 HH Hour, (00-23), two digit Zend_Date::HOUR 02 m Minute, (0-59), one or two digit Zend_Date::MINUTE_SHORT 2 mm Minute, (00-59), two digit Zend_Date::MINUTE 02 s Second, (0-59), one or two digit Zend_Date::SECOND_SHORT 2 ss Second, (00-59), two digit Zend_Date::SECOND 02 S Millisecond Zend_Date::MILLISECOND 20536 z Time zone, localized, abbreviated Zend_Date::TIMEZONE CET zz Time zone, localized, abbreviated Zend_Date::TIMEZONE CET zzz Time zone, localized, abbreviated Zend_Date::TIMEZONE CET zzzz Time zone, localized, complete Zend_Date::TIMEZONE_NAME Europe/Paris Z Difference of time zone Zend_Date::GMT_DIFF +0100 ZZ Difference of time zone Zend_Date::GMT_DIFF +0100 ZZZ Difference of time zone Zend_Date::GMT_DIFF +0100 ZZZZ Difference of time zone, separated Zend_Date::GMT_DIFF_SEP +01:00 A Millisecond Zend_Date::MILLISECOND 20563 
                Note that the default ISO format differs from PHP&#39;s format which can be
                irritating if you have not used in previous. Especially the format specifiers
                for  Year and Minute  are often not used in the
                intended way.
             
                For  year  there are two specifiers available
                which are often mistaken. The  Y  specifier
                for the ISO year and the  y  specifier for the
                real year. The difference is small but significant.
                 Y  calculates the ISO year, which is often used
                for calendar formats. See for example the 31. December 2007. The real year is
                2007, but it is the first day of the first week in the week 1 of the year 2008.
                So, if you are using &#39;dd.MM.yyyy&#39; you will get &#39;31.December.2007&#39; but if you use
                &#39;dd.MM.YYYY&#39; you will get &#39;31.December.2008&#39;. As you see this is no bug but a
                expected behaviour depending on the used specifiers.
             
                For  minute  the difference is not so big. ISO
                uses the specifier  m  for the minute, unlike
                PHP which uses  i . So if you are getting no
                minute in your format check if you have used the right specifier.
             Self-defined OUTPUT formats using PHP&#39;s date() format specifiers 
            If you are more comfortable with PHP&#39;s date format specifier than with ISO format specifiers, then you can
            use the  Zend_Date::setOptions(array(&#39;format&#39; =&gt; &#39;php&#39;))  method to switch Zend_Date methods from
            supporting ISO format specifiers to PHP date() type specifiers. Afterwards, all format parameters must be
            given with
             PHP&#39;s  date()  format specifiers 
            . The PHP date format lacks some of the formats supported by the ISO Format, and vice-versa. If you are not
            already comfortable with it, then use the standard ISO format instead. Also, if you have legacy code using
            PHP&#39;s date format, then either manually convert it to the ISO format using
             Zend_Locale_Format::convertPhpToIsoFormat() 
            , or use  setOptions() . The following examples illustrate the usage of constants from the table
            below to create self-defined formats.
         Example usage for self-defined formats with PHP specifier &lt;?php
require_once &#39;Zend/Date.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
Zend_Date::setOptions(array(&#39;format_type&#39; =&gt; &#39;php&#39;));
$date = new Zend_Date(1234567890, false, $locale);

// outputs something like &#39;February 16, 2007, 3:36 am&#39;
print $date-&gt;toString(&#39;F j, Y, g:i a&#39;);

print $date-&gt;toString(&quot;&#39;Format:D M j G:i:s T Y=&#39;D M j G:i:s T Y&quot;);
             
            The following table shows the list of PHP date format specifiers with their equivalent Zend_Date constants
            and CLDR/ISO equivalent format specifiers. In most cases, when the CLDR/ISO format does not have an
            equivalent format specifier, the PHP format specifier is not altered by
             Zend_Locale_Format::convertPhpToIsoFormat() , and the Zend_Date methods then recognize these
            &quot;peculiar&quot; PHP format specifiers, even when in the default &quot;ISO&quot; format mode.
         Constants for  PHP date output 
             Constant Description Corresponds best to closest CLDR equivalent Affected part/example d Day of the month, two digit Zend_Date::DAY dd 09 D Day of the week, localized, abbreviated, three digit Zend_Date::WEEKDAY_SHORT EEE Mon j Day of the month, one or two digit Zend_Date::DAY_SHORT d 9 l (lowercase L) Day of the week, localized, complete Zend_Date::WEEKDAY EEEE Monday N Number of the weekday, one digit Zend_Date::WEEKDAY_8601 e 4 S English suffixes for day of month, two chars no equivalent no equivalent st w Number of the weekday, 0=sunday, 6=saturday Zend_Date::WEEKDAY_DIGIT no equivalent 4 z Day of the year, one, two or three digit Zend_Date::DAY_OF_YEAR D 7 W Week, one or two digit Zend_Date::WEEK w 5 F Month, localized, complete Zend_Date::MONTH_NAME MMMM February m Month, two digit Zend_Date::MONTH MM 02 M Month, localized, abbreviated Zend_Date::MONTH_NAME_SHORT MMM Feb n Month, one or two digit Zend_Date::MONTH_SHORT M 2 t Number of days per month, one or two digits Zend_Date::MONTH_DAYS no equivalent 30 L Leapyear, boolean Zend_Date::LEAPYEAR no equivalent true o Year according to ISO 8601, at least four digit Zend_Date::YEAR_8601 YYYY 2009 Y Year, at least four digit Zend_Date::YEAR yyyy 2009 y Year, at least two digit Zend_Date::YEAR_SHORT yy 09 a Time of day, localized Zend_Date::MERIDIEM a (sort of, but likely to be uppercase) vorm. A Time of day, localized Zend_Date::MERIDIEM a (sort of, but no guarantee that the format is uppercase) VORM. B Swatch internet time Zend_Date::SWATCH no equivalent 1463 g Hour, (1-12), one or two digit Zend_Date::HOUR_SHORT_AM h 2 G Hour, (0-23), one or two digit Zend_Date::HOUR_SHORT H 2 h Hour, (01-12), two digit Zend_Date::HOUR_AM hh 02 H Hour, (00-23), two digit Zend_Date::HOUR HH 02 i Minute, (00-59), two digit Zend_Date::MINUTE mm 02 s Second, (00-59), two digit Zend_Date::SECOND ss 02 e Time zone, localized, complete Zend_Date::TIMEZONE_NAME zzzz Europe/Paris I Daylight Zend_Date::DAYLIGHT no equivalent 1 O Difference of time zone Zend_Date::GMT_DIFF Z or ZZ or ZZZ +0100 P Difference of time zone, separated Zend_Date::GMT_DIFF_SEP ZZZZ +01:00 T Time zone, localized, abbreviated Zend_Date::TIMEZONE z or zz or zzz CET Z Time zone offset in seconds Zend_Date::TIMEZONE_SECS no equivalent 3600 c Standard Iso format output Zend_Date::ISO_8601 no equivalent 2004-02-12T15:19:21+00:00 r Standard Rfc 2822 format output Zend_Date::RFC_2822 no equivalent Thu, 21 Dec 2000 16:01:07 +0200 U Unix timestamp Zend_Date::TIMESTAMP no equivalent 15275422364 Creation of dates Zend_Date  provides several different ways to create a new instance of itself. As there are
        different needs the most convinient ways will be shown in this chapter.
     Create the actual date 
            The simplest way of creating a date object is to create the actual date. You can eigther create a new
            instance with  new Zend_Date()  or use the convinient static method
             Zend_Date::now()  which both will return the actual date as new
            instance of  Zend_Date . The actual date always include the actual date and time for the
            actual set timezone.
         Date creation by instance 
                Date creation by creating a new instance means that you do not need to give an parameter. Of course
                there are several parameters which will be described later but normally this is the simplest and
                most used way to get the actual date as  Zend_Date  instance.
             &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date();
             Static date creation 
                Sometimes it is easier to use a static method for date creation. Therefor you can use the
                 now()  method. It returns a new instance of
                 Zend_Date  the same way as if you would use  new Zend_Date() . But it will
                always return the actual date and can not be changed by giving optional parameters.
             &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = Zend_Date::now();
             Create a date from database 
            Databases are often used to store date values. But the problem is, that every database outputs it&#39;s
            date values in a different way.  MsSQL  databases use a quite different standard date
            output than  MySQL  databases. But for simplification  Zend_Date  makes it very
            easy to create a date from database date values.
         
            Of course each database can be said to convert the output of a defined column to a special value.
            For example you could convert a  datetime  value to output a minute value. But this is
            time expensive and often you are in need of handling dates in an other way than expected when creating
            the database query.
         
            So we have one quick and one convinient way of creating dates from database values.
         Quick creation of dates from database date values 
                All databases are known to handle queries as fast as possible. They are built to act and respond
                quick. The quickest way for handling dates is to get unix timestamps from the database. All
                databases store date values internal as timestamp (not unix timestamp). This means that the time
                for creating a timestamp through a query is much smaller than converting it to a specified format.
             &lt;?php
// SELECT UNIX_TIMESTAMP(my_datetime_column) FROM my_table
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date($unixtimestamp, Zend_Date::TIMESTAMP);
             Convenient creation of dates from database date values 
                The standard output of all databases is quite different even if it looks the same on the first
                eyecatch. But all are part of the  ISO  Standard and explained through it. So the
                easiest way of date creation is the usage of  Zend_Date::ISO_8601 . Databases which are
                known to be recognised by  Zend_Date::ISO_8601  are  MySQL ,
                 MsSQL  for example. But all databases are also able to return a  ISO 8601 
                representation of a date column.  ISO 8601  has the big advantage that it is human
                readable. The disadvantage is that  ISO 8601  needs more time for computation than a
                simple unix timestamp. But it should also be mentioned that unix timestamps are only supported
                for dates after 1 January 1970.
             &lt;?php
// SELECT datecolumn FROM my_table
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date($datecolumn, Zend_Date::ISO_8601);
             Create dates from an array 
            Dates can also be created by the usage of an array. This is a simple and easy way. The used array
            keys are:
         day : day of the date as number
                     month : month of the date as number
                     year : full year of the date
                     hour : hour of the date
                     minute : minute of the date
                     second : second of the date
                     Date creation by array 
                Normally you will give a complete date array for creation of a new date instance. But when you
                do not give all values, the not given array values are zeroed. This means that if f.e. no hour is
                given the hour  0  is used.
             &lt;?php
require_once &#39;Zend/Date.php&#39;;
$datearray = array(&#39;year&#39; =&gt; 2006, &#39;month&#39; =&gt; 4, &#39;day&#39; =&gt; 18, &#39;hour&#39; =&gt; 12, &#39;minute&#39; =&gt; 3, &#39;second&#39; =&gt; 10);
$date = new Zend_Date($datearray);
             &lt;?php
require_once &#39;Zend/Date.php&#39;;
$datearray = array(&#39;year&#39; =&gt; 2006, &#39;month&#39; =&gt; 4, &#39;day&#39; =&gt; 18);
$date = new Zend_Date($datearray);
             Introduction 
        The  Zend_Date  component offers a detailed, but simple API for manipulating dates and times. Its
        methods accept a wide variety of types of information, including date parts, in numerous combinations yielding
        many features and possibilities above and beyond the existing PHP date related functions. For the very latest
        manual updates, please see
         our online manual
        (frequently synced to Subversion) 
        .
     
        Although simplicity remains the goal, working with localized dates and times while modifying, combining, and
        comparing parts involves some unavoidable complexity. Dates, as well as times, are often written differently in
        different locales. For example, some place the month first, while other write the year first when expressing
        calendar dates. For more information about handling localization and normalization, please refer to
         Zend_Locale 
        .
     Zend_Date  also supports abbreviated names of months in many languages.  Zend_Locale 
        facilitates the normalization of localized month and weekday names to timestamps, which may, in turn, be shown
        localized to other regions.
     Always Set a Default Timezone 
            Before using any date related functions in PHP or the Zend Framework, first make certain your application
            has a correct default timezone, by either setting the TZ environment variable, using the
             date.timezone  php.ini setting, or using
             date_default_timezone_set() 
            . In PHP, we can adjust all date and time related functions to work for a particular user by setting a
            default timezone according to the user&#39;s expectations. For a complete list of timezone settings, see the
             CLDR Timezone Identifier List 
            .
             Setting a default timezone &lt;?php
date_default_timezone_set(&#39;America/Los_Angeles&#39;); // timezone for an American in California
date_default_timezone_set(&#39;Europe/Berlin&#39;);       // timezone for a German in Germany
                 
             When creating Zend_Date instances, their timezone will automatically become the
            current default timezone!  Thus, the timezone setting will account for any Daylight Savings Time
            (DST) in effect, eliminating the need to explicitly specify DST.
         
            Keep in mind that the timezones  UTC  and
             GMT  do not include Daylight Saving Time. This means that even
            if you define per hand that  Zend_Date  should work with DST, it would automatically
            be switched back for the instances of  Zend_Date  which have been set to UTC or GMT.
         Why Use Zend_Date? Zend_Date  offers the following features, which extend the scope of PHP date functions:
         
                    Simple API
                 Zend_Date  offers a very simple API, which combines the best of date/time functionality
                    from four programming languages. It is possible, for example, to add or compare two times within a
                    single row.
                 
                    Completely internationalized
                 
                    All full and abbreviated names of months and weekdays are supported for more than 130 languages.
                    Methods support both input and the output of dates using the localized names of months and weekdays,
                    in the conventional format associated with each locale.
                 
                    Unlimited timestamps
                 
                    Although PHP 5.2 docs state, &quot;The valid range of a timestamp is typically from Fri, 13 Dec 1901
                    20:45:54 GMT to Tue, 19 Jan 2038 03:14:07 GMT,&quot;  Zend_Date  supports a nearly unlimited
                    range, with the help of the BCMath extension. If BCMath is not available, then Zend_Date will have
                    reduced support only for timestamps within the range of the  float  type supported by
                    your server. &quot;The size of a float is platform-dependent, although a maximum of ~1.8e308 with a
                    precision of roughly 14 decimal digits is a common value (that&#39;s 64 bit IEEE format).&quot; [
                     http://www.php.net/float 
                    ].  Additionally, inherent limitations of float data types, and rounding error of float numbers
                    may introduce errors into calculations.  To avoid these problems, the ZF i18n components use
                    BCMath extension, if available.
                 
                    Support for ISO_8601 date specifications
                 
                    ISO_8601 date specifications are supported. Even partially compliant ISO_8601 date specifications
                    will be identified. These date formats are particularly useful when working with databases. For
                    example, even though MsSQL and
                     MySQL 
                    differ a little from each other, both are supported by  Zend_Date  using the
                     Zend_Date::ISO_8601 
                    format specification constant. When date strings conform to &quot;Y/m/d&quot; or &quot;Y-m-d H:i:s&quot;, according to
                    PHP date() format tokens, use Zend_Date&#39;s built-in support for ISO 8601 formatted dates.
                 
                    Calculate sunrise and sunset
                 
                    For any place and day, the times for sunrise and sunset can be displayed, so that you won&#39;t miss a
                    single daylight second for working on your favorite PHP project :)
                 Zend_Date API Overview 
        While the  Zend_Date  API remains simplistic and unitary, its design remains flexible and powerful
        through the rich permutations of operations and operands.
     Zend_Date Options Selecting the date format type 
                Several methods use date format strings, in a way similar to PHP&#39;s  date() .
                If you are more comfortable with PHP&#39;s date format specifier than with ISO format specifiers,
                then you can use  Zend_Date::setOptions(array(&#39;format_type&#39; =&gt; &#39;php&#39;)) .
                Afterward, use PHP&#39;s date format specifiers for all functions which accept a  $format  parameter.
                Use  Zend_Date::setOptions(array(&#39;format_type&#39; =&gt; &#39;iso&#39;))  to switch back to the default mode of
                supporting only ISO date format tokens. For a list of supported format codes, see
                 
             DST and Date Math 
                When dates are manipulated, sometimes they cross over a DST change, normally resulting in the date
                losing or gaining an hour.  For exmaple, when adding months to a date before a DST change, if the
                resulting date is after the DST change, then the resulting date will appear to lose or gain an hour,
                resulting in the time value of the date changing.  For boundary dates, such as midnight of the first
                or last day of a month, adding enough months to cross a date boundary results in the date losing
                an hour and becoming the last hour of the preceding month, giving the appearance of an &quot;off by 1&quot;
                error.  To avoid this situation, the DST change ignored by using the  fix_dst  option.
                When crossing the Summer/Winter DST boundary, normally an hour is substracted or added depending
                on the date.  For example, date math crossing the Spring DST leads to a date having a day value
                one less than expected, if the time part of the date was originally 00:00:00.  Since Zend_Date
                is based on timestamps, and not calendar dates with a time component, the timestamp loses an hour,
                resulting in the date having a calendar day value one less than expected.
                To prevent such problems use the option  fix_dst , which defaults to true, causing DST
                to have no effect on date &quot;math&quot; ( addMOnth(), subMonth() ). Use
                 Zend_Date::setOptions(array(&#39;fix_dst&#39; =&gt; false))  to enable the subtraction or addition
                of the DST adjustment when performing date &quot;math&quot;.
             If your actual timezone within the instance of  Zend_Date 
                is set to UTC or GMT the option  &#39;fix_dst&#39;  will not be used  because
                these two timezones do not work with DST. When you change the timezone for this instance
                again to a timezone which is not UTC or GMT the previous set &#39;fix_dst&#39; option will be used
                again for date &quot;math&quot;. 
             Month Calculations 
                When adding or substracting months from an existing date, the resulting value for the day of
                the month might be unexpected, if the original date fell on a day close to the end of the month.
                For example, when adding one month to January 31st, people familiar with SQL will expect February
                28th as the result. On the other side, people familiar with Excel and OpenOffice will expect
                March 3rd as the result. The problem only occurs, if the resulting month does not have the day,
                which is set in the original date.  For ZF developers, the desired behavior is selectable using
                the  extend_month  option to choose either the SQL behaviour, if set to false,
                or the spreadsheet behaviour when set to true. The default behaviour for  extend_month 
                is false, providing behavior compatible to SQL.  By default,  Zend_Date  computes month
                calculations by truncating dates to the end of the month (if necessary), without wrapping into the
                next month when the original date designates a day of the month exceeding the number of days in
                the resulting month.  Use  Zend_Date::setOptions(array(&#39;extend_month&#39; =&gt; true)); 
                to make month calculations work like popular spreadsheet programs.
             Speed up date localization and normalization with Zend_Cache 
                You can speed up  Zend_Date  by using an  Zend_Cache  adapter.
                This speeds up all methods of  Zend_Date  when you are using localized data.
                For example all methods which accept  Zend_Date::DATE  and
                 Zend_Date::TIME  constants would benefit from this. To set an  Zend_Cache 
                adapter to  Zend_Date  just use
                 Zend_Date::setOptions(array(&#39;cache&#39; =&gt; $adapter)); .
             Receiving syncronised timestamps with Zend_TimeSync 
                Normally the clocks from servers and computers differ from each other.  Zend_Date 
                is able to handle such problems with the help of  Zend_TimeSync . You can set a
                timeserver with  Zend_Date::setOptions(array(&#39;timesync&#39; =&gt; $timeserver));  which
                will set the offset between the own actual timestamp and the real actual timestamp for all
                instances of Zend_Date. Using this option does not change the timestamp of existing instances.
                So best usage is to set it within the bootstrap file.
             Working with Date Values 
            Once input has been normalized via the creation of a  Zend_Date  object, it will have an
            associated timezone, but an internal representation using standard
             UNIX timestamps 
            . In order for a date to be rendered in a localized manner, a timezone must be known first. The default
            timezone is always GMT/UTC. To examine an object&#39;s timezone use  getTimeZone()) . To change an
            object&#39;s timezone, use  setTimeZone()) . All manipulations of these objects are assumed to be
            relative to this timezone.
         
            Beware of mixing and matching operations with date parts between date objects for different timezones, which
            generally produce undesireable results, unless the manipulations are only related to the timestamp.
            Operating on  Zend_Date  objects having different timezones generally works, except as just
            noted, since dates are normalized to UNIX timestamps on instantiation of  Zend_Date .
         
            Most methods expect a constant selecting the desired  $part  of a date, such as
             Zend_Date::HOUR . These constants are valid for all of the functions below. A list of all
            available constants is provided in
             
            . If no  $part  is specified, then  Zend_Date::TIMESTAMP  is assumed. Alternatively, a
            user-specified format may be used for  $part , using the same underlying mechanism and format
            codes as
             Zend_Locale_Format::getDate() 
            . If a date object is constructed using an obviously invalid date (e.g. a month number greater than 12),
            then  Zend_Date  will throw an exception, unless no specific date format has been selected -i.e.
             $part  is either  null  or  Zend_Date::DATES  (a &quot;loose&quot; format).
         User-specified input date format &lt;?php
$date1 = new Zend_Date(&#39;Feb 31, 2007&#39;, null, &#39;en_US&#39;);
echo $date1, &quot;\n&quot;; // outputs &quot;Mar 3, 2007 12:00:00 AM&quot;

$date2 = new Zend_Date(&#39;Feb 31, 2007&#39;, Zend_Date::DATES, &#39;en_US&#39;);
echo $date2, &quot;\n&quot;; // outputs &quot;Mar 3, 2007 12:00:00 AM&quot;

$date3 = new Zend_Date(&#39;Feb 31, 2007&#39;, &#39;MM.dd.yyyy&#39;); // strictly restricts interpretation to specified format
echo $date3, &quot;\n&quot;; // outputs &quot;Mar 3, 2007 12:00:00 AM&quot;
             
            If the optional  $locale  parameter is provided, then the  $locale  disambiguates the
             $date  operand by replacing month and weekday names for string  $date  operands, and
            even parsing date strings expressed according to the conventions of that locale (see  Zend_Locale_Format::getDate()  ). The automatic normalization of localized  $date  operands of a string type occurs when
             $part  is one of the  Zend_Date::DATE*  or  Zend_Date::TIME*  constants.
            The locale identifies which language should be used to parse month names and weekday names, if the
             $date  is a string containing a date. If there is no  $date  input parameter, then
            the  $locale  parameter specifies the locale to use for localizing output (e.g. the date format
            for a string representation). Note that the  $date  input parameter might actually have a type
            name instead (e.g.  $hour  for  addHour() ), although that does not prevent the use of
             Zend_Date  objects as arguments for that parameter. If no  $locale  was specified,
            then the locale of the current object is used to interpret  $date , or select the localized
            format for output.
         Basic  Zend_Date  Operations Common to Many Date Parts 
            The methods  add(), sub(), compare(), get(), and set()  operate generically on dates. In each
            case, the operation is performed on the date held in the instance object. The  $date  operand is
            required for all of these methods, except  get() , and may be a  Zend_Date  instance
            object, a numeric string, or an integer. These methods assume  $date  is a timestamp, if it is
            not an object. However, the  $part  operand controls which logical part of the two dates are
            operated on, allowing operations on parts of the object&#39;s date, such as year or minute, even when
             $date  contains a long form date string, such as, &quot;December 31, 2007 23:59:59&quot;. The result of
            the operation changes the date in the object, except for  compare() , and  get() .
         Operating on Parts of Dates &lt;?php
require_once &#39;Zend/Date.php&#39;;

$date = new Zend_Date(); // $date&#39;s timestamp === time()

// changes $date by adding 12 hours
$date-&gt;add(&#39;12&#39;, Zend_Date::HOUR);
print $date;
             
            Convenience methods exist for each combination of the basic operations and several common date parts as
            shown in the tables below. These convenience methods help us lazy programmers avoid having to type out the
             date part constants 
            when using the general methods above. Conveniently, they are named by combining a prefix (name of a basic
            operation) with a suffix (type of date part), such as  addYear() . In the list below, all
            combinations of &quot;Date Parts&quot; and &quot;Basic Operations&quot; exist. For example, the operation &quot;add&quot; exists for each
            of these date parts, including  addDay() ,  addYear() , etc.
         
            These convenience methods have the same equivalent functionality as the basic operation methods, but expect
            string and integer  $date  operands containing only the values representing the type indicated by
            the suffix of the convenience method. Thus, the names of these methods (e.g. &quot;Year&quot; or &quot;Minute&quot;) identify
            the units of the  $date  operand, when  $date  is a string or integer.
         List of Date Parts Date Parts Date Part Explanation Timestamp 
                            UNIX timestamp, expressed in seconds elapsed since January 1st, 1970 00:00:00 GMT/UTC.
                         Year Gregorian calendar year (e.g. 2006) Month Gregorian calendar month (1-12, localized names supported) 24 hour clock Hours of the day (0-23) denote the hours elapsed, since the start of the day. minute Minutes of the hour (0-59) denote minutes elapsed, since the start of the hour. Second Seconds of the minute (0-59) denote the elapsed seconds, since the start of the minute. millisecond Milliseconds denote thousandths of a second (0-999).  Zend_Date  supports two additional methods for working with time units smaller than seconds. By default,  Zend_Date  instances use a precision defaulting to milliseconds, as seen using  getFractionalPrecision() . To change the precision use  setFractionalPrecision($precision) .  However, precision is limited practically to microseconds, since  Zend_Date  uses  microtime() . Day Zend_Date::DAY_SHORT  is extracted from  $date  if the  $date  operand is an instance of  Zend_Date  or a numeric string.  Otherwise, an attempt is made to extract the day according to the conventions documented for these constants:  Zend_Date::WEEKDAY_NARROW ,  Zend_Date::WEEKDAY_NAME ,  Zend_Date::WEEKDAY_SHORT ,  Zend_Date::WEEKDAY  (Gregorian calendar assumed) Week Zend_Date::WEEK  is extracted from  $date  if the  $date  operand is an instance of  Zend_Date  or a numeric string. Otherwise an exception is raised. (Gregorian calendar assumed) Date Zend_Date::DAY_MEDIUM  is extracted from  $date  if the  $date  operand is an instance of  Zend_Date .  Otherwise, an attempt is made to normalize the  $date  string into a Zend_Date::DATE_MEDIUM formatted date. The format of  Zend_Date::DAY_MEDIUM  depends on the object&#39;s locale. Weekday Weekdays are represented numerically as 0 (for Sunday) through 6 (for Saturday).   Zend_Date::WEEKDAY_DIGIT  is extracted from  $date , if the  $date  operand is an instance of  Zend_Date  or a numeric string.  Otherwise, an attempt is made to extract the day according to the conventions documented for these constants:  Zend_Date::WEEKDAY_NARROW ,  Zend_Date::WEEKDAY_NAME ,  Zend_Date::WEEKDAY_SHORT ,  Zend_Date::WEEKDAY  (Gregorian calendar assumed) DayOfYear In  Zend_Date , the day of the year represents the number of calendar days elapsed since the start of the year (0-365).  As with other units above, fractions are rounded down to the nearest whole number. (Gregorian calendar assumed)
                         Arpa Arpa dates (i.e. RFC 822 formatted dates) are supported. Output uses either a &quot;GMT&quot; or &quot;Local differential hours+min&quot; format (see section 5 of RFC 822).  Before PHP 5.2.2, using the DATE_RFC822 constant with PHP date functions sometimes produces  incorrect results .  Zend_Date&#39;s results are correct.  Example:  Mon, 31 Dec 06 23:59:59 GMT 
                             Iso Only complete ISO 8601 dates are supported for output. Example:  2009-02-14T00:31:30+01:00 
                             List of Date Operations 
                The basic operations below can be used instead of the convenience operations for specific date parts, if
                the
                 appropriate constant 
                is used for the  $part  parameter.
             Basic Operations Basic Operation Explanation get() get($part = null, $locale = null) 
                                    Use  get($part)  to retrieve the date  $part  of this object&#39;s
                                    date localized to  $locale  as a formatted string or integer. When using
                                    the BCMath extension, numeric strings might be returned instead of integers for
                                    large values.  NOTE:  Unlike  get() ,
                                    the other get*() convenience methods only return instances of  Zend_Date 
                                    containing a date representing the selected or computed date/time.
                                 set() set($date, $part = null, $locale = null) 
                                    Sets the  $part  of the current object to the corresponding value for
                                    that part found in the input  $date  having a locale
                                     $locale .
                                 add() add($date, $part = null, $locale = null) 
                                    Adds the  $part  of  $date  having a locale
                                     $locale  to the current object&#39;s date.
                                 sub() sub($date, $part = null, $locale = null) 
                                    Subtracts the  $part  of  $date  having a locale
                                     $locale  from the current object&#39;s date.
                                 copyPart() copyPart($part, $locale = null) 
                                    Returns a cloned object, with only  $part  of the object&#39;s date copied to
                                    the clone, with the clone have its locale arbitrarily set to  $locale 
                                    (if specified).
                                 compare() compare($date, $part = null, $locale = null) 
                                    compares  $part  of  $date  to this object&#39;s timestamp,
                                    returning 0 if they are equal, 1 if this object&#39;s part was more recent than $date&#39;s
                                    part, otherwise -1.
                                 Comparing Dates 
            The following basic operations do not have corresponding convenience methods for the date parts listed in
             
            .
         Date Comparison Methods Method Explanation equals() equals($date, $part = null, $locale = null) 
                                returns true, if  $part  of  $date  having locale
                                 $locale  is the same as this object&#39;s date  $part , otherwise
                                false
                             isEarlier() isEarlier($date, $part = null, $locale = null) 
                                returns true, if  $part  of this object&#39;s date is earlier than
                                 $part  of  $date  having a locale  $locale 
                             isLater() isLater($date, $part = null, $locale = null) 
                                returns true, if  $part  of this object&#39;s date is later than
                                 $part  of  $date  having a locale  $locale 
                             isToday() isToday() 
                                Tests if today&#39;s year, month, and day match this object&#39;s date value, using this
                                object&#39;s timezone.
                             isTomorrow() isTomorrow() 
                                Tests if tomorrow&#39;s year, month, and day match this object&#39;s date value, using this
                                object&#39;s timezone.
                             isYesterday() isYesterday() 
                                Tests if yesterday&#39;s year, month, and day match this object&#39;s date value, using this
                                object&#39;s timezone.
                             isLeapYear() isLeapYear() 
                                Use  isLeapYear()  to determine if the current object is a leap year, or use
                                Zend_Date::checkLeapYear($year) to check $year, which can be a string, integer, or
                                instance of  Zend_Date . Is the year a leap year?
                             isDate() isDate($date, $format = null, $locale = null) 
                                This method checks if a given date is a real date and returns true if all checks are ok.
                                It works like php&#39;s checkdate() function but can also check for localized month names and
                                for dates extending the range of checkdate()
                                false
                             Getting Dates and Date Parts 
            Several methods support retrieving values related to a  Zend_Date  instance.
         Date Output Methods Method Explanation toString() toString($format = null, $locale = null) 
                                Invoke directly or via the magic method  __toString() . The
                                 toString()  method automatically formats the date object&#39;s value according
                                to the conventions of the object&#39;s locale, or an optionally specified
                                 $locale . For a list of supported format codes, see
                                 
                                .
                             toArray() toArray() 
                                Returns an array representation of the selected date according to
                                the conventions of the object&#39;s locale. The returned array is equivalent to
                                PHP&#39;s  getdate()  function and includes:
                             
                                            Number of day as &#39; day &#39;
                                            ( Zend_Date::DAY_SHORT )
                                         
                                            Number of month as &#39; month &#39;
                                            ( Zend_Date::MONTH_SHORT )
                                         
                                            Year as &#39; year &#39;
                                            ( Zend_Date::YEAR )
                                         
                                            Hour as &#39; hour &#39;
                                            ( Zend_Date::HOUR_SHORT )
                                         
                                            Minute as &#39; minute &#39;
                                            ( Zend_Date::MINUTE_SHORT )
                                         
                                            Second as &#39; second &#39;
                                            ( Zend_Date::SECOND_SHORT )
                                         
                                            Abbreviated timezone as &#39; timezone &#39;
                                            ( Zend_Date::TIMEZONE )
                                         
                                            Unix timestamp as &#39; timestamp &#39;
                                            ( Zend_Date::TIMESTAMP )
                                         
                                            Number of weekday as &#39; weekday &#39;
                                            ( Zend_Date::WEEKDAY_DIGIT )
                                         
                                            Day of year as &#39; dayofyear &#39;
                                            ( Zend_Date::DAY_OF_YEAR )
                                         
                                            Week as &#39; week &#39;
                                            ( Zend_Date::WEEK )
                                         
                                            Delay of timezone to GMT as
                                            &#39; gmtsecs &#39;
                                            ( Zend_Date::GMT_SECS )
                                         toValue() toValue($part = null) 
                                Returns an integer representation of the selected date  $part  according to
                                the conventions of the object&#39;s locale. Returns  false  when
                                 $part  selects a non-numeric value, such as
                                 Zend_Date::MONTH_NAME_SHORT .  NOTE:  This
                                method calls
                                 get() 
                                and casts the result to a PHP integer, which will give unpredictable results, if
                                 get()  returns a numeric string containing a number too large for a PHP
                                integer on your system. Use  get()  instead.
                             get() get($part = null, $locale = null) 
                                This method returns the  $part  of object&#39;s date localized to
                                 $locale  as a formatted string or integer. See
                                 
                                for more information.
                             now() now($locale = null) 
                                This convenience function is equivalent to  new Zend_Date() . It returns the
                                current date as a  Zend_Date  object, having  $locale 
                             Working with Fractions of Seconds 
            Several methods support retrieving values related to a  Zend_Date  instance.
         Date Output Methods Method Explanation getFractionalPrecision() Return the precision of the part seconds setFractionalPrecision() Set the precision of the part seconds Sunrise / Sunset 
            Three methods provide access to geographically localized information about the Sun, including the time of
            sunrise and sunset.
         Miscellaneous Methods Method Explanation getSunrise($location) Return the date&#39;s time of sunrise getSunset($location) Return the date&#39;s time of sunset getSunInfo($location) Return an array with the date&#39;s sun dates Theory of Operation 
        Why is there only one class  Zend_Date  for handling dates and times in the Zend Framework?
     
        Many languages split the handling of times and calendar dates into two classes. However, the Zend Framework
        strives for extreme simplicity, and forcing the developer to manage different objects with different methods for
        times and dates becomes a burden in many situations. Since  Zend_Date  methods support working with
        ambiguous dates that might not include all parts (era, year, month, day, hour, minute, second, timezone),
        developers enjoy the flexibility and ease of using the same class and the same methods to perform the same
        manipulations (e.g. addition, subtraction, comparision, merging of date parts, etc.). Splitting the handling of
        these date fragments into multiple classes would create complications when smooth interoperation is desired with
        a small learning curve. A single class reduces code duplication for similar operations, without the need for a
        complex inheritance hierarchy.
     Internals 
                        UNIX Timestamp
                     
                        All dates and times, even ambiguous ones (e.g. no year), are represented internally as absolute
                        moments in time, represented as a UNIX timestamp expressing the difference between the desired
                        time and January 1st, 1970 00:00:00 GMT/UTC. This was only possible, because
                         Zend_Date  is not limited to UNIX timestamps nor integer values. The BCMath
                        extension is required to support extremely large dates outside of the range Fri, 13 Dec 1901
                        20:45:54 GMT to Tue, 19 Jan 2038 03:14:07 GMT.  Additional, tiny math errors may arise due to
                        the inherent limitations of float data types and rounding, unless using the BCMath extension.
                     
                        Date parts as timestamp offsets
                     
                        Thus, an instance object representing three hours would be expressed as three hours after
                        January 1st, 1970 00:00:00 GMT/UTC -i.e. 0 + 3 * 60 * 60 = 10800.
                     
                        PHP functions
                     
                        Where possible,  Zend_Date  usually uses PHP functions to improve performance.
                     Zend_Db_Adapter 
        Zend_Db and its related classes provide a simple SQL database interface
        for Zend Framework.  The Zend_Db_Adapter is the basic class you use to
        connect your PHP application to an RDBMS.  There is a different Adapter
        class for each brand of RDBMS.
     
        The Zend_Db Adapters create a bridge from the vendor-specific PHP
        extensions to a common interface, to help you write PHP applications
        once and deploy with multiple brands of RDBMS with very little effort.
     
        The interface of the Adapter class is similar to the interface of the
         PHP Data Objects  extension.
        Zend_Db provides Adapter classes to PDO drivers for the following RDBMS
        brands:
     
                IBM DB2 and Informix Dynamic Server (IDS), using the
                 pdo_ibm  PHP extension
             
                MySQL, using the  pdo_mysql  PHP extension
             
                Microsoft SQL Server, using the  pdo_mssql  PHP
                extension
             
                Oracle, using the  pdo_oci  PHP extension
             
                PostgreSQL, using the  pdo_pgsql  PHP extension
             
                SQLite, using the  pdo_sqlite  PHP extension
             
        In addition, Zend_Db provides Adapter classes that utilize PHP database
        extensions for the following RDBMS brands:
     
                MySQL, using the  mysqli  PHP extension
             
                Oracle, using the  oci8  PHP extension
             
                IBM DB2, using the  ibm_db2  PHP extension
             
                Firebird/Interbase, using the  php_interbase  PHP extension
             
            Each Zend_Db Adapter uses a PHP extension.  You must have the
            respective PHP extension enabled in your PHP environment to use a
            Zend_Db Adapter.  For example, if you use any of the PDO Zend_Db
            Adapters, you need to enable both the PDO extension and the
            PDO driver for the brand of RDBMS you use.
         Connecting to a Database using an Adapter 
            This section describes how to create an instance of a database Adapter.
            This corresponds to making a connection to your RDBMS server from your
            PHP application.
         Using a Zend_Db Adapter Constructor 
                You can create an instance of an Adapter using its constructor.
                An Adapter constructor takes one argument, which is an array
                of parameters used to declare the connection.
             Using an Adapter constructor &lt;?php
require_once &#39;Zend/Db/Adapter/Pdo/Mysql.php&#39;;

$db = new Zend_Db_Adapter_Pdo_Mysql(array(
    &#39;host&#39;     =&gt; &#39;127.0.0.1&#39;,
    &#39;username&#39; =&gt; &#39;webuser&#39;,
    &#39;password&#39; =&gt; &#39;xxxxxxxx&#39;,
    &#39;dbname&#39;   =&gt; &#39;test&#39;
));
                 Using the Zend_Db Factory 
                As an alternative to using an Adapter constructor directly, you
                can create an instance of an Adapter using the static method
                 Zend_Db::factory() .  This method dynamically loads
                the Adapter class file on demand, using
                 Zend_Loader::loadClass() .
             
                The first argument is a string that names the base name of the
                Adapter class.  For example the string &#39;Pdo_Mysql&#39; corresponds
                to the class Zend_Db_Adapter_Pdo_Mysql.  The second argument is
                the same array of parameters you would have given to the
                Adapter constructor.
             Using the Adapter factory method &lt;?php
require_once &#39;Zend/Db.php&#39;;

// Automatically load class Zend_Db_Adapter_Pdo_Mysql and create an instance of it.
$db = Zend_Db::factory(&#39;Pdo_Mysql&#39;, array(
    &#39;host&#39;     =&gt; &#39;127.0.0.1&#39;,
    &#39;username&#39; =&gt; &#39;webuser&#39;,
    &#39;password&#39; =&gt; &#39;xxxxxxxx&#39;,
    &#39;dbname&#39;   =&gt; &#39;test&#39;
));
                 
                If you create your own class that extends
                Zend_Db_Adapter_Abstract, but you do not name your class with
                the &quot;Zend_Db_Adapter&quot; package prefix, you can use the
                 factory()  method to load your Adapter if you
                specify the leading portion of the adapter class with the
                &#39;adapterNamespace&#39; key in the parameters array.
             Using the Adapter factory method for a custom adapter class &lt;?php
require_once &#39;Zend/Db.php&#39;;

// Automatically load class MyProject_Db_Adapter_Pdo_Mysql and create an instance of it.
$db = Zend_Db::factory(&#39;Pdo_Mysql&#39;, array(
    &#39;host&#39;             =&gt; &#39;127.0.0.1&#39;,
    &#39;username&#39;         =&gt; &#39;webuser&#39;,
    &#39;password&#39;         =&gt; &#39;xxxxxxxx&#39;,
    &#39;dbname&#39;           =&gt; &#39;test&#39;,
    &#39;adapterNamespace&#39; =&gt; &#39;MyProject_Db_Adapter&#39;
));
                 Using Zend_Config with the Zend_Db Factory 
                Optionally, you may specify either argument of the
                 factory()  method as an object of type
                 Zend_Config .
             
                If the first argument is a config object, it is expected to
                contain a property named  adapter , containing the
                string naming the adapter class name base.  Optionally, the object
                may contain a property named  params , with
                subproperties corresponding to adapter parameter names.
                This is used only if the second argument of the
                 factory()  method is absent.
             Using the Adapter factory method with a Zend_Config object 
                    In the example below, a Zend_Config object is created from
                    an array.  You can also load data from an external file,
                    for example with
                     Zend_Config_Ini 
                    or  Zend_Config_Xml .
                 &lt;?php
require_once &#39;Zend/Config.php&#39;;
require_once &#39;Zend/Db.php&#39;;

$config = new Zend_Config(
    array(
        &#39;database&#39; =&gt; array(
            &#39;adapter&#39; =&gt; &#39;Mysqli&#39;,
            &#39;params&#39; =&gt; array(
                &#39;dbname&#39; =&gt; &#39;test&#39;,
                &#39;username&#39; =&gt; &#39;webuser&#39;,
                &#39;password&#39; =&gt; &#39;secret&#39;,
            )
        )
    )
);

$db = Zend_Db::factory($config-&gt;database);
                 
                The second argument of the  factory()  method may be
                an associative array containing entries corresponding to
                adapter parameters.  This argument is optional.  If the first
                argument is of type Zend_Config, it is assumed to contain all
                parameters, and the second argument is ignored.
             Adapter Parameters 
                The list below explains common parameters recognized by Zend_Db Adapter classes.
             host :
                        a string containing a hostname or IP address of the
                        database server.  If the database is running on the
                        same host as the PHP application, you may use
                        &#39;localhost&#39; or &#39;127.0.0.1&#39;.
                     username :
                        account identifier for authenticating a connection to the
                        RDBMS server.
                     password :
                        account password credential for authenticating a
                        connection to the RDBMS server.
                     dbname :
                        database instance name on the RDBMS server.
                     port :
                        some RDBMS servers can accept network connections on a
                        administrator-specified port number.  The port
                        parameter allow you to specify the port to which your
                        PHP application connects, to match the port configured
                        on the RDBMS server.
                     options :
                        this parameter is an associative array of options
                        that are generic to all Zend_Db_Adapter classes.
                     driver_options :
                        this parameter is an associative array of additional
                        options that are specific to a given database
                        extension.  One typical use of this parameter is to
                        set attributes of a PDO driver.
                     adapterNamespace :
                        names the initial part of the class name for the
                        adapter, instead of &#39;Zend_Db_Adapter&#39;.  Use this if
                        you need to use the  factory()  method to
                        load a non-Zend database adapter class.
                     Passing the case-folding option to the factory 
                    You can specify this option by the constant
                     Zend_Db::CASE_FOLDING .
                    This corresponds to the  ATTR_CASE  attribute in
                    PDO and IBM DB2 database drivers, adjusting the case of
                    string keys in query result sets.  The option takes values
                     Zend_Db::CASE_NATURAL  (the default),
                     Zend_Db::CASE_UPPER , and
                     Zend_Db::CASE_LOWER .
                 &lt;?php
$options = array(
    Zend_Db::CASE_FOLDING =&gt; Zend_Db::CASE_UPPER
);

$params = array(
    &#39;host&#39;           =&gt; &#39;127.0.0.1&#39;,
    &#39;username&#39;       =&gt; &#39;webuser&#39;,
    &#39;password&#39;       =&gt; &#39;xxxxxxxx&#39;,
    &#39;dbname&#39;         =&gt; &#39;test&#39;,
    &#39;options&#39;        =&gt; $options
);

$db = Zend_Db::factory(&#39;Db2&#39;, $params);
                 Passing the auto-quoting option to the factory 
                    You can specify this option by the constant
                     Zend_Db::AUTO_QUOTE_IDENTIFIERS .  If the value
                    is  true  (the default), identifiers like table
                    names, column names, and even aliases are delimited in all
                    SQL syntax generated by the Adapter object.  This makes it
                    simple to use identifiers that contain SQL keywords, or
                    special characters.  If the value is  false ,
                    identifiers are not delimited automatically.  If you need
                    to delimit identifiers, you must do so yourself using the
                     quoteIdentifier()  method.
                 &lt;?php
$options = array(
    Zend_Db::AUTO_QUOTE_IDENTIFIERS =&gt; false
);

$params = array(
    &#39;host&#39;           =&gt; &#39;127.0.0.1&#39;,
    &#39;username&#39;       =&gt; &#39;webuser&#39;,
    &#39;password&#39;       =&gt; &#39;xxxxxxxx&#39;,
    &#39;dbname&#39;         =&gt; &#39;test&#39;,
    &#39;options&#39;        =&gt; $options
);

$db = Zend_Db::factory(&#39;Pdo_Mysql&#39;, $params);
                 Passing PDO driver options to the factory &lt;?php
$pdoParams = array(
    PDO::MYSQL_ATTR_USE_BUFFERED_QUERY =&gt; true
);

$params = array(
    &#39;host&#39;           =&gt; &#39;127.0.0.1&#39;,
    &#39;username&#39;       =&gt; &#39;webuser&#39;,
    &#39;password&#39;       =&gt; &#39;xxxxxxxx&#39;,
    &#39;dbname&#39;         =&gt; &#39;test&#39;,
    &#39;driver_options&#39; =&gt; $pdoParams
);

$db = Zend_Db::factory(&#39;Pdo_Mysql&#39;, $params);

echo $db-&gt;getConnection()-&gt;getAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY);
                 Managing Lazy Connections 
                Creating an instance of an Adapter class does not immediately
                connect to the RDBMS server.  The Adapter saves the connection
                parameters, and makes the actual connection on demand, the
                first time you need to execute a query.  This ensures that
                creating an Adapter object is quick and inexpensive.  You can
                create an instance of an Adapter even if you are not certain
                that you need to run any database queries during the current
                request your application is serving.
             
                If you need to force the Adapter to connect to the RDBMS, use
                the  getConnection()  method.  This method returns
                an object for the connection as represented by the respective
                PHP database extension.  For example, if you use any of the
                Adapter classes for PDO drivers, then
                 getConnection()  returns the PDO object, after
                initiating it as a live connection to the specific database.
             
                It can be useful to force the connection if you want to catch
                any exceptions it throws as a result of invalid account
                credentials, or other failure to connect to the RDBMS server.
                These exceptions are not thrown until the connection is made,
                so it can help simplify your application code if you handle the
                exceptions in one place, instead of at the time of
                the first query against the database.
             Handling connection exceptions &lt;?php
try {
    $db = Zend_Db::factory(&#39;Pdo_Mysql&#39;, $parameters);
    $db-&gt;getConnection();
} catch (Zend_Db_Adapter_Exception $e) {
    // perhaps a failed login credential, or perhaps the RDBMS is not running
} catch (Zend_Exception $e) {
    // perhaps factory() failed to load the specified Adapter class
}
                 The example database 
            In the documentation for Zend_Db classes, we use a set of simple
            tables to illustrate usage of the classes and methods.  These
            example tables could store information for tracking bugs in a
            software development project.  The database contains four tables:
         accounts  stores
                    information about each user of the bug-tracking database.
                 products  stores
                    information about each product for which a bug can be
                    logged.
                 bugs  stores information
                    about bugs, including that current state of the bug, the
                    person who reported the bug, the person who is assigned to
                    fix the bug, and the person who is assigned to verify the
                    fix.
                 bugs_products  stores a
                    relationship between bugs and products.  This implements a
                    many-to-many relationship, because a given bug may be
                    relevant to multiple products, and of course a given
                    product can have multiple bugs.
                 
            The following SQL data definition language pseudocode describes the
            tables in this example database.  These example tables are used
            extensively by the automated unit tests for Zend_Db.
         
CREATE TABLE accounts (
  account_name      VARCHAR(100) NOT NULL PRIMARY KEY
);

CREATE TABLE products (
  product_id        INTEGER NOT NULL PRIMARY KEY,
  product_name      VARCHAR(100)
);

CREATE TABLE bugs (
  bug_id            INTEGER NOT NULL PRIMARY KEY,
  bug_description   VARCHAR(100),
  bug_status        VARCHAR(20),
  reported_by       VARCHAR(100) REFERENCES accounts(account_name),
  assigned_to       VARCHAR(100) REFERENCES accounts(account_name),
  verified_by       VARCHAR(100) REFERENCES accounts(account_name)
);

CREATE TABLE bugs_products (
  bug_id            INTEGER NOT NULL REFERENCES bugs,
  product_id        INTEGER NOT NULL REFERENCES products,
  PRIMARY KEY       (bug_id, product_id)
);
         
            Also notice that the  bugs  table contains multiple
            foreign key references to the  accounts  table.
            Each of these foreign keys may reference a different row in the
             accounts  table for a given bug.
         
            The diagram below illustrates the physical data model of the
            example database.
         Reading Query Results 
            This section describes methods of the Adapter class with which you
            can run SELECT queries and retrieve the query results.
         Fetching a Complete Result Set 
                You can run a SQL SELECT query and retrieve its results in one
                step using the  fetchAll()  method.
             
                The first argument to this method is a string containing a
                SELECT statement.  Alternatively, the first argument can be an
                object of class  Zend_Db_Select .
                The Adapter automatically converts this object to a string
                representation of the SELECT statement.
             
                The second argument to  fetchAll()  is an array of
                values to substitute for parameter placeholders in the SQL
                statement.
             Using fetchAll() &lt;?php
$sql = &#39;SELECT * FROM bugs WHERE bug_id = ?&#39;;

$result = $db-&gt;fetchAll($sql, 2);
                 Changing the Fetch Mode 
                By default,  fetchAll()  returns an array of
                rows, each of which is an associative array.  The keys of the
                associative array are the columns or column aliases named in
                the select query.
             
                You can specify a different style of fetching results using the
                 setFetchMode()  method.  The modes supported are
                identified by constants:
             Zend_Db::FETCH_ASSOC :
                        return data in an array of associative arrays.
                        The array keys are column names, as strings.
                        This is the default fetch mode for Zend_Db_Adapter classes.
                     
                        Note that if your select-list contains more than one
                        column with the same name, for example if they are from
                        two different tables in a JOIN, there can be only one
                        entry in the associative array for a given name.
                        If you use the FETCH_ASSOC mode, you should specify
                        column aliases in your SELECT query to ensure that the
                        names result in unique array keys.
                     
                        By default, these strings are returned as they are
                        returned by the database driver.  This is typically the
                        spelling of the column in the RDBMS server.  You can
                        specify the case for these strings, using the
                         Zend_Db::CASE_FOLDING  option.
                        Specify this when instantiating the Adapter.
                        See  .
                     Zend_Db::FETCH_NUM :
                        return data in an array of arrays.  The arrays are
                        indexed by integers, corresponding to the position of
                        the respective field in the select-list of the query.
                     Zend_Db::FETCH_BOTH :
                        return data in an array of arrays.  The array keys are
                        both strings as used in the FETCH_ASSOC mode, and
                        integers as used in the FETCH_NUM mode.  Note that the
                        number of elements in the array is double that which
                        would be in the array if you used either FETCH_ASSOC
                        or FETCH_NUM.
                     Zend_Db::FETCH_COLUMN :
                        return data in an array of values.  The value in each array
                        is the value returned by one column of the result set.
                        By default, this is the first column, indexed by 0.
                     Zend_Db::FETCH_OBJ :
                        return data in an array of objects.  The default class
                        is the PHP built-in class stdClass.  Columns of the
                        result set are available as public properties of the
                        object.
                     Using setFetchMode() &lt;?php
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchAll(&#39;SELECT * FROM bugs WHERE bug_id = ?&#39;, 2);

// $result is an array of objects
echo $result[0]-&gt;bug_description;
                 Fetching a Result Set as an Associative Array 
                The  fetchAssoc()  method returns data in an array
                of associative arrays, regardless of what value you have set
                for the fetch mode.
             Using fetchAssoc() &lt;?php
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchAssoc(&#39;SELECT * FROM bugs WHERE bug_id = ?&#39;, 2);

// $result is an array of associative arrays, in spite of the fetch mode
echo $result[0][&#39;bug_description&#39;];
                 Fetching a Single Column from a Result Set 
                The  fetchCol()  method returns data in an array
                of values, regardless of the value you have set for the fetch mode.
                This only returns the first column returned by the query.
                Any other columns returned by the query are discarded.
                If you need to return a column other than the first, see  .
             Using fetchCol() &lt;?php
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchCol(&#39;SELECT bug_description, bug_id FROM bugs WHERE bug_id = ?&#39;, 2);

// contains bug_description; bug_id is not returned
echo $result[0];
                 Fetching Key-Value Pairs from a Result Set 
                The  fetchPairs()  method returns data in an array
                of key-value pairs, as an associative array with a single entry
                per row.  The key of this associative array is taken from the
                first column returned by the SELECT query.  The value is taken
                from the second column returned by the SELECT query.  Any other
                columns returned by the query are discarded.
             
                You should design the SELECT query so that the first column
                returned has unique values.  If there are duplicates values in
                the first column, entries in the associative array will be
                overwritten.
             Using fetchPairs() &lt;?php
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchPairs(&#39;SELECT bug_id, bug_status FROM bugs&#39;);

echo $result[2];
                 Fetching a Single Row from a Result Set 
                The  fetchRow()  method returns data using the
                current fetch mode, but it returns only the first row
                fetched from the result set.
             Using fetchRow() &lt;?php
$db-&gt;setFetchMode(Zend_Db::FETCH_OBJ);

$result = $db-&gt;fetchRow(&#39;SELECT * FROM bugs WHERE bug_id = 2&#39;);

// note that $result is a single object, not an array of objects
echo $result-&gt;bug_description;
                 Fetching a Single Scalar from a Result Set 
                The  fetchOne()  method is like a combination
                of  fetchRow()  with  fetchCol() ,
                in that it returns data only for the first row fetched from
                the result set, and it returns only the value of the first
                column in that row.  Therefore it returns only a single
                scalar value, not an array or an object.
             Using fetchOne() &lt;?php
$result = $db-&gt;fetchOne(&#39;SELECT bug_status FROM bugs WHERE bug_id = 2&#39;);

// this is a single string value
echo $result;
                 Writing Changes to the Database 
            You can use the Adapter class to write new data or change existing
            data in your database.  This section describes methods to do these
            operations.
         Inserting Data 
                You can add new rows to a table in your database using the
                 insert()  method.  The first argument is a string
                that names the table, and the second argument is an associative
                array, mapping column names to data values.
             Inserting to a table &lt;?php
$data = array(
    &#39;created_on&#39;      =&gt; &#39;2007-03-22&#39;,
    &#39;bug_description&#39; =&gt; &#39;Something wrong&#39;,
    &#39;bug_status&#39;      =&gt; &#39;NEW&#39;
);

$db-&gt;insert(&#39;bugs&#39;, $data);
                 
                Columns you exclude from the array of data are not specified to
                the database.  Therefore, they follow the same rules that an
                SQL INSERT statement follows:  if the column has a DEFAULT
                clause, the column takes that value in the row created,
                otherwise the column is left in a NULL state.
             
                By default, the values in your data array are inserted using
                parameters.  This reduces risk of some types of security
                issues.  You don&#39;t need to apply escaping or quoting to values
                in the data array.
             
                You might need values in the data array to be treated as SQL
                expressions, in which case they should not be quoted.  By
                default, all data values passed as strings are treated as
                string literals.  To specify that the value is an SQL
                expression and therefore should not be quoted, pass the value
                in the data array as an object of type Zend_Db_Expr instead of
                a plain string.
             Inserting expressions to a table &lt;?php
$data = array(
    &#39;created_on&#39;      =&gt; new Zend_Db_Expr(&#39;CURDATE()&#39;),
    &#39;bug_description&#39; =&gt; &#39;Something wrong&#39;,
    &#39;bug_status&#39;      =&gt; &#39;NEW&#39;
);

$db-&gt;insert(&#39;bugs&#39;, $data);
                 Retrieving a Generated Value 
                Some RDBMS brands support auto-incrementing primary keys.
                A table defined this way generates a primary key value
                automatically during an INSERT of a new row.  The return value
                of the  insert()  method is  not 
                the last inserted ID, because the table might not have an
                auto-incremented column.  Instead, the return value is the
                number of rows affected (usually 1).
             
                If your table is defined with an auto-incrementing primary key,
                you can call the  lastInsertId()  method after the
                insert.  This method returns the last value generated in the
                scope of the current database connection.
             Using lastInsertId() for an auto-increment key &lt;?php
$db-&gt;insert(&#39;bugs&#39;, $data);

// return the last value generated by an auto-increment column
$id = $db-&gt;lastInsertId();
                 
                Some RDBMS brands support a sequence object, which generates
                unique values to serve as primary key values.  To support
                sequences, the  lastInsertId()  method accepts two
                optional string arguments.  These arguments name the table and
                the column, assuming you have followed the convention that a
                sequence is named using the table and column names for which
                the sequence generates values, and a suffix &quot;_seq&quot;.  This is
                based on the convention used by PostgreSQL when naming
                sequences for SERIAL columns.  For example, a table &quot;bugs&quot; with
                primary key column &quot;bug_id&quot; would use a sequence named
                &quot;bugs_bug_id_seq&quot;.
             Using lastInsertId() for a sequence &lt;?php
$db-&gt;insert(&#39;bugs&#39;, $data);

// return the last value generated by sequence &#39;bugs_bug_id_seq&#39;.
$id = $db-&gt;lastInsertId(&#39;bugs&#39;, &#39;bug_id&#39;);

// alternatively, return the last value generated by sequence &#39;bugs_seq&#39;.
$id = $db-&gt;lastInsertId(&#39;bugs&#39;);
                 
                If the name of your sequence object does not follow this naming
                convention, use the  lastSequenceId()  method
                instead.  This method takes a single string argument, naming
                the sequence literally.
             Using lastSequenceId() &lt;?php
$db-&gt;insert(&#39;bugs&#39;, $data);

// return the last value generated by sequence &#39;bugs_id_gen&#39;.
$id = $db-&gt;lastSequenceId(&#39;bugs_id_gen&#39;);
                 
                For RDBMS brands that don&#39;t support sequences, including MySQL,
                Microsoft SQL Server, and SQLite, the arguments to the
                lastInsertId() method are ignored, and the value returned is the
                most recent value generated for any table by INSERT operations
                during the current connection.   For these RDBMS brands, the
                lastSequenceId() method always returns  null .
             Why not use &quot;SELECT MAX(id) FROM table&quot;? 
                    Sometimes this query returns the most recent primary key
                    value inserted into the table.  However, this technique
                    is not safe to use in an environment where multiple clients are
                    inserting records to the database.  It is possible, and
                    therefore is bound to happen eventually, that another
                    client inserts another row in the instant between the
                    insert performed by your client application and your query
                    for the MAX(id) value.  Thus the value returned does not
                    identify the row you inserted, it identifies the row
                    inserted by some other client.  There is no way to know
                    when this has happened.
                 
                    Using a strong transaction isolation mode such as
                    &quot;repeatable read&quot; can mitigate this risk, but some RDBMS
                    brands don&#39;t support the transaction isolation required for
                    this, or else your application may use a lower transaction
                    isolation mode by design.
                 
                    Furthermore, using an expression like &quot;MAX(id)+1&quot; to generate
                    a new value for a primary key is not safe, because two clients
                    could do this query simultaneously, and then both use the same
                    calculated value for their next INSERT operation.
                 
                    All RDBMS brands provide mechanisms to generate unique
                    values, and to return the last value generated.  These
                    mechanisms necessarily work outside of the scope of
                    transaction isolation, so there is no chance of two clients
                    generating the same value, and there is no chance that the
                    value generated by another client could be reported to your
                    client&#39;s connection as the last value generated.
                 Updating Data 
                You can update rows in a database table using the
                 update()  method of an Adapter.  This method takes
                three arguments:  the first is the name of the table; the
                second is an associative array mapping columns to change to new
                values to assign to these columns.
             
                The values in the data array are treated as string literals.
                See  
                for information on using SQL expressions in the data array.
             
                The third argument is a string containing an SQL expression
                that is used as criteria for the rows to change.  The values
                and identifiers in this argument are not quoted or escaped.
                You are responsible for ensuring that any dynamic content is
                interpolated into this string safely.
                See  
                for methods to help you do this.
             
                The return value is the number of rows affected by the update
                operation.
             Updating rows &lt;?php
$data = array(
    &#39;updated_on&#39;      =&gt; &#39;2007-03-23&#39;,
    &#39;bug_status&#39;      =&gt; &#39;FIXED&#39;
);

$n = $db-&gt;update(&#39;bugs&#39;, $data, &#39;bug_id = 2&#39;);
                 
                If you omit the third argument, then all rows in the database
                table are updated with the values specified in the data array.
             
                If you provide an array of strings as the third argument, these
                strings are joined together as terms in an expression separated
                by  AND  operators.
             Updating rows using an array of expressions &lt;?php
$data = array(
    &#39;updated_on&#39;      =&gt; &#39;2007-03-23&#39;,
    &#39;bug_status&#39;      =&gt; &#39;FIXED&#39;
);

$where[] = &quot;reported_by = &#39;goofy&#39;&quot;;
$where[] = &quot;bug_status = &#39;OPEN&#39;&quot;;

$n = $db-&gt;update(&#39;bugs&#39;, $data, $where);

// Resulting SQL is:
//  UPDATE &quot;bugs&quot; SET &quot;update_on&quot; = &#39;2007-03-23&#39;, &quot;bug_status&quot; = &#39;FIXED&#39;
//  WHERE (&quot;reported_by&quot; = &#39;goofy&#39;) AND (&quot;bug_status&quot; = &#39;OPEN&#39;)
                 Deleting Data 
                You can delete rows from a database table using the
                 delete()  method.  This method takes two arguments:
                the first is a string naming the table.
             
                The second argument is a string containing an SQL expression
                that is used as criteria for the rows to delete.  The values
                and identifiers in this argument are not quoted or escaped.
                You are responsible for ensuring that any dynamic content is
                interpolated into this string safely.
                See  
                for methods to help you do this.
             
                The return value is the number of rows affected by the delete
                operation.
             Deleting rows &lt;?php
$n = $db-&gt;delete(&#39;bugs&#39;, &#39;bug_id = 3&#39;);
                 
                If you omit the second argument, the result is that all rows in
                the database table are deleted.
             
                If you provide an array of strings as the second argument, these
                strings are joined together as terms in an expression separated
                by  AND  operators.
             Quoting Values and Identifiers 
            When you form SQL queries, often it is the case that you need to
            include the values of PHP variables in SQL expressions.  This is
            risky, because if the value in a PHP string contains certain
            symbols, such as the quote symbol, it could result in invalid SQL.
            For example, notice the imbalanced quote characters in the
            following query:
             
$name = &quot;O&#39;Reilly&quot;;
$sql = &quot;SELECT * FROM bugs WHERE reported_by = &#39;$name&#39;&quot;;

echo $sql;
// SELECT * FROM bugs WHERE reported_by = &#39;O&#39;Reilly&#39;
             
         
            Even worse is the risk that such code mistakes might be exploited
            deliberately by a person who is trying to manipulate the function
            of your web application.  If they can specify the value of a PHP
            variable through the use of an HTTP parameter or other mechanism,
            they might be able to make your SQL queries do things that you
            didn&#39;t intend them to do, such as return data to which the person
            should not have privilege to read.  This is a serious and widespread
            technique for violating application security, known as &quot;SQL Injection&quot;
            (see  http://en.wikipedia.org/wiki/SQL_Injection ).
         
            The Zend_Db Adapter class provides convenient functions to help you
            reduce vulnerabilities to SQL Injection attacks in your PHP code.
            The solution is to escape special characters such as quotes in PHP
            values before they are interpolated into your SQL strings.
            This protects against both accidental and deliberate manipulation
            of SQL strings by PHP variables that contain special characters.
         Using  quote() 
                The  quote()  method accepts a single argument, a
                scalar string value.  It returns the value with special
                characters escaped in a manner appropriate for the RDBMS you
                are using, and surrounded by string value delimiters.  The
                standard SQL string value delimiter is the single-quote
                ( &#39; ).
             Using quote() &lt;?php
$name = $db-&gt;quote(&quot;O&#39;Reilly&quot;);
echo $name;
// &#39;O\&#39;Reilly&#39;

$sql = &quot;SELECT * FROM bugs WHERE reported_by = $name&quot;;

echo $sql;
// SELECT * FROM bugs WHERE reported_by = &#39;O\&#39;Reilly&#39;
                 
                Note that the return value of  quote()  includes the
                quote delimiters around the string.  This is different from
                some functions that escape special characters but do not add
                the quote delimiters, for example
                 mysql_real_escape_string() .
             
                Values may need to be quoted or not quoted according to the SQL
                datatype context in which they are used.  For instance, in some
                RDBMS brands, an integer value must not be quoted as a string
                if it is compared to an integer-type column or expression.
                In other words, the following is an error in some SQL
                implementations, assuming  intColumn  has a SQL
                datatype of  INTEGER 

                 
SELECT * FROM atable WHERE intColumn = &#39;123&#39;
                 
             
                You can use the optional second argument to the
                 quote()  method to apply quoting selectively for
                the SQL datatype you specify.
             Using quote() with a SQL type &lt;?php
$value = &#39;1234&#39;;
$sql = &#39;SELECT * FROM atable WHERE intColumn = &#39;
     . $db-&gt;quote($value, &#39;INTEGER&#39;);

                 
                Each Zend_Db_Adapter class has encoded the names of numeric
                SQL datatypes for the respective brand of RDBMS.  You can also
                use the constants  Zend_Db::INT_TYPE ,
                 Zend_Db::BIGINT_TYPE , and
                 Zend_Db::FLOAT_TYPE  to write code in a more
                RDBMS-independent way.
             
                Zend_Db_Table specifies SQL types to  quote() 
                automatically when generating SQL queries that reference a
                table&#39;s key columns.
             Using  quoteInto() 
                The most typical usage of quoting is to interpolate a PHP
                variable into a SQL expression or statement.  You can use the
                 quoteInto()  method to do this in one step.  This
                method takes two arguments: the first argument is a string
                containing a placeholder symbol ( ? ), and the
                second argument is a value or PHP variable that should be
                substituted for that placeholder.
             
                The placeholder symbol is the same symbol used by many RDBMS
                brands for positional parameters, but the
                 quoteInto()  method only emulates query parameters.
                The method simply interpolates the value into the string,
                escapes special characters, and applies quotes around it.
                True query parameters maintain the separation between the SQL
                string and the parameters as the statement is parsed in the
                RDBMS server.
             Using quoteInto() &lt;?php
$sql = $db-&gt;quoteInto(&quot;SELECT * FROM bugs WHERE reported_by = ?&quot;, &quot;O&#39;Reilly&quot;);

echo $sql;
// SELECT * FROM bugs WHERE reported_by = &#39;O\&#39;Reilly&#39;
                 
                You can use the optional third parameter of
                 quoteInto()  to specify the SQL datatype.  Numeric
                datatypes are not quoted, and other types are quoted.
             Using quoteInto() with a SQL type &lt;?php
$sql = $db-&gt;quoteInto(&quot;SELECT * FROM bugs WHERE bug_id = ?&quot;, &#39;1234&#39;, &#39;INTEGER&#39;);

echo $sql;
// SELECT * FROM bugs WHERE reported_by = 1234
                 Using  quoteIdentifier() 
                Values are not the only part of SQL syntax that might need to
                be variable.  If you use PHP variables to name tables, columns,
                or other identifiers in your SQL statements, you might need to
                quote these strings too.  By default, SQL identifiers have
                syntax rules like PHP and most other programming languages.
                For example, identifiers should not contain spaces, certain
                punctuation or special characters, or international characters.
                Also certain words are reserved for SQL syntax, and should not
                be used as identifiers.
             
                However, SQL has a feature called  delimited identifiers ,
                which allows broader choices for the spelling of identifiers.
                If you enclose a SQL identifier in the proper types of quotes,
                you can use identifiers with spellings that would be invalid
                without the quotes.  Delimited identifiers can contain spaces,
                punctuation, or international characters.  You can also use SQL
                reserved words if you enclose them in identifier delimiters.
             
                The  quoteIdentifier()  method works like
                 quote() , but it applies the identifier delimiter
                characters to the string according to the type of Adapter you
                use.  For example, standard SQL uses double-quotes
                ( &quot; ) for identifier delimiters, and most RDBMS
                brands use that symbol.  MySQL uses back-quotes
                ( ` ) by default.  The
                 quoteIdentifier()  method also escapes special
                characters within the string argument.
             Using quoteIdentifier() &lt;?php
// we might have a table name that is an SQL reserved word
$tableName = $db-&gt;quoteIdentifier(&quot;order&quot;);

$sql = &quot;SELECT * FROM $tableName&quot;;

echo $sql
// SELECT * FROM &quot;order&quot;
                 
                SQL delimited identifiers are case-sensitive, unlike unquoted
                identifiers.  Therefore, if you use delimited identifiers, you
                must use the spelling of the identifier exactly as it is stored
                in your schema, including the case of the letters.
             
                In most cases where SQL is generated within Zend_Db classes,
                the default is that all identifiers are delimited
                automatically.  You can change this behavior with the option
                 Zend_Db::AUTO_QUOTE_IDENTIFIERS .  Specify this
                when instantiating the Adapter.
                See  .
             Controlling Database Transactions 
            Databases define transactions as logical units of work that can be
            committed or rolled back as a single change, even if they operate
            on multiple tables.  All queries to a database are executed within
            the context of a transaction, even if the database driver manages
            them implicitly.  This is called  auto-commit 
            mode, in which the database driver creates a transaction for every
            statement you execute, and commits that transaction after your
            SQL statement has been executed.  By default, all Zend_Db Adapter
            classes operate in auto-commit mode.
         
            Alternatively, you can specify the beginning and resolution of a
            transaction, and thus control how many SQL queries are included in
            a single group that is committed (or rolled back) as a single
            operation.  Use the  beginTransaction()  method to
            initiate a transaction.  Subsequent SQL statements are executed in
            the context of the same transaction until you resolve it
            explicitly.
         
            To resolve the transaction, use either the  commit()  or
             rollBack()  methods.  The  commit()  method
            marks changes made during your transaction as committed, which
            means the effects of these changes are shown in queries run in
            other transactions.
         
            The  rollBack()  method does the opposite: it discards
            the changes made during your transaction.  The changes are
            effectively undone, and the state of the data returns to how it was
            before you began your transaction.  However, rolling back your
            transaction has no effect on changes made by other transactions
            running concurrently.
         
            After you resolve this transaction,  Zend_Db_Adapter 
            returns to auto-commit mode until you call
             beginTransaction()  again.
         Managing a transaction to ensure consistency &lt;?php
// Start a transaction explicitly.
$db-&gt;beginTransaction();

try {
    // Attempt to execute one or more queries:
    $db-&gt;query(...);
    $db-&gt;query(...);
    $db-&gt;query(...);

    // If all succeed, commit the transaction and all changes
    // are committed at once.
    $db-&gt;commit();

} catch (Exception $e) {
    // If any of the queries failed and threw an exception,
    // we want to roll back the whole transaction, reversing
    // changes made in the transaction, even those that succeeded.
    // Thus all changes are committed together, or none are.
    $db-&gt;rollBack();
    echo $e-&gt;getMessage();
}
             Listing and Describing Tables 
            The  listTables()  method returns an array of strings,
            naming all tables in the current database.
         
            The  describeTable()  method returns an associative
            array of metadata about a table.  Specify the name of the table
            as a string in the first argument to this method.  The second
            argument is optional, and names the schema in which the table
            exists.
         
            The keys of the associative array returned are the column names of
            the table.  The value corresponding to each column is also an
            associative array, with the following keys and values:
         Metadata fields returned by describeTable() Key Type Description SCHEMA_NAME (string) Name of the database schema in which this table exists. TABLE_NAME (string) Name of the table to which this column belongs. COLUMN_NAME (string) Name of the column. COLUMN_POSITION (integer) Ordinal position of the column in the table. DATA_TYPE (string) RDBMS name of the datatype of the column. DEFAULT (string) Default value for the column, if any. NULLABLE (boolean) True if the column accepts SQL NULLs, false if the column has a NOT NULL constraint. LENGTH (integer) Length or size of the column as reported by the RDBMS. SCALE (integer) Scale of SQL NUMERIC or DECIMAL type. PRECISION (integer) Precision of SQL NUMERIC or DECIMAL type. UNSIGNED (boolean) True if an integer-based type is reported as UNSIGNED. PRIMARY (boolean) True if the column is part of the primary key of this table. PRIMARY_POSITION (integer) Ordinal position (1-based) of the column in the primary key. IDENTITY (boolean) True if the column uses an auto-generated value. 
            If no table exists matching the table name and optional schema name
            specified, then  describeTable()  returns an empty array.
         Closing a Connection 
            Normally it is not necessary to close a database connection.  PHP
            automatically cleans up all resources and the end of a request.
            Database extensions are designed to close the connection as the
            reference to the resource object is cleaned up.
         
            However, if you have a long-duration PHP script that initiates many
            database connections, you might need to close the connection, to avoid
            exhausting the capacity of your RDBMS server.  You can use the
            Adapter&#39;s  closeConnection()  method to explicitly close
            the underlying database connection.
         Closing a database connection &lt;?php
$db-&gt;closeConnection();
             Does Zend_Db support persistent connections? 
                The usage of persistent connections is not supported
                or encouraged in Zend_Db.
             
                Using persistent connections can cause an excess of idle
                connections on the RDBMS server, which causes more problems
                than any performance gain you might achieve by reducing the
                overhead of making connections.
             
                Database connections have state.  That is, some objects in the
                RDBMS server exist in session scope.  Examples are locks, user
                variables, temporary tables, and information about the most
                recently executed query, such as rows affected, and last
                generated id value.  If you use persistent connections, your
                application could access invalid or privileged data that were
                created in a previous PHP request.
             Running Other Database Statements 
            There might be cases in which you need to access the connection
            object directly, as provided by the PHP database extension.  Some
            of these extensions may offer features that are not surfaced by
            methods of Zend_Db_Adapter_Abstract.
         
            For example, all SQL statements run by Zend_Db are prepared, then
            executed.  However, some database features are incompatible with
            prepared statements.  DDL statements like CREATE and ALTER cannot
            be prepared in MySQL.  Also, SQL statements don&#39;t benefit
            from the  MySQL Query Cache ,
            prior to MySQL 5.1.17.
         
            Most PHP database extensions provide a method to execute SQL
            statements without preparing them.  For example, in PDO, this
            method is  exec() .  You can access the connection
            object in the PHP extension directly using getConnection().
         Running a non-prepared statement in a PDO adapter &lt;?php
$result = $db-&gt;getConnection()-&gt;exec(&#39;DROP TABLE bugs&#39;);
             
            Similarly, you can access other methods or properties that are
            specific to PHP database extensions.  Be aware, though, that by
            doing this you might constrain your application to the interface
            provided by the extension for a specific brand of RDBMS.
         
            In future versions of Zend_Db, there will be opportunities to
            add method entry points for functionality that is common to
            the supported PHP database extensions.  This will not affect
            backward compatibility.
         Notes on Specific Adapters 
            This section lists differences between the Adapter classes of which
            you should be aware.
         IBM DB2 
                        Specify this Adapter to the factory() method with the
                        name &#39;Db2&#39;.
                     
                        This Adapter uses the PHP extension ibm_db2.
                     
                        IBM DB2 supports both sequences and auto-incrementing
                        keys.  Therefore the arguments to
                         lastInsertId()  are optional.  If you give
                        no arguments, the Adapter returns the last value
                        generated for an auto-increment key.  If you give
                        arguments, the Adapter returns the last value generated
                        by the sequence named according to the convention
                        &#39; table _ column _seq&#39;.
                     MySQLi 
                        Specify this Adapter to the  factory() 
                        method with the name &#39;Mysqli&#39;.
                     
                        This Adapter utilizes the PHP extension mysqli.
                     
                        MySQL does not support sequences, so
                         lastInsertId()  ignores its arguments and
                        always returns the last value generated for an
                        auto-increment key.  The  lastSequenceId() 
                        method returns  null .
                     Oracle 
                        Specify this Adapter to the  factory() 
                        method with the name &#39;Oracle&#39;.
                     
                        This Adapter uses the PHP extension oci8.
                     
                        Oracle does not support auto-incrementing keys, so you
                        should specify the name of a sequence to
                         lastInsertId()  or
                         lastSequenceId() .
                     
                        The Oracle extension does not support positional
                        parameters.  You must use named parameters.
                     
                        Currently the  Zend_Db::CASE_FOLDING  option
                        is not supported by the Oracle adapter. To use this
                        option with Oracle, you must use the PDO OCI adapter.
                     PDO for IBM DB2 and Informix Dynamic Server (IDS) 
                        Specify this Adapter to the  factory() 
                        method with the name &#39;Pdo_Ibm&#39;.
                     
                        This Adapter uses the PHP extensions pdo and pdo_ibm.
                     
                        You must use at least PDO_IBM extension version 1.2.2.
                        If you have an earlier version of this extension, you
                        must upgrade the PDO_IBM extension from PECL.
                     PDO Microsoft SQL Server 
                        Specify this Adapter to the  factory() 
                        method with the name &#39;Pdo_Mssql&#39;.
                     
                        This Adapter uses the PHP extensions pdo and pdo_mssql.
                     
                        Microsoft SQL Server does not support sequences, so
                         lastInsertId()  ignores its arguments and
                        always returns the last value generated for an
                        auto-increment key.  The  lastSequenceId() 
                        method returns  null .
                     
                        Zend_Db_Adapter_Pdo_Mssql sets  QUOTED_IDENTIFIER ON 
                        immediately after connecting to a SQL Server database.
                        This makes the driver use the standard SQL identifier
                        delimiter symbol ( &quot; ) instead of the
                        proprietary square-brackets syntax SQL Server uses for
                        delimiting identifiers.
                     
                        You can specify  pdoType  as a key in the
                        options array.  The value can be &quot;mssql&quot; (the default),
                        &quot;dblib&quot;, &quot;freetds&quot;, or &quot;sybase&quot;.  This option affects
                        the DSN prefix the adapter uses when constructing the
                        DSN string.  Both &quot;freetds&quot; and &quot;sybase&quot; imply a prefix
                        of &quot;sybase:&quot;, which is used for the
                         FreeTDS  set
                        of libraries.
                        See also
                         
                        http://www.php.net/manual/en/ref.pdo-dblib.connection.php 
                        for more information on the DSN prefixes used in this driver.
                     PDO MySQL 
                        Specify this Adapter to the  factory() 
                        method with the name &#39;Pdo_Mysql&#39;.
                     
                        This Adapter uses the PHP extensions pdo and pdo_mysql.
                     
                        MySQL does not support sequences, so
                         lastInsertId()  ignores its arguments and
                        always returns the last value generated for an
                        auto-increment key.  The  lastSequenceId() 
                        method returns  null .
                     PDO Oracle 
                        Specify this Adapter to the  factory() 
                        method with the name &#39;Pdo_Oci&#39;.
                     
                        This Adapter uses the PHP extensions pdo and pdo_oci.
                     
                        Oracle does not support auto-incrementing keys, so you
                        should specify the name of a sequence to
                         lastInsertId()  or
                         lastSequenceId() .
                     PDO PostgreSQL 
                        Specify this Adapter to the  factory() 
                        method with the name &#39;Pdo_Pgsql&#39;.
                     
                        This Adapter uses the PHP extensions pdo and pdo_pgsql.
                     
                        PostgreSQL supports both sequences and auto-incrementing
                        keys.  Therefore the arguments to
                         lastInsertId()  are optional.  If you give
                        no arguments, the Adapter returns the last value
                        generated for an auto-increment key.  If you give
                        arguments, the Adapter returns the last value generated
                        by the sequence named according to the convention
                        &#39; table _ column _seq&#39;.
                     PDO SQLite 
                        Specify this Adapter to the  factory() 
                        method with the name &#39;Pdo_Sqlite&#39;.
                     
                        This Adapter uses the PHP extensions pdo and pdo_sqlite.
                     
                        SQLite does not support sequences, so
                         lastInsertId()  ignores its arguments and
                        always returns the last value generated for an
                        auto-increment key.  The  lastSequenceId() 
                        method returns  null .
                     
                        To connect to an SQLite2 database, specify
                         &#39;dsnprefix&#39;=&gt;&#39;sqlite2&#39;  in the array of
                        parameters when creating an instance of the
                        Pdo_Sqlite Adapter.
                     
                        To connect to an in-memory SQLite database,
                        specify  &#39;dbname&#39;=&gt;&#39;:memory:&#39;  in the
                        array of parameters when creating an instance of
                        the Pdo_Sqlite Adapter.
                     
                        Older versions of the SQLite driver for PHP do not seem
                        to support the PRAGMA commands necessary to ensure that
                        short column names are used in result sets.  If you
                        have problems that your result sets are returned with
                        keys of the form &quot;tablename.columnname&quot; when you do a
                        join query, then you should upgrade to the current
                        version of PHP.
                     Firebird/Interbase 
                        This Adapter uses the PHP extension php_interbase.
                     
                        Firebird/interbase does not support auto-incrementing keys,
                        so you should specify the name of a sequence to
                         lastInsertId()  or
                         lastSequenceId() .
                     
                        Currently the  Zend_Db::CASE_FOLDING  option
                        is not supported by the Firebird/interbase adapter.
                        Unquoted identifiers are automaticaly returned in
                        upper case.
                     Zend_Db_Profiler Introduction Zend_Db_Profiler  can be enabled to allow profiling of
            queries. Profiles include the queries processed by the adapter as
            well as elapsed time to run the queries, allowing inspection of the
            queries that have been performed without needing to add extra
            debugging code to classes. Advanced usage also allows the
            developer to filter which queries are profiled.
         
            Enable the profiler by either passing a directive to the adapter
            constructor, or by asking the adapter to enable it later.
         &lt;?php
require_once &#39;Zend/Db.php&#39;;

$params = array(
    &#39;host&#39;     =&gt; &#39;127.0.0.1&#39;,
    &#39;username&#39; =&gt; &#39;webuser&#39;,
    &#39;password&#39; =&gt; &#39;xxxxxxxx&#39;,
    &#39;dbname&#39;   =&gt; &#39;test&#39;
    &#39;profiler&#39; =&gt; true  // turn on profiler; set to false to disable (default)
);

$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $params);

// turn off profiler:
$db-&gt;getProfiler()-&gt;setEnabled(false);

// turn on profiler:
$db-&gt;getProfiler()-&gt;setEnabled(true);
         
            The value of the &#39; profiler &#39; option is flexible. It is interpreted differently depending on its
            type.  Most often, you should use a simple boolean value, but other types enable you to customize the
            profiler behavior.
         
            A boolean argument sets the profiler to enabled if it is a  true  value, or disabled if
             false .  The profiler class is the adapter&#39;s default profiler class,
             Zend_Db_Profiler .
             
$params[&#39;profiler&#39;] = true;
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $params);
             
         
            An instance of a profiler object makes the adapter use that object.  The object type must be
             Zend_Db_Profiler  or a subclass thereof. Enabling the profiler is done separately.
             
$profiler = MyProject_Db_Profiler();
$profiler-&gt;setEnabled(true);
$params[&#39;profiler&#39;] = $profiler;
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $params);
             
         
            The argument can be an associative array containing any or all of the keys &#39; enabled &#39;,
            &#39; instance &#39;, and &#39; class &#39;. The &#39; enabled &#39; and &#39; instance &#39;
            keys correspond to the boolean and instance types documented above. The &#39; class &#39; key is used
            to name a class to use for a custom profiler. The class must be  Zend_Db_Profiler  or a
            subclass. The class is instantiated with no constructor arguments. The &#39; class &#39; option is
            ignored when the &#39; instance &#39; option is supplied.
             
$params[&#39;profiler&#39;] = array(
    &#39;enabled&#39; =&gt; true,
    &#39;class&#39;   =&gt; &#39;MyProject_Db_Profiler&#39;
);
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $params);
             
         
            Finally, the argument can be an object of type  Zend_Config  containing properties, which are treated as the array keys described above.  For example, a file &quot;config.ini&quot; might contain the following data:
             
[main]
db.profiler.class   = &quot;MyProject_Db_Profiler&quot;
db.profiler.enabled = true
             

            This configuration can be applied by the following PHP code:

             
$config = new Zend_Config_Ini(&#39;config.ini&#39;, &#39;main&#39;);
$params[&#39;profiler&#39;] = $config-&gt;db-&gt;profiler;
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $params);
             

            The &#39; instance &#39; property may be used as in the following:
             
$profiler = new MyProject_Db_Profiler();
$profiler-&gt;setEnabled(true);
$configData = array(
    &#39;instance&#39; =&gt; $profiler
    );
$config = new Zend_Config($configData);
$params[&#39;profiler&#39;] = $config;
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $params);
             

         Using the Profiler 
            At any point, grab the profiler using the adapter&#39;s
             getProfiler()  method:
         &lt;?php
$profiler = $db-&gt;getProfiler();
         
            This returns a  Zend_Db_Profiler  object instance. With
            that instance, the developer can examine your queries using a
            variety of methods:
         getTotalNumQueries()  returns the total number
                    of queries that have been profiled.
                 getTotalElapsedSecs()  returns the total
                    number of seconds elapsed for all profiled queries.
                 getQueryProfiles()  returns an array of all
                    query profiles.
                 getLastQueryProfile()  returns the last (most
                    recent) query profile, regardless of whether or not the query
                    has finished (if it hasn&#39;t, the end time will be null)
                 clear()  clears any past query profiles
                    from the stack.
                 
            The return value of  getLastQueryProfile()  and the
            individual elements of  getQueryProfiles()  are
             Zend_Db_Profiler_Query  objects, which provide the
            ability to inspect the individual queries themselves:
         getQuery()  returns the SQL text of the query.
                    The SQL text of a prepared statement with parameters is the
                    text at the time the query was prepared, so it contains
                    parameter placeholders, not the values used when the
                    statement is executed.
                 getQueryParams()  returns an array of
                    parameter values used when executing a prepared query.
                    This includes both bound parameters and arguments to the
                    statement&#39;s  execute()  method.  The keys of
                    the array are the positional (1-based) or named (string)
                    parameter indices.
                 getElapsedSecs()  returns the number of
                    seconds the query ran.
                 
            The information  Zend_Db_Profiler  provides is useful for
            profiling bottlenecks in applications, and for debugging queries
            that have been run. For instance, to see the exact query that was
            last run:
         &lt;?php
$query = $profiler-&gt;getLastQueryProfile();

echo $query-&gt;getQuery();
         
            Perhaps a page is generating slowly; use the profiler to determine
            first the total number of seconds of all queries, and then step
            through the queries to find the one that ran longest:
         &lt;?php
$totalTime    = $profiler-&gt;getTotalElapsedSecs();
$queryCount   = $profiler-&gt;getTotalNumQueries();
$longestTime  = 0;
$longestQuery = null;

foreach ($profiler-&gt;getQueryProfiles() as $query) {
    if ($query-&gt;getElapsedSecs() &gt; $longestTime) {
        $longestTime  = $query-&gt;getElapsedSecs();
        $longestQuery = $query-&gt;getQuery();
    }
}

echo &#39;Executed &#39; . $queryCount . &#39; queries in &#39; . $totalTime . &#39; seconds&#39; . &quot;\n&quot;;
echo &#39;Average query length: &#39; . $totalTime / $queryCount . &#39; seconds&#39; . &quot;\n&quot;;
echo &#39;Queries per second: &#39; . $queryCount / $totalTime . &quot;\n&quot;;
echo &#39;Longest query length: &#39; . $longestTime . &quot;\n&quot;;
echo &quot;Longest query: \n&quot; . $longestQuery . &quot;\n&quot;;
         Advanced Profiler Usage 
            In addition to query inspection, the profiler also allows the
            developer to filter which queries get profiled. The following
            methods operate on a  Zend_Db_Profiler  instance:
         Filter by query elapsed time setFilterElapsedSecs()  allows the developer to set
                a minimum query time before a query is profiled. To remove the
                filter, pass the method a null value.
             &lt;?php
// Only profile queries that take at least 5 seconds:
$profiler-&gt;setFilterElapsedSecs(5);

// Profile all queries regardless of length:
$profiler-&gt;setFilterElapsedSecs(null);
             Filter by query type setFilterQueryType()  allows the developer to set
                which types of queries should be profiled; to profile multiple
                types, logical OR them. Query types are defined as the following
                 Zend_Db_Profiler  constants:
             Zend_Db_Profiler::CONNECT : connection
                        operations, or selecting a database.
                     Zend_Db_Profiler::QUERY : general database
                        queries that do not match other types.
                     Zend_Db_Profiler::INSERT : any query that
                        adds new data to the database, generally SQL INSERT.
                     Zend_Db_Profiler::UPDATE : any query that
                        updates existing data, usually SQL UPDATE.
                     Zend_Db_Profiler::DELETE : any query that
                        deletes existing data, usually SQL DELETE.
                     Zend_Db_Profiler::SELECT : any query that
                        retrieves existing data, usually SQL SELECT.
                     Zend_Db_Profiler::TRANSACTION : any
                        transactional operation, such as start transaction, commit,
                        or rollback.
                     
                As with  setFilterElapsedSecs() , you can remove any
                existing filters by passing  null  as the sole
                argument.
             &lt;?php
// profile only SELECT queries
$profiler-&gt;setFilterQueryType(Zend_Db_Profiler::SELECT);

// profile SELECT, INSERT, and UPDATE queries
$profiler-&gt;setFilterQueryType(Zend_Db_Profiler::SELECT | Zend_Db_Profiler::INSERT | Zend_Db_Profiler::UPDATE);

// profile DELETE queries (so we can figure out why data keeps disappearing)
$profiler-&gt;setFilterQueryType(Zend_Db_Profiler::DELETE);

// Remove all filters
$profiler-&gt;setFilterQueryType(null);
             Retrieve profiles by query type 
                Using  setFilterQueryType()  can cut down on the
                profiles generated. However, sometimes it can be more useful to
                keep all profiles, but view only those you need at a given
                moment. Another feature of  getQueryProfiles()  is
                that it can do this filtering on-the-fly, by passing a query
                type (or logical combination of query types) as its first
                argument; see  
                for a list of the query type constants.
             &lt;?php
// Retrieve only SELECT query profiles
$profiles = $profiler-&gt;getQueryProfiles(Zend_Db_Profiler::SELECT);

// Retrieve only SELECT, INSERT, and UPDATE query profiles
$profiles = $profiler-&gt;getQueryProfiles(Zend_Db_Profiler::SELECT | Zend_Db_Profiler::INSERT | Zend_Db_Profiler::UPDATE);

// Retrieve DELETE query profiles (so we can figure out why data keeps
// disappearing)
$profiles = $profiler-&gt;getQueryProfiles(Zend_Db_Profiler::DELETE);
             Zend_Db_Select Overview of the Select Object 
            The Zend_Db_Select object represents a SQL  SELECT  query statement. The
            class has methods for adding individual parts to the query. You can specify some
            parts of the query using PHP methods and data structures, and the class forms the
            correct SQL syntax for you. After you build a query, you can execute the query as if
            you had written it as a string.
         
            The value offered by Zend_Db_Select includes:
         
                    Object-oriented methods for specifying SQL queries in a piece-by-piece manner;
                 
                    Database-independent abstraction of some parts of the SQL query;
                 
                    Automatic quoting of metadata identifiers in most cases, to support identifiers
                    containing SQL reserved words and special characters;
                 
                    Quoting identifiers and values, to help reduce risk of SQL injection attacks.
                 
            Using Zend_Db_Select is not mandatory. For very simple SELECT queries, it is usually
            simpler to specify the entire SQL query as a string and execute it using Adapter
            methods like  query()  or  fetchAll() . Using Zend_Db_Select is
            helpful if you need to assemble a SELECT query procedurally, or based on conditional
            logic in your application.
         Creating a Select Object 
            You can create an instance of a Zend_Db_Select object using the  select() 
            method of a Zend_Db_Adapter_Abstract object.
         Example of the database adapter&#39;s select() method &lt;?php
$db = Zend_Db::factory( ...options... );
$select = $db-&gt;select();
             
            Another way to create a Zend_Db_Select object is with its constructor, specifying the
            database adapter as an argument.
         Example of creating a new Select object &lt;?php
$db = Zend_Db::factory( ...options... );
$select = new Zend_Db_Select($db);
             Building Select queries 
            When building the query, you can add clauses of the query one by one. There is a
            separate method to add each clause to the Zend_Db_Select object.
         Example of the using methods to add clauses &lt;?php
// Create the Zend_Db_Select object
$select = $db-&gt;select();

// Add a FROM clause
$select-&gt;from( ...specify table and columns... )

// Add a WHERE clause
$select-&gt;where( ...specify search criteria... )

// Add an ORDER BY clause
$select-&gt;order( ...specify sorting criteria... );
             
            You also can use most methods of the Zend_Db_Select object with a convenient fluent
            interface. A fluent interface means that each method returns a reference to the object
            on which it was called, so you can immediately call another method.
         Example of the using the fluent interface &lt;?php
$select = $db-&gt;select()
    -&gt;from( ...specify table and columns... )
    -&gt;where( ...specify search criteria... )
    -&gt;order( ...specify sorting criteria... );
             
            The examples in this section show usage of the fluent interface, but you can use the
            non-fluent interface in all cases. It is often necessary to use the non-fluent
            interface, for example, if your application needs to perform some logic before adding a
            clause to a query.
         Adding a FROM clause 
                Specify the table for this query using the  from()  method. You can
                specify the table name as a simple string. Zend_Db_Select applies identifier
                quoting around the table name, so you can use special characters.
             Example of the from() method &lt;?php
// Build this query:
//   SELECT *
//   FROM &quot;products&quot;

$select = $db-&gt;select()
    -&gt;from( &#39;products&#39; );
                 
                You can also specify the correlation name (sometimes called the &quot;table alias&quot;) for
                a table. Instead of a simple string, use an associative array mapping the
                correlation name to the table name. In other clauses of the SQL query, use this
                correlation name. If your query joins more than one table, Zend_Db_Select generates
                unique correlation names based on the table names, for any tables for which you
                don&#39;t specify the correlation name.
             Example of specifying a table correlation name &lt;?php
// Build this query:
//   SELECT p.*
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from( array(&#39;p&#39; =&gt; &#39;products&#39;) );
                 
                Some RDBMS brands support a leading schema specifier for a table. You can specify
                the table name as &quot; schemaName.tableName &quot;, where Zend_Db_Select quotes
                each part individually, or you may specify the schema name separately. A schema
                name specified in the table name takes precedence over a schema provided separately
                in the event that both are provided.
             Example of specifying a schema name &lt;?php
// Build this query:
//   SELECT *
//   FROM &quot;myschema&quot;.&quot;products&quot;

$select = $db-&gt;select()
    -&gt;from( &#39;myschema.products&#39; );

// or

$select = $db-&gt;select()
    -&gt;from(&#39;products&#39;, &#39;*&#39;, &#39;myschema&#39;);
                 Adding Columns 
                In the second argument of the  from()  method, you can specify the
                columns to select from the respective table. If you specify no columns, the default
                is &quot; * &quot;, the SQL wildcard for &quot;all columns&quot;.
             
                You can list the columns in a simple array of strings, or as an associative mapping
                of column alias to column name. If you only have one column to query, and you don&#39;t
                need to specify a column alias, you can list it as a plain string instead of an
                array.
             
                If you give an empty array as the columns argument, no columns from the respective
                table are included in the result set. See a
                 code example 
                under the section on the  join()  method.
             
                You can specify the column name as &quot; correlationName.columnName &quot;.
                Zend_Db_Select quotes each part individually. If you don&#39;t specify a correlation
                name for a column, it uses the correlation name for the table named in the current
                 from()  method.
             Examples of specifying columns &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;, &#39;product_name&#39;));

// Build the same query, specifying correlation names:
//   SELECT p.&quot;product_id&quot;, p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;p.product_id&#39;, &#39;p.product_name&#39;));

// Build this query with an alias for one column:
//   SELECT p.&quot;product_id&quot; AS prodno, p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;prodno&#39; =&gt; &#39;product_id&#39;, &#39;product_name&#39;));
                 Adding Expression Columns 
                Columns in SQL queries are sometimes expressions, not simply column names from a
                table. Expressions should not have correlation names or quoting applied. If your
                column string contains parentheses, Zend_Db_Select recognizes it as an expression.
             
                You also can create an object of type Zend_Db_Expr explicitly, to prevent a string
                from being treated as a column name. Zend_Db_Expr is a minimal class that contains
                a single string. Zend_Db_Select recognizes objects of type Zend_Db_Expr and
                converts them back to string, but does not apply any alterations, such as quoting
                or correlation names.
             
                    Using Zend_Db_Expr for column names is not necessary if your column expression
                    contains parentheses; Zend_Db_Select recognizes parentheses and treats the
                    string as an expression, skipping quoting and correlation names.
                 Examples of specifying columns containing expressions &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, LOWER(product_name)
//   FROM &quot;products&quot; AS p
// An expression with parentheses implicitly becomes
// a Zend_Db_Expr.

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;, &#39;LOWER(product_name)&#39;));

// Build this query:
//   SELECT p.&quot;product_id&quot;, (p.cost * 1.08) AS cost_plus_tax
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;, &#39;cost_plus_tax&#39; =&gt; &#39;(p.cost * 1.08)&#39;));

// Build this query using Zend_Db_Expr explicitly:
//   SELECT p.&quot;product_id&quot;, p.cost * 1.08 AS cost_plus_tax
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;, &#39;cost_plus_tax&#39; =&gt; new Zend_Db_Expr(&#39;p.cost * 1.08&#39;)));
                 
                In the cases above, Zend_Db_Select does not alter the string to apply correlation
                names or identifier quoting. If those changes are necessary to resolve ambiguity,
                you must make the changes manually in the string.
             
                If your column names are SQL keywords or contain special characters, you should use
                the Adapter&#39;s  quoteIdentifier()  method and interpolate the result into
                the string. The  quoteIdentifier()  method uses SQL quoting to delimit
                the identifier, which makes it clear that it is an identifier for a table or a
                column, and not any other part of SQL syntax.
             
                Your code is more database-independent if you use the
                 quoteIdentifier()  method instead of typing quotes literally in your
                string, because some RDBMS brands use nonstandard symbols for quoting identifiers.
                The  quoteIdentifier()  method is designed to use the appropriate
                quoting symbols based on the adapter type. The  quoteIdentifier() 
                method also escapes any quote characters that appear within the identifier name
                itself.
             Examples of quoting columns in an expression &lt;?php
// Build this query, quoting a special column name &quot;from&quot; in the expression:
//   SELECT p.&quot;from&quot; + 10 AS origin
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;origin&#39; =&gt; &#39;(p.&#39; . $db-&gt;quoteIdentifier(&#39;from&#39;) . &#39; + 10)&#39;));
                 Adding columns to an existing FROM or JOIN table 
                There may be cases where you wish to add columns to an existing FROM or JOIN table
                after those methods have been called. The  columns()  method allows you
                to add specific columns at any point before the query is executed. You can supply
                the columns as either a string or  Zend_Db_Expr  or as an array of these
                elements. The second argument to this method can be omitted, implying that the
                columns are to be added to the FROM table, otherwise an existing correlation name
                must be used.
             Examples of adding columns with the  columns()  method &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;), &#39;product_id&#39;)
    -&gt;columns(&#39;product_name&#39;);

// Build the same query, specifying correlation names:
//   SELECT p.&quot;product_id&quot;, p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;), &#39;p.product_id&#39;)
    -&gt;columns(&#39;product_name&#39;, &#39;p&#39;); // Alternatively use columns(&#39;p.product_name&#39;)
                 Adding Another Table to the Query with JOIN 
                Many useful queries involve using a  JOIN  to combine rows from multiple
                tables. You can add tables to a Zend_Db_Select query using the  join() 
                method. Using this method is similar to the  from()  method, except you
                can also specify a join condition in most cases.
             Example of the join() method &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, p.&quot;product_name&quot;, l.*
//   FROM &quot;products&quot; AS p JOIN &quot;line_items&quot; AS l
//     ON p.product_id = l.product_id

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;, &#39;product_name&#39;))
    -&gt;join(array(&#39;l&#39; =&gt; &#39;line_items&#39;),
        &#39;p.product_id = l.product_id&#39;);
                 
                The second argument to  join()  is a string that is the join condition.
                This is an expression that declares the criteria by which rows in one table match
                rows in the the other table. You can use correlation names in this expression.
             
                    No quoting is applied to the expression you specify for the join condition; if
                    you have column names that need to be quoted, you must use
                     quoteIdentifier()  as you form the string for the join condition.
                 
                The third argument to  join()  is an array of column names, like that
                used in the  from()  method. It defaults to &quot; * &quot;, supports
                correlation names, expressions, and Zend_Db_Expr in the same way as the array of
                column names in the  from()  method.
             
                To select no columns from a table, use an empty array for the list of columns. This
                usage works in the  from()  method too, but typically you want some
                columns from the primary table in your queries, whereas you might want no columns
                from a joined table.
             Example of specifying no columns &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p JOIN &quot;line_items&quot; AS l
//     ON p.product_id = l.product_id

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;, &#39;product_name&#39;))
    -&gt;join(array(&#39;l&#39; =&gt; &#39;line_items&#39;),
        &#39;p.product_id = l.product_id&#39;,
        array() ); // empty list of columns
                 
                    Note the empty  array()  in the above example in place of a list of
                    columns from the joined table.
                 
                SQL has several types of joins. See the list below for the methods to support
                different join types in Zend_Db_Select.
             INNER JOIN  with the
                         join(table, join, [columns])  or
                         joinInner(table, join, [columns])  methods.
                     
                        This may be the most common type of join. Rows from each table are compared
                        using the join condition you specify. The result set includes only the rows
                        that satisfy the join condition. The result set can be empty if no rows
                        satisfy this condition.
                     
                        All RDBMS brands support this join type.
                     LEFT JOIN  with the
                         joinLeft(table, condition, [columns])  method.
                     
                        All rows from the left operand table are included, matching rows from the
                        right operand table included, and the columns from the right operand table
                        are filled with NULLs if no row exists matching the left table.
                     
                        All RDBMS brands support this join type.
                     RIGHT JOIN  with the
                         joinRight(table, condition, [columns])  method.
                     
                        Right outer join is the complement of left outer join. All rows from the
                        right operand table are included, matching rows from the left operand table
                        included, and the columns from the left operand table are filled with NULLs
                        if no row exists matching the right table.
                     
                        Some RDBMS brands don&#39;t support this join type, but in general any right
                        join can be represented as a left join by reversing the order of the
                        tables.
                     FULL JOIN  with the
                         joinFull(table, condition, [columns])  method.
                     
                        A full outer join is like combining a left outer join and a right outer
                        join. All rows from both tables are included, paired with each other on the
                        same row of the result set if they satisfy the join condition, and
                        otherwise paired with NULLs in place of columns from the other table.
                     
                        Some RDBMS brands don&#39;t support this join type.
                     CROSS JOIN  with the
                         joinCross(table, [columns])  method.
                     
                        A cross join is a Cartesian product. Every row in the first table is
                        matched to every row in the second table. Therefore the number of rows in
                        the result set is equal to the product of the number of rows in each table.
                        You can filter the result set using conditions in a WHERE clause; in this
                        way a cross join is similar to the old SQL-89 join syntax.
                     
                        The  joinCross()  method has no parameter to specify the join
                        condition. Some RDBMS brands don&#39;t support this join type.
                     NATURAL JOIN  with the
                         joinNatural(table, [columns])  method.
                     
                        A natural join compares any column(s) that appear with the same name in
                        both tables. The comparison is equality of all the column(s); comparing the
                        columns using inequality is not a natural join. Only natural inner joins
                        are supported by this API, even though SQL permits natural outer joins as
                        well.
                     
                        The  joinNatural()  method has no parameter to specify the join
                        condition.
                     
                In addition to these join methods, you can simplify your queries by using the
                JoinUsing methods. Instead of supplying a full condition to your join, you simply
                pass the column name on which to join and the Zend_Db_Select object completes the
                condition for you.
             Example of the joinUsing() method &lt;?php
// Build this query:
//   SELECT *
//   FROM &quot;table1&quot;
//   JOIN &quot;table2&quot;
//   ON &quot;table1&quot;.column1 = &quot;table2&quot;.column1
//   WHERE column2 = &#39;foo&#39;

$select = $db-&gt;select()
    -&gt;from(&#39;table1&#39;)
    -&gt;joinUsing(&#39;table2&#39;, &#39;column1&#39;)
    -&gt;where(&#39;column2 = ?&#39;, &#39;foo&#39;);
                 
                Each of the applicable join methods in the Zend_Db_Select component has a
                corresponding &#39;using&#39; method.
             joinUsing(table, join, [columns])  and
                         joinInnerUsing(table, join, [columns]) 
                     joinLeftUsing(table, join, [columns]) joinRightUsing(table, join, [columns]) joinFullUsing(table, join, [columns]) Adding a WHERE Clause 
                You can specify criteria for restricting rows of the result set using the
                 where()  method. The first argument of this method is a SQL expression,
                and this expression is used in a SQL  WHERE  clause in the query.
             Example of the where() method &lt;?php
// Build this query:
//   SELECT product_id, product_name, price
//   FROM &quot;products&quot;
//   WHERE price &gt; 100.00

$select = $db-&gt;select()
    -&gt;from(
        &#39;products&#39;,
        array(&#39;product_id&#39;, &#39;product_name&#39;, &#39;price&#39;))
    -&gt;where(&#39;price &gt; 100.00&#39;);
                 
                    No quoting is applied to expressions given to the  where()  or
                     orWhere()  methods. If you have column names that need to be
                    quoted, you must use  quoteIdentifier()  as you form the string for
                    the condition.
                 
                The second argument to the  where()  method is optional. It is a value
                to substitute into the expression. Zend_Db_Select quotes the value and substitutes
                it for a question-mark (&quot; ? &quot;) symbol in the expression.
             
                This method accepts only one parameter. If you have an expression into which you
                need to substitute multiple variables, you must format the string manually,
                interpolating variables and performing quoting yourself.
             Example of a parameter in the where() method &lt;?php
// Build this query:
//   SELECT product_id, product_name, price
//   FROM &quot;products&quot;
//   WHERE (price &gt; 100.00)

$minimumPrice = 100;

$select = $db-&gt;select()
    -&gt;from(
        &#39;products&#39;,
        array(&#39;product_id&#39;, &#39;product_name&#39;, &#39;price&#39;))
    -&gt;where(&#39;price &gt; ?&#39;, $minimumPrice);
                 
                You can invoke the  where()  method multiple times on the same
                Zend_Db_Select object. The resulting query combines the multiple terms together
                using  AND  between them.
             Example of multiple where() methods &lt;?php
// Build this query:
//   SELECT product_id, product_name, price
//   FROM &quot;products&quot;
//   WHERE (price &gt; 100.00)
//     AND (price &lt; 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db-&gt;select()
    -&gt;from(&#39;products&#39;,
        array(&#39;product_id&#39;, &#39;product_name&#39;, &#39;price&#39;))
    -&gt;where(&#39;price &gt; ?&#39;, $minimumPrice)
    -&gt;where(&#39;price &lt; ?&#39;, $maximumPrice);
                 
                If you need to combine terms together using  OR , use the
                 orWhere()  method. This method is used in the same way as the
                 where()  method, except that the term specified is preceded by
                 OR , instead of  AND .
             Example of the orWhere() method &lt;?php
// Build this query:
//   SELECT product_id, product_name, price
//   FROM &quot;products&quot;
//   WHERE (price &lt; 100.00)
//     OR (price &gt; 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db-&gt;select()
    -&gt;from(&#39;products&#39;,
        array(&#39;product_id&#39;, &#39;product_name&#39;, &#39;price&#39;))
    -&gt;where(&#39;price &lt; ?&#39;, $minimumPrice)
    -&gt;orWhere(&#39;price &gt; ?&#39;, $maximumPrice);
                 
                Zend_Db_Select automatically puts parentheses around each expression you specify
                using the  where()  or  orWhere()  methods. This helps to
                ensure that Boolean operator precedence does not cause unexpected results.
             Example of parenthesizing Boolean expressions &lt;?php
// Build this query:
//   SELECT product_id, product_name, price
//   FROM &quot;products&quot;
//   WHERE (price &lt; 100.00 OR price &gt; 500.00)
//     AND (product_name = &#39;Apple&#39;)

$minimumPrice = 100;
$maximumPrice = 500;
$prod = &#39;Apple&#39;;

$select = $db-&gt;select()
    -&gt;from(&#39;products&#39;,
        array(&#39;product_id&#39;, &#39;product_name&#39;, &#39;price&#39;))
    -&gt;where(&quot;price &lt; $minimumPrice OR price &gt; $maximumPrice&quot;)
    -&gt;where(&#39;product_name = ?&#39;, $prod);
                 
                In the example above, the results would be quite different without the parentheses,
                because  AND  has higher precedence than  OR . Zend_Db_Select
                applies the parentheses so the effect is that each expression in successive calls
                to the  where()  bind more tightly than the  AND  that
                combines the expressions.
             Adding a GROUP BY Clause 
                In SQL, the  GROUP BY  clause allows you to reduce the rows of a query
                result set to one row per unique value found in the column(s) named in the
                 GROUP BY  clause.
             
                In Zend_Db_Select, you can specify the column(s) to use for calculating the groups
                of rows using the  group()  method. The argument to this method is a
                column or an array of columns to use in the  GROUP BY  clause.
             Example of the group() method &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, COUNT(*) AS line_items_per_product
//   FROM &quot;products&quot; AS p JOIN &quot;line_items&quot; AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;))
    -&gt;join(array(&#39;l&#39; =&gt; &#39;line_items&#39;),
        &#39;p.product_id = l.product_id&#39;,
        array(&#39;line_items_per_product&#39; =&gt; &#39;COUNT(*)&#39;))
    -&gt;group(&#39;p.product_id&#39;);
                 
                Like the columns array in the  from()  method, you can use correlation
                names in the column name strings, and the column is quoted as an identifier unless
                the string contains parentheses or is an object of type Zend_Db_Expr.
             Adding a HAVING Clause 
                In SQL, the  HAVING  clause applies a restriction condition on groups of
                rows. This is similar to how a  WHERE  clause applies a restriction
                condition on rows. But the two clauses are different because  WHERE 
                conditions are applied before groups are defined, whereas  HAVING 
                conditions are applied after groups are defined.
             
                In Zend_Db_Select, you can specify conditions for restricting groups using the
                 having()  method. Its usage is similar to that of the
                 where()  method. The first argument is a string containing a SQL
                expression. The optional second argument is a value that is used to replace a
                positional parameter placeholder in the SQL expression. Expressions given in
                multiple invocations of the  having()  method are combined using the
                Boolean  AND  operator, or the  OR  operator if you use the
                 orHaving()  method.
             Example of the having() method &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, COUNT(*) AS line_items_per_product
//   FROM &quot;products&quot; AS p JOIN &quot;line_items&quot; AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   HAVING line_items_per_product &gt; 10

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;))
    -&gt;join(array(&#39;l&#39; =&gt; &#39;line_items&#39;),
        &#39;p.product_id = l.product_id&#39;,
        array(&#39;line_items_per_product&#39; =&gt; &#39;COUNT(*)&#39;))
    -&gt;group(&#39;p.product_id&#39;)
    -&gt;having(&#39;line_items_per_product &gt; 10&#39;);
                 
                    No quoting is applied to expressions given to the  having()  or
                     orHaving()  methods. If you have column names that need to be
                    quoted, you must use  quoteIdentifier()  as you form the string for
                    the condition.
                 Adding an ORDER BY Clause 
                In SQL, the  ORDER BY  clause specifies one or more columns or
                expressions by which the result set of a query is sorted. If multiple columns are
                listed, the secondary columns are used to resolve ties; the sort order is
                determined by the secondary columns if the preceding columns contain identical
                values. The default sorting is from least value to greatest value. You can also
                sort by greatest value to least value for a given column in the list by specifying
                the keyword  DESC  after that column.
             
                In Zend_Db_Select, you can use the  order()  method to specify a column
                or an array of columns by which to sort. Each element of the array is a string
                naming a column. optionally with the  ASC   DESC  keyword
                following it, separated by a space.
             
                Like in the  from()  and  group()  methods, column names are
                quoted as identifiers, unless they contain contain parentheses or are an object of
                type Zend_Db_Expr.
             Example of the order() method &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, COUNT(*) AS line_items_per_product
//   FROM &quot;products&quot; AS p JOIN &quot;line_items&quot; AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   ORDER BY &quot;line_items_per_product&quot; DESC, &quot;product_id&quot;

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;),
        array(&#39;product_id&#39;))
    -&gt;join(array(&#39;l&#39; =&gt; &#39;line_items&#39;),
        &#39;p.product_id = l.product_id&#39;,
        array(&#39;line_items_per_product&#39; =&gt; &#39;COUNT(*)&#39;))
    -&gt;group(&#39;p.product_id&#39;)
    -&gt;order(array(&#39;line_items_per_product DESC&#39;, &#39;product_id&#39;));
                 Adding a LIMIT Clause 
                Some RDBMS brands extend SQL with a query clause known as the  LIMIT 
                clause. This clause reduces the number of rows in the result set to at most a
                number you specify. You can also specify to skip a number of rows before starting
                to output. This feature makes it easy to take a subset of a result set, for example
                when displaying query results on progressive pages of output.
             
                In Zend_Db_Select, you can use the  limit()  method to specify the count
                of rows and the number of rows to skip. The first argument to this method is the
                desired count of rows. The second argument is the number of rows to skip.
             Example of the limit() method &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p
//   LIMIT 10, 20

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;), array(&#39;product_id&#39;, &#39;product_name&#39;))
    -&gt;limit(10, 20);
                 
                    The  LIMIT  syntax is not supported by all RDBMS brands. Some RDBMS
                    require different syntax to support similar functionality. Each
                    Zend_Db_Adapter_Abstract class includes a method to produce SQL appropriate for
                    that RDBMS.
                 
                Use the  limitPage()  method for an alternative way to specify row count
                and offset. This method allows you to limit the result set to one of a series of
                fixed-length subsets of rows from the query&#39;s total result set. In other words, you
                specify the length of a &quot;page&quot; of results, and the ordinal number of the single
                page of results you want the query to return. The page number is the first argument
                of the  limitPage()  method, and the page length is the second argument.
                Both arguments are required; they have no default values.
             Example of the limitPage() method &lt;?php
// Build this query:
//   SELECT p.&quot;product_id&quot;, p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p
//   LIMIT 10, 20

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;), array(&#39;product_id&#39;, &#39;product_name&#39;))
    -&gt;limitPage(2, 10);
                 Adding the DISTINCT Query Modifier 
                The  distinct()  method enables you to add the  DISTINCT 
                keyword to your SQL query.
             Example of the distinct() method &lt;?php
// Build this query:
//   SELECT DISTINCT p.&quot;product_name&quot;
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;distinct()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;), &#39;product_name&#39;);
                 Adding the FOR UPDATE Query Modifier 
                The  forUpdate()  method enables you to add the  FOR UPDATE 
                modifier to your SQL query.
             Example of forUpdate() method &lt;?php
// Build this query:
//   SELECT FOR UPDATE p.*
//   FROM &quot;products&quot; AS p

$select = $db-&gt;select()
    -&gt;forUpdate()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;));
                 Executing Select Queries 
            This section describes how to execute the query represented by a Zend_Db_Select object.
         Executing Select Queries from the Db Adapter 
                You can execute the query represented by the Zend_Db_Select object by passing it as
                the first argument to the  query()  method of a Zend_Db_Adapter_Abstract
                object. Use the Zend_Db_Select objects instead of a string query.
             
                The  query()  method returns an object of type Zend_Db_Statement or
                PDOStatement, depending on the adapter type.
             Example using the Db adapter&#39;s query() method &lt;?php
$select = $db-&gt;select()
  -&gt;from(&#39;products&#39;);

$stmt = $db-&gt;query($select);
$result = $stmt-&gt;fetchAll();
                 Executing Select Queries from the Object 
                As an alternative to using the  query()  method of the adapter object,
                you can use the  query()  method of the Zend_Db_Select object. Both
                methods return an object of type Zend_Db_Statement or PDOStatement, depending on
                the adapter type.
             Example using the Select object&#39;s query method &lt;?php
$select = $db-&gt;select()
    -&gt;from(&#39;products&#39;);

$stmt = $select-&gt;query();
$result = $stmt-&gt;fetchAll();
                 Converting a Select Object to a SQL String 
                If you need access to a string representation of the SQL query corresponding to the
                Zend_Db_Select object, use the  __toString()  method.
             Example of the __toString() method &lt;?php
$select = $db-&gt;select()
    -&gt;from(&#39;products&#39;);

$sql = $select-&gt;__toString();
echo &quot;$sql\n&quot;;

// The output is the string:
//   SELECT * FROM &quot;products&quot;
                 Other methods 
            This section describes other methods of the Zend_Db_Select class that are not covered
            above:  getPart()  and  reset() .
         Retrieving Parts of the Select Object 
                The  getPart()  method returns a representation of one part of your SQL
                query. For example, you can use this method to return the array of expressions for
                the  WHERE  clause, or the array of columns (or column expressions) that
                are in the  SELECT  list, or the values of the count and offset for the
                 LIMIT  clause.
             
                The return value is not a string containing a fragment of SQL syntax. The return
                value is an internal representation, which is typically an array structure
                containing values and expressions. Each part of the query has a different
                structure.
             
                The single argument to the  getPart()  method is a string that
                identifies which part of the Select query to return. For example, the string
                 &#39;from&#39;  identifies the part of the Select object that stores
                information about the tables in the  FROM  clause, including joined
                tables.
             
                The Zend_Db_Select class defines constants you can use for parts of the SQL query.
                You can use these constant definitions, or you can the literal strings.
             Constants used by getPart() and reset() Constant String value Zend_Db_Select::DISTINCT &#39;distinct&#39; Zend_Db_Select::FOR_UPDATE &#39;forupdate&#39; Zend_Db_Select::COLUMNS &#39;columns&#39; Zend_Db_Select::FROM &#39;from&#39; Zend_Db_Select::WHERE &#39;where&#39; Zend_Db_Select::GROUP &#39;group&#39; Zend_Db_Select::HAVING &#39;having&#39; Zend_Db_Select::ORDER &#39;order&#39; Zend_Db_Select::LIMIT_COUNT &#39;limitcount&#39; Zend_Db_Select::LIMIT_OFFSET &#39;limitoffset&#39; Example of the getPart() method &lt;?php
$select = $db-&gt;select()
    -&gt;from(&#39;products&#39;)
    -&gt;order(&#39;product_id&#39;);

// You can use a string literal to specify the part
$orderData = $select-&gt;getPart( &#39;order&#39; );

// You can use a constant to specify the same part
$orderData = $select-&gt;getPart( Zend_Db_Select::ORDER );

// The return value may be an array structure, not a string.
// Each part has a different structure.
print_r( $orderData );
                 Resetting Parts of the Select Object 
                The  reset()  method enables you to clear one specified part of the SQL
                query, or else clear all parts of the SQL query if you omit the argument.
             
                The single argument is optional. You can specify the part of the query to clear,
                using the same strings you used in the argument to the  getPart() 
                method. The part of the query you specify is reset to a default state.
             
                If you omit the parameter,  reset()  changes all parts of the query to
                their default state. This makes the Zend_Db_Select object equivalent to a new
                object, as though you had just instantiated it.
             Example of the reset() method &lt;?php
// Build this query:
//   SELECT p.*
//   FROM &quot;products&quot; AS p
//   ORDER BY &quot;product_name&quot;

$select = $db-&gt;select()
    -&gt;from(array(&#39;p&#39; =&gt; &#39;products&#39;)
    -&gt;order(&#39;product_name&#39;);

// Changed requirement, instead order by a different columns:
//   SELECT p.*
//   FROM &quot;products&quot; AS p
//   ORDER BY &quot;product_id&quot;

// Clear one part so we can redefine it
$select-&gt;reset( Zend_Db_Select::ORDER );

// And specify a different column
$select-&gt;order(&#39;product_id&#39;);

// Clear all parts of the query
$select-&gt;reset();
                 Zend_Db_Statement 
        In addition to convenient methods such as  fetchAll()  and
         insert()  documented in  ,
        you can use a statement object to gain more options for running
        queries and fetching result sets.  This section describes how to get an
        instance of a statement object, and how to use its methods.
     
        Zend_Db_Statement is based on the PDOStatement object in the
         PHP Data Objects  extension.
     Creating a Statement 
            Typically, a statement object is returned by the
             query()  method of the database Adapter class.
            This method is a general way to prepare any SQL statement.
            The first argument is a string containing an SQL statement.
            The optional second argument is an array of values to bind
            to parameter placeholders in the SQL string.
         Creating a SQL statement object with query() &lt;?php
$stmt = $db-&gt;query(&#39;SELECT * FROM bugs WHERE reported_by = ? AND bug_status = ?&#39;,
                array(&#39;goofy&#39;, &#39;FIXED&#39;));
             
            The statement object corresponds to a SQL statement that has been
            prepared, and executed once with the bind-values specified.
            If the statement was a SELECT query or other type of statement
            that returns a result set, it is now ready to fetch results.
         
            You can create a statement with its contructor, but this is less
            typical usage.  There is no factory method to create this object,
            so you need to load the specific statement class and call its
            constructor.  Pass the Adapter object as the first argument, and
            a string containing an SQL statement as the second argument.
            The statement is prepared, but not executed.
         Using a SQL statement constructor &lt;?php
require_once &#39;Zend/Db/Statement/Mysqli.php&#39;;

$sql = &#39;SELECT * FROM bugs WHERE reported_by = ? AND bug_status = ?&#39;;

$stmt = new Zend_Db_Statement_Mysqli($db, $sql);
             Executing a Statement 
            You need to execute a statement object if you create it using its
            constructor, or if you want to execute the same statement multiple
            times.  Use the  execute()  method of the statement
            object.  The single argument is an array of value to bind to
            parameter placeholders in the statement.
         
            If you use  positional parameters , or those
            that are marked with a question mark symbol ( ? ), pass
            the bind values in a plain array.
         Executing a statement with positional parameters &lt;?php
$sql = &#39;SELECT * FROM bugs WHERE reported_by = ? AND bug_status = ?&#39;;

$stmt = new Zend_Db_Statement_Mysqli($db, $sql);

$stmt-&gt;execute(array(&#39;goofy&#39;, &#39;FIXED&#39;));
             
            If you use  named parameters , or those that are
            indicated by a string identifier preceded by a colon character
            ( : ), pass the bind values in an associative array.
            The keys of this array should match the parameter names.
         Executing a statement with named parameters &lt;?php
$sql = &#39;SELECT * FROM bugs WHERE reported_by = :reporter AND bug_status = :status&#39;;

$stmt = new Zend_Db_Statement_Mysqli($db, $sql);

$stmt-&gt;execute(array(&#39;:reporter&#39; =&gt; &#39;goofy&#39;, &#39;:status&#39; =&gt; &#39;FIXED&#39;));
             
            PDO statements support both positional parameters and named
            parameters, but not both types in a single SQL statement.  Some of
            the Zend_Db_Statement classes for non-PDO extensions may support
            only one type of parameter or the other.
         Fetching Results from a  SELECT  Statement 
            You can call methods on the statement object to retrieve rows from
            SQL statements that produce result set.  SELECT, SHOW, DESCRIBE and
            EXPLAIN are examples of statements that produce a result set.
            INSERT, UPDATE, and DELETE are examples of statements that don&#39;t
            produce a result set.  You can execute the latter SQL statements
            using Zend_Db_Statement, but you cannot call methods to fetch rows
            of results from them.
         Fetching a Single Row from a Result Set 
                To retrieve one row from the result set, use the
                 fetch()  method of the statement object.
                All three arguments of this method are optional:
             Fetch style  is the
                        first argument.  This controls the structure in which
                        the row is returned.
                        See  
                        for a description of the valid values and the
                        corresponding data formats.
                     Cursor orientation 
                        is the second argument.  The default is
                        Zend_Db::FETCH_ORI_NEXT, which simply means that each
                        call to  fetch()  returns the next row in
                        the result set, in the order returned by the RDBMS.
                     Offset  is the third
                        argument.
                        If the cursor orientation is Zend_Db::FETCH_ORI_ABS,
                        then the offset number is the ordinal number of the row
                        to return.
                        If the cursor orientation is Zend_Db::FETCH_ORI_REL,
                        then the offset number is relative to the cursor
                        position before  fetch()  was called.
                     fetch()  returns  false  if all rows of
                the result set have been fetched.
             Using fetch() in a loop &lt;?php
$stmt = $db-&gt;query(&#39;SELECT * FROM bugs&#39;);

while ($row = $stmt-&gt;fetch()) {
    echo $row[&#39;bug_description&#39;];
}
                 
                See also  PDOStatement::fetch() .
             Fetching a Complete Result Set 
                To retrieve all the rows of the result set in one step, use the
                 fetchAll()  method.  This is equivalent to calling
                the  fetch()  method in a loop and returning all
                the rows in an array.  The  fetchAll()  method accepts
                two arguments.  The first is the fetch style, as described above,
                and the second indicates the number of the column to return,
                when the fetch style is Zend_Db::FETCH_COLUMN.
             Using fetchAll() &lt;?php
$stmt = $db-&gt;query(&#39;SELECT * FROM bugs&#39;);

$rows = $stmt-&gt;fetchAll();

echo $rows[0][&#39;bug_description&#39;];
                 
                See also  PDOStatement::fetchAll() .
             Changing the Fetch Mode 
                By default, the statement object returns rows of the result set
                as associative arrays, mapping column names to column values.
                You can specify a different format for the statement class to
                return rows, just as you can in the Adapter class.  You can use
                the  setFetchMode()  method of the statement object
                to specify the fetch mode.  Specify the fetch mode using
                Zend_Db class constants FETCH_ASSOC, FETCH_NUM, FETCH_BOTH,
                FETCH_COLUMN, and FETCH_OBJ.
                See  
                for more information on these modes.
                Subsequent calls to the statement methods  fetch() 
                or  fetchAll()  use the fetch mode that you specify.
             Setting the fetch mode &lt;?php
$stmt = $db-&gt;query(&#39;SELECT * FROM bugs&#39;);

$stmt-&gt;setFetchMode(Zend_Db::FETCH_NUM);

$rows = $stmt-&gt;fetchAll();

echo $rows[0][0];
                 
                See also  PDOStatement::setFetchMode() .
             Fetching a Single Column from a Result Set 
                To return a single column from the next row of the result set,
                use  fetchColumn() .  The optional argument is the
                integer index of the column, and it defaults to 0.  This method
                returns a scalar value, or  false  if all rows of
                the result set have been fetched.
             
                Note this method operates differently than the
                 fetchCol()  method of the Adapter class.
                The  fetchColumn()  method of a statement returns a
                single value from one row.
                The  fetchCol()  method of an adapter returns an
                array of values, taken from the first column of all rows of the
                result set.
             Using fetchColumn() &lt;?php
$stmt = $db-&gt;query(&#39;SELECT bug_id, bug_description, bug_status FROM bugs&#39;);

$bug_status = $stmt-&gt;fetchColumn(2);
                 
                See also  PDOStatement::fetchColumn() .
             Fetching a Row as an Object 
                To retrieve a row from the result set structured as an object,
                use the  fetchObject() .  This method takes two
                optional arguments.  The first argument is a string that names
                the class name of the object to return; the default is
                &#39;stdClass&#39;.  The second argument is an array of values that
                will be passed to the constructor of that class.
             Using fetchObject() &lt;?php
$stmt = $db-&gt;query(&#39;SELECT bug_id, bug_description, bug_status FROM bugs&#39;);

$obj = $stmt-&gt;fetchObject();

echo $obj-&gt;bug_description;
                 
                See also  PDOStatement::fetchObject() .
             Zend_Db_Table Relationships Introduction 
            Tables have relationships to each other in a relational database. An entity in one
            table can be linked to one or more entities in another table by using referential
            integrity constraints defined in the database schema.
         
            The Zend_Db_Table_Row class has methods for querying related rows in other tables.
         Defining Relationships 
            Define classes for each of your tables, extending the abstract class
            Zend_Db_Table_Abstract, as described in  . Also
            see   for a description of the
            example database for which the following example code is designed.
         
            Below are the PHP class definitions for these tables:
         &lt;?php
class Accounts extends Zend_Db_Table_Abstract
{
    protected $_name            = &#39;accounts&#39;;
    protected $_dependentTables = array(&#39;Bugs&#39;);
}

class Products extends Zend_Db_Table_Abstract
{
    protected $_name            = &#39;products&#39;;
    protected $_dependentTables = array(&#39;BugsProducts&#39;);
}

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name            = &#39;bugs&#39;;

    protected $_dependentTables = array(&#39;BugsProducts&#39;);

    protected $_referenceMap    = array(
        &#39;Reporter&#39; =&gt; array(
            &#39;columns&#39;           =&gt; &#39;reported_by&#39;,
            &#39;refTableClass&#39;     =&gt; &#39;Accounts&#39;,
            &#39;refColumns&#39;        =&gt; &#39;account_name&#39;
        ),
        &#39;Engineer&#39; =&gt; array(
            &#39;columns&#39;           =&gt; &#39;assigned_to&#39;,
            &#39;refTableClass&#39;     =&gt; &#39;Accounts&#39;,
            &#39;refColumns&#39;        =&gt; &#39;account_name&#39;
        ),
        &#39;Verifier&#39; =&gt; array(
            &#39;columns&#39;           =&gt; array(&#39;verified_by&#39;),
            &#39;refTableClass&#39;     =&gt; &#39;Accounts&#39;,
            &#39;refColumns&#39;        =&gt; array(&#39;account_name&#39;)
        )
    );
}

class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs_products&#39;;

    protected $_referenceMap    = array(
        &#39;Bug&#39; =&gt; array(
            &#39;columns&#39;           =&gt; array(&#39;bug_id&#39;),
            &#39;refTableClass&#39;     =&gt; &#39;Bugs&#39;,
            &#39;refColumns&#39;        =&gt; array(&#39;bug_id&#39;)
        ),
        &#39;Product&#39; =&gt; array(
            &#39;columns&#39;           =&gt; array(&#39;product_id&#39;),
            &#39;refTableClass&#39;     =&gt; &#39;Products&#39;,
            &#39;refColumns&#39;        =&gt; array(&#39;product_id&#39;)
        )
    );

}
         
            If you use Zend_Db_Table to emulate cascading UPDATE and DELETE operations, declare the
             $_dependentTables  array in the class for the parent table. List the class
            name for each dependent table. Use the class name, not the physical name of the SQL
            table.
         
                Skip declaration of  $_dependentTables  if you use referential integrity
                constraints in the RDBMS server to implement cascading operations. See
                  for more information.
             
            Declare the  $_referenceMap  array in the class for each dependent table.
            This is an associative array of reference &quot;rules&quot;. A reference rule identifies which
            table is the parent table in the relationship, and also lists which columns in the
            dependent table reference which columns in the parent table.
         
            The rule key is a string used as an index to the  $_referenceMap  array.
            This rule key is used to identify each reference relationship. Choose a descriptive
            name for this rule key. It&#39;s best to use a string that can be part of a PHP method
            name, as you will see later.
         
            In the example PHP code above, the rule keys in the Bugs table class are:
             &#39;Reporter&#39; ,  &#39;Engineer&#39; ,  &#39;Verifier&#39; , and
             &#39;Product&#39; .
         
            The value of each rule entry in the  $_referenceMap  array is also an
            associative array. The elements of this rule entry are described below:
         columns  =&gt; A string or an array of strings
                    naming the foreign key column name(s) in the dependent table.
                 
                    It&#39;s common for this to be a single column, but some tables have multi-column
                    keys.
                 refTableClass  =&gt; The class name of the
                    parent table. Use the class name, not the physical name of the SQL table.
                 
                    It&#39;s common for a dependent table to have only one reference to its parent
                    table, but some tables have multiple references to the same parent table. In
                    the example database, there is one reference from the  bugs  table
                    to the  products  table, but three references from the
                     bugs  table to the  accounts  table. Put each reference
                    in a separate entry in the  $_referenceMap  array.
                 refColumns  =&gt; A string or an array of
                    strings naming the primary key column name(s) in the parent table.
                 
                    It&#39;s common for this to be a single column, but some tables have multi-column
                    keys. If the reference uses a multi-column key, the order of columns in the
                     &#39;columns&#39;  entry must match the order of columns in the
                     &#39;refColumns&#39;  entry.
                 
                    It is optional to specify this element. If you don&#39;t specify the
                     refColumns , the column(s) reported as the primary key columns of
                    the parent table are used by default.
                 onDelete  =&gt; The rule for an action to
                    execute if a row is deleted in the parent table. See
                      for more information.
                 onUpdate  =&gt; The rule for an action to
                    execute if values in primary key columns are updated in the parent table. See
                      for more information.
                 Fetching a Dependent Rowset 
            If you have a Row object as the result of a query on a parent table, you can fetch rows
            from dependent tables that reference the current row. Use the method:
         &lt;
$row-&gt;findDependentRowset($table, [$rule]);
         
            This method returns a Zend_Db_Table_Rowset_Abstract object, containing a set of rows
            from the dependent table  $table  that refer to the row identified by the
             $row  object.
         
            The first argument  $table  can be a string that specifies the dependent
            table by its class name. You can also specify the dependent table by using an object of
            that table class.
         Fetching a Dependent Rowset 
                This example shows getting a Row object from the table  Accounts , and
                finding the  Bugs  reported by that account.
             &lt;?php
$accountsTable      = new Accounts();
$accountsRowset     = $accountsTable-&gt;find(1234);
$user1234           = $accountsRowset-&gt;current();

$bugsReportedByUser = $user1234-&gt;findDependentRowset(&#39;Bugs&#39;);
             
            The second argument  $rule  is optional. It is a string that names the rule
            key in the  $_referenceMap  array of the dependent table class. If you don&#39;t
            specify a rule, the first rule in the array that references the parent table is used.
            If you need to use a rule other than the first, you need to specify the key.
         
            In the example code above, the rule key is not specified, so the rule used by default
            is the first one that matches the parent table. This is the rule
             &#39;Reporter&#39; .
         Fetching a Dependent Rowset By a Specific Rule 
                This example shows getting a Row object from the table  Accounts , and
                finding the  Bugs  assigned to be fixed by the user of that account. The
                rule key string that corresponds to this reference relationship in this example is
                 &#39;Engineer&#39; .
             &lt;?php
$accountsTable      = new Accounts();
$accountsRowset     = $accountsTable-&gt;find(1234);
$user1234           = $accountsRowset-&gt;current();

$bugsAssignedToUser = $user1234-&gt;findDependentRowset(&#39;Bugs&#39;, &#39;Engineer&#39;);
             
            You can also add criteria, ordering and limits to your relationships using the parent
            row&#39;s select object.
         Fetching a Dependent Rowset using a Zend_Db_Table_Select 
                    This example shows getting a Row object from the table  Accounts ,
                    and finding the  Bugs  assigned to be fixed by the user of that
                    account, limited only to 3 rows and ordered by name.
                 &lt;?php
$accountsTable      = new Accounts();
$accountsRowset     = $accountsTable-&gt;find(1234);
$user1234           = $accountsRowset-&gt;current();
$select             = $accountsTable-&gt;select()-&gt;order(&#39;name ASC&#39;)
                                              -&gt;limit(3);

$bugsAssignedToUser = $user1234-&gt;findDependentRowset(&#39;Bugs&#39;, &#39;Engineer&#39;, $select);
                 

            Alternatively, you can query rows from a dependent table using a special mechanism
            called a &quot;magic method&quot;. Zend_Db_Table_Row_Abstract invokes the method:
             findDependentRowset(&#39;&lt;TableClass&gt;&#39;, &#39;&lt;Rule&gt;&#39;)  if you invoke a method on
            the Row object matching either of the following patterns:
         $row-&gt;find&lt;TableClass&gt;() $row-&gt;find&lt;TableClass&gt;By&lt;Rule&gt;() 
            In the patterns above,  &lt;TableClass&gt;  and  &lt;Rule&gt;  are strings
            that correspond to the class name of the dependent table, and the dependent table&#39;s
            rule key that references the parent table.
         
                Some application frameworks, such as Ruby on Rails, use a mechanism called
                &quot;inflection&quot; to allow the spelling of identifiers to change depending on usage. For
                simplicity, Zend_Db_Table_Row does not provide any inflection mechanism. The table
                identity and the rule key named in the method call must match the spelling of the
                class and rule key exactly.
             Fetching Dependent Rowsets using the Magic Method 
                This example shows finding dependent Rowsets equivalent to those in the previous
                examples. In this case, the application uses the magic method invocation instead of
                specifying the table and rule as strings.
             &lt;?php
$accountsTable    = new Accounts();
$accountsRowset   = $accountsTable-&gt;find(1234);
$user1234         = $accountsRowset-&gt;current();

// Use the default reference rule
$bugsReportedBy   = $user1234-&gt;findBugs();

// Specify the reference rule
$bugsAssignedTo   = $user1234-&gt;findBugsByEngineer();
             Fetching a Parent Row 
            If you have a Row object as the result of a query on a dependent table, you can fetch
            the row in the parent to which the dependent row refers. Use the method:
         &lt;
$row-&gt;findParentRow($table, [$rule]);
         
            There always should be exactly one row in the parent table referenced by a dependent
            row, therefore this method returns a Row object, not a Rowset object.
         
            The first argument  $table  can be a string that specifies the parent table
            by its class name. You can also specify the parent table by using an object of that
            table class.
         Fetching the Parent Row 
                This example shows getting a Row object from the table  Bugs  (for
                example one of those bugs with status &#39;NEW&#39;), and finding the row in the
                 Accounts  table for the user who reported the bug.
             &lt;?php
$bugsTable         = new Bugs();
$bugsRowset        = $bugsTable-&gt;fetchAll(array(&#39;bug_status = ?&#39; =&gt; &#39;NEW&#39;));
$bug1              = $bugsRowset-&gt;current();

$reporter          = $bug1-&gt;findParentRow(&#39;Accounts&#39;);
             
            The second argument  $rule  is optional. It is a string that names the rule
            key in the  $_referenceMap  array of the dependent table class. If you don&#39;t
            specify a rule, the first rule in the array that references the parent table is used.
            If you need to use a rule other than the first, you need to specify the key.
         
            In the example above, the rule key is not specified, so the rule used by default is the
            first one that matches the parent table. This is the rule  &#39;Reporter&#39; .
         Fetching a Parent Row By a Specific Rule 
                This example shows getting a Row object from the table  Bugs , and
                finding the account for the engineer assigned to fix that bug. The rule key string
                that corresponds to this reference relationship in this example is
                 &#39;Engineer&#39; .
             &lt;?php
$bugsTable         = new Bugs();
$bugsRowset        = $bugsTable-&gt;fetchAll(array(&#39;bug_status = ?&#39;, &#39;NEW&#39;));
$bug1              = $bugsRowset-&gt;current();

$engineer          = $bug1-&gt;findParentRow(&#39;Accounts&#39;, &#39;Engineer&#39;);
             
            Alternatively, you can query rows from a parent table using a &quot;magic method&quot;.
            Zend_Db_Table_Row_Abstract invokes the method:
             findParentRow(&#39;&lt;TableClass&gt;&#39;, &#39;&lt;Rule&gt;&#39;)  if you invoke a method
            on the Row object matching either of the following patterns:
         $row-&gt;findParent&lt;TableClass&gt;([Zend_Db_Table_Select $select]) $row-&gt;findParent&lt;TableClass&gt;By&lt;Rule&gt;([Zend_Db_Table_Select
                    $select]) 
            In the patterns above,  &lt;TableClass&gt;  and  &lt;Rule&gt; 
            are strings that correspond to the class name of the parent table, and the dependent
            table&#39;s rule key that references the parent table.
         
                The table identity and the rule key named in the method call must match the
                spelling of the class and rule key exactly.
             Fetching the Parent Row using the Magic Method 
                This example shows finding parent Rows equivalent to those in the previous
                examples. In this case, the application uses the magic method invocation instead of
                specifying the table and rule as strings.
             &lt;?php
$bugsTable         = new Bugs();
$bugsRowset        = $bugsTable-&gt;fetchAll(array(&#39;bug_status = ?&#39;, &#39;NEW&#39;));
$bug1              = $bugsRowset-&gt;current();

// Use the default reference rule
$reporter          = $bug1-&gt;findParentAccounts();

// Specify the reference rule
$engineer          = $bug1-&gt;findParentAccountsByEngineer();
             Fetching a Rowset via a Many-to-many Relationship 
            If you have a Row object as the result of a query on one table in a many-to-many
            relationship (for purposes of the example, call this the &quot;origin&quot; table), you can
            fetch corresponding rows in the other table (call this the &quot;destination&quot; table) via an
            intersection table. Use the method:
         &lt;
$row-&gt;findManyToManyRowset($table, $intersectionTable, [$rule1, [$rule2, [Zend_Db_Table_Select $select]]]);
         
            This method returns a Zend_Db_Table_Rowset_Abstract containing rows from the table
             $table , satisfying the many-to-many relationship. The current Row object
             $row  from the origin table is used to find rows in the intersection table,
            and that is joined to the destination table.
         
            The first argument  $table  can be a string that specifies the destination
            table in the many-to-many relationship by its class name. You can also specify the
            destination table by using an object of that table class.
         
            The second argument  $intersectionTable  can be a string that specifies the
            intersection table between the two tables in the the many-to-many relationship by its
            class name. You can also specify the intersection table by using an object of that
            table class.
         Fetching a Rowset with the Many-to-many Method 
                This example shows geting a Row object from from the origin table
                 Bugs , and finding rows from the destination table
                 Products , representing products related to that bug.
             &lt;?php
$bugsTable        = new Bugs();
$bugsRowset       = $bugsTable-&gt;find(1234);
$bug1234          = $bugsRowset-&gt;current();

$productsRowset   = $bug1234-&gt;findManyToManyRowset(&#39;Products&#39;, &#39;BugsProducts&#39;);
             
            The third and fourth arguments  $rule1  and  $rule2  are
            optional. These are strings that name the rule keys in the  $_referenceMap 
            array of the intersection table.
         
            The  $rule1  key names the rule for the relationship from the intersection
            table to the origin table. In this example, this is the relationship from
             BugsProducts  to  Bugs .
         
            The  $rule2  key names the rule for the relationship from the intersection
            table to the destination table. In this example, this is the relationship from
             Bugs  to  Products .
         
            Similarly to the methods for finding parent and dependent rows, if you don&#39;t specify a
            rule, the method uses the first rule in the  $_referenceMap  array that
            matches the tables in the relationship. If you need to use a rule other than the first,
            you need to specify the key.
         
            In the example code above, the rule key is not specified, so the rules used by default
            are the first ones that match. In this case,  $rule1  is
             &#39;Reporter&#39;  and  $rule2  is  &#39;Product&#39; .
         Fetching a Rowset with the Many-to-many Method By a Specific Rule 
                This example shows geting a Row object from from the origin table
                 Bugs , and finding rows from the destination table
                 Products , representing products related to that bug.
             &lt;?php
$bugsTable        = new Bugs();
$bugsRowset       = $bugsTable-&gt;find(1234);
$bug1234          = $bugsRowset-&gt;current();

$productsRowset   = $bug1234-&gt;findManyToManyRowset(&#39;Products&#39;, &#39;BugsProducts&#39;, &#39;Bug&#39;);
             
            Alternatively, you can query rows from the destination table in a many-to-many
            relationship using a &quot;magic method.&quot; Zend_Db_Table_Row_Abstract invokes the method:
             findManyToManyRowset(&#39;&lt;TableClass&gt;&#39;, &#39;&lt;IntersectionTableClass&gt;&#39;,
            &#39;&lt;Rule1&gt;&#39;, &#39;&lt;Rule2&gt;&#39;)  if you invoke a method matching any of the
            following patterns:
         $row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;
                    ([Zend_Db_Table_Select $select]) $row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;By&lt;Rule1&gt;
                    ([Zend_Db_Table_Select $select]) $row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;By&lt;Rule1&gt;And&lt;Rule2&gt;
                    ([Zend_Db_Table_Select $select]) 
            In the patterns above,  &lt;TableClass&gt;  and
             &lt;IntersectionTableClass&gt;  are strings that correspond to the class
            names of the destination table and the intersection table, respectively.
             &lt;Rule1&gt;  and  &lt;Rule2&gt;  are strings that correspond
            to the rule keys in the intersection table that reference the origin table and the
            destination table, respectively.
         
                The table identities and the rule keys named in the method call must match the
                spelling of the class and rule key exactly.
             Fetching Rowsets using the Magic Many-to-many Method 
                This example shows finding rows in the destination table of a many-to-many
                relationship representing products related to a given bug.
             &lt;?php
$bugsTable        = new Bugs();
$bugsRowset       = $bugsTable-&gt;find(1234);
$bug1234          = $bugsRowset-&gt;current();

// Use the default reference rule
$products          = $bug1234-&gt;findProductsViaBugsProducts();

// Specify the reference rule
$products          = $bug1234-&gt;findProductsViaBugsProductsByBug();
             Cascading Write Operations Declare DRI in the database: 
                Declaring cascading operations in Zend_Db_Table is intended
                 only  for RDBMS brands that do not support
                declarative referential integrity (DRI).
             
                For example, if you use MySQL&#39;s MyISAM storage engine, or SQLite, these solutions
                do not support DRI. You may find it helpful to declare the cascading operations
                with Zend_Db_Table.
             
                If your RDBMS implements DRI and the  ON DELETE  and
                 ON UPDATE  clauses, you should declare these clauses in your database
                schema, instead of using the cascading feature in Zend_Db_Table. Declaring
                cascading DRI rules in the RDBMS is better for database performance, consistency,
                and integrity.
             
                Most importantly, do not declare cascading operations both in the RDBMS and in your
                Zend_Db_Table class.
             
            You can declare cascading operations to execute against a dependent table when you
            apply an  UPDATE  or a  DELETE  to a row in a parent table.
         Example of a Cascading Delete 
                This example shows deleting a row in the  Products  table, which is
                configured to automatically delete dependent rows in the  Bugs  table.
             &lt;?php
$productsTable  = new Products();
$productsRowset = $productsTable-&gt;find(1234);
$product1234    = $productsRowset-&gt;current();

$product1234-&gt;delete();
// Automatically cascades to Bugs table
// and deletes dependent rows.
             
            Similarly, if you use  UPDATE  to change the value of a primary key in a
            parent table, you may want the value in foreign keys of dependent tables to be updated
            automatically to match the new value, so that such references are kept up to date.
         
            It&#39;s usually not necessary to update the value of a primary key that was generated by a
            sequence or other mechanism. But if you use a  natural key  that may
            change value occasionally, it is more likely that you need to apply cascading updates
            to dependent tables.
         
            To declare a cascading relationship in the Zend_Db_Table, edit the rules in the
             $_referenceMap . Set the associative array keys  &#39;onDelete&#39;  and
             &#39;onUpdate&#39;  to the string &#39;cascade&#39; (or the constant
             self::CASCADE ). Before a row is deleted from the parent table, or its
            primary key values updated, any rows in the dependent table that refer to the parent&#39;s
            row are deleted or updated first.
         Example Declaration of Cascading Operations 
                In the example below, rows in the  Bugs  table are automatically deleted
                if the row in the  Products  table to which they refer is deleted. The
                 &#39;onDelete&#39;  element of the reference map entry is set to
                 self::CASCADE .
             
                No cascading update is done in the example below if the primary key value in the
                parent class is changed. The  &#39;onUpdate&#39;  element of the reference map
                entry is  self::RESTRICT . You can get the same result using the value
                 self::NO_ACTION , or by omitting the  &#39;onUpdate&#39;  entry.
             &lt;?php
class BugsProducts extends Zend_Db_Table_Abstract
{
    ...
    protected $_referenceMap    = array(
        &#39;Product&#39; =&gt; array(
            &#39;columns&#39;           =&gt; array(&#39;product_id&#39;),
            &#39;refTableClass&#39;     =&gt; &#39;Products&#39;,
            &#39;refColumns&#39;        =&gt; array(&#39;product_id&#39;),
            &#39;onDelete&#39;          =&gt; self::CASCADE,
            &#39;onUpdate&#39;          =&gt; self::RESTRICT
        ),
        ...
    );
}
             Notes Regarding Cascading Operations Cascading operations invoked by Zend_Db_Table are not
                atomic. 
                This means that if your database implements and enforces referential integrity
                constraints, a cascading  UPDATE  executed by a Zend_Db_Table class
                conflicts with the constraint, and results in a referential integrity violation.
                You can use cascading  UPDATE  in Zend_Db_Table
                 only  if your database does not enforce that referential
                integrity constraint.
             
                Cascading  DELETE  suffers less from the problem of referential
                integrity violations. You can delete dependent rows as a non-atomic action before
                deleting the parent row that they reference.
             
                However, for both  UPDATE  and  DELETE , changing the
                database in a non-atomic way also creates the risk that another database user can
                see the data in an inconsistent state. For example, if you delete a row and all its
                dependent rows, there is a small chance that another database client program can
                query the database after you have deleted the dependent rows, but before you delete
                the parent row. That client program may see the parent row with no dependent rows,
                and assume this is the intended state of the data. There is no way for that client
                to know that its query read the database in the middle of a change.
             
                The issue of non-atomic change can be mitigated by using transactions to isolate
                your change. But some RDBMS brands don&#39;t support transactions, or allow clients to
                read &quot;dirty&quot; changes that have not been committed yet.
             Cascading operations in Zend_Db_Table are invoked only by
                Zend_Db_Table. 
                Cascading deletes and updates defined in your Zend_Db_Table classes are applied if
                you execute the  save()  or  delete()  methods on the Row
                class. However, if you update or delete data using another interface, such as a
                query tool or another application, the cascading operations are not applied. Even
                when using  update()  and  delete()  methods in the
                Zend_Db_Adapter class, cascading operations defined in your Zend_Db_Table classes
                are not executed.
             No Cascading  INSERT . 
                There is no support for a cascading  INSERT . You must insert a row to a
                parent table in one operation, and insert row(s) to a dependent table in a separate
                operation.
             Zend_Db_Table Introduction to Table Class 
            The Zend_Db_Table class is an object-oriented interface to database tables. It provides
            methods for many common operations on tables. The base class is extensible, so you can
            add custom logic.
         
            The Zend_Db_Table solution is an implementation of the
             Table Data
            Gateway  pattern. The solution also includes a class that implements the
             Row Data
            Gateway  pattern.
         Defining a Table Class 
            For each table in your database that you want to access, define a class that extends
            Zend_Db_Table_Abstract.
         Defining the Table Name and Schema 
                Declare the database table for which this class is defined, using the protected
                variable  $_name . This is a string, and must contain the name of the
                table spelled as it appears in the database.
             Declaring a table class with explicit table name &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;
}
                 
                If you don&#39;t specify the table name, it defaults to the name of the class. If you
                rely on this default, the class name must match the spelling of the table name as
                it appears in the database.
             Declaring a table class with implicit table name &lt;?php
class bugs extends Zend_Db_Table_Abstract
{
    // table name matches class name
}
                 
                You can also declare the schema for the table, either with the protected variable
                 $_schema , or with the schema prepended to the table name in the
                 $_name  property. Any schema specified with the  $_name 
                property takes precedence over a schema specified with the  $_schema 
                property. In some RDBMS brands, the term for schema is &quot;database&quot; or &quot;tablespace,&quot;
                but it is used similarly.
             Declaring a table class with schema &lt;?php
// First alternative:
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_schema = &#39;bug_db&#39;;
    protected $_name   = &#39;bugs&#39;;
}

// Second alternative:
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bug_db.bugs&#39;;
}

// If schemas are specified in both $_name and $_schema, the one
// specified in $_name takes precedence:

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name   = &#39;bug_db.bugs&#39;;
    protected $_schema = &#39;ignored&#39;;
}
                 
                The schema and table names may also be specified via constructor configuration
                directives, which override any default values specified with the
                 $_name  and  $_schema  properties. A schema specification
                given with the  name  directive overrides any value provided with the
                 schema  option.
             Declaring table and schema names upon instantiation &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
}

// First alternative:

$tableBugs = new Bugs(array(&#39;name&#39; =&gt; &#39;bugs&#39;, &#39;schema&#39; =&gt; &#39;bug_db&#39;));

// Second alternative:

$tableBugs = new Bugs(array(&#39;name&#39; =&gt; &#39;bug_db.bugs&#39;);

// If schemas are specified in both &#39;name&#39; and &#39;schema&#39;, the one
// specified in &#39;name&#39; takes precedence:

$tableBugs = new Bugs(array(&#39;name&#39; =&gt; &#39;bug_db.bugs&#39;, &#39;schema&#39; =&gt; &#39;ignored&#39;);
                 
                If you don&#39;t specify the schema name, it defaults to the schema to which your
                database adapter instance is connected.
             Defining the Table Primary Key 
                Every table must have a primary key. You can declare the column for the primary key
                using the protected variable  $_primary . This is either a string that
                names the single column for the primary key, or else it is an array of column names
                if your primary key is a compound key.
             Example of specifying the primary key &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;
    protected $_primary = &#39;bug_id&#39;;
}
                 
                If you don&#39;t specify the primary key, Zend_Db_Table_Abstract tries to discover the
                primary key based on the information provided by the  describeTable() Â´
                method.
             
                    Every table class must know which column(s) can be used to address rows
                    uniquely. If no primary key column(s) are specified in the table class
                    definition or the table constructor arguments, or discovered in the table
                    metadata provided by  describeTable() , then the table cannot be
                    used with Zend_Db_Table.
                 Overriding Table Setup Methods 
                When you create an instance of a Table class, the constructor calls a set of
                protected methods that initialize metadata for the table. You can extend any of
                these methods to define metadata explicitly. Remember to call the method of the
                same name in the parent class at the end of your method.
             Example of overriding the _setupTableName() method &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
    protected function _setupTableName()
    {
        $this-&gt;_name = &#39;bugs&#39;;
        parent::_setupTableName();
    }
}
                 
                The setup methods you can override are the following:
             _setupDatabaseAdapter()  checks that an adapter has been
                        provided; gets a default adapter from the registry if needed. By overriding
                        this method, you can set a database adapter from some other source.
                     _setupTableName()  defaults the table name to the name of the
                        class. By overriding this method, you can set the table name before this
                        default behavior runs.
                     _setupMetadata()  sets the schema if the table name contains
                        the pattern &quot;schema.table&quot;; calls  describeTable()  to get
                        metadata information; defaults the  $_cols  array to the columns
                        reported by  describeTable() . By overriding this method, you
                        can specify the columns.
                     _setupPrimaryKey()  defaults the primary key columns to those
                        reported by  describeTable() ; checks that the primary key
                        columns are included in the  $_cols  array. By overriding this
                        method, you can specify the primary key columns.
                     Table initialization 
                If application-specific logic needs to be initialized when a Table class is
                constructed, you can select to move your tasks to the  init()  method,
                which is called after all Table metadata has been processed. This is recommended
                over the  __construct  method if you do not need to alter the metadata
                in any programmatic way.

                 Example usage of init() method &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_observer;

    protected function init()
    {
        $this-&gt;_observer = new MyObserverClass();
    }
}
                     

             Creating an Instance of a Table 
            Before you use a Table class, create an instance using its constructor. The
            constructor&#39;s argument is an array of options. The most important option to a Table
            constructor is the database adapter instance, representing a live connection to an
            RDBMS. There are three ways of specifying the database adapter to a Table class, and
            these three ways are described below:
         Specifying a Database Adapter 
                The first way to provide a database adapter to a Table class is by passing it as an
                object of type Zend_Db_Adapter_Abstract in the options array, identified by the key
                 &#39;db&#39; .
             Example of constructing a Table using an Adapter object &lt;?php
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $options);

$table = new Bugs(array(&#39;db&#39; =&gt; $db));
                 Setting a Default Database Adapter 
                The second way to provide a database adapter to a Table class is by declaring an
                object of type Zend_Db_Adapter_Abstract to be a default database adapter for all
                subsequent instances of Tables in your application. You can do this with the static
                method  Zend_Db_Table_Abstract::setDefaultAdapter() . The argument is an
                object of type Zend_Db_Adapter_Abstract.
             Example of constructing a Table using a the Default Adapter &lt;?php
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $options);
Zend_Db_Table_Abstract::setDefaultAdapter($db);

// Later...

$table = new Bugs();
                 
                It can be convenient to create the database adapter object in a central place of
                your application, such as the bootstrap, and then store it as the default adapter.
                This gives you a means to ensure that the adapter instance is the same throughout
                your application. However, setting a default adapter is limited to a single adapter
                instance.
             Storing a Database Adapter in the Registry 
                The third way to provide a database adapter to a Table class is by passing a string
                in the options array, also identified by the  &#39;db&#39;  key. The string is
                used as a key to the static Zend_Registry instance, where the entry at that key is
                an object of type Zend_Db_Adapter_Abstract.
             Example of constructing a Table using a Registry key &lt;?php
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $options);
Zend_Registry::set(&#39;my_db&#39;, $db);

// Later...

$table = new Bugs(array(&#39;db&#39; =&gt; &#39;my_db&#39;));
                 
                Like setting the default adapter, this gives you the means to ensure that the same
                adapter instance is used throughout your application. Using the registry is more
                flexible, because you can store more than one adapter instance. A given adapter
                instance is specific to a certain RDBMS brand and database instance. If your
                application needs access to multiple databases or even multiple database brands,
                then you need to use multiple adapters.
             Inserting Rows to a Table 
            You can use the Table object to insert rows into the database table on which the Table
            object is based. Use the  insert()  method of your Table object. The
            argument is an associative array, mapping column names to values.
         Example of inserting to a Table &lt;?php
$table = new Bugs();

$data = array(
    &#39;created_on&#39;      =&gt; &#39;2007-03-22&#39;,
    &#39;bug_description&#39; =&gt; &#39;Something wrong&#39;,
    &#39;bug_status&#39;      =&gt; &#39;NEW&#39;
);

$table-&gt;insert($data);
             
            By default, the values in your data array are inserted as literal values, using
            parameters. If you need them to be treated as SQL expressions, you must make sure they
            are distinct from plain strings. Use an object of type Zend_Db_Expr to do this.
         Example of inserting expressions to a Table &lt;?php
$table = new Bugs();

$data = array(
    &#39;created_on&#39;      =&gt; new Zend_Db_Expr(&#39;CURDATE()&#39;),
    &#39;bug_description&#39; =&gt; &#39;Something wrong&#39;,
    &#39;bug_status&#39;      =&gt; &#39;NEW&#39;
);
             
            In the examples of inserting rows above, it is assumed that the table has an
            auto-incrementing primary key. This is the default behavior of Zend_Db_Table_Abstract,
            but there are other types of primary keys as well. The following sections describe how
            to support different types of primary keys.
         Using a Table with an Auto-incrementing Key 
                An auto-incrementing primary key generates a unique integer value for you if you
                omit the primary key column from your SQL  INSERT  statement.
             
                In Zend_Db_Table_Abstract, if you define the protected variable
                 $_sequence  to be the Boolean value  true , then the class
                assumes that the table has an auto-incrementing primary key.
             Example of declaring a Table with auto-incrementing primary key &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;

    // This is the default in the Zend_Db_Table_Abstract class;
    // you do not need to define this.
    protected $_sequence = true;
}
                 
                MySQL, Microsoft SQL Server, and SQLite are examples of RDBMS brands that support
                auto-incrementing primary keys.
             
                PostgreSQL has a  SERIAL  notation that implicitly defines a sequence
                based on the table and column name, and uses the sequence to generate key values
                for new rows. IBM DB2 has an  IDENTITY  notation that works similarly.
                If you use either of these notations, treat your Zend_Db_Table class as having an
                auto-incrementing column with respect to declaring the  $_sequence 
                member as  true .
             Using a Table with a Sequence 
                A sequence is a database object that generates a unique value, which can be used
                as a primary key value in one or more tables of the database.
             
                If you define  $_sequence  to be a string, then Zend_Db_Table_Abstract
                assumes the string to name a sequence object in the database. The sequence is
                invoked to generate a new value, and this value is used in the  INSERT 
                operation.
             Example of declaring a Table with a sequence &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;

    protected $_sequence = &#39;bug_sequence&#39;;
}
                 
                Oracle, PostgreSQL, and IBM DB2 are examples of RDBMS brands that support sequence
                objects in the database.
             
                PostgreSQL and IBM DB2 also have syntax that defines sequences implicitly and
                associated with columns. If you use this notation, treat the table as having an
                auto-incrementing key column. Define the sequence name as a string only in cases
                where you would invoke the sequence explicitly to get the next key value.
             Using a Table with a Natural Key 
                Some tables have a natural key. This means that the key is not automatically
                generated by the table or by a sequence. You must specify the value for the primary
                key in this case.
             
                If you define the  $_sequence  to be the Boolean value
                 false , then Zend_Db_Table_Abstract assumes that the table has a
                natural primary key. You must provide values for the primary key columns in the
                array of data to the  insert()  method, or else this method throws a
                Zend_Db_Table_Exception.
             Example of declaring a Table with a natural key &lt;?php
class BugStatus extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bug_status&#39;;

    protected $_sequence = false;
}
                 
                    All RDBMS brands support tables with natural keys. Examples of tables that are
                    often declared as having natural keys are lookup tables, intersection tables in
                    many-to-many relationships, or most tables with compound primary keys.
                 Updating Rows in a Table 
            You can update rows in a database table using the  update  method of a Table
            class. This method takes two arguments: an associative array of columns to change and
            new values to assign to these columns; and an SQL expression that is used in a
             WHERE  clause, as criteria for the rows to change in the
             UPDATE  operation.
         Example of updating rows in a Table &lt;?php
$table = new Bugs();

$data = array(
    &#39;updated_on&#39;      =&gt; &#39;2007-03-23&#39;,
    &#39;bug_status&#39;      =&gt; &#39;FIXED&#39;
);

$where = $table-&gt;getAdapter()-&gt;quoteInto(&#39;bug_id = ?&#39;, 1234);

$table-&gt;update($data, $where);
             
            Since the table  update()  method proxies to the database adapter
             update()  method, the
            second argument can be an array of SQL expressions. The expressions are combined as
            Boolean terms using an  AND  operator.
         
                The values and identifiers in the SQL expression are not quoted for you. If you
                have values or identifiers that require quoting, you are responsible for doing
                this. Use the  quote() ,  quoteInto() , and
                 quoteIdentifier()  methods of the database adapter.
             Deleting Rows from a Table 
            You can delete rows from a database table using the  delete()  method. This
            method takes one argument, which is an SQL expression that is used in a
             WHERE  clause, as criteria for the rows to delete.
         Example of deleting rows from a Table &lt;?php
$table = new Bugs();

$where = $table-&gt;getAdapter()-&gt;quoteInto(&#39;bug_id = ?&#39;, 1235);

$table-&gt;delete($where);
             
            The second argument can be an array of SQL expressions. The expressions are combined as
            Boolean terms using an  AND  operator.
         
            Since the table  delete()  method proxies to the database adapter
             delete()  method, the
            second argument can be an array of SQL expressions. The expressions are combined as
            Boolean terms using an  AND  operator.
         
                The values and identifiers in the SQL expression are not quoted for you. If you
                have values or identifiers that require quoting, you are responsible for doing
                this. Use the  quote() ,  quoteInto() , and
                 quoteIdentifier()  methods of the database adapter.
             Finding Rows by Primary Key 
            You can query the database table for rows matching specific values in the primary key,
            using the  find()  method. The first argument of this method is either a
            single value or an array of values to match against the primary key of the table.
         Example of finding rows by primary key values &lt;?php
$table = new Bugs();

// Find a single row
// Returns a Rowset
$rows = $table-&gt;find(1234);

// Find multiple rows
// Also returns a Rowset
$rows = $table-&gt;find(array(1234, 5678));
             
            If you specify a single value, the method returns at most one row, because a primary
            key cannot have duplicate values and there is at most one row in the database table
            matching the value you specify. If you specify multiple values in an array, the method
            returns at most as many rows as the number of distinct values you specify.
         
            The  find()  method might return fewer rows than the number of values you
            specify for the primary key, if some of the values don&#39;t match any rows in the database
            table. The method even may return zero rows. Because the number of rows returned is
            variable, the  find()  method returns an object of type
             Zend_Db_Table_Rowset_Abstract .
         
            If the primary key is a compound key, that is, it consists of multiple columns, you can
            specify the additional columns as additional arguments to the  find() 
            method. You must provide as many arguments as the number of columns in the table&#39;s
            primary key.
         
            To find multiple rows from a table with a compound primary key, provide an array for
            each of the arguments. All of these arrays must have the same number of elements. The
            values in each array are formed into tuples in order; for example, the first element
            in all the array arguments define the first compound primary key value, then the second
            elements of all the arrays define the second compound primary key value, and so on.
         Example of finding rows by compound primary key values 
                The call to  find()  below to match multiple rows can match two rows in
                the database. The first row must have primary key value (1234, &#39;ABC&#39;), and the
                second row must have primary key value (5678, &#39;DEF&#39;).
             &lt;?php
class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs_products&#39;;
    protected $_primary = array(&#39;bug_id&#39;, &#39;product_id&#39;);
}

$table = new BugsProducts();

// Find a single row with a compound primary key
// Returns a Rowset
$rows = $table-&gt;find(1234, &#39;ABC&#39;);

// Find multiple rows with compound primary keys
// Also returns a Rowset
$rows = $table-&gt;find(array(1234, 5678), array(&#39;ABC&#39;, &#39;DEF&#39;));
             Querying for a Set of Rows Select API 
                        The API for fetch operations has been superceded to allow a
                         Zend_Db_Table_Select  object to modify the query. However, the
                        deprecated usage of the  fetchRow()  and  fetchAll() 
                        methods will continue to work without modification.
                     
                        The following statements are all legal and functionally identical, however
                        it is recommended to update your code to take advantage of the new usage
                        where possible.
                     // Fetching a rowset
    $rows = $table-&gt;fetchAll(&#39;bug_status = &quot;NEW&quot;&#39;, &#39;bug_id ASC&#39;, 10, 0);
    $rows = $table-&gt;fetchAll($table-&gt;select()-&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;)
                                             -&gt;order(&#39;bug_id ASC&#39;)
                                             -&gt;limit(10, 0));

    // Fetching a single row
    $row = $table-&gt;fetchRow(&#39;bug_status = &quot;NEW&quot;&#39;, &#39;bug_id ASC&#39;);
    $row = $table-&gt;fetchRow($table-&gt;select()-&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;)
                                            -&gt;order(&#39;bug_id ASC&#39;));
                         
                The  Zend_Db_Table_Select  object is an extension of the
                 Zend_Db_Select  object that applies specific restrictions to
                a query. The enhancements and restrictions are:
             
                        You  can  elect to return a subset of columns within a
                        fetchRow or fetchAll query. This can provide optimization benefits where
                        returning a large set of results for all columns is not desirable.
                     
                        You  can  specify columns that evaluate expressions from
                        within the selected table. However this will mean that the returned row or
                        rowset will be  readOnly  and cannot be used for save()
                        operations. A  Zend_Db_Table_Row  with
                         readOnly  status will throw an exception if a
                         save()  operation is attempted.
                     
                        You  can  allow JOIN clauses on a select to allow
                        multi-table lookups.
                     
                        You  can not  specify columns from a JOINed tabled to be
                        returned in a row/rowset. Doing so will trigger a PHP error. This was done
                        to ensure the integrity of the  Zend_Db_Table is retained . i.e.
                        A  Zend_Db_Table_Row  should only reference columns derived from
                        its parent table.
                     Simple usage &lt;?php
$table = new Bugs();

$select = $table-&gt;select();
$select-&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;);

$rows = $table-&gt;fetchAll($select);
                     
                Fluent interfaces are implemented across the component, so this can be rewritten
                this in a more abbreviated form.
             Example of fluent interface &lt;?php
$table = new Bugs();

$rows = $table-&gt;fetchAll($table-&gt;select()-&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;));
                     Fetching a rowset 
                You can query for a set of rows using any criteria other than the primary key
                values, using the  fetchAll()  method of the Table class. This method
                returns an object of type  Zend_Db_Table_Rowset_Abstract .
             Example of finding rows by an expression &lt;?php
$table = new Bugs();

$select = $table-&gt;select()-&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;);

$rows = $table-&gt;fetchAll($select);
                 
                You may also pass sorting criteria in an  ORDER BY  clause, as well as
                count and offset integer values, used to make the query return a specific subset of
                rows. These values are used in a  LIMIT  clause, or in equivalent logic
                for RDBMS brands that do not support the  LIMIT  syntax.
             Example of finding rows by an expression &lt;?php
$table = new Bugs();

$order  = &#39;bug_id&#39;;

// Return the 21st through 30th rows
$count  = 10;
$offset = 20;

$select = $table-&gt;select()-&gt;where(array(&#39;bug_status = ?&#39; =&gt; &#39;NEW&#39;))
                          -&gt;order($order)
                          -&gt;limit($count, $offset);

$rows = $table-&gt;fetchAll($select);
                 
                All of the arguments above are optional. If you omit the ORDER clause, the result
                set includes rows from the table in an unpredictable order. If no LIMIT clause is
                set, you retrieve every row in the table that matches the WHERE clause.
             Advanced usage 
                For more specific and optimized requests, you may wish to limit the number of
                columns returned in a row/rowset. This can be achieved by passing a FROM clause to
                the select object. The first argument in the FROM clause is identical to that of a
                Zend_Db_Select object with the addition of being able to pass an instance of
                Zend_Db_Table_Abstract and have it automatically determine the table name.
             Retrieving specific columns &lt;?php
$table = new Bugs();

$select = $table-&gt;select();
$select-&gt;from($table, array(&#39;bug_id&#39;, &#39;bug_description&#39;))
       -&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;);

$rows = $table-&gt;fetchAll($select);
                     
                        The rowset contains rows that are still &#39;valid&#39; - they simply contain a
                        subset of the columns of a table. If a save() method is called on a partial
                        row then only the fields available will be modified.
                     

                You can also specify expressions within a FROM clause and have these returned as a
                readOnly row/rowset. In this example we will return a rows from the bugs table that
                show an aggregate of the number of new bugs reported by individuals. Note the GROUP
                clause. The &#39;count&#39; column will be made available to the row for evaluation and can
                be accessed as if it were part of the schema.
             Retrieving expressions as columns &lt;?php
$table = new Bugs();

$select = $table-&gt;select();
$select-&gt;from($table, array(&#39;COUNT(reported_by) as `count`&#39;, &#39;reported_by&#39;))
       -&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;)
       -&gt;group(&#39;reported_by&#39;);

$rows = $table-&gt;fetchAll($select);
                     

                You can also use a lookup as part of your query to further refine your fetch
                operations. In this example the accounts table is queried as part of a search for
                all new bugs reported by &#39;Bob&#39;.
             Using a lookup table to refine the results of fetchAll() &lt;?php
$table = new Bugs();

$select = $table-&gt;select();
$select-&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;)
       -&gt;join(&#39;accounts&#39;, &#39;accounts.account_name = bugs.reported_by&#39;)
       -&gt;where(&#39;accounts.account_name = ?&#39;, &#39;Bob&#39;);

$rows = $table-&gt;fetchAll($select);
                     
                The  Zend_Db_Table_Select  is primarily used to constrain and
                validate so that it may enforce the criteria for a legal SELECT query. However
                there may be certain cases where you require the flexibility of the
                Zend_Db_Table_Row component and do not require a writeable or deletable row. For
                this specific user case, it is possible to retrieve a row/rowset by passing a false
                value to setIntegrityCheck. The resulting row/rowset will be returned as a &#39;locked&#39;
                row (meaning the save(), delete() and any field-setting methods will throw an
                exception).
             Removing the integrity check on Zend_Db_Table_Select to allow JOINed rows &lt;?php
$table = new Bugs();

$select = $table-&gt;select()-&gt;setIntegrityCheck(false);
$select-&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;)
       -&gt;join(&#39;accounts&#39;, &#39;accounts.account_name = bugs.reported_by&#39;, &#39;account_name&#39;)
       -&gt;where(&#39;accounts.account_name = ?&#39;, &#39;Bob&#39;);

$rows = $table-&gt;fetchAll($select);
                 Querying for a Single Row 
            You can query for a single row using criteria similar to that of the
             fetchAll()  method.
         Example of finding a single row by an expression &lt;?php
$table = new Bugs();

$select  = $table-&gt;select()-&gt;where(&#39;bug_status = ?&#39;, &#39;NEW&#39;)
                           -&gt;order(&#39;bug_id&#39;);

$row = $table-&gt;fetchRow($select);
             
            This method returns an object of type Zend_Db_Table_Row_Abstract. If the search
            criteria you specified match no rows in the database table, then
             fetchRow()  returns PHP&#39;s  null  value.
         Retrieving Table Metadata Information 
            The Zend_Db_Table_Abstract class provides some information about its metadata. The
             info()  method returns an array structure with information about the table,
            its columns and primary key, and other metadata.
         Example of getting the table name &lt;?php
$table = new Bugs();

$info = $table-&gt;info();

echo &quot;The table name is &quot; . $info[&#39;name&#39;] . &quot;\n&quot;;
             
            The keys of the array returned by the  info()  method are described below:
         name  =&gt; the name of the table.
                 cols  =&gt; an array, naming the column(s) of
                    the table.
                 primary  =&gt; an array, naming the column(s) in
                    the primary key.
                 metadata  =&gt; an associative array, mapping
                    column names to information about the columns. This is the information returned
                    by the  describeTable()  method.
                 rowClass  =&gt; the name of the concrete class
                    used for Row objects returned by methods of this table instance. This defaults
                    to Zend_Db_Table_Row.
                 rowsetClass  =&gt; the name of the concrete
                    class used for Rowset objects returned by methods of this table instance. This
                    defaults to Zend_Db_Table_Rowset.
                 referenceMap  =&gt; an associative array, with
                    information about references from this table to any parent tables. See
                     .
                 dependentTables  =&gt; an array of class names
                    of tables that reference this table. See
                     .
                 schema  =&gt; the name of the schema (or
                    database or tablespace) for this table.
                 Caching Table Metadata 
            By default,  Zend_Db_Table_Abstract  queries the underlying database for
             table metadata  upon instantiation of a table
            object. That is, when a new table object is created, the object&#39;s default behavior is
            to fetch the table metadata from the database using the adapter&#39;s
             describeTable()  method.
         
            In some circumstances, particularly when many table objects are instantiated against
            the same database table, querying the database for the table metadata for each instance
            may be undesirable from a performance standpoint. In such cases, users may benefit by
            caching the table metadata retrieved from the database.
         
            There are two primary ways in which a user may take advantage of table metadata
            caching:

             Call
                        Zend_Db_Table_Abstract::setDefaultMetadataCache()  - This allows
                        a developer to once set the default cache object to be used for all table
                        classes.
                     Configure
                        Zend_Db_Table_Abstract::__construct()  - This allows a developer
                        to set the cache object to be used for a particular table class instance.
                     

            In both cases, the cache specification must be either  null  (i.e., no cache
            used) or an instance of
             Zend_Cache_Core . The
            methods may be used in conjunction when it is desirable to have both a default metadata
            cache and the ability to change the cache for individual table objects.
         Using a Default Metadata Cache for all Table Objects 
                The following code demonstrates how to set a default metadata cache to be used for
                all table objects:
             &lt;?php
// First, set up the Cache
require_once &#39;Zend/Cache.php&#39;;

$frontendOptions = array(
    &#39;automatic_serialization&#39; =&gt; true
    );

$backendOptions  = array(
    &#39;cache_dir&#39;                =&gt; &#39;cacheDir&#39;
    );

$cache = Zend_Cache::factory(&#39;Core&#39;, &#39;File&#39;, $frontendOptions, $backendOptions);


// Next, set the cache to be used with all table objects
require_once &#39;Zend/Db/Table/Abstract.php&#39;;

Zend_Db_Table_Abstract::setDefaultMetadataCache($cache);


// A table class is also needed
class Bugs extends Zend_Db_Table_Abstract
{
    // ...
}


// Each instance of Bugs now uses the default metadata cache
$bugs = new Bugs();
             Using a Metadata Cache for a Specific Table Object 
                The following code demonstrates how to set a metadata cache for a specific table
                object instance:
             &lt;?php
// First, set up the Cache
require_once &#39;Zend/Cache.php&#39;;

$frontendOptions = array(
    &#39;automatic_serialization&#39; =&gt; true
    );

$backendOptions  = array(
    &#39;cache_dir&#39;                =&gt; &#39;cacheDir&#39;
    );

$cache = Zend_Cache::factory(&#39;Core&#39;, &#39;File&#39;, $frontendOptions, $backendOptions);

// A table class is also needed
require_once &#39;Zend/Db/Table/Abstract.php&#39;;

class Bugs extends Zend_Db_Table_Abstract
{
    // ...
}

// Configure an instance upon instantiation
$bugs = new Bugs(array(&#39;metadataCache&#39; =&gt; $cache));
             Automatic Serialization with the Cache Frontend 
                Since the information returned from the adapter&#39;s describeTable() method is an
                array, ensure that the  automatic_serialization  option is set to
                 true  for the  Zend_Cache_Core  frontend.
             
            Though the above examples use  Zend_Cache_Backend_File , developers may use
            whatever cache backend is appropriate for the situation. Please see
             Zend_Cache  for more information.
         Customizing and Extending a Table Class Using Custom Row or Rowset Classes 
                By default, methods of the Table class return a Rowset in instances of the concrete
                class Zend_Db_Table_Rowset, and Rowsets contain a collection of instances of the
                concrete class Zend_Db_Table_Row. You can specify an alternative class to use for
                either of these, but they must be classes that extend Zend_Db_Table_Rowset_Abstract
                and Zend_Db_Table_Row_Abstract, respectively.
             
                You can specify Row and Rowset classes using the Table constructor&#39;s options array,
                in keys  &#39;rowClass&#39;  and  &#39;rowsetClass&#39;  respectively.
                Specify the names of the classes using strings.
             Example of specifying the Row and Rowset classes &lt;?php
class My_Row extends Zend_Db_Table_Row_Abstract
{
    ...
}

class My_Rowset extends Zend_Db_Table_Rowset_Abstract
{
    ...
}

$table = new Bugs(
    array(
        &#39;rowClass&#39;    =&gt; &#39;My_Row&#39;,
        &#39;rowsetClass&#39; =&gt; &#39;My_Rowset&#39;
    )
);

$where = $table-&gt;getAdapter()-&gt;quoteInto(&#39;bug_status = ?&#39;, &#39;NEW&#39;)

// Returns an object of type My_Rowset,
// containing an array of objects of type My_Row.
$rows = $table-&gt;fetchAll($where);
                 
                You can change the classes by specifying them with the  setRowClass() 
                and  setRowsetClass()  methods. This applies to rows and rowsets created
                subsequently; it does not change the class of any row or rowset objects you have
                created previously.
             Example of changing the Row and Rowset classes &lt;?php
$table = new Bugs();

$where = $table-&gt;getAdapter()-&gt;quoteInto(&#39;bug_status = ?&#39;, &#39;NEW&#39;)

// Returns an object of type Zend_Db_Table_Rowset
// containing an array of objects of type Zend_Db_Table_Row.
$rowsStandard = $table-&gt;fetchAll($where);

$table-&gt;setRowClass(&#39;My_Row&#39;);
$table-&gt;setRowsetClass(&#39;My_Rowset&#39;);

// Returns an object of type My_Rowset,
// containing an array of objects of type My_Row.
$rowsCustom = $table-&gt;fetchAll($where);

// The $rowsStandard object still exists, and it is unchanged.
                 
                For more information on the Row and Rowset classes, see
                  and  .
             Defining Custom Logic for Insert, Update, and Delete 
                You can override the  insert()  and  update()  methods in
                your Table class. This gives you the opportunity to implement custom code that is
                executed before performing the database operation. Be sure to call the parent class
                method when you are done.
             Custom logic to manage timestamps &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;

    public function insert(array $data)
    {
        // add a timestamp
        if (empty($data[&#39;created_on&#39;])) {
            $data[&#39;created_on&#39;] = time();
        }
        return parent::insert($data);
    }

    public function update(array $data, $where)
    {
        // add a timestamp
        if (empty($data[&#39;updated_on&#39;])) {
            $data[&#39;updated_on&#39;] = time();
        }
        return parent::update($data, $where);
    }
}
                 
                You can also override the  delete()  method.
             Define Custom Search Methods in Zend_Db_Table 
                You can implement custom query methods in your Table class, if you have frequent
                need to do queries against this table with specific criteria. Most queries can be
                written using  fetchAll() , but this requires that you duplicate code to
                form the query conditions if you need to run the query in several places in your
                application. Therefore it can be convenient to implement a method in the Table
                class to perform frequently-used queries against this table.
             Custom method to find bugs by status &lt;?php
class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;

    public function findByStatus($status)
    {
        $where = $this-&gt;getAdapter()-&gt;quoteInto(&#39;bug_status = ?&#39;, $status);
        return $this-&gt;fetchAll($where, &#39;bug_id&#39;);
    }
}
                 Define Inflection in Zend_Db_Table 
                Some people prefer that the table class name match a table name in the RDBMS by
                using a string transformation called  inflection .
             
                For example, if your table class name is &quot; BugsProducts &quot;, it would
                match the physical table in the database called &quot; bugs_products ,&quot; if
                you omit the explicit declaration of the  $_name  class property. In
                this inflection mapping, the class name spelled in &quot;CamelCase&quot; format would be
                transformed to lower case, and words are separated with an underscore.
             
                You can specify the database table name independently from the class name by
                declaring the table name with the  $_name  class property in each of
                your table classes.
             
                Zend_Db_Table_Abstract performs no inflection to map the class name to the table
                name. If you omit the declaration of  $_name  in your table class, the
                class maps to a database table that matches the spelling of the class name exactly.
             
                It is inappropriate to transform identifiers from the database, because this can
                lead to ambiguity or make some identifiers inaccessible. Using the SQL identifiers
                exactly as they appear in the database makes Zend_Db_Table_Abstract both simpler
                and more flexible.
             
                If you prefer to use inflection, then you must implement the transformation
                yourself, by overriding the  _setupTableName()  method in your Table
                classes. One way to do this is to define an abstract class that extends
                Zend_Db_Table_Abstract, and then the rest of your tables extend your new abstract
                class.
             Example of an abstract table class that implements inflection &lt;?php
abstract class MyAbstractTable extends Zend_Db_Table_Abstract
{
    protected function _setupTableName()
    {
        if (!$this-&gt;_name) {
            $this-&gt;_name = myCustomInflector(get_class($this));
        }
        parent::_setupTableName();
    }
}

class BugsProducts extends MyAbstractTable
{
}
                 
                You are responsible for writing the functions to perform inflection transformation.
                Zend Framework does not provide such a function.
             Zend_Db_Table_Row Introduction 
            Zend_Db_Table_Row is a class that contains an individual row of a Zend_Db_Table object.
            When you run a query against a Table class, the result is returned in a set of
            Zend_Db_Table_Row objects. You can also use this object to create new rows and add them
            to the database table.
         
            Zend_Db_Table_Row is an implementation of the  Row Data Gateway 
            pattern.
         Fetching a Row 
            Zend_Db_Table_Abstract provides methods  find()  and
             fetchAll() , which each return an object of type Zend_Db_Table_Rowset, and
            the method  fetchRow() , which returns an object of type Zend_Db_Table_Row.
         Example of fetching a row &lt;?php
$bugs = new Bugs();
$row = $bugs-&gt;fetchRow($bugs-&gt;select()-&gt;where(&#39;bug_id = ?&#39;, 1));
             
            A Zend_Db_Table_Rowset object contains a collection of Zend_Db_Table_Row objects. See
             .
         Example of reading a row in a rowset &lt;?php
$bugs = new Bugs();
$rowset = $bugs-&gt;fetchAll($bugs-&gt;select()-&gt;where(&#39;bug_status = ?&#39;, 1));
$row = $rowset-&gt;current();
             Reading column values from a row 
                Zend_Db_Table_Row_Abstract provides accessor methods so you can reference columns
                in the row as object properties.
             Example of reading a column in a row &lt;?php
$bugs = new Bugs();
$row = $bugs-&gt;fetchRow($bugs-&gt;select()-&gt;where(&#39;bug_id = ?&#39;, 1));

// Echo the value of the bug_description column
echo $row-&gt;bug_description;
                 
                    Earlier versions of Zend_Db_Table_Row mapped these column accessors to the
                    database column names using a string transformation called
                     inflection .
                 
                    Currently, Zend_Db_Table_Row does not implement inflection. Accessed property
                    names need to match the spelling of the column names as they appear in your
                    database.
                 Retrieving Row Data as an Array 
                You can access the row&#39;s data as an array using the  toArray()  method
                of the Row object. This returns an associative array of the colum names to the
                column values.
             Example of using the toArray() method &lt;?php
$bugs = new Bugs();
$row = $bugs-&gt;fetchRow($bugs-&gt;select()-&gt;where(&#39;bug_id = ?&#39;, 1));

// Get the column/value associative array from the Row object
$rowArray = $row-&gt;toArray();

// Now use it as a normal array
foreach ($rowArray as $column =&gt; $value) {
    echo &quot;Column: $column\n&quot;;
    echo &quot;Value:  $value\n&quot;;
}
                 
                The array returned from  toArray()  is not updateable. You can modify
                values in the array as you can with any array, but you cannot save changes to this
                array to the database directly.
             Fetching data from related tables 
                The Zend_Db_Table_Row_Abstract class provides methods for fetching rows and rowsets
                from related tables. See   for more
                information on table relationships.
             Writing rows to the database Changing column values in a row 
                You can set individual column values using column accessors, similar to how the
                columns are read as object properties in the example above.
             
                Using a column accessor to set a value changes the column value of the row object
                in your application, but it does not commit the change to the database yet. You can
                do that with the  save()  method.
             Example of changing a column in a row &lt;?php
$bugs = new Bugs();
$row = $bugs-&gt;fetchRow($bugs-&gt;select()-&gt;where(&#39;bug_id = ?&#39;, 1));

// Change the value of one or more columns
$row-&gt;bug_status = &#39;FIXED&#39;;

// UPDATE the row in the database with new values
$row-&gt;save();
                 Inserting a new row 
                You can create a new row for a given table with the  createRow()  method
                of the table class. You can access fields of this row with the object-oriented
                interface, but the row is not stored in the database until you call the
                 save()  method.
             Example of creating a new row for a table &lt;?php
$bugs = new Bugs();
$newRow = $bugs-&gt;createRow();

// Set column values as appropriate for your application
$newRow-&gt;bug_description = &#39;...description...&#39;;
$newRow-&gt;bug_status = &#39;NEW&#39;;

// INSERT the new row to the database
$newRow-&gt;save();
                 
                The optional argument to the createRow() method is an associative array, with which
                you can populate fields of the new row.
             Example of populating a new row for a table &lt;?php
$data = array(
    &#39;bug_description&#39; =&gt; &#39;...description...&#39;,
    &#39;bug_status&#39;      =&gt; &#39;NEW&#39;
);

$bugs = new Bugs();
$newRow = $bugs-&gt;createRow($data);

// INSERT the new row to the database
$newRow-&gt;save();
                 
                    The  createRow()  method was called  fetchNew()  in
                    earlier releases of Zend_Db_Table. You are encouraged to use the new method
                    name, even though the old name continues to work for the sake of backward
                    compatibility.
                 Changing values in multiple columns 
                Zend_Db_Table_Row_Abstract provides the  setFromArray()  method to
                enable you to set several columns in a single row at once, specified in an
                associative array that maps the column names to values. You may find this method
                convenient for setting values both for new rows and for rows you need to update.
             Example of using setFromArray() to set values in a new Row &lt;?php
$bugs = new Bugs();
$newRow = $bugs-&gt;createRow();

// Data are arranged in an associative array
$data = array(
    &#39;bug_description&#39; =&gt; &#39;...description...&#39;,
    &#39;bug_status&#39;      =&gt; &#39;NEW&#39;
);

// Set all the column values at once
$newRow-&gt;setFromArray($data);

// INSERT the new row to the database
$newRow-&gt;save();
                 Deleting a row 
                You can call the  delete()  method on a Row object. This deletes rows in
                the database matching the primary key in the Row object.
             Example of deleting a row &lt;?php
$bugs = new Bugs();
$row = $bugs-&gt;fetchRow(&#39;bug_id = 1&#39;);

// DELETE this row
$row-&gt;delete();
                 
                You do not have to call  save()  to apply the delete; it is executed
                against the database immediately.
             Serializing and unserializing rows 
            It is often convenient to save the contents of a database row to be used later.
             Serialization  is the name for the operation that converts an
            object into a form that is easy to save in offline storage (for example, a file).
            Objects of type Zend_Db_Table_Row_Abstract are serializable.
         Serializing a Row 
                Simply use PHP&#39;s  serialize()  function to create a string containing a
                byte-stream representation of the Row object argument.
             Example of serializing a row &lt;?php
$bugs = new Bugs();
$row = $bugs-&gt;fetchRow(&#39;bug_id = 1&#39;);

// Convert object to serialized form
$serializedRow = serialize($row);

// Now you can write $serializedRow to a file, etc.
                 Unserializing Row Data 
                Use PHP&#39;s  unserialize()  function to restore a string containing a
                byte-stream representation of an object. The function returns the original object.
             
                Note that the Row object returned is in a  disconnected  state.
                You can read the Row object and its properties, but you cannot change values in the
                Row or execute other methods that require a database connection (for example,
                queries against related tables).
             Example of unserializing a serialized row &lt;?php
$rowClone = unserialize($serializedRow);

// Now you can use object properties, but read-only
echo $rowClone-&gt;bug_description;
                 Why do Rows unserialize in a disconnected state? 
                    A serialized object is a string that is readable to anyone who possesses it. It
                    could be a security risk to store parameters such as database account and
                    password in plain, unencrypted text in the serialized string. You would not
                    want to store such data to a text file that is not protected, or send it in an
                    email or other medium that is easily read by potential attackers. The reader of
                    the serialized object should not be able to use it to gain access to your
                    database without knowing valid credentials.
                 Reactivating a Row as Live Data 
                You can reactivate a disconnected Row, using the  setTable()  method.
                The argument to this method is a valid object of type Zend_Db_Table_Abstract, which
                you create. Creating a Table object requires a live connection to the database, so
                by reassociating the Table with the Row, the Row gains access to the database.
                Subsequently, you can change values in the Row object and save the changes to the
                database.
             Example of reactivating a row &lt;?php
$rowClone = unserialize($serializedRow);

$bugs = new Bugs();

// Reconnect the row to a table, and
// thus to a live database connection
$rowClone-&gt;setTable($bugs);

// Now you can make changes to the row and save them
$rowClone-&gt;bug_status = &#39;FIXED&#39;;
$rowClone-&gt;save();
                 Extending the Row class 
            Zend_Db_Table_Row is the default concrete class that extends
            Zend_Db_Table_Row_Abstract. You can define your own concrete class for instances of Row
            by extending Zend_Db_Table_Row_Abstract. To use your new Row class to store results of
            Table queries, specify the custom Row class by name either in the
             $_rowClass  protected member of a Table class, or in the array argument of
            the constructor of a Table object.
         Specifying a custom Row class &lt;?php
class MyRow extends Zend_Db_Table_Row_Abstract
{
    // ...customizations
}

// Specify a custom Row to be used by default
// in all instances of a Table class.
class Products extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;products&#39;;
    protected $_rowClass = &#39;MyRow&#39;;
}

// Or specify a custom Row to be used in one
// instance of a Table class.
$bugs = new Bugs(array(&#39;rowClass&#39; =&gt; &#39;MyRow&#39;));
             Row initialization 
                If application-specific logic needs to be initialized when a row is constructed,
                you can select to move your tasks to the  init()  method, which is
                called after all row metadata has been processed. This is recommended over the
                 __construct  method if you do not need to alter the metadata in any
                programmatic way.

                 Example usage of init() method &lt;?php
class MyApplicationRow extends Zend_Db_Table_Row_Abstract
{
    protected $_role;

    protected function init()
    {
        $this-&gt;_role = new MyRoleClass();
    }
}
                     

             Defining Custom Logic for Insert, Update, and Delete in Zend_Db_Table_Row 
                The Row class calls protected methods  _insert() ,
                 _update() , and  _delete()  before performing the
                corresponding operations  INSERT ,  UPDATE , and
                 DELETE . You can add logic to these methods in your custom Row
                subclass.
             
                If you need to do custom logic in a specific table, and the custom logic must occur
                for every operation on that table, it may make more sense to implement your custom
                code in the  insert() ,  update()  and  delete() 
                methods of your Table class. However, sometimes it may be necessary to do custom
                logic in the Row class.
             
                Below are some example cases where it might make sense to implement custom logic in
                a Row class instead of in the Table class:
             Example of custom logic in a Row class 
                    The custom logic may not apply in all cases of operations on the respective
                    Table. You can provide custom logic on demand by implementing it in a Row class
                    and creating an instance of the Table class with that custom Row class
                    specified. Otherwise, the Table uses the default Row class.
                 
                    You need data operations on this table to record the operation to a
                    Zend_Log object, but only if the application configuration has enabled this
                    behavior.
                 &lt;?php
class MyLoggingRow extends Zend_Db_Table_Row_Abstract
{
    protected function _insert()
    {
        $log = Zend_Registry::get(&#39;database_log&#39;);
        $log-&gt;info(Zend_Debug::dump($this-&gt;_data, &quot;INSERT: $this-&gt;_tableClass&quot;, false));
    }
}

// $loggingEnabled is an example property that depends
// on your application configuration
if ($loggingEnabled) {
    $bugs = new Bugs(array(&#39;rowClass&#39; =&gt; &#39;MyLoggingRow&#39;));
} else {
    $bugs = new Bugs();
}
                 Example of a Row class that logs insert data for multiple tables 
                    The custom logic may be common to multiple tables. Instead of implementing the
                    same custom logic in every one of your Table classes, you can implement the
                    code for such actions in the definition of a Row class, and use this Row in
                    each of your Table classes.
                 
                    In this example, the logging code is identical in all table classes.
                 &lt;?php
class MyLoggingRow extends Zend_Db_Table_Row_Abstract
{
    protected function _insert()
    {
        $log = Zend_Registry::get(&#39;database_log&#39;);
        $log-&gt;info(Zend_Debug::dump($this-&gt;_data, &quot;INSERT: $this-&gt;_tableClass&quot;, false));
    }
}

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;
    protected $_rowClass = &#39;MyLoggingRow&#39;;
}

class Products extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;products&#39;;
    protected $_rowClass = &#39;MyLoggingRow&#39;;
}
                 Define Inflection in Zend_Db_Table_Row 
                Some people prefer that the table class name match a table name in the RDBMS by
                using a string transformation called  inflection .
             
                Zend_Db classes do not implement inflection by default. See
                  for an explanation of this
                policy.
             
                If you prefer to use inflection, then you must implement the transformation yourself,
                by overriding the  _transformColumn()  method in a custom Row class, and
                using that custom Row class when you perform queries against your Table class.
             Example of defining an inflection transformation 
                    This allows you to use an inflected version of the column name in the
                    accessors. The Row class uses the  _transformColumn()  method to
                    change the name you use to the native column name in the database table.
                 &lt;?php
class MyInflectedRow extends Zend_Db_Table_Row_Abstract
{
    protected function _transformColumn($columnName)
    {
        $nativeColumnName = myCustomInflector($columnName);
        return $nativeColumnName;
    }
}

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;
    protected $_rowClass = &#39;MyInflectedRow&#39;;
}

$bugs = new Bugs();
$row = $bugs-&gt;fetchNew();

// Use camelcase column names, and rely on the
// transformation function to change it into the
// native representation.
$row-&gt;bugDescription = &#39;New description&#39;;
                 
                You are responsible for writing the functions to perform inflection transformation.
                Zend Framework does not provide such a function.
             Zend_Db_Table_Rowset Introduction 
            When you run a query against a Table class using the  find()  or  fetchAll() 
            methods, the result is returned in an object of type  Zend_Db_Table_Rowset_Abstract . A Rowset
            contains a collection of objects descending from  Zend_Db_Table_Row_Abstract . You can iterate
            through the Rowset and access individual Row objects, reading or modifying data in the Rows.
         Fetching a Rowset Zend_Db_Table_Abstract  provides methods  find()  and  fetchAll() , each
            of which returns an object of type  Zend_Db_Table_Rowset_Abstract .
         Example of fetching a rowset &lt;?php

$bugs   = new Bugs();
$rowset = $bugs-&gt;fetchAll(&quot;bug_status = &#39;NEW&#39;&quot;); Retrieving Rows from a Rowset 
            The Rowset itself is usually less interesting than the Rows that it contains. This section illustrates how
            to get the Rows that comprise the Rowset.
         
            A legitimate query returns zero rows when no rows in the database match the query conditions. Therefore, a
            Rowset object might contain zero Row objects. Since  Zend_Db_Table_Rowset_Abstract  implements
            the  Countable  interface, you can use  count()  to determine the number of Rows in
            the Rowset.
         Counting the Rows in a Rowset &lt;?php

$rowset   = $bugs-&gt;fetchAll(&quot;bug_status = &#39;FIXED&#39;&quot;);

$rowCount = count($rowset);

if ($rowCount &gt; 0) {
    echo &quot;found $rowCount rows&quot;;
} else {
    echo &#39;no rows matched the query&#39;;
} Reading a Single Row from a Rowset 
                The simplest way to access a Row from a Rowset is to use the  current()  method. This is
                particularly appropriate when the Rowset contains exactly one Row.
             &lt;?php

$bugs   = new Bugs();
$rowset = $bugs-&gt;fetchAll(&quot;bug_id = 1&quot;);
$row    = $rowset-&gt;current(); 
            If the Rowset contains zero rows,  current()  returns
            PHP&#39;s  null  value.
         Iterating through a Rowset 
                Objects descending from  Zend_Db_Table_Rowset_Abstract  implement the  SeekableIterator 
                interface, which means you can loop through them using the  foreach  construct. Each value
                you retrieve this way is a  Zend_Db_Table_Row_Abstract  object that corresponds to one
                record from the table.
             &lt;?php

$bugs = new Bugs();

// fetch all records from the table
$rowset = $bugs-&gt;fetchAll();

foreach ($rowset as $row) {

    // output &#39;Zend_Db_Table_Row&#39; or similar
    echo get_class($row) . &quot;\n&quot;;

    // read a column in the row
    $status = $row-&gt;bug_status;

    // modify a column in the current row
    $row-&gt;assigned_to = &#39;mmouse&#39;;

    // write the change to the database
    $row-&gt;save();
} Seeking to a known position into a Rowset SeekableIterator  allows you to seek to a position that you would like the iterator to jump to.
                Simply use the  seek()  method for that. Pass it an integer representing the number of the Row
                you would like your Rowset to point to next, don&#39;t forget that it starts with index 0. If the index is wrong,
                ie doesn&#39;t exist, an exception will be thrown. You should use  count()  to check the number of
                results before seeking to a position.
             &lt;?php

$bugs = new Bugs();

// fetch all records from the table
$rowset = $bugs-&gt;fetchAll();

// takes the iterator to the 9th element (zero is one element) :
$rowset-&gt;seek(8);

// retrive it
$row9 = $rowset-&gt;current();

// and use it
$row9-&gt;assigned_to = &#39;mmouse&#39;;
$row9-&gt;save(); getRow()  allows you to get a specific row in the Rowset, knowing its position; don&#39;t forget
                however that positions start with index zero. The first parameter for  getRow()  is an integer
                for the position asked. The second optional parameter is a boolean; it tells the Rowset iterator if it must
                seek to that position in the same time, or not (default is false). This method returns a Zend_Db_Table_Row
                object by default. If the position requested does not exist, an exception will be thrown. Here is an example :
             &lt;?php

$bugs = new Bugs();

// fetch all records from the table
$rowset = $bugs-&gt;fetchAll();

// retrieve the 9th element immediatly :
$row9-&gt;getRow(8);

// and use it :
$row9-&gt;assigned_to = &#39;mmouse&#39;;
$row9-&gt;save();
} 
            After you have access to an individual Row object, you can manipulate the Row using methods described in
             .
         Retrieving a Rowset as an Array 
            You can access all the data in the Rowset as an array using the  toArray()  method of the Rowset
            object. This returns an array containing one entry per Row. Each entry is an associative array having keys
            that correspond to column names and elements that correspond to the respective column values.
         Using toArray() &lt;?php

$bugs   = new Bugs();
$rowset = $bugs-&gt;fetchAll();

$rowsetArray = $rowset-&gt;toArray();

$rowCount = 1;
foreach ($rowsetArray as $rowArray) {
    echo &quot;row #$rowCount:\n&quot;;
    foreach ($rowArray as $column =&gt; $value) {
        echo &quot;\t$column =&gt; $value\n&quot;;
    }
    ++$rowCount;
    echo &quot;\n&quot;;
} 
            The array returned from  toArray()  is not updateable. That is, you can modify values in the
            array as you can with any array, but changes to the array data are not propagated to the database.
         Serializing and Unserializing a Rowset 
            Objects of type  Zend_Db_Table_Rowset_Abstract  are serializable. In a similar fashion to
            serializing an individual Row object, you can serialize a Rowset and unserialize it later.
         Serializing a Rowset 
                Simply use PHP&#39;s  serialize()  function to create a string containing a byte-stream
                representation of the Rowset object argument.
             &lt;?php

$bugs   = new Bugs();
$rowset = $bugs-&gt;fetchAll();

// Convert object to serialized form
$serializedRowset = serialize($rowset);

// Now you can write $serializedRowset to a file, etc. Unserializing a Serialized Rowset 
                Use PHP&#39;s  unserialize()  function to restore a string containing a byte-stream
                representation of an object.  The function returns the original object.
             
                Note that the Rowset object returned is in a  disconnected  state. You can iterate
                through the Rowset and read the Row objects and their properties, but you cannot change values in the
                Rows or execute other methods that require a database connection (for example, queries against related
                tables).
             &lt;?php

$rowsetDisconnected = unserialize($serializedRowset);

// Now you can use object methods and properties, but read-only
$row = $rowsetDisconnected-&gt;current();
echo $row-&gt;bug_description; Why do Rowsets unserialize in a disconnected state? 
                A serialized object is a string that is readable to anyone who possesses it. It could be a security
                risk to store parameters such as database account and password in plain, unencrypted text in the
                serialized string. You would not want to store such data to a text file that is not protected, or send
                it in an email or other medium that is easily read by potential attackers. The reader of the serialized
                object should not be able to use it to gain access to your database without knowing valid credentials.
             
            You can reactivate a disconnected Rowset using the  setTable()  method.  The argument to this
            method is a valid object of type  Zend_Db_Table_Abstract , which you create.  Creating a Table
            object requires a live connection to the database, so by reassociating the Table with the Rowset, the
            Rowset gains access to the database.  Subsequently, you can change values in the Row objects contained in
            the Rowset and save the changes to the database.
         Reactivating a Rowset as Live Data &lt;?php

$rowset = unserialize($serializedRowset);

$bugs = new Bugs();

// Reconnect the rowset to a table, and
// thus to a live database connection
$rowset-&gt;setTable($bugs);

$row = $rowset-&gt;current();

// Now you can make changes to the row and save them
$row-&gt;bug_status = &#39;FIXED&#39;;
$row-&gt;save(); 
            Reactivating a Rowset with  setTable()  also reactivates all the Row objects contained in that
            Rowset.
         Extending the Rowset class 
            You can use an alternative concrete class for instances of Rowsets
            by extending Zend_Db_Table_Rowset_Abstract.  Specify the custom
            Rowset class by name either in the  $_rowsetClass 
            protected member of a Table class, or in the array argument of the
            constructor of a Table object.
         Specifying a custom Rowset class &lt;?php

class MyRowset extends Zend_Db_Table_Rowset_Abstract
{
    // ...customizations
}

// Specify a custom Rowset to be used by default
// in all instances of a Table class.
class Products extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;products&#39;;
    protected $_rowsetClass = &#39;MyRowset&#39;;
}

// Or specify a custom Rowset to be used in one
// instance of a Table class.
$bugs = new Bugs(array(&#39;rowsetClass&#39; =&gt; &#39;MyRowset&#39;)); 
            Typically, the standard Zend_Db_Rowset concrete class is
            sufficient for most usage.  However, you might find it useful
            to add new logic to a Rowset, specific to a given Table.
            For example, a new method could calculate an aggregate
            over all the Rows in the Rowset.
         Example of Rowset class with a new method &lt;?php

class MyBugsRowset extends Zend_Db_Table_Rowset_Abstract
{
    /**
     * Find the Row in the current Rowset with the
     * greatest value in its &#39;updated_at&#39; column.
     */
    public function getLatestUpdatedRow()
    {
        $max_updated_at = 0;
        $latestRow = null;
        foreach ($this as $row) {
            if ($row-&gt;updated_at &gt; $max_updated_at) {
                $latestRow = $row;
            }
        }
        return $latestRow;
    }
}

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name = &#39;bugs&#39;;
    protected $_rowsetClass = &#39;MyBugsRowset&#39;;
} Dumping Variables 
        The static method  Zend_Debug::dump()  prints or returns
        information about an expression.  This simple technique of debugging is
        common, because it is easy to use in an ad hoc fashion, and requires no
        initialization, special tools, or debugging environment.
     Example of dump() method &lt;?php

Zend_Debug::dump($var, $label=null, $echo=true); 
        The  $var  argument specifies the expression or variable
        about which the  Zend_Debug::dump()  method outputs
        information.
     
        The  $label  argument is a string to be prepended to the
        output of  Zend_Debug::dump() .  It may be useful, for
        example, to use labels if you are dumping information about multiple
        variables on a given screen.
     
        The boolean  $echo  argument specifies whether the output
        of  Zend_Debug::dump()  is echoed or not.
        If  true , the output is echoed.
        Regardless of the value of the  $echo  argument, the
        return value of this method contains the output.
     
        It may be helpful to understand that internally,
         Zend_Debug::dump()  method wraps the PHP function
         var_dump() .
        If the output stream is detected as a web presentation,
        the output of  var_dump()  is escaped using
         htmlspecialchars() 
        and wrapped with (X)HTML  &lt;pre&gt;  tags.
     Debugging with Zend_Log 
            Using  Zend_Debug::dump()  is best for ad hoc
            debugging during software development.  You can add code to dump
            a variable and then remove the code very quickly.
         
            Also consider the  Zend_Log 
            component when writing more permanent debugging code.
            For example, you can use the  DEBUG  log level and the
            Stream log writer, to output the string returned by
             Zend_Debug::dump() .
         Using Exceptions 
        All exceptions thrown by Zend Framework classes should throw
        an exception that derives from the base class Zend_Exception.
     Example of catching an exception &lt;?php

try {
    Zend_Loader::loadClass(&#39;nonexistantclass&#39;);
} catch (Zend_Exception $e) {
    echo &quot;Caught exception: &quot; . get_class($e) . &quot;\n&quot;;
    echo &quot;Message: &quot; . $e-&gt;getMessage() . &quot;\n&quot;;
    // other code to recover from the failure.
} 
        See the documentation for each respective Zend Framework
        component for more specific information on which methods
        throw exceptions, the circumstances for the exceptions,
        and which exception classes derive from Zend_Exception.
     Consuming an Atom Feed Zend_Feed_Atom  is used in much the same way as  Zend_Feed_Rss . It provides
        the same access to feed-level properties and iteration over entries in the feed. The main
        difference is in the structure of the Atom protocol itself. Atom is a successor to RSS; it is more
        generalized protocol and it is designed to deal more easily with feeds that provide their full
        content inside the feed, splitting RSS&#39;  description  tag into two elements,
         summary  and  content , for that purpose.
     Basic Use of an Atom Feed 
            Read an Atom feed and print the  title  and  summary  of each entry:
         &lt;?php

$feed = new Zend_Feed_Atom(&#39;http://atom.example.com/feed/&#39;);
echo &#39;The feed contains &#39; . $feed-&gt;count() . &#39; entries.&#39; . &quot;\n\n&quot;;
foreach ($feed as $entry) {
    echo &#39;Title: &#39; . $entry-&gt;title() . &quot;\n&quot;;
    echo &#39;Summary: &#39; . $entry-&gt;summary() . &quot;\n\n&quot;;
} 
        In an Atom feed you can expect to find the following feed properties:
     title  - The feed&#39;s title, same as RSS&#39;s channel title id  - Every feed and entry in Atom has a unique identifier link  - Feeds can have multiple links, which are distinguished by a
                 type  attribute 
                    The equivalent to RSS&#39;s channel link would be  type=&quot;text/html&quot; . If the link
                    is to an alternate version of the same content that&#39;s in the feed, it would have a
                     rel=&quot;alternate&quot;  attribute.
                 subtitle  - The feed&#39;s description, equivalent to RSS&#39; channel description
                 author-&gt;name()  - The feed author&#39;s name author-&gt;email()  - The feed author&#39;s email address 
        Atom entries commonly have the following properties:
     id  - The entry&#39;s unique identifier title  - The entry&#39;s title, same as RSS item titles link  - A link to another format or an alternate view of this entry summary  - A summary of this entry&#39;s content content  - The full content of the entry; can be skipped if the feed just
                contains summaries author  - with  name  and  email  sub-tags like
                feeds have published  - the date the entry was published, in RFC 3339 format updated  - the date the entry was last updated, in RFC 3339 format 
        For more information on Atom and plenty of resources, see
         http://www.atomenabled.org/ .
     Consuming a Single Atom Entry 
        Single Atom  &lt;entry&gt;  elements are also valid by themselves. Usually the URL for an
        entry is the feed&#39;s URL followed by  /&lt;entryId&gt; , such as
         http://atom.example.com/feed/1 , using the example URL we used above.
     
        If you read a single entry, you will still have a  Zend_Feed_Atom  object, but it will
        automatically create an &quot;anonymous&quot; feed to contain the entry.
     Reading a Single-Entry Atom Feed &lt;?php

$feed = new Zend_Feed_Atom(&#39;http://atom.example.com/feed/1&#39;);
echo &#39;The feed has: &#39; . $feed-&gt;count() . &#39; entry.&#39;;

$entry = $feed-&gt;current(); 
        Alternatively, you could instantiate the entry object directly if you know you are accessing an
         &lt;entry&gt; -only document:
     Using the Entry Object Directly for a Single-Entry Atom Feed &lt;?php

$entry = new Zend_Feed_Entry_Atom(&#39;http://atom.example.com/feed/1&#39;);
echo $entry-&gt;title(); Consuming an RSS Feed 
        Reading an RSS feed is as simple as instantiating a  Zend_Feed_Rss  object with the URL
        of the feed:
     &lt;?php
$channel = new Zend_Feed_Rss(&#39;http://rss.example.com/channelName&#39;);
     
        If any errors occur fetching the feed, a  Zend_Feed_Exception  will be thrown.
     
        Once you have a feed object, you can access any of the standard RSS &quot;channel&quot; properties directly
        on the object:
     &lt;?php
echo $channel-&gt;title();
     
        Note the function syntax.  Zend_Feed  uses a convention of treating properties as XML
        object if they are requested with variable &quot;getter&quot; syntax ( $obj-&gt;property ) and as
        strings if they are access with method syntax ( $obj-&gt;property() ). This enables access
        to the full text of any individual node while still allowing full access to all children.
     
        If channel properties have attributes, they are accessible using PHP&#39;s array syntax:
     &lt;?php
echo $channel-&gt;category[&#39;domain&#39;];
     
        Since XML attributes cannot have children, method syntax is not necessary for accessing attribute
        values.
     
        Most commonly you&#39;ll want to loop through the feed and do something with its entries.
         Zend_Feed_Abstract  implements PHP&#39;s  Iterator  interface, so printing all
        titles of articles in a channel is just a matter of:
     &lt;?php
foreach ($channel as $item) {
    echo $item-&gt;title() . &quot;\n&quot;;
}
     
        If you are not familiar with RSS, here are the standard elements you can expect to be available in
        an RSS channel and in individual RSS items (entries).
     
        Required channel elements:
     title  - The name of the channel link  - The URL of the web site corresponding to the channel description  - A sentence or several describing the channel 
        Common optional channel elements:
     pubDate  - The publication date of this set of content, in RFC 822 date
                format language  - The language the channel is written in category  - One or more (specified by multiple tags) categories the
                channel belongs to 
        RSS  &lt;item&gt;  elements do not have any strictly required elements. However, either
         title  or  description  must be present.
     
        Common item elements:
     title  - The title of the item link  - The URL of the item description  - A synopsis of the item author  - The author&#39;s email address category  - One more more categories that the item belongs to comments  - URL of comments relating to this item pubDate  - The date the item was published, in RFC 822 date format 
        In your code you can always test to see if an element is non-empty with:
     &lt;?php
if ($item-&gt;propname()) {
    // ... proceed.
}
     
        If you use  $item-&gt;propname  instead, you will always get an empty object which will
        evaluate to  TRUE , so your check will fail.
     
        For further information, the official RSS 2.0 specification is available at:
         http://blogs.law.harvard.edu/tech/rss 
     Custom Feed and Entry Classes 
        Finally, you can extend the  Zend_Feed  classes if you&#39;d like to provide your own format or
        niceties like automatic handling of elements that should go into a custom namespace.
     
        Here is an example of a custom Atom entry class that handles its own  myns:  namespace
        entries. Note that it also makes the  registerNamespace()  call for you, so the end user
        doesn&#39;t need to worry about namespaces at all.
     Extending the Atom Entry Class with Custom Namespaces &lt;?php
/**
 * The custom entry class automatically knows the feed URI (optional) and
 * can automatically add extra namespaces.
 */
class MyEntry extends Zend_Feed_Entry_Atom
{

    public function __construct($uri = &#39;http://www.example.com/myfeed/&#39;,
                                $xml = null)
    {
        parent::__construct($uri, $xml);

        Zend_Feed::registerNamespace(&#39;myns&#39;, &#39;http://www.example.com/myns/1.0&#39;);
    }

    public function __get($var)
    {
        switch ($var) {
            case &#39;myUpdated&#39;:
                // Translate myUpdated to myns:updated.
                return parent::__get(&#39;myns:updated&#39;);

            default:
                return parent::__get($var);
            }
    }

    public function __set($var, $value)
    {
        switch ($var) {
            case &#39;myUpdated&#39;:
                // Translate myUpdated to myns:updated.
                parent::__set(&#39;myns:updated&#39;, $value);
                break;

            default:
                parent::__set($var, $value);
        }
    }

    public function __call($var, $unused)
    {
        switch ($var) {
            case &#39;myUpdated&#39;:
                // Translate myUpdated to myns:updated.
                return parent::__call(&#39;myns:updated&#39;, $unused);

            default:
                return parent::__call($var, $unused);
        }
    }
}
         
            Then to use this class, you&#39;d just instantiate it directly and set the  myUpdated 
            property:
         &lt;?php
$entry = new MyEntry();
$entry-&gt;myUpdated = &#39;2005-04-19T15:30&#39;;

// method-style call is handled by __call function
$entry-&gt;myUpdated();  
// property-style call is handled by __get function
$entry-&gt;myUpdated;
         Retrieving Feeds from Web Pages 
        Web pages often contain  &lt;link&gt;  tags that refer to feeds with content relevant to
        the particular page.  Zend_Feed  enables you to retrieve all feeds referenced by a web
        page with one simple method call:
     &lt;?php
$feedArray = Zend_Feed::findFeeds(&#39;http://www.example.com/news.html&#39;);
     
        Here the  findFeeds()  method returns an array of  Zend_Feed_Abstract 
        objects that are referenced by  &lt;link&gt;  tags on the news.html web page. Depending on
        the type of each feed, each respective entry in the  $feedArray  array may be a
         Zend_Feed_Rss  or  Zend_Feed_Atom  instance.  Zend_Feed  will throw a
         Zend_Feed_Exception  upon failure, such as an HTTP 404 response code or a malformed feed.
     Importing Feeds Zend_Feed  enables developers to retrieve feeds very easily. If you know the URI of a feed, simply
        use the  Zend_Feed::import()  method:
     &lt;?php
$feed = Zend_Feed::import(&#39;http://feeds.example.com/feedName&#39;);
     
        You can also use  Zend_Feed  to fetch the contents of a feed from a file or the contents of a PHP
        string variable:
     &lt;?php
// importing a feed from a text file
$feedFromFile = Zend_Feed::importFile(&#39;feed.xml&#39;);

// importing a feed from a PHP string variable
$feedFromPHP = Zend_Feed::importString($feedString);
     
        In each of the examples above, an object of a class that extends  Zend_Feed_Abstract  is returned
        upon success, depending on the type of the feed. If an RSS feed were retrieved via one of the import methods
        above, then a  Zend_Feed_Rss  object would be returned. On the other hand, if an Atom feed were
        imported, then a  Zend_Feed_Atom  object is returned. The import methods will also throw a
         Zend_Feed_Exception  object upon failure, such as an unreadable or malformed feed.
     Custom feeds Zend_Feed  enables developers to create custom feeds very easily. You just have to create an
            array and to import it with Zend_Feed. This array can be imported with  Zend_Feed::importArray() 
            or with  Zend_Feed::importBuilder() . In this last case the array will be computed on the fly by
            a custom data source implementing  Zend_Feed_Builder_Interface .
         Importing a custom array &lt;?php
// importing a feed from an array
$atomFeedFromArray = Zend_Feed::importArray($array);

// the following line is equivalent to the above; by default a Zend_Feed_Atom instance is returned
$atomFeedFromArray = Zend_Feed::importArray($array, &#39;atom&#39;);

// importing a rss feed from an array
$rssFeedFromArray = Zend_Feed::importArray($array, &#39;rss&#39;);
             
                The format of the array must conform to this structure:
             &lt;?php
array(
      &#39;title&#39;       =&gt; &#39;title of the feed&#39;, //required
      &#39;link&#39;        =&gt; &#39;canonical url to the feed&#39;, //required
      &#39;lastUpdate&#39;  =&gt; &#39;timestamp of the update date&#39;, // optional
      &#39;published&#39;   =&gt; &#39;timestamp of the publication date&#39;, //optional
      &#39;charset&#39;     =&gt; &#39;charset of the textual data&#39;, // required
      &#39;description&#39; =&gt; &#39;short description of the feed&#39;, //optional
      &#39;author&#39;      =&gt; &#39;author/publisher of the feed&#39;, //optional
      &#39;email&#39;       =&gt; &#39;email of the author&#39;, //optional
      &#39;webmaster&#39;   =&gt; &#39;email address for person responsible for technical issues&#39; // optional, ignored if atom is used
      &#39;copyright&#39;   =&gt; &#39;copyright notice&#39;, //optional
      &#39;image&#39;       =&gt; &#39;url to image&#39;, //optional
      &#39;generator&#39;   =&gt; &#39;generator&#39;, // optional
      &#39;language&#39;    =&gt; &#39;language the feed is written in&#39;, // optional
      &#39;ttl&#39;         =&gt; &#39;how long in minutes a feed can be cached before refreshing&#39;, // optional, ignored if atom is used
      &#39;rating&#39;      =&gt; &#39;The PICS rating for the channel.&#39;, // optional, ignored if atom is used
      &#39;cloud&#39;       =&gt; array(
                             &#39;domain&#39;            =&gt; &#39;domain of the cloud, e.g. rpc.sys.com&#39; // required
                             &#39;port&#39;              =&gt; &#39;port to connect to&#39; // optional, default to 80
                             &#39;path&#39;              =&gt; &#39;path of the cloud, e.g. /RPC2&#39; //required
                             &#39;registerProcedure&#39; =&gt; &#39;procedure to call, e.g. myCloud.rssPleaseNotify&#39; // required
                             &#39;protocol&#39;          =&gt; &#39;protocol to use, e.g. soap or xml-rpc&#39; // required
                             ), // a cloud to be notified of updates // optional, ignored if atom is used
      &#39;textInput&#39;   =&gt; array(
                             &#39;title&#39;       =&gt; &#39;the label of the Submit button in the text input area&#39; // required,
                             &#39;description&#39; =&gt; &#39;explains the text input area&#39; // required
                             &#39;name&#39;        =&gt; &#39;the name of the text object in the text input area&#39; // required
                             &#39;link&#39;        =&gt; &#39;the URL of the CGI script that processes text input requests&#39; // required
                             ) // a text input box that can be displayed with the feed // optional, ignored if atom is used
      &#39;skipHours&#39;   =&gt; array(
                             &#39;hour in 24 format&#39;, // e.g 13 (1pm)
                             // up to 24 rows whose value is a number between 0 and 23
                             ) // Hint telling aggregators which hours they can skip // optional, ignored if atom is used
      &#39;skipDays &#39;   =&gt; array(
                             &#39;a day to skip&#39;, // e.g Monday
                             // up to 7 rows whose value is a Monday, Tuesday, Wednesday, Thursday, Friday, Saturday or Sunday
                             ) // Hint telling aggregators which days they can skip // optional, ignored if atom is used
      &#39;itunes&#39;      =&gt; array(
                             &#39;author&#39;       =&gt; &#39;Artist column&#39; // optional, default to the main author value
                             &#39;owner&#39;        =&gt; array(
                                                     &#39;name&#39; =&gt; &#39;name of the owner&#39; // optional, default to main author value
                                                     &#39;email&#39; =&gt; &#39;email of the owner&#39; // optional, default to main email value
                                                     ) // Owner of the podcast // optional
                             &#39;image&#39;        =&gt; &#39;album/podcast art&#39; // optional, default to the main image value
                             &#39;subtitle&#39;     =&gt; &#39;short description&#39; // optional, default to the main description value
                             &#39;summary&#39;      =&gt; &#39;longer description&#39; // optional, default to the main description value
                             &#39;block&#39;        =&gt; &#39;Prevent an episode from appearing (yes|no)&#39; // optional
                             &#39;category&#39;     =&gt; array(
                                                     array(&#39;main&#39; =&gt; &#39;main category&#39;, // required
                                                           &#39;sub&#39;  =&gt; &#39;sub category&#39; // optional
                                                           ),
                                                     // up to 3 rows
                                                     ) // &#39;Category column and in iTunes Music Store Browse&#39; // required
                             &#39;explicit&#39;     =&gt; &#39;parental advisory graphic (yes|no|clean)&#39; // optional
                             &#39;keywords&#39;     =&gt; &#39;a comma separated list of 12 keywords maximum&#39; // optional
                             &#39;new-feed-url&#39; =&gt; &#39;used to inform iTunes of new feed URL location&#39; // optional
                             ) // Itunes extension data // optional, ignored if atom is used
      &#39;entries&#39;     =&gt; array(
                             array(
                                   &#39;title&#39;        =&gt; &#39;title of the feed entry&#39;, //required
                                   &#39;link&#39;         =&gt; &#39;url to a feed entry&#39;, //required
                                   &#39;description&#39;  =&gt; &#39;short version of a feed entry&#39;, // only text, no html, required
                                   &#39;guid&#39;         =&gt; &#39;id of the article, if not given link value will used&#39;, //optional
                                   &#39;content&#39;      =&gt; &#39;long version&#39;, // can contain html, optional
                                   &#39;lastUpdate&#39;   =&gt; &#39;timestamp of the publication date&#39;, // optional
                                   &#39;comments&#39;     =&gt; &#39;comments page of the feed entry&#39;, // optional
                                   &#39;commentRss&#39;   =&gt; &#39;the feed url of the associated comments&#39;, // optional
                                   &#39;source&#39;       =&gt; array(
                                                           &#39;title&#39; =&gt; &#39;title of the original source&#39; // required,
                                                           &#39;url&#39; =&gt; &#39;url of the original source&#39; // required
                                                           ) // original source of the feed entry // optional
                                   &#39;category&#39;     =&gt; array(
                                                           array(
                                                                 &#39;term&#39; =&gt; &#39;first category label&#39; // required,
                                                                 &#39;scheme&#39; =&gt; &#39;url that identifies a categorization scheme&#39; // optional
                                                                 ),
                                                           array(
                                                                 //data for the second category and so on
                                                                 )
                                                           ) // list of the attached categories // optional
                                   &#39;enclosure&#39;    =&gt; array(
                                                           array(
                                                                 &#39;url&#39; =&gt; &#39;url of the linked enclosure&#39; // required
                                                                 &#39;type&#39; =&gt; &#39;mime type of the enclosure&#39; // optional
                                                                 &#39;length&#39; =&gt; &#39;length of the linked content in octets&#39; // optional
                                                                 ),
                                                           array(
                                                                 //data for the second enclosure and so on
                                                                 )
                                                           ) // list of the enclosures of the feed entry // optional
                                   ),
                             array(
                                   //data for the second entry and so on
                                   )
                             )
       );
             
                References:
                 
                            RSS 2.0 specification:  RSS 2.0 
                         
                            Atom specification:  RFC 4287 
                         
                            WFW specification:  Well
                            Formed Web 
                         
                            iTunes specification:
                             iTunes Technical
                            Specifications 
                         
             Importing a custom data source 
                You can create a Zeed_Feed instance from any data source implementing
                 Zend_Feed_Builder_Interface . You just have to implement the  getHeader()  and
                 getEntries()  methods to be able to use your object with
                 Zend_Feed::importBuilder() . As a simple reference implementation, you can use
                 Zend_Feed_Builder , which takes an array in its constructor, performs some minor validation,
                and then can be used in the  importBuilder()  method. The  getHeader()  method
                must return an instance of  Zend_Feed_Builder_Header , and  getEntries()  must
                return an array of  Zend_Feed_Builder_Entry  instances.
             Zend_Feed_Builder  serves as a concrete implementation to demonstrate the usage. Users
                    are encouraged to make their own classes to implement  Zend_Feed_Builder_Interface .
                 
                Here is an example of  Zend_Feed::importBuilder()  usage:
             &lt;?php
// importing a feed from a custom builder source
$atomFeedFromArray = Zend_Feed::importBuilder(new Zend_Feed_Builder($array));

// the following line is equivalent to the above; by default a Zend_Feed_Atom instance is returned
$atomFeedFromArray = Zend_Feed::importArray(new Zend_Feed_Builder($array), &#39;atom&#39;);

// importing a rss feed from a custom builder array
$rssFeedFromArray = Zend_Feed::importArray(new Zend_Feed_Builder($array), &#39;rss&#39;);
             Dumping the contents of a feed 
                To dump the contents of a  Zend_Feed_Abstract  instance, you may use  send()  or
                 saveXml()  methods.
             &lt;?php
assert($feed instanceof Zend_Feed_Abstract);

// dump the feed to standard output
print $feed-&gt;saveXML();

// send http headers and dump the feed
$feed-&gt;send();
             Introduction Zend_Feed  provides functionality for consuming RSS and Atom feeds. It provides a
        natural syntax for accessing elements of feeds, feed attributes, and entry attributes.
         Zend_Feed  also has extensive support for modifying feed and entry structure with the
        same natural syntax, and turning the result back into XML. In the future, this modification support
        could provide support for the Atom Publishing Protocol.
     
        Programmatically,  Zend_Feed  consists of a base  Zend_Feed  class, abstract
         Zend_Feed_Abstract  and  Zend_Feed_Entry_Abstract  base classes for
        representing Feeds and Entries, specific implementations of feeds and entries for RSS and Atom, and
        a behind-the-scenes helper for making the natural syntax magic work.
     
        In the example below, we demonstrate a simple use case of retrieving an RSS feed and saving relevant
        portions of the feed data to a simple PHP array, which could then be used for printing the data, storing
        to a database, etc.
     Be aware 
            Many RSS feeds have different channel and item properties available. The RSS specification provides for
            many optional properties, so be aware of this when writing code to work with RSS data.
         Putting Zend_Feed to Work on RSS Feed Data &lt;?php
require_once &#39;Zend/Feed.php&#39;;

// Fetch the latest Slashdot headlines
try {
    $slashdotRss = Zend_Feed::import(&#39;http://rss.slashdot.org/Slashdot/slashdot&#39;);
} catch (Zend_Feed_Exception $e) {
    // feed import failed
    echo &quot;Exception caught importing feed: {$e-&gt;getMessage()}\n&quot;;
    exit;
}

// Initialize the channel data array
$channel = array(
    &#39;title&#39;       =&gt; $slashdotRss-&gt;title(),
    &#39;link&#39;        =&gt; $slashdotRss-&gt;link(),
    &#39;description&#39; =&gt; $slashdotRss-&gt;description(),
    &#39;items&#39;       =&gt; array()
    );

// Loop over each channel item and store relevant data
foreach ($slashdotRss as $item) {
    $channel[&#39;items&#39;][] = array(
        &#39;title&#39;       =&gt; $item-&gt;title(),
        &#39;link&#39;        =&gt; $item-&gt;link(),
        &#39;description&#39; =&gt; $item-&gt;description()
        );
}
         Modifying Feed and Entry structures Zend_Feed &#39;s natural syntax extends to constructing and modifying feeds and entries as well
        as reading them. You can easily turn your new or modified objects back into well-formed XML for saving
        to a file or sending to a server.
     Modifying an Existing Feed Entry &lt;?php
$feed = new Zend_Feed_Atom(&#39;http://atom.example.com/feed/1&#39;);
$entry = $feed-&gt;current();

$entry-&gt;title = &#39;This is a new title&#39;;
$entry-&gt;author-&gt;email = &#39;my_email@example.com&#39;;

echo $entry-&gt;saveXML();
         
            This will output a full (includes  &lt;?xml ... &gt;  prologue) XML representation of the
            new entry, including any necessary XML namespaces.
         
            Note that the above will work even if the existing entry does not already have an author tag. You can
            use as many levels of  -&gt;  access as you like before getting to an assignment; all of the
            intervening levels will be created for you automatically if necessary.
         
        If you want to use a namespace other than  atom: ,  rss: , or  osrss: 
        in your entry, you need to register the namespace with  Zend_Feed  using  
        Zend_Feed::registerNamespace() . When you are modifying an existing element, it will always
        maintain its original namespace. When adding a new element, it will go into the default namespace if
        you do not explicitly specify another namespace.
     Creating an Atom Entry with Elements of Custom Namespaces &lt;?php
$entry = new Zend_Feed_Entry_Atom();
// id is always assigned by the server in Atom
$entry-&gt;title = &#39;my custom entry&#39;;
$entry-&gt;author-&gt;name = &#39;Example Author&#39;;
$entry-&gt;author-&gt;email = &#39;me@example.com&#39;;

// Now do the custom part.
Zend_Feed::registerNamespace(&#39;myns&#39;, &#39;http://www.example.com/myns/1.0&#39;);

$entry-&gt;{&#39;myns:myelement_one&#39;} = &#39;my first custom value&#39;;
$entry-&gt;{&#39;myns:container_elt&#39;}-&gt;part1 = &#39;first nested custom part&#39;;
$entry-&gt;{&#39;myns:container_elt&#39;}-&gt;part2 = &#39;second nested custom part&#39;;

echo $entry-&gt;saveXML();
         Filter Chains 
        Often multiple filters should be applied to some value in a particular order. For example, a
        login form accepts a username that should be only lowercase, alphabetic characters.
         Zend_Filter  provides a simple method by which filters may be chained together. The
        following code illustrates how to chain together two filters for the submitted username:

         &lt;?php
// Provides filter chaining capability
require_once &#39;Zend/Filter.php&#39;;

// Filters needed for the example
require_once &#39;Zend/Filter/Alpha.php&#39;;
require_once &#39;Zend/Filter/StringToLower.php&#39;;

// Create a filter chain and add filters to the chain
$filterChain = new Zend_Filter();
$filterChain-&gt;addFilter(new Zend_Filter_Alpha())
            -&gt;addFilter(new Zend_Filter_StringToLower());

// Filter the username
$username = $filterChain-&gt;filter($_POST[&#39;username&#39;]);
         

        Filters are run in the order they were added to  Zend_Filter . In the above example, the
        username is first removed of any non-alphabetic characters, and then any uppercase characters are
        converted to lowercase.

     
        Any object that implements  Zend_Filter_Interface  may be used in a filter chain.
     Zend_Filter_Inflector Zend_Filter_Inflector  is a general purpose tool for
        rules-based inflection of strings to a given target.
     
        As an example, you may find you need to transform MixedCase or camelCasedWords into a
        path; for readability, OS policies, or other reasons, you also need to
        lower case this, and you want to separate the words using a dash (&#39;-&#39;).
        An inflector can do this for you.
     Zend_Filter_Inflector  implements
         Zend_Filter_Interface ; you perform inflection by calling
         filter()  on the object instance.
     Transforming MixedCase and camelCaseText to another format &lt;?php
$inflector = new Zend_Filter_Inflector(&#39;pages/:page.:suffix&#39;);
$inflector-&gt;setRules(array(
    &#39;:page&#39;  =&gt; array(&#39;Word_CamelCaseToDash&#39;, &#39;StringToLower&#39;),
    &#39;suffix&#39; =&gt; &#39;html&#39;
));

$string   = &#39;camelCasedWords&#39;;
$filtered = $inflector-&gt;filter(array(&#39;page&#39; =&gt; $string)); // pages/camel-cased-words.html

$string   = &#39;this_is_not_camel_cased&#39;;
$filtered = $inflector-&gt;filter(array(&#39;page&#39; =&gt; $string)); // pages/this_is_not_camel_cased.html
?&gt; Operation 
            An inflector requires a  target  and one or more
             rules . A target is basically a string that
            defines placeholders for variables you wish to substitute. These are
            specified by prefixing with a &#39;:&#39;:  :script .
         
            When calling  filter() , you then pass in an array of
            key/value pairs corresponding to the variables in the target.
         
            Each variable in the target can have zero or more rules associated
            with them. Rules may be either  static  or refer to a
             Zend_Filter  class. Static rules will replace with the
            text provided. Otherwise, a class matching the rule provided will be
            used to inflect the text. Classes are typically specified using a
            short name indicating the filter name stripped of any common prefix.
         
            As an example, you can use any  Zend_Filter  concrete
            implementations; however, instead of referring to them as
            &#39;Zend_Filter_Alpha&#39; or &#39;Zend_Filter_StringToLower&#39;, you&#39;d specify
            only &#39;Alpha&#39; or &#39;StringToLower&#39;.
         Setting Paths To Alternate Filters Zend_Filter_Inflector  uses
             Zend_Loader_PluginLoader  to manage loading filters to
            use with inflection. By default, any filter prefixed with
             Zend_Filter  will be available. To access filters with
            that prefix but which occur deeper in the hierarchy, such as the
            various Word filters, simply strip off the Zend_Filter prefix:
         &lt;?php
// use Zend_Filter_Word_CamelCaseToDash as a rule
$inflector-&gt;addRules(array(&#39;script&#39; =&gt; &#39;Word_CamelCaseToDash&#39;));
?&gt; 
            To set alternate paths,  Zend_Filter_Inflector  has a
            utility method that proxies to the plugin loader,
             addFilterPrefixPath() :
         &lt;?php
$inflector-&gt;addFilterPrefixPath(&#39;My_Filter&#39;, &#39;My/Filter/&#39;);
?&gt; 
            Alternatively, you can retrieve the plugin loader from the
            inflector, and interact with it directly:
         &lt;?php
$loader = $inflector-&gt;getPluginLoader();
$loader-&gt;addPrefixPath(&#39;My_Filter&#39;, &#39;My/Filter/&#39;);
?&gt; 
            For more options on modifying the paths to filters, please see  the PluginLoader
                documentation .
         Setting the Inflector Target 
            The inflector target is a string with some placeholders for
            variables. Placeholders take the form of an identifier, a colon
            (&#39;:&#39;) by default, followed by a variable name: &#39;:script&#39;, &#39;:path&#39;,
            etc. The  filter()  method looks for the identifier
            followed by the variable name being replaced.
         
            You can change the identifier using the
             setTargetReplacementIdentifier()  method, or passing it
            as the third argument to the constructor:
         &lt;?php
// Via constructor:
$inflector = new Zend_Filter_Inflector(&#39;#foo/#bar.#sfx&#39;, null, &#39;#&#39;);

// Via accessor:
$inflector-&gt;setTargetReplacementIdentifier(&#39;#&#39;);
?&gt; 
            Typically, you will set the target via the constructor. However, you
            may want to re-set the target later (for instance, to modify the
            default inflector in core components, such as the
             ViewRenderer  or  Zend_Layout ).
             setTarget()  can be used for this purpose:
         &lt;?php
$inflector = $layout-&gt;getInflector();
$inflector-&gt;setTarget(&#39;layouts/:script.phtml&#39;);
?&gt; 
            Additionally, you may wish to have a class member for your class
            that you can use to keep the inflector target updated -- without
            needing to directly update the target each time (thus saving on
            method calls).  setTargetReference()  allows you to do
            this:
         &lt;?php
class Foo
{
    /**
     * @var string Inflector target
     */
    protected $_target = &#39;foo/:bar/:baz.:suffix&#39;;

    /**
     * Constructor
     * @return void
     */
    public function __construct()
    {
        $this-&gt;_inflector = new Zend_Filter_Inflector();
        $this-&gt;_inflector-&gt;setTargetReference($this-&gt;_target);
    }

    /**
     * Set target; updates target in inflector
     * 
     * @param  string $target 
     * @return Foo
     */
    public function setTarget($target)
    {
        $this-&gt;_target = $target;
        return $this;
    }
}
?&gt; Inflection Rules 
            As mentioned in the introduction, there are two types of rules:
            static and filter-based.
         
	            It is important to note that regardless of the method in which you add 
	            rules to the inflector, either one-by-one, or all-at-once; the order is very
	            important.  More specific names, or names that might contain other rule names,
	            must be added before least specific names.  For example, assuming the two rule
	            names &#39;moduleDir&#39; and &#39;module&#39;, the &#39;moduleDir&#39; rule should appear before module
	            since &#39;module&#39; is contained within &#39;moduleDir&#39;.  If &#39;module&#39; were added before
	            &#39;moduleDir&#39;, &#39;module&#39; will match part of &#39;moduleDir&#39; and process it leaving &#39;Dir&#39;
	            inside of the target uninflected.
             Static Rules 
                Static rules do simple string substitution; use them when you
                have a segment in the target that will typically be static, but
                which you want to allow the developer to modify. Use the
                 setStaticRule()  method to set or modify the rule:
             &lt;?php
$inflector = new Zend_Filter_Inflector(&#39;:script.:suffix&#39;);
$inflector-&gt;setStaticRule(&#39;suffix&#39;, &#39;phtml&#39;);

// change it later:
$inflector-&gt;setStaticRule(&#39;suffix&#39;, &#39;php&#39;);
?&gt; 
                Much like the target itself, you can also bind a static rule to
                a reference, allowing you to update a single variable instead of
                require a method call; this is often useful when your class uses
                an inflector internally, and you don&#39;t want your users to need
                to fetch the inflector in order to update it. The
                 setStaticRuleReference()  method is used to
                accomplish this:
             &lt;?php
class Foo
{
    /**
     * @var string Suffix
     */
    protected $_suffix = &#39;phtml&#39;;

    /**
     * Constructor
     * @return void
     */
    public function __construct()
    {
        $this-&gt;_inflector = new Zend_Filter_Inflector(&#39;:script.:suffix&#39;);
        $this-&gt;_inflector-&gt;setStaticRuleReference(&#39;suffix&#39;, $this-&gt;_suffix);
    }

    /**
     * Set suffix; updates suffix static rule in inflector
     * 
     * @param  string $suffix 
     * @return Foo
     */
    public function setSuffix($suffix)
    {
        $this-&gt;_suffix = $suffix;
        return $this;
    }
}
?&gt; Filter Inflector Rules Zend_Filter  filters may be used as inflector rules
                as well. Just like static rules, these are bound to a target
                variable; unlike static rules, you may define multiple filters
                to use when inflecting. These filters are processed in order, so
                be careful to register them in an order that makes sense for the
                data you receive.
             
                Rules may be added using  setFilterRule()  (which
                overwrites any previous rules for that variable) or
                 addFilterRule()  (which appends the new rule to any
                existing rule for that variable). Filters are specified in one
                of the following ways:
             String . The string may be a filter
                        class name, or a class name segment minus any prefix set
                        in the inflector&#39;s plugin loader (by default, minus the
                        &#39;Zend_Filter&#39; prefix).
                 Filter object . Any object instance
                        implementing  Zend_Filter_Interface  may be
                        passed as a filter.
                 Array . An array of one or more
                        strings or filter objects as defined above.
                 &lt;?php
$inflector = new Zend_Filter_Inflector(&#39;:script.:suffix&#39;);

// Set rule to use Zend_Filter_Word_CamelCaseToDash filter
$inflector-&gt;setFilterRule(&#39;script&#39;, &#39;Word_CamelCaseToDash&#39;);

// Add rule to lowercase string
$inflector-&gt;addFilterRule(&#39;script&#39;, new Zend_Filter_StringToLower());

// Set rules en-masse
$inflector-&gt;setFilterRule(&#39;script&#39;, array(
    &#39;Word_CamelCaseToDash&#39;,
    new Zend_Filter_StringToLower()
));
?&gt; Setting Many Rules At Once 
                Typically, it&#39;s easier to set many rules at once than to
                configure a single variable and its inflection rules at a time.
                 Zend_Filter_Inflector &#39;s  addRules()  and
                 setRules()  method allow this.
             
                Each method takes an array of variable/rule pairs, where the
                rule may be whatever the type of rule accepts (string, filter
                object, or array). Variable names accept a special notation to
                allow setting static rules and filter rules, according to the
                following notation:
             &#39;:&#39; prefix : filter rules.
                 No prefix : static rule.
                 Setting Multiple Rules at Once &lt;?php
// Could also use setRules() with this notation:
$inflector-&gt;addRules(array(
    // filter rules:
    &#39;:controller&#39; =&gt; array(&#39;CamelCaseToUnderscore&#39;,&#39;StringToLower&#39;),
    &#39;:action&#39;     =&gt; array(&#39;CamelCaseToUnderscore&#39;,&#39;StringToLower&#39;),

    // Static rule:
    &#39;suffix&#39;      =&gt; &#39;phtml&#39;
));
?&gt; Utility Methods Zend_Filter_Inflector  has a number of utility methods
            for retrieving and setting the plugin loader, manipulating and
            retrieving rules, and controlling if and when exceptions are thrown.
         setPluginLoader()  can be used when you have
                    configured your own plugin loader and wish to use it with
                     Zend_Filter_Inflector ;
                     getPluginLoader()  retrieves the currently set
                    one.
             setThrowTargetExceptionsOn()  can be used to
                    control whether or not  filter()  throws an
                    exception when a given replacement identifier passed to it
                    is not found in the target. By default, no exceptions are
                    thrown.  isThrowTargetExceptionsOn()  will tell
                    you what the current value is.
             getRules($spec = null)  can be used to retrieve all
                    registered rules for all variables, or just the rules for a
                    single variable.
             getRule($spec, $index)  fetches a single rule
                    for a given variable; this can be useful for fetching a
                    specific filter rule for a variable that has a filter chain.
                     $index  must be passed.
             clearRules()  will clear all currently
                    registered rules.
             Using Zend_Config with Zend_Filter_Inflector 
            You can use  Zend_Config  to set rules, filter prefix
            paths, and other object state in your inflectors, either by passing
            a  Zend_Config  object to the constructor or  setConfig() .
            The following settings may be specified:
         target  specifies the inflection target.
             filterPrefixPath  specifies one or more filter
                    prefix/path pairs for use with the inflector.
             throwTargetExceptionsOn  should be a boolean
                    indicating whether or not to throw exceptions when a
                    replacement identifier is still present after inflection.
             targetReplacementIdentifier  specifies the
                    character to use when identifiying replacement variables in
                    the target string.
             rules  specifies an array of inflection rules;
                    it should consist of keys that specify either values or
                    arrays of values, consistent with  addRules() .
             Using Zend_Config with Zend_Filter_Inflector &lt;?php
// With the constructor:
$config    = new Zend_Config($options);
$inflector = new Zend_Filter_Inflector($config);

// Or with setConfig():
$inflector = new Zend_Filter_Inflector();
$inflector-&gt;setConfig($config);
?&gt; Standard Filter Classes 
        The Zend Framework comes with a standard set of filters, which are ready for you to use.
     Alnum 
            Returns the string  $value , removing all but alphabetic and digit characters. This filter
            includes an option to also allow white space characters.
         Alpha 
            Returns the string  $value , removing all but alphabetic characters. This filter includes an
            option to also allow white space characters.
         BaseName 
            Given a string containing a path to a file, this filter will return the base
            name of the file
         Digits 
            Returns the string  $value , removing all but digit characters.
         Dir 
            Returns directory name component of path.
         HtmlEntities 
            Returns the string  $value , converting characters to their corresponding
            HTML entity equivalents where they exist.
         Int 
            Returns (int)  $value 
         RealPath 
            Expands all symbolic links and resolves references to &#39;/./&#39;, &#39;/../&#39; and extra &#39;/&#39;
            characters in the input path and return the canonicalized absolute pathname. The resulting
            path will have no symbolic link, &#39;/./&#39; or &#39;/../&#39; components.
         Zend_Filter_RealPath  will return  FALSE 
            on failure, e.g. if the file does not exist. On BSD systems  Zend_Filter_RealPath 
            doesn&#39;t fail if only the last path component doesn&#39;t exist, while other systems will return
             FALSE .
         StringToLower 
            Returns the string  $value , converting alphabetic characters to lowercase as necessary.
         StringToUpper 
            Returns the string  $value , converting alphabetic characters to uppercase as necessary.
         StringTrim 
            Returns the string  $value  with characters stripped from the beginning and end.
         StripTags 
            This filter returns the input string, with all HTML and PHP tags stripped from it, except those that have
            been explicitly allowed. In addition to the ability to specify which tags are allowed, developers can
            specify which attributes are allowed across all allowed tags and for specific tags only. Finally, this
            filter offers control over whether comments (e.g.,  &lt;!-- ... --&gt; ) are removed or
            allowed.
         Writing Filters 
        Zend_Filter supplies a set of commonly needed filters, but developers will often need to write custom
        filters for their particular use cases. The task of writing a custom filter is facilitated by
        implementing  Zend_Filter_Interface .
     Zend_Filter_Interface  defines a single method,  filter() , that may be
        implemented by user classes. An object that implements this interface may be added to a filter chain
        with  Zend_Filter::addFilter() .
     
        The following example demonstrates how to write a custom filter:

         &lt;?php
require_once &#39;Zend/Filter/Interface.php&#39;;

class MyFilter implements Zend_Filter_Interface
{
    public function filter($value)
    {
        // perform some transformation upon $value to arrive on $valueFiltered

        return $valueFiltered;
    }
}
         

     
        To add an instance of the above filter to a filter chain:

         &lt;?php
$filterChain = new Zend_Filter();
$filterChain-&gt;addFilter(new MyFilter());
         

     Introduction 
        The Zend_Filter component provides a set of commonly needed data
        filters. It also provides a simple filter chaining mechanism by which
        multiple filters may be applied to a single datum in a user-defined
        order.
     What is a filter? 
            In the physical world, a filter is typically used for removing
            unwanted portions of input, and the desired portion of the input
            passes through as filter output (e.g., coffee). In such scenarios,
            a filter is an operator that produces a subset of the input. This
            type of filtering is useful for web applications - removing illegal
            input, trimming unnecessary white space, etc.
         
            This basic definition of a filter may be extended to include
            generalized transformations upon input.  A common transformation
            applied in web applications is the escaping of HTML entities. For
            example, if a form field is automatically populated with untrusted
            input (e.g., from a web browser), this value should either be free
            of HTML entities or contain only escaped HTML entities, in order to
            prevent undesired behavior and security vulnerabilities. To meet
            this requirement, HTML entities that appear in the input must
            either be removed or escaped. Of course, which approach is more
            appropriate depends on the situation. A filter that removes the
            HTML entities operates within the scope of the first definition of
            filter - an operator that produces a subset of the input. A filter
            that escapes the HTML entities, however, transforms the input
            (e.g., &quot; &amp; &quot; is transformed to
            &quot; &amp;amp; &quot;). Supporting such use cases for web
            developers is important, and &quot;to filter,&quot; in the context of using
            Zend_Filter, means to perform some transformations upon input data.
         Basic usage of filters 
            Having this filter definition established provides the foundation
            for  Zend_Filter_Interface , which requires a single
            method named  filter()  to be implemented by a filter
            class.
         
            Following is a basic example of using a filter upon two input data,
            the ampersand ( &amp; ) and double quote
            ( &quot; ) characters:

             &lt;?php
require_once &#39;Zend/Filter/HtmlEntities.php&#39;;

$htmlEntities = new Zend_Filter_HtmlEntities();

echo $htmlEntities-&gt;filter(&#39;&amp;&#39;); // &amp;amp;
echo $htmlEntities-&gt;filter(&#39;&quot;&#39;); // &amp;quot;
             

         Using the static  get()  method 
            If it&#39;s inconvenient to load a given filter class and create an
            instance of the filter, you can use the static method
             Zend_Filter::get()  as an alternative invocation style.
            The first argument of this method is a data input value, that you
            would pass to the  filter()  method.  The second
            argument is a string, which corresponds to the basename of the
            filter class, relative to the Zend_Filter namespace.  The
             get()  method automatically loads the class, creates an
            instance, and applies the  filter()  method to the data
            input.

             &lt;?php
require_once &#39;Zend/Filter.php&#39;;

echo Zend_Filter::get(&#39;&amp;&#39;, &#39;HtmlEntities&#39;);
             

         
            You can also pass an array of constructor arguments, if they
            are needed for the filter class.

             &lt;?php
require_once &#39;Zend/Filter.php&#39;;

echo Zend_Filter::get(&#39;&quot;&#39;, &#39;HtmlEntities&#39;, array(ENT_QUOTES));
             

         
            The static usage can be convenient for invoking a filter ad hoc,
            but if you have the need to run a filter for multiple inputs,
            it&#39;s more efficient to follow the first example above,
            creating an instance of the filter object and calling its
             filter()  method.
         
            Also, the Zend_Filter_Input class allows you to instantiate and run
            multiple filter and validator classes on demand to process
            sets of input data.  See  .
         Zend_Filter_Input 
        Zend_Filter_Input provides a declarative interface to associate
        multiple filters and validators, apply them to collections of data, and
        to retrieve input values after they have been processed by the filters
        and validators.  Values are returned in escaped format by default for
        safe HTML output.
     
        Consider the metaphor that this class is a cage for external data.
        Data enter the application from external sources, such as HTTP request
        parameters, HTTP headers, a web service, or even read from a database
        or another file.  Data are first put into the cage, and subsequently
        the application can access data only by telling the cage what the data
        should be and how they plan to use it.  The cage inspects the data for
        validity.  It might apply escaping to the data values for the
        appropriate context.  The cage releases data only if it can fulfill
        these responsibilities.  With a simple and convenient interface, it
        encourages good programming habits and makes developers think about how
        data are used.
     Filters  transform input
                values, by removing or changing characters within the value.
                The goal is to &quot;normalize&quot; input values until they match an
                expected format.  For example, if a string of numeric digits is
                needed, and the input value is &quot;abc123&quot;, then it might be a
                reasonable transformation to change the value to the string
                &quot;123&quot;.
             Validators  check input
                values against criteria and report whether they passed the test
                or not.  The value is not changed, but the check may fail.  For
                example, if a string must look like an email address, and the
                input value is &quot;abc123&quot;, then the value is not considered
                valid.
             Escapers  transform a value
                by removing magic behavior of certain characters.  In some
                output contexts, special characters have meaning.  For example,
                the characters &#39;&lt;&#39; and &#39;&gt;&#39; delimit HTML tags, and if a
                string containing those characters is output in an HTML
                context, the content between them might affect the output or
                functionality of the HTML presentation.  Escaping the
                characters removes the special meaning, so they are output as
                literal characters.
             
        To use Zend_Filter_Input, perform the following steps:
     
                Declare filter and validator rules
             
                Create the filter and validator processor
             
                Provide input data
             
                Retrieve validated fields and other reports
             
        The following sections describe the steps for using this class.
     Declaring Filter and Validator Rules 
            Before creating an instance of Zend_Filter_Input, declare an
            array of filter rules and and an array of validator rules.
            This associative array maps a rule name to a filter or
            validator or a chain of filters or validators.
         
            The following example filter rule set that declares the field
            &#39;month&#39; is filtered by Zend_Filter_Digits, and the field &#39;account&#39;
            is filtered by Zend_Filter_StringTrim.  Then a validation rule set
            declares that the field &#39;account&#39; is valid only if it contains only
            alphabetical characters.
         &lt;?php
$filters = array(
    &#39;month&#39;   =&gt; &#39;Digits&#39;,
    &#39;account&#39; =&gt; &#39;StringTrim&#39;
);

$validators = array(
    &#39;account&#39; =&gt; &#39;Alpha&#39;
);
         
            Each key in the  $filters  array above is the name of a rule for applying a
            filter to a specific data field.  By default, the name of the rule
            is also the name of the input data field to which to apply the
            rule.
         
            You can declare a rule in several formats:
         
                    A single string scalar, which is mapped to a class name.
                     &lt;?php
$validators = array(
    &#39;month&#39;   =&gt; &#39;Digits&#39;,
);
                     
                 
                    An object instance of one of the classes that implement
                    Zend_Filter_Interface or Zend_Validate_Interface.
                     &lt;?php
$digits = new Zend_Validate_Digits();

$validators = array(
    &#39;month&#39;   =&gt; $digits
);
                     
                 
                    An array, to declare a chain of filters or validators.
                    The elements of this array can be strings mapping to class
                    names or filter/validator objects, as in the cases
                    described above.  In addition, you can use a third choice:
                    an array containing a string mapping to the class name
                    followed by arguments to pass to its constructor.

                     &lt;?php
$validators = array(
    &#39;month&#39;   =&gt; array(
        &#39;Digits&#39;,                // string
        new Zend_Validate_Int(), // object instance
        array(&#39;Between&#39;, 1, 12)  // string with constructor arguments
    )
);
                     
                 
                If you declare a filter or validator with constructor arguments
                in an array, then you must make an array for the rule, even if
                the rule has only one filter or validator.
             
            You can use a special &quot;wildcard&quot; rule key  &#39;*&#39;  in
            either the filters array or the validators array.  This means that
            the filters or validators declared in this rule will be applied to
            all input data fields.  Note that the order of entries in the
            filters array or validators array is significant; the rules are
            applied in the same order in which you declare them.
         &lt;?php
$filters = array(
    &#39;*&#39;     =&gt; &#39;StringTrim&#39;,
    &#39;month&#39; =&gt; &#39;Digits&#39;
);
         Creating the Filter and Validator Processor 
            After declaring the filters and validators arrays, use them as
            arguments in the constructor of Zend_Filter_Input.  This returns an
            object that knows all your filtering and validating rules, and you
            can use this object to process one or more sets of input data.
         &lt;?php
$input = new Zend_Filter_Input($filters, $validators);
         
            You can specify input data as the third constructor argument.  The
            data structure is an associative array.  The keys are field names,
            and the values are data values.  The standard  $_GET 
            and  $_POST  superglobal variables in PHP are examples
            of this format.  You can use either of these variables as input
            data for Zend_Filter_Input.
         &lt;?php
$data = $_GET;

$input = new Zend_Filter_Input($filters, $validators, $data);
         
            Alternatively, use the  setData()  method, passing
            an associative array of key/value pairs the same format as
            described above.
         &lt;?php
$input = new Zend_Filter_Input($filters, $validators);
$input-&gt;setData($newData);
         
            The  setData()  method redefines data in an existing
            Zend_Filter_Input object without changing the filtering and
            validation rules.  Using this method, you can run the same rules
            against different sets of input data.
         Retrieving Validated Fields and other Reports 
            After you have declared filters and validators and created the
            input processor, you can retrieve reports of missing, unknown, and
            invalid fields.  You also can get the values of fields after
            filters have been applied.
         Querying if the input is valid 
                If all input data pass the validation rules, the
                 isValid()  method returns  true .
                If any field is invalid or any required field is missing,
                 isValid()  returns  false .
             &lt;?php
if ($input-&gt;isValid()) {
  echo &quot;OK\n&quot;;
}
             
                This method accepts an optional string argument, naming
                an individual field.  If the specified field passed validation
                and is ready for fetching,  isValid(&#39;fieldName&#39;) 
                returns  true .
             &lt;?php
if ($input-&gt;isValid(&#39;month&#39;)) {
  echo &quot;Field &#39;month&#39; is OK\n&quot;;
}
             Getting Invalid, Missing, or Unknown Fields Invalid  fields are
                        those that don&#39;t pass one or more of their validation
                        checks.
                     Missing  fields are
                        those that are not present in the input data, but were
                        declared with the metacommand
                         &#39;presence&#39;=&gt;&#39;required&#39;  (see the
                         later section 
                        on metacommands).
                     Unknown  fields are
                        those that are not declared in any rule in the array of
                        validators, but appear in the input data.
                     &lt;?php
if ($input-&gt;hasInvalid() || $input-&gt;hasMissing()) {
  $messages = $input-&gt;getMessages();
}

// getMessages() simply returns the merge of getInvalid() and getMissing()

if ($input-&gt;hasInvalid()) {
  $invalidFields = $input-&gt;getInvalid();
}

if ($input-&gt;hasMissing()) {
  $missingFields = $input-&gt;getMissing();
}

if ($input-&gt;hasUnknown()) {
  $unknownFields = $input-&gt;getUnknown();
}
             
                The results of the  getMessages()  method is an
                associative array, mapping a rule name to an array of error
                messages related to that rule.  Note that the index of this
                array is the rule name used in the rule declaration, which may
                be different from the names of fields checked by the rule.
             
                The  getMessages()  method returns the merge of the
                arrays returned by the  getInvalid()  and
                 getMissing() .  These methods return subsets of the
                messages, related to validation failures, or fields that were
                declared as required but missing from the input.
             
                The  getErrors()  method returns an associative array,
                mapping a rule name to an array of error identifiers.  Error
                identifiers are fixed strings, to identify the reason for a
                validation failure, while messages can be customized.
                See   for
                more information.
             
                You can specify the message returned by
                 getMissing()  using the &#39;missingMessage&#39; option,
                as an argument to the Zend_Filter_Input constructor or using
                the  setOptions()  method.
             &lt;?php
$options = array(
    &#39;missingMessage&#39; =&gt; &quot;Field &#39;%field%&#39; is required&quot;
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);

// alternative method:

$input = new Zend_Filter_Input($filters, $validators, $data);
$input-&gt;setOptions($options);
             
                The results of the  getUnknown()  method is an
                associative array, mapping field names to field values.  Field
                names are used as the array keys in this case, instead of rule
                names, because no rule mentions the fields considered to be
                unknown fields.
             Getting Valid Fields 
                All fields that are neither invalid, missing, nor unknown are
                considered valid.  You can get values for valid fields using a
                magic accessor.  There are also non-magic accessor methods
                 getEscaped()  and  getUnescaped() .
             &lt;?php
$m = $input-&gt;month;                 // escaped output from magic accessor
$m = $input-&gt;getEscaped(&#39;month&#39;);   // escaped output
$m = $input-&gt;getUnescaped(&#39;month&#39;); // not escaped
             
                By default, when retrieving a value, it is filtered with the
                Zend_Filter_HtmlEntities.  This is the default because it is
                considered the most common usage to output the value of a field
                in HTML.  The HtmlEntities filter helps prevent unintentional
                output of code, which can result in security problems.
             
                    As shown above, you can retrieve the unescaped value using
                    the  getUnescaped()  method, but you must write
                    code to use the value safely, and avoid security issues
                    such as vulnerability to cross-site scripting attacks.
                 
                You can specify a different filter for escaping values, by
                specifying it in the constructor options array:
             &lt;?php
$options = array(&#39;escapeFilter&#39; =&gt; &#39;StringTrim&#39;);
$input = new Zend_Filter_Input($filters, $validators, $data, $options);
             
                Alternatively, you can use the
                 setDefaultEscapeFilter()  method:
             &lt;?php
$input = new Zend_Filter_Input($filters, $validators, $data);
$input-&gt;setDefaultEscapeFilter(new Zend_Filter_StringTrim());
             
                In either usage, you can specify the escape filter as a string
                base name of the filter class, or as an object instance of a
                filter class.  The escape filter can be an instance of a filter
                chain, an object of the class Zend_Filter.
             
                Filters to escape output should be run in this way, to make
                sure they run after validation.  Other filters you declare in
                the array of filter rules are applied to input data before data
                are validated.  If escaping filters were run before validation,
                the process of validation would be more complex, and it would
                be harder to provide both escaped and unescaped versions of the
                data.  So it is recommended to declare filters to escape output
                using  setDefaultEscapeFilter() , not in the
                 $filters  array.
             
                There is only one method  getEscaped() , and
                therefore you can specify only one filter for escaping
                (although this filter can be a filter chain).  If you need a
                single instance of Zend_Filter_Input to return escaped output
                using more than one filtering method, you should extend
                Zend_Filter_Input and implement new methods in your subclass to
                get values in different ways.
             Using Metacommands to Control Filter or Validator Rules 
            In addition to declaring the mapping from fields to filters
            or validators, you can specify some &quot;metacommands&quot; in the array
            declarations, to control some optional behavior of
            Zend_Filter_Input.  Metacommands appear as string-indexed
            entries in a given filter or validator array value.
         The  FIELDS  metacommand 
                If the rule name for a filter or validator is different than
                the field to which it should apply, you can specify the
                field name with the &#39;fields&#39; metacommand.
             
                You can specify this metacommand using the class constant
                 Zend_Filter_Input::FIELDS  instead of the
                string.
             &lt;?php
$filters = array(
    &#39;month&#39; =&gt; array(
        &#39;Digits&#39;,        // filter name at integer index [0]
        &#39;fields&#39; =&gt; &#39;mo&#39; // field name at string index [&#39;fields&#39;]
    )
);
             
                In the example above, the filter rule applies the &#39;digits&#39;
                filter to the input field named &#39;mo&#39;.  The string &#39;month&#39;
                simply becomes a mnemonic key for this filtering rule; it is
                not used as the field name if the field is specified with the
                &#39;fields&#39; metacommand, but it is used as the rule name.
             
                The default value of the &#39;fields&#39; metacommand is the index of
                the current rule.  In the example above, if the &#39;fields&#39;
                metacommand is not specified, the rule would apply to the input
                field named &#39;month&#39;.
             
                Another use of the &#39;fields&#39; metacommand is to specify fields
                for filters or validators that require multiple fields as
                input.  If the &#39;fields&#39; metacommand is an array, the argument
                to the corresponding filter or validator is an array of the
                values of those fields.  For example, it is common for users to
                specify a password string in two fields, and they must type the
                same string in both fields.  Suppose you implement a validator
                class that takes an array argument, and returns
                 true  if all the values in the array are equal to
                each other.
             &lt;?php
$validators = array(
    &#39;password&#39; =&gt; array(
        &#39;StringEquals&#39;,
        &#39;fields&#39; =&gt; array(&#39;password1&#39;, &#39;password2&#39;)
    )
);
// Invokes hypothetical class Zend_Validate_StringEquals, passing an array argument
// containing the values of the two input data fields named &#39;password1&#39; and &#39;password2&#39;.
             
                If the validation of this rule fails, the rule key
                ( &#39;password&#39; ) is used in the return value of
                 getInvalid() , not any of the fields named in
                the &#39;fields&#39; metacommand.
             The  PRESENCE  metacommand 
                Each entry in the validator array may have a metacommand called
                &#39;presence&#39;.  If the value of this metacommand is &#39;required&#39;
                then the field must exist in the input data, or else it is
                reported as a missing field.
             
                You can specify this metacommand using the class constant
                 Zend_Filter_Input::PRESENCE  instead of the
                string.
             &lt;?php
$validators = array(
    &#39;month&#39; =&gt; array(
        &#39;digits&#39;,
        &#39;presence&#39; =&gt; &#39;required&#39;
    )
);
             
                The default value of this metacommand is &#39;optional&#39;.
             The  DEFAULT_VALUE  metacommand 
                If a field is not present in the input data, and you specify a
                value for the &#39;default&#39; metacommand for that rule, the field
                takes the value of the metacommand.
             
                You can specify this metacommand using the class constant
                 Zend_Filter_Input::DEFAULT_VALUE  instead of the
                string.
             
                This default value is assigned to the field before any of the
                validators are invoked.  The default value is applied to the
                field only for the current rule; if the same field is
                referenced in a subsequent rule, the field has no value when
                evaluating that rule.  Thus different rules can declare
                different default values for a given field.
             &lt;?php
$validators = array(
    &#39;month&#39; =&gt; array(
        &#39;digits&#39;,
        &#39;default&#39; =&gt; &#39;1&#39;
    )
);

// no value for &#39;month&#39; field
$data = array();

$input = new Zend_Filter_Input(null, $validators, $data);
echo $input-&gt;month; // echoes 1
             
                If your rule uses the  FIELDS  metacommand
                to define an array of multiple fields, you can define
                an array for the  DEFAULT_VALUE  metacommand
                and the defaults of corresponding keys are used for any
                missing fields.  If  FIELDS  defines multiple
                fields but  DEFAULT_VALUE  is a scalar, then
                that default value is used as the value for any missing
                fields in the array.
             
                There is no default value for this metacommand.
             The  ALLOW_EMPTY  metacommand 
                By default, if a field exists in the input data, then
                validators are applied to it, even if the value of the field is
                an empty string ( &#39;&#39; ).  This is likely to result in
                a failure to validate.  For example, if the validator checks
                for digit characters, and there are none because a zero-length
                string has no characters, then the validator reports the data
                as invalid.
             
                If in your case an empty string should be considered valid, you
                can set the metacommand &#39;allowEmpty&#39; to  true .
                Then the input data passes validation if it is present in the
                input data, but has the value of an empty string.
             
                You can specify this metacommand using the class constant
                 Zend_Filter_Input::ALLOW_EMPTY  instead of the
                string.
             &lt;?php
$validators = array(
    &#39;address2&#39; =&gt; array(
        &#39;Alnum&#39;,
        &#39;allowEmpty&#39; =&gt; true
    )
);
             
                The default value of this metacommand is  false .
             
                In the uncommon case that you declare a validation rule with
                no validators, but the &#39;allowEmpty&#39; metacommand is
                 false  (that is, the field is considered invalid if
                it is empty), Zend_Filter_Input returns a default error message
                that you can retrieve with  getMessages() .  You can
                specify this message using the &#39;notEmptyMessage&#39; option, as an
                argument to the Zend_Filter_Input constructor or using the
                 setOptions()  method.
             &lt;?php
$options = array(
    &#39;notEmptyMessage&#39; =&gt; &quot;A non-empty value is required for field &#39;%field%&#39;&quot;
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);

// alternative method:

$input = new Zend_Filter_Input($filters, $validators, $data);
$input-&gt;setOptions($options);
             The  BREAK_CHAIN  metacommand 
                By default if a rule has more than one validator, all
                validators are applied to the input, and the resulting messages
                contain all error messages caused by the input.
             
                Alternatively, if the value of the &#39;breakChainOnFailure&#39;
                metacommand is  true , the validator chain
                terminates after the first validator fails.  The input data is
                not checked against subsequent validators in the chain, so it
                might cause more violations even if you correct the one
                reported.
             
                You can specify this metacommand using the class constant
                 Zend_Filter_Input::BREAK_CHAIN  instead of the
                string.
             &lt;?php
$validators = array(
    &#39;month&#39; =&gt; array(
        &#39;Digits&#39;,
        new Zend_Validate_Between(1,12),
        new Zend_Validate_GreaterThan(0),
        &#39;breakChainOnFailure&#39; =&gt; true
    )
);
$input = new Zend_Filter_Input(null, $validators);
             
                The default value of this metacommand is  false .
             
                The validator chain class, Zend_Validate, is more flexible with
                respect to breaking chain execution than Zend_Filter_Input.
                With the former class, you can set the option to break the
                chain on failure independently for each validator in the chain.
                With the latter class, the defined value of the
                &#39;breakChainOnFailure&#39; metacommand for a rule applies uniformly
                for all validators in the rule.  If you require the more
                flexible usage, you should create the validator chain yourself,
                and use it as an object in the validator rule
                definition:
             &lt;?php
// Create validator chain with non-uniform breakChainOnFailure attributes
$chain = new Zend_Validate();
$chain-&gt;addValidator(new Zend_Validate_Digits(), true);
$chain-&gt;addValidator(new Zend_Validate_Between(1,12), false);
$chain-&gt;addValidator(new Zend_Validate_GreaterThan(0), true);

// Declare validator rule using the chain defined above
$validators = array(
    &#39;month&#39; =&gt; $chain
);
$input = new Zend_Filter_Input(null, $validators);
             The  MESSAGES  metacommand 
                You can specify error messages for each validator in a rule
                using the metacommand &#39;messages&#39;.  The value of this metacommand
                varies based on whether you have multiple validators in the
                rule, or if you want to set the message for a specific error
                condition in a given validator.
             
                You can specify this metacommand using the class constant
                 Zend_Filter_Input::MESSAGES  instead of the
                string.
             
                Below is a simple example of setting the default error message
                for a single validator.
             &lt;?php
$validators = array(
    &#39;month&#39; =&gt; array(
        &#39;digits&#39;,
        &#39;messages&#39; =&gt; &#39;A month must consist only of digits&#39;
    )
);
             
                If you have multiple validators for which you want to set the
                error message, you should use an array for the value of the
                &#39;messages&#39; metacommand.
             
                Each element of this array is applied to the validator at the
                same index position.  You can specify a message for the
                validator at position  n  by using the value
                 n  as the array index.  Thus you can allow
                some validators to use their default message, while setting the
                message for a subsequent validator in the chain.
             &lt;?php
$validators = array(
    &#39;month&#39; =&gt; array(
        &#39;digits&#39;,
        new Zend_Validate_Between(1, 12),
        &#39;messages&#39; =&gt; array(
            // use default message for validator [0]
            // set new message for validator [1]
            1 =&gt; &#39;A month value must be between 1 and 12&#39;
        )
    )
);
             
                If one of your validators has multiple error messages, they are
                identified by a message key.  There are different keys in each
                validator class, serving as identifiers for error messages that
                the respective validator class might generate.  Each validate
                class defines constants for its message keys.  You can use
                these keys in the &#39;messages&#39; metacommand by passing an
                associative array instead of a string.
             &lt;?php
$validators = array(
    &#39;month&#39; =&gt; array(
        &#39;digits&#39;, new Zend_Validate_Between(1, 12),
        &#39;messages&#39; =&gt; array(
            &#39;A month must consist only of digits&#39;,
            array(
                Zend_Validate_Between::NOT_BETWEEN =&gt;
                    &#39;Month value %value% must be between %min% and %max%&#39;,
                Zend_Validate_Between::NOT_BETWEEN_STRICT =&gt;
                    &#39;Month value %value% must be strictly between %min% and %max%&#39;
            )
        )
    )
);
             
                You should refer to documentation for each validator class to
                know if it has multiple error messages, the keys of these
                messages, and the tokens you can use in the message templates.
             Using options to set metacommands for all rules 
                The default value for &#39;allowEmpty&#39;, &#39;breakChainOnFailure&#39;, and
                &#39;presence&#39; metacommands can be set for all rules using the
                 $options  argument to the constructor of
                Zend_Filter_Input.  This allows you to set the default value
                for all rules, without requiring you to set the metacommand for
                every rule.
             &lt;?php
// The default is set so all fields allow an empty string.
$options = array(&#39;allowEmpty&#39; =&gt; true);

// You can override this in a rule definition,
// if a field should not accept an empty string.
$validators = array(
    &#39;month&#39; =&gt; array(
        &#39;Digits&#39;,
        &#39;allowEmpty&#39; =&gt; false
    )
);

$input = new Zend_Filter_Input($filters, $validators, $data, $options);
             
                The &#39;fields&#39;, &#39;messages&#39;, and &#39;default&#39; metacommands cannot be
                set using this technique.
             Adding Filter Class Namespaces 
            By default, when you declare a filter or validator as a string,
            Zend_Filter_Input searches for the corresponding classes under
            the Zend_Filter or Zend_Validate namespaces.  For example,
            a filter named by the string &#39;digits&#39; is found in the class
            Zend_Filter_Digits.
         
            If you write your own filter or validator classes, or use filters
            or validators provided by a third-party, the classes may exist in
            different namespaces than Zend_Filter or Zend_Validate.  You can
            tell Zend_Filter_Input to search more namespaces.  You can specify
            namespaces in the constructor options:
         &lt;?php
$options = array(&#39;inputNamespace&#39; =&gt; &#39;My_Namespace&#39;);
$input = new Zend_Filter_Input($filters, $validators, $data, $options);
         
            Alternatively, you can use the addNamespace() method:
         &lt;?php
$input-&gt;addNamespace(&#39;Other_Namespace&#39;);

// Now the search order is:
// 1. My_Namespace
// 2. Other_Namespace
// 3. Zend_Filter
// 4. Zend_Validate
         
            You cannot remove Zend_Filter and Zend_Validate as namespaces, you
            only can add namespaces.  User-defined namespaces are searched
            first, Zend namespaces are searched last.
         Advanced Zend_Form Usage Zend_Form  has a wealth of functionality, much of it aimed
        at experienced developers. This chapter aims to document some of this
        functionality with examples and use cases.
     Array Notation 
            Many experienced web developers like to group related form elements
            using array notation in the element names. For example, if you have
            two addresses you wish to capture, a shipping and a billing address,
            you may have identical elements; by grouping them in an array, you
            can ensure they are captured separately. Take the following form,
            for example:
         
&lt;form&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;Shipping Address&lt;/legend&gt;
        &lt;dl&gt;
            &lt;dt&gt;&lt;label for=&quot;recipient&quot;&gt;Ship to:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;recipient&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;address&quot;&gt;Address:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;address&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;municipality&quot;&gt;City:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;municipality&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;province&quot;&gt;State:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;province&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;postal&quot;&gt;Postal Code:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;postal&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;
        &lt;/dl&gt;
    &lt;/fieldset&gt;

    &lt;fieldset&gt;
        &lt;legend&gt;Billing Address&lt;/legend&gt;
        &lt;dl&gt;
            &lt;dt&gt;&lt;label for=&quot;payer&quot;&gt;Bill To:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;payer&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;address&quot;&gt;Address:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;address&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;municipality&quot;&gt;City:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;municipality&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;province&quot;&gt;State:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;province&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;postal&quot;&gt;Postal Code:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;postal&quot; type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;
        &lt;/dl&gt;
    &lt;/fieldset&gt;

    &lt;dl&gt;
        &lt;dt&gt;&lt;label for=&quot;terms&quot;&gt;I agree to the Terms of Service&lt;/label&gt;&lt;/dt&gt;
        &lt;dd&gt;&lt;input name=&quot;terms&quot; type=&quot;checkbox&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

        &lt;dt&gt;&lt;/dt&gt;
        &lt;dd&gt;&lt;input name=&quot;save&quot; type=&quot;submit&quot; value=&quot;Save&quot; /&gt;&lt;/dd&gt;
    &lt;/dl&gt;
&lt;/form&gt;
 
            In this example, the billing and shipping address contain some
            identical fields, which means one would overwrite the other. We can
            solve this solution using array notation:
         
&lt;form&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;Shipping Address&lt;/legend&gt;
        &lt;dl&gt;
            &lt;dt&gt;&lt;label for=&quot;shipping-recipient&quot;&gt;Ship to:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;shipping[recipient]&quot; id=&quot;shipping-recipient&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;shipping-address&quot;&gt;Address:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;shipping[address]&quot; id=&quot;shipping-address&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;shipping-municipality&quot;&gt;City:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;shipping[municipality]&quot; id=&quot;shipping-municipality&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;shipping-province&quot;&gt;State:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;shipping[province]&quot; id=&quot;shipping-province&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;shipping-postal&quot;&gt;Postal Code:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;shipping[postal]&quot; id=&quot;shipping-postal&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;
        &lt;/dl&gt;
    &lt;/fieldset&gt;

    &lt;fieldset&gt;
        &lt;legend&gt;Billing Address&lt;/legend&gt;
        &lt;dl&gt;
            &lt;dt&gt;&lt;label for=&quot;billing-payer&quot;&gt;Bill To:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;billing[payer]&quot; id=&quot;billing-payer&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;billing-address&quot;&gt;Address:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;billing[address]&quot; id=&quot;billing-address&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;billing-municipality&quot;&gt;City:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;billing[municipality]&quot; id=&quot;billing-municipality&quot; 
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;billing-province&quot;&gt;State:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;billing[province]&quot; id=&quot;billing-province&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

            &lt;dt&gt;&lt;label for=&quot;billing-postal&quot;&gt;Postal Code:&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input name=&quot;billing[postal]&quot; id=&quot;billing-postal&quot;
                type=&quot;text&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;
        &lt;/dl&gt;
    &lt;/fieldset&gt;

    &lt;dl&gt;
        &lt;dt&gt;&lt;label for=&quot;terms&quot;&gt;I agree to the Terms of Service&lt;/label&gt;&lt;/dt&gt;
        &lt;dd&gt;&lt;input name=&quot;terms&quot; type=&quot;checkbox&quot; value=&quot;&quot; /&gt;&lt;/dd&gt;

        &lt;dt&gt;&lt;/dt&gt;
        &lt;dd&gt;&lt;input name=&quot;save&quot; type=&quot;submit&quot; value=&quot;Save&quot; /&gt;&lt;/dd&gt;
    &lt;/dl&gt;
&lt;/form&gt;
 
            In the above sample, we now get separate addresses. In the submitted
            form, we&#39;ll now have three elements, the &#39;save&#39; element for the
            submit, and then two arrays, &#39;shipping&#39; and &#39;billing&#39;, each with
            keys for their various elements.
         Zend_Form  attempts to automate this process with its
             sub forms . By
            default, sub forms render using the array notation as shown in the
            previous HTML form listing, complete with ids. The array name is
            based on the sub form name, with the keys based on the elements
            contained in the sub form. Sub forms may be nested arbitrarily deep,
            and this will create nested arrays to reflect the structure.
            Additionally, the various validation routines in
             Zend_Form  honor the array structure, ensuring that your
            form validates correctly, no matter how arbitrarily deep you nest
            your sub forms. You need do nothing to benefit from this; this
            behaviour is enabled by default.
         
            Additionally, there are facilities that allow you to turn on array
            notation conditionally, as well as specify the specific array to
            which an element or collection belongs:
         Zend_Form::setIsArray($flag) : By setting the
                    flag true, you can indicate that an entire form should be
                    treated as an array. By default, the form&#39;s name will be
                    used as the name of the array, unless
                     setElementsBelongTo()  has been called. If the
                    form has no specified name, or if
                     setElementsBelongTo()  has not been set, this
                    flag will be ignored (as there is no array name to which
                    the elements may belong).
                 
                    You may determine if a form is being treated as an array
                    using the  isArray()  accessor.
                 Zend_Form::setElementsBelongTo($array) :
                    Using this method, you can specify the name of an array to
                    which all elements of the form belong. You can determine the
                    name using the  getElementsBelongTo()  accessor.
             
            Additionally, on the element level, you can specify individual
            elements may belong to particular arrays using
             Zend_Form_Element::setBelongsTo()  method.
            However, doing this may cause issues when validating your element,
            and is not recommended in most cases. However, you may occasionally
            want to know  which  array an element belongs to,
            which you may discover using the  getBelongsTo() 
            accessor. 
         Multi-Page Forms 
            Currently, Multi-Page forms are not officially supported in
             Zend_Form ; however, most support for implementing them
            is available and can be utilized with a little extra tooling.
         
            The key to creating a multi-page form is to utilize sub forms, but
            to display only one such sub form per page. This allows you to
            submit a single sub form at a time and validate it, but not process
            the form until all sub forms are complete.
         Registration Form Example 
                Let&#39;s use a registration form as an example. For our purposes,
                we want to capture the desired username and password on the
                first page, then the user&#39;s metadata -- given name, family name,
                and location -- and finally allow them to decide what mailing
                lists, if any, they wish to subscribe to.
             
                First, let&#39;s create our own form, and define several sub forms
                within it:
             &lt;?php
class My_Form_Registration extends Zend_Form
{
    public function init()
    {
        // Create user sub form: username and password
        $user = new Zend_Form_SubForm();
        $user-&gt;addElements(array(
            new Zend_Form_Element_Text(&#39;username&#39;, array(
                &#39;required&#39;   =&gt; true,
                &#39;label&#39;      =&gt; &#39;Username:&#39;,
                &#39;filters&#39;    =&gt; array(&#39;StringTrim&#39;, &#39;StringToLower&#39;),
                &#39;validators&#39; =&gt; array(
                    &#39;Alnum&#39;,
                    array(&#39;Regex&#39;, false, array(&#39;/^[a-z][a-z0-9]{2,}$/&#39;))
                )
            )),

            new Zend_Form_Element_Password(&#39;password&#39;, array(
                &#39;required&#39;   =&gt; true,
                &#39;label&#39;      =&gt; &#39;Password:&#39;,
                &#39;filters&#39;    =&gt; array(&#39;StringTrim&#39;),
                &#39;validators&#39; =&gt; array(
                    &#39;NotEmpty&#39;,
                    array(&#39;StringLength&#39;, false, array(6))
                )
            )),
        ));

        // Create demographics sub form: given name, family name, and location
        $demog = new Zend_Form_SubForm();
        $demog-&gt;addElements(array(
            new Zend_Form_Element_Text(&#39;givenName&#39;, array(
                &#39;required&#39;   =&gt; true,
                &#39;label&#39;      =&gt; &#39;Given (First) Name:&#39;,
                &#39;filters&#39;    =&gt; array(&#39;StringTrim&#39;),
                &#39;validators&#39; =&gt; array(
                    array(&#39;Regex&#39;, false, array(&#39;/^[a-z][a-z0-9., \&#39;-]{2,}$/i&#39;))
                )
            )),

            new Zend_Form_Element_Text(&#39;familyName&#39;, array(
                &#39;required&#39;   =&gt; true,
                &#39;label&#39;      =&gt; &#39;Family (Last) Name:&#39;,
                &#39;filters&#39;    =&gt; array(&#39;StringTrim&#39;),
                &#39;validators&#39; =&gt; array(
                    array(&#39;Regex&#39;, false, array(&#39;/^[a-z][a-z0-9., \&#39;-]{2,}$/i&#39;))
                )
            )),

            new Zend_Form_Element_Text(&#39;location&#39;, array(
                &#39;required&#39;   =&gt; true,
                &#39;label&#39;      =&gt; &#39;Your Location:&#39;,
                &#39;filters&#39;    =&gt; array(&#39;StringTrim&#39;),
                &#39;validators&#39; =&gt; array(
                    array(&#39;StringLength&#39;, false, array(2))
                )
            )),
        ));

        // Create mailing lists sub form
        $listOptions = array(
            &#39;none&#39;        =&gt; &#39;No lists, please&#39;,
            &#39;fw-general&#39;  =&gt;  &#39;Zend Framework General List&#39;,
            &#39;fw-mvc&#39;      =&gt;  &#39;Zend Framework MVC List&#39;,
            &#39;fw-auth&#39;     =&gt;  &#39;Zend Framwork Authentication and ACL List&#39;,
            &#39;fw-services&#39; =&gt; &#39;Zend Framework Web Services List&#39;,
        );
        $lists = new Zend_Form_SubForm();
        $lists-&gt;addElements(array(
            new Zend_Form_Element_MultiCheckbox(&#39;subscriptions&#39;, array(
                &#39;label&#39;        =&gt; &#39;Which lists would you like to subscribe to?&#39;,
                &#39;multiOptions&#39; =&gt; $listOptions,
                &#39;required&#39;     =&gt; true,
                &#39;filters&#39;      =&gt; array(&#39;StringTrim&#39;),
                &#39;validators&#39;   =&gt; array(
                    array(&#39;InArray&#39;, false, array(array_keys($listOptions)))
                )
            )),
        ));

        // Attach sub forms to main form
        $this-&gt;addSubForms(array(
            &#39;user&#39;  =&gt; $user,
            &#39;demog&#39; =&gt; $demog,
            &#39;lists&#39; =&gt; $lists
        ));
    }
}
 
                Note that there are no submit buttons, and that we have done
                nothing with the sub form decorators -- which means that by
                default they will be displayed as fieldsets. We will need to be
                able to override these as we display each individual sub form,
                and add in submit buttons so we can actually process them --
                which will also require action and method properties. Let&#39;s add
                some scaffolding to our class to provide that information:
             
class My_Form_Registration extends Zend_Form
{
    // ...

    /**
     * Prepare a sub form for display
     * 
     * @param  string|Zend_Form_SubForm $spec 
     * @return Zend_Form_SubForm
     */
    public function prepareSubForm($spec)
    {
        if (is_string($spec)) {
            $subForm = $this-&gt;{$spec};
        } elseif ($spec instanceof Zend_Form_SubForm) {
            $subForm = $spec;
        } else {
            throw new Exception(&#39;Invalid argument passed to &#39; . __FUNCTION__ . &#39;()&#39;);
        }
        $this-&gt;setSubFormDecorators($subForm)
             -&gt;addSubmitButton($subForm)
             -&gt;addSubFormActions($subForm);
        return $subForm;
    }

    /**
     * Add form decorators to an individual sub form
     * 
     * @param  Zend_Form_SubForm $subForm
     * @return My_Form_Registration
     */
    public function setSubFormDecorators(Zend_Form_SubForm $subForm)
    {
        $subForm-&gt;setDecorators(array(
            &#39;FormElements&#39;,
            array(&#39;HtmlTag&#39;, array(&#39;tag&#39; =&gt; &#39;dl&#39;, &#39;class&#39; =&gt; &#39;zend_form&#39;)),
            &#39;Form&#39;,
        ));
        return $this;
    }

    /**
     * Add a submit button to an individual sub form
     * 
     * @param  Zend_Form_SubForm $subForm
     * @return My_Form_Registration
     */
    public function addSubmitButton(Zend_Form_SubForm $subForm)
    {
        $subForm-&gt;addElement(new Zend_Form_Element_Submit(
            &#39;save&#39;, 
            array(
                &#39;label&#39;    =&gt; &#39;Save and continue&#39;,
                &#39;required&#39; =&gt; false,
                &#39;ignore&#39;   =&gt; true,
            )
        ));
        return $this;
    }

    /**
     * Add action and method to sub form
     * 
     * @param  Zend_Form_SubForm $subForm 
     * @return My_Form_Registration
     */
    public function addSubFormActions(Zend_Form_SubForm $subForm)
    {
        $subForm-&gt;setAction(&#39;/registration/process&#39;)
                -&gt;setMethod(&#39;post&#39;);
        return $this;
    }
}
 
                Next, we need to add some scaffolding in our action controller,
                and have several considerations.  First, we need to make sure we
                persist form data between requests, so that we can determine
                when to quit.  Second, we need some logic to determine what form
                segments have already been submitted, and what sub form to
                display based on that information.  We&#39;ll use
                 Zend_Session_Namespace  to persist data, which will
                also help us answer the question of which form to submit.
             
                Let&#39;s create our controller, and add a method for retrieving a
                form instance:
             &lt;?php
class RegistrationController extends Zend_Controller_Action
{
    protected $_form;

    public function getForm()
    {
        if (null === $this-&gt;_form) {
            require_once &#39;My/Form/Registration.php&#39;;
            $this-&gt;_form = new My_Form_Registration();
        }
        return $this-&gt;_form;
    }
}
 
                Now, let&#39;s add some functionality for determining which form to
                display. Basically, until the entire form is considered valid,
                we need to continue displaying form segments. Additionally, we
                likely want to make sure they&#39;re in a particular order: user,
                demog, and then lists. We can determine what data has been
                submitted by checking our session namespace for particular keys
                representing each subform.
             
class RegistrationController extends Zend_Controller_Action
{
    // ...

    protected $_namespace = &#39;RegistrationController&#39;;
    protected $_session;

    /**
     * Get the session namespace we&#39;re using
     * 
     * @return Zend_Session_Namespace
     */
    public function getSessionNamespace()
    {
        if (null === $this-&gt;_session) {
            require_once &#39;Zend/Session/Namespace.php&#39;;
            $this-&gt;_session = new Zend_Session_Namespace($this-&gt;_namespace);
        }

        return $this-&gt;_session;
    }

    /**
     * Get a list of forms already stored in the session
     * 
     * @return array
     */
    public function getStoredForms()
    {
        $stored = array();
        foreach ($this-&gt;getSessionNamespace() as $key =&gt; $value) {
            $stored[] = $key;
        }

        return $stored;
    }

    /**
     * Get list of all subforms available
     * 
     * @return array
     */
    public function getPotentialForms()
    {
        return array_keys($this-&gt;getForm()-&gt;getSubForms());
    }

    /**
     * What sub form was submitted?
     * 
     * @return false|Zend_Form_SubForm
     */
    public function getCurrentSubForm()
    {
        $request = $this-&gt;getRequest();
        if (!$request-&gt;isPost()) {
            return false;
        }

        foreach ($this-&gt;getPotentialForms() as $name) {
            if ($data = $request-&gt;getPost($name, false)) {
                if (is_array($data)) {
                    return $this-&gt;getForm()-&gt;getSubForm($name);
                    break;
                }
            }
        }

        return false;
    }

    /**
     * Get the next sub form to display
     * 
     * @return Zend_Form_SubForm|false
     */
    public function getNextSubForm()
    {
        $storedForms    = $this-&gt;getStoredForms();
        $potentialForms = $this-&gt;getPotentialForms();

        foreach ($potentialForms as $name) {
            if (!in_array($name, $storedForms)) {
                return $this-&gt;getForm()-&gt;getSubForm($name);
            }
        }

        return false;
    }
}
 
                The above methods allow us to use notations such as &quot; $subForm =
                    $this-&gt;getCurrentSubForm(); &quot; to retrieve the current
                sub form for validation, or &quot; $next =
                    $this-&gt;getNextSubForm(); &quot; to get the next one to
                display.
             
                Now, let&#39;s figure out how to process and display the various sub
                forms. We can use  getCurrentSubForm()  to determine
                if any sub forms have been submitted (false return values
                indicate none have been displayed or submitted), and
                 getNextSubForm()  to retrieve a form to display. We
                can then use the form&#39;s  prepareSubForm()  method to
                ensure the form is ready for display.
             
                When we have a form submission, we can validate the sub form,
                and then check to see if the entire form is now valid. To do
                these tasks, we&#39;ll need additional methods that ensure that
                submitted data is added to the session, and that when validating
                the form entire, we validate against all segments from the
                session:
             &lt;?php
class My_Form_Registration extends Zend_Form
{
    // ...
    
    /**
     * Is the sub form valid?
     * 
     * @param  Zend_Form_SubForm $subForm 
     * @param  array $data 
     * @return bool
     */
    public function subFormIsValid(Zend_Form_SubForm $subForm, array $data)
    {
        $name = $subForm-&gt;getName();
        if ($subForm-&gt;isValid($data)) {
            $this-&gt;getSessionNamespace()-&gt;$name = $subForm-&gt;getValues();
            return true;
        }

        return false;
    }

    /**
     * Is the full form valid?
     * 
     * @return bool
     */
    public function formIsValid()
    {
        $data = array();
        foreach ($this-&gt;getSessionNamespace() as $key =&gt; $info) {
            $data[$key] = $info;
        }

        return $this-&gt;getForm()-&gt;isValid($data);
    }
}
 
                Now that we have the legwork out of the way, let&#39;s build the
                actions for this controller. We&#39;ll need a landing page for the
                form, and then a &#39;process&#39; action for processing the form.
             &lt;?php
class My_Form_Registration extends Zend_Form
{
    // ...

    public function indexAction()
    {
        // Either re-display the current page, or grab the &quot;next&quot; (first) 
        // sub form
        if (!$form = $this-&gt;getCurrentSubForm()) {
            $form = $this-&gt;getNextSubForm();
        }
        $this-&gt;view-&gt;form = $this-&gt;getForm()-&gt;prepareSubForm($form);
    }

    public function processAction()
    {
        if (!$form = $this-&gt;getCurrentSubForm()) {
            return $this-&gt;_forward(&#39;index&#39;);
        }

        if (!$this-&gt;subFormIsValid($form, $this-&gt;getRequest()-&gt;getPost())) {
            $this-&gt;view-&gt;form = $this-&gt;getForm()-&gt;prepareSubForm($form);
            return $this-&gt;render(&#39;index&#39;);
        }

        if (!$this-&gt;formIsValid()) {
            $form = $this-&gt;getNextSubForm();
            $this-&gt;view-&gt;form = $this-&gt;getForm()-&gt;prepareSubForm($form);
            return $this-&gt;render(&#39;index&#39;);
        }

        // Valid form!
        // Render information in a verification page
        $this-&gt;view-&gt;info = $this-&gt;getSessionNamespace();
        $this-&gt;render(&#39;verification&#39;);
    }
}
 
                As you&#39;ll notice, the actual code for processing the form is
                relatively simple. We check to see if we have a current sub form
                submission, and if not, we go back to the landing page. If we do
                have a sub form, we attempt to validate it, redisplaying it if
                it fails. If the sub form is valid, we then check to see if the
                form is valid, which would indicate we&#39;re done; if not, we
                display the next form segment. Finally, we display a
                verification page with the contents of the session.
             
                The view scripts are very simple:
             
&lt;? // registration/index.phtml ?&gt;
&lt;h2&gt;Registration&lt;/h2&gt;
&lt;?= $this-&gt;form ?&gt;

&lt;? // registration/verification.phtml ?&gt;
&lt;h2&gt;Thank you for registering!&lt;/h2&gt;
&lt;p&gt;
    Here is the information you provided:
&lt;/p&gt;

&lt;?
// Have to do this construct due to how items are stored in session namespaces
foreach ($this-&gt;info as $info):
    foreach ($info as $form =&gt; $data): ?&gt;
&lt;h4&gt;&lt;?= ucfirst($form) ?&gt;:&lt;/h4&gt;
&lt;dl&gt;
    &lt;? foreach ($data as $key =&gt; $value): ?&gt;
    &lt;dt&gt;&lt;?= ucfirst($key) ?&gt;&lt;/dt&gt;
    &lt;? if (is_array($value)):
        foreach ($value as $label =&gt; $val): ?&gt;
    &lt;dd&gt;&lt;?= $val ?&gt;&lt;/dd&gt;
        &lt;? endforeach;
       else: ?&gt;
    &lt;dd&gt;&lt;?= $this-&gt;escape($value) ?&gt;&lt;/dd&gt;
    &lt;? endif;
    endforeach; ?&gt;
&lt;/dl&gt;
&lt;? endforeach;
endforeach ?&gt;
 
                Upcoming releases of Zend Framework will include components to
                make multi page forms simpler by abstracting the session and
                ordering logic. In the meantime, the above example should serve
                as a reasonable guideline on how to accomplish this task for
                your site.
             Creating Custom Form Markup Using Zend_Form_Decorator 
        Rendering a form object is completely optional -- you do not need to use
         Zend_Form &#39;s render() methods at all. However, if you do,
        decorators are used to render the various form objects. 
     
        An arbitrary number of decorators may be attached to each item
        (elements, display groups, sub forms, or the form object itself);
        however, only one decorator of a given type may be attached to each
        item.  Decorators are called in the order they are registered. Depending
        on the decorator, it may replace the content passed to it, or append or
        prepend the content.
     
        Object state is set via configuration options passed to the constructor
        or the decorator&#39;s  setOptions()  method. When creating
        decorators via an item&#39;s  addDecorator()  or related methods,
        options may be passed as an argument to the method. These can be used to
        specify placement, a separator to use between passed in content and
        newly generated content, and whatever options the decorator supports.
     
        Before each decorator&#39;s  render()  method is called, the
        current item is set in the decorator using  setElement() ,
        giving the decorator awareness of the item being rendered. This allows
        you to create decorators that only render specific portions of the item
        -- such as the label, the value, error messages, etc. By stringing
        together several decorators that render specific element segments, you
        can build complex markup representing the entire item.
     Operation 
            To configure a decorator, pass an array of options or a
             Zend_Config  object to its constructor, an array to
             setOptions() , or a  Zend_Config  object to
             setConfig() .
         
            Standard options include:
         placement : Placement can be either &#39;append&#39; or
                    &#39;prepend&#39; (case insensitive), and indicates whether content
                    passed to  render()  will be appended or
                    prepended, respectively. In the case that a decorator
                    replaces the content, this setting is ignored. The default
                    setting is to append.
             separator : The separator is used between the
                    content passed to  render()  and new content
                    generated by the decorator, or between items rendered by the
                    decorator (e.g. FormElements uses the separator between each
                    item rendered). In the case that a decorator replaces the
                    content, this setting may be ignored. The default value is
                     PHP_EOL .
             
            The decorator interface specifies methods for interacting with
            options. These include:
         setOption($key, $value) : set a single option.
             getOption($key) : retrieve a single option
                    value.
             getOptions() : retrieve all options.
             removeOption($key) : remove a single option.
             clearOptions() : remove all options.
             
            Decorators are meant to interact with the various
             Zend_Form  class types:  Zend_Form ,
             Zend_Form_Element ,  Zend_Form_DisplayGroup ,
            and all classes deriving from them. The method
             setElement()  allows you to set the object the
            decorator is currently working with, and  getElement() 
            is used to retrieve it.
         
            Each decorator&#39;s  render()  method accepts a string,
             $content . When the first decorator is called, this
            string is typically empty, while on subsequent calls it will be
            populated. Based on the type of decorator and the options passed in,
            the decorator will either replace this string, prepend the string,
            or append the string; an optional separator will be used in the
            latter two situations.
         Standard Decorators Zend_Form  ships with many standard decorators; see
             the chapter on Standard
            Decorators  for details.
         Custom Decorators 
            If you find your rendering needs are complex or need heavy
            customization, you should consider creating a custom decorator.
         
            Decorators need only implement
             Zend_Decorator_Interface . The interface specifies the
            following:
         &lt;?php
interface Zend_Decorator_Interface
{
    public function __construct($options = null);
    public function setElement($element);
    public function getElement();
    public function setOptions(array $options);
    public function setConfig(Zend_Config $config);
    public function setOption($key, $value);
    public function getOption($key);
    public function getOptions();
    public function removeOption($key);
    public function clearOptions();
    public function render($content);
}
?&gt; 
            To make this simpler, you can simply extend
             Zend_Decorator_Abstract , which implements all methods
            except  render() . 
         
            As an example, let&#39;s say you wanted to reduce the number of
            decorators you use, and build a &quot;composite&quot; decorator that took care
            of rendering the label, element, any error messages, and description
            in an HTML  div . You might build such a &#39;Composite&#39;
            decorator as follows:
         &lt;?php
class My_Decorator_Composite extends Zend_Form_Decorator_Abstract
{
    public function buildLabel()
    {
        $element = $this-&gt;getElement();
        $label = $element-&gt;getLabel();
        if ($translator = $element-&gt;getTranslator()) {
            $label = $translator-&gt;translate($label);
        }
        if ($element-&gt;getRequired()) {
            $label .= &#39;*&#39;;
        }
        $label .= &#39;:&#39;;
        return $element-&gt;getView()-&gt;formLabel($element-&gt;getName(), $label);
    }

    public function buildInput()
    {
        $element = $this-&gt;getElement();
        $helper  = $element-&gt;helper;
        return $element-&gt;getView()-&gt;$helper(
            $element-&gt;getName(),
            $element-&gt;getValue(),
            $element-&gt;getAttribs(),
            $element-&gt;options
        );
    }

    public function buildErrors()
    {
        $element  = $this-&gt;getElement();
        $messages = $element-&gt;getMessages();
        if (empty($messages)) {
            return &#39;&#39;;
        }
        return &#39;&lt;div class=&quot;errors&quot;&gt;&#39; . $element-&gt;getView()-&gt;formErrors($messages) . &#39;&lt;/div&gt;&#39;;
    }

    public function buildDescription()
    {
        $element = $this-&gt;getElement();
        $desc    = $element-&gt;getDescription();
        if (empty($messages)) {
            return &#39;&#39;;
        }
        return &#39;&lt;div class=&quot;description&quot;&gt;&#39; . $desc . &#39;&lt;/div&gt;&#39;;
    }

    public function render($content)
    {
        $element = $this-&gt;getElement();
        if (!$element instanceof Zend_Form_Element) {
            return $content;
        }
        if (null === $element-&gt;getView()) {
            return $content;
        }

        $separator = $this-&gt;getSeparator();
        $placement = $this-&gt;getPlacement();
        $label     = $this-&gt;buildLabel();
        $input     = $this-&gt;buildInput();
        $errors    = $this-&gt;buildErrors();
        $desc      = $this-&gt;buildDescription();

        $output = &#39;&lt;div class=&quot;form element&quot;&gt;&#39;
                . $label
                . $input
                . $errors
                . $desc
                . &#39;&lt;/div&gt;&#39;

        switch ($placement) {
            case (self::PREPEND):
                return $output . $separator . $content;
            case (self::APPEND):
            default:
                return $content . $separator . $output;
        }
    }
}
?&gt; 
            You can then place this in the decorator path:
         &lt;?php
// for an element:
$element-&gt;addPrefixPath(&#39;My_Decorator&#39;, &#39;My/Decorator/&#39;, &#39;decorator&#39;);

// for all elements:
$form-&gt;addElementPrefixPath(&#39;My_Decorator&#39;, &#39;My/Decorator/&#39;, &#39;decorator&#39;);
?&gt; 
            You can then specify this decorator as &#39;Composite&#39; and attach it to
            an element:
         &lt;?php
// Overwrite existing decorators with this single one:
$element-&gt;setDecorators(array(&#39;Composite&#39;));
?&gt; 
            While this example showed how to create a decorator that renders
            complex output from several element properties, you can also create
            decorators that handle a single aspect of an element; the
            &#39;Decorator&#39; and &#39;Label&#39; decorators are excellent examples of this
            practice. Doing so allows you to mix and match decorators to achieve
            complex output -- and also override single aspects of decoration to
            customize for your needs.
         
            For example, if you wanted to simply display that an error occurred
            when validating an element, but not display each of the individual
            validation error messages, you might create your own &#39;Errors&#39;
            decorator:
         &lt;?php
class My_Decorator_Errors
{
    public function render($content = &#39;&#39;)
    {
        $output = &#39;&lt;div class=&quot;errors&quot;&gt;The value you provided was invalid;
            please try again&lt;/div&gt;&#39;;

        $placement = $this-&gt;getPlacement();
        $separator = $this-&gt;getSeparator();

        switch ($placement) {
            case &#39;PREPEND&#39;:
                return $output . $separator . $content;
            case &#39;APPEND&#39;:
            default:
                return $content . $separator . $output;
        }
    }
}
?&gt; 
            In this particular example, because the decorator&#39;s final segment,
            &#39;Errors&#39;, matches the same as  Zend_Form_Decorator_Errors ,
            it will be rendered  in place of  that decorator
            -- meaning you would not need to change any decorators to modify the
            output. By naming your decorators after existing standard
            decorators, you can modify decoration without needing to modify your
            elements&#39; decorators.
         Creating Form Elements Using Zend_Form_Element 
        A form is made of elements, which typically correspond to HTML form
        input. Zend_Form_Element encapsulates single form elements, with the
        following areas of responsibility:
     
                validation (is submitted data valid?)
             capturing of validation error codes and messages 
            filtering (how is the element escaped or normalized prior to
            validation and/or for output?)
         
            rendering (how is the element displayed?)
         
            metadata and attributes (what information further qualifies the element?)
         
        The base class,  Zend_Form_Element , has reasonable defaults
        for many cases, but it is best to extend the class for commonly used
        special purpose elements. Additionally, Zend Framework ships with a
        number of standard XHTML elements; you can read about them  in the Standard Elements
            chapter .
     Plugin Loaders Zend_Form_Element  makes use of  Zend_Loader_PluginLoader 
            to allow developers to specify locations of alternate validators,
            filters, and decorators. Each has its own plugin loader associated
            with it, and general accessors are used to retrieve and modify
            each.
         
            The following loader types are used with the various plugin loader
            methods: &#39;validate&#39;, &#39;filter&#39;, and &#39;decorator&#39;. The type names are
            case insensitive.
         
            The methods used to interact with plugin loaders are as follows:
         setPluginLoader($loader, $type) :
                 $loader  is the plugin loader object itself, while
                 $type  is one of the types specified above.  This
                sets the plugin loader for the given type to the newly
                specified loader object.
             getPluginLoader($type) : retrieves the plugin
                loader associated with  $type .
             addPrefixPath($prefix, $path, $type = null) : adds
                a prefix/path association to the loader specified by
                 $type . If  $type  is null, it will
                attempt to add the path to all loaders, by appending the prefix
                with each of &quot;_Validate&quot;, &quot;_Filter&quot;, and &quot;_Decorator&quot;; and
                appending the path with &quot;Validate/&quot;, &quot;Filter/&quot;, and
                &quot;Decorator/&quot;. If you have all your extra form element classes
                under a common hierarchy, this is a convenience method for
                setting the base prefix for them.
             addPrefixPaths(array $spec) : allows you to add
                many paths at once to one or more plugin loaders. It expects
                each array item to be an array with the keys &#39;path&#39;, &#39;prefix&#39;,
                and &#39;type&#39;.
             
            Custom validators, filters, and decorators are an easy way to share
            functionality between forms and encapsulate custom functionality.
         Custom Label 
                One common use case for plugins is to provide replacements for
                standard classes. For instance, if you want to provide a
                different implementation of the &#39;Label&#39; decorator -- for
                instance, to always append a colon -- you could create your own
                &#39;Label&#39; decorator with your own class prefix, and then add it to
                your prefix path.
             
                Let&#39;s start with a custom Label decorator. We&#39;ll give it the
                class prefix &quot;My_Decorator&quot;, and the class itself will be in the
                file &quot;My/Decorator/Label.php&quot;.
             &lt;?php
class My_Decorator_Label extends Zend_Form_Decorator_Abstract
{
    protected $_placement = &#39;PREPEND&#39;;

    public function render($content)
    {
        if (null === ($element = $this-&gt;getElement())) {
            return $content;
        }
        if (!method_exists($element, &#39;getLabel&#39;)) {
            return $content;
        }

        $label = $element-&gt;getLabel() . &#39;:&#39;;

        if (null === ($view = $element-&gt;getView())) {
            return $this-&gt;renderLabel($content, $label);
        }

        $label = $view-&gt;formLabel($element-&gt;getName(), $label);

        return $this-&gt;renderLabel($content, $label);
    }

    public function renderLabel($content, $label)
    {
        $placement = $this-&gt;getPlacement();
        $separator = $this-&gt;getSeparator();

        switch ($placement) {
            case &#39;APPEND&#39;:
                return $content . $separator . $label;
            case &#39;PREPEND&#39;:
            default:
                return $label . $separator . $content;
        }
    }
}
 
                Now we can tell the element to use this plugin path when looking
                for decorators:
             
$element-&gt;addPrefixPath(&#39;My_Decorator&#39;, &#39;My/Decorator/&#39;, &#39;decorator&#39;);
 
                Alternately, we can do that at the form level to ensure all
                decorators use this path:
             
$form-&gt;addElementPrefixPath(&#39;My_Decorator&#39;, &#39;My/Decorator/&#39;, &#39;decorator&#39;);
 
                With this path added, when you add a decorator, the
                &#39;My/Decorator/&#39; path will be searched first to see if the
                decorator exists there. As a result, &#39;My_Decorator_Label&#39; will
                now be used when the &#39;Label&#39; decorator is requested.
             Filters 
            It&#39;s often useful and/or necessary to perform some normalization on
            input prior to validation -- for instance, you may want to strip out
            all HTML, but run your validations on what remains to ensure the
            submission is valid. Or you may want to trim empty space surrounding
            input so that a StringLength validator will not return a false
            positive. These operations may be performed using
             Zend_Filter , and  Zend_Form_Element  has
            support for filter chains, allowing you to specify multiple,
            sequential filters to utilize.  Filtering happens both during
            validation and when you retrieve the element value via
             getValue() :
         &lt;?php
$filtered = $element-&gt;getValue();
?&gt; 
            Filters may be added to the chain in two ways:
         
                passing in a concrete filter instance
             
                providing a filter name -- either a short name or fully
                qualified class name
             
            Let&#39;s see some examples:
         &lt;?php
// Concrete filter instance:
$element-&gt;addFilter(new Zend_Filter_Alnum());

// Fully qualified class name:
$element-&gt;addFilter(&#39;Zend_Filter_Alnum&#39;);

// Short filter name:
$element-&gt;addFilter(&#39;Alnum&#39;);
$element-&gt;addFilter(&#39;alnum&#39;);
?&gt; 
            Short names are typically the filter name minus the prefix. In the
            default case, this will mean minus the &#39;Zend_Filter_&#39; prefix.
            Additionally, the first letter need not be upper-cased.
         Using Custom Filter Classes 
                If you have your own set of filter classes, you can tell
                 Zend_Form_Element  about these using
                 addPrefixPath() . For instance, if you have
                validators under the &#39;My_Filter&#39; prefix, you can tell
                 Zend_Form_Element  about this as follows:
             &lt;?php
$element-&gt;addPrefixPath(&#39;My_Filter&#39;, &#39;My/Filter/&#39;, &#39;filter&#39;);
?&gt; 
                (Recall that the third argument indicates which plugin loader
                on which to perform the action.)
             
            If at any time you need the unfiltered value, use the
             getUnfilteredValue()  method:
         &lt;?php
$unfiltered = $element-&gt;getUnfilteredValue();
?&gt; 
            For more information on filters, see the  Zend_Filter
                documentation .
         
            Methods associated with filters include:
         addFilter($nameOrFilter, array $options = null) addFilters(array $filters) setFilters(array $filters)  (overwrites all filters)
             getFilter($name)  (retrieve a filter object by name)
             getFilters()  (retrieve all filters)
             removeFilter($name)  (remove filter by name)
             clearFilters()  (remove all filters)
             Validators 
            If you subscribe to the security mantra of &quot;filter input, escape
            output,&quot; you&#39;ll want to validate (&quot;filter input&quot;) your form input.
            In  Zend_Form , each element includes its own validator
            chain, consisting of  Zend_Validate_*  validators.
         
            Validators may be added to the chain in two ways:
         
                passing in a concrete validator instance
             
                providing a validator name -- either a short name or fully
                qualified class name
             
            Let&#39;s see some examples:
         &lt;?php
// Concrete validator instance:
$element-&gt;addValidator(new Zend_Validate_Alnum());

// Fully qualified class name:
$element-&gt;addValidator(&#39;Zend_Validate_Alnum&#39;);

// Short validator name:
$element-&gt;addValidator(&#39;Alnum&#39;);
$element-&gt;addValidator(&#39;alnum&#39;);
?&gt; 
            Short names are typically the validator name minus the prefix. In
            the default case, this will mean minus the &#39;Zend_Validate_&#39; prefix.
            Additionally, the first letter need not be upper-cased.
         Using Custom Validator Classes 
                If you have your own set of validator classes, you can tell
                 Zend_Form_Element  about these using
                 addPrefixPath() . For instance, if you have
                validators under the &#39;My_Validator&#39; prefix, you can tell
                 Zend_Form_Element  about this as follows:
             &lt;?php
$element-&gt;addPrefixPath(&#39;My_Validator&#39;, &#39;My/Validator/&#39;, &#39;validate&#39;);
?&gt; 
                (Recall that the third argument indicates which plugin loader
                on which to perform the action.)
             
            If failing a particular validation should prevent later validators
            from firing, pass boolean  true  as the second parameter:
         &lt;?php
$element-&gt;addValidator(&#39;alnum&#39;, true);
?&gt; 
            If you are using a string name to add a validator, and the
            validator class accepts arguments to the constructor, you may pass
            these to the third parameter of  addValidator()  as an
            array:
         &lt;?php
$element-&gt;addValidator(&#39;StringLength&#39;, false, array(6, 20));
?&gt; 
            Arguments passed in this way should be in the order in which they
            are defined in the constructor. The above example will instantiate
            the  Zend_Validate_StringLenth  class with its
             $min  and  $max  parameters:
         &lt;?php
$validator = new Zend_Validate_StringLength(6, 20);
?&gt; Providing Custom Validator Error Messages 
                Some developers may wish to provide custom error messages for a
                validator.  Zend_Form_Element::addValidator() &#39;s
                 $options  argument allows you to do so by providing
                the key &#39;messages&#39; and setting it to an array of key/value pairs
                for setting the message templates. You will need to know the
                error codes of the various validation error types for the
                particular validator.
             
                A better option is to use a  Zend_Translate_Adapter 
                with your form. Error codes are automatically passed to the
                adapter by the default Errors decorator; you can then specify
                your own error message strings by setting up translations for
                the various error codes of your validators.
             
            You can also set many validators at once, using
             addValidators() . The basic usage is to pass an array
            of arrays, with each array containing 1 to 3 values, matching the
            constructor of  addValidator() :
         &lt;?php
$element-&gt;addValidators(array(
    array(&#39;NotEmpty&#39;, true),
    array(&#39;alnum&#39;),
    array(&#39;stringLength&#39;, false, array(6, 20)),
));
?&gt; 
            If you want to be more verbose or explicit, you can use the array
            keys &#39;validator&#39;, &#39;breakChainOnFailure&#39;, and &#39;options&#39;:
         &lt;?php
$element-&gt;addValidators(array(
    array(
        &#39;validator&#39;           =&gt; &#39;NotEmpty&#39;,
        &#39;breakChainOnFailure&#39; =&gt; true),
    array(&#39;validator&#39; =&gt; &#39;alnum&#39;),
    array(
        &#39;validator&#39; =&gt; &#39;stringLength&#39;,
        &#39;options&#39;   =&gt; array(6, 20)),
));
?&gt; 
            This usage is good for illustrating how you could then configure
            validators in a config file:
         
element.validators.notempty.validator = &quot;NotEmpty&quot;
element.validators.notempty.breakChainOnFailure = true
element.validators.alnum.validator = &quot;Alnum&quot;
element.validators.strlen.validator = &quot;StringLength&quot;
element.validators.strlen.options.min = 6
element.validators.strlen.options.max = 20
 
            Notice that every item has a key, whether or not it needs one; this
            is a limitation of using configuration files -- but it also helps
            make explicit what the arguments are for. Just remember that any
            validator options must be specified in order.
         
            To validate an element, pass the value to 
             isValid() :
         &lt;?php
if ($element-&gt;isValid($value)) {
    // valid
} else {
    // invalid
}
?&gt; Validation Operates On Filtered Values Zend_Form_Element::isValid()  filters values through
                the provided filter chain prior to validation. See  the Filters
                    section  for more information.
             Validation Context Zend_Form_Element::isValid()  supports an
                additional argument,  $context .
                 Zend_Form::isValid()  passes the entire array of
                data being processed to  $context  when validating a
                form, and  Zend_Form_Element::isValid() , in turn,
                passes it to each validator.  This means you can write
                validators that are aware of data passed to other form
                elements. As an example, consider a standard registration form
                that has fields for both password and a password confirmation;
                one validation would be that the two fields match. Such a
                validator might look like the following:
             &lt;?php
class My_Validate_PasswordConfirmation extends Zend_Validate_Abstract
{
    const NOT_MATCH = &#39;notMatch&#39;;

    protected $_messageTemplates = array(
        self::NOT_MATCH =&gt; &#39;Password confirmation does not match&#39;
    );

    public function isValid($value, $context = null)
    {
        $value = (string) $value;
        $this-&gt;_setValue($value);

        if (is_array($context)) {
            if (isset($context[&#39;password_confirm&#39;])
                &amp;&amp; ($value == $context[&#39;password_confirm&#39;]))
            {
                return true;
            }
        } elseif (is_string($context) &amp;&amp; ($value == $context)) {
            return true;
        }

        $this-&gt;_error(self::NOT_MATCH);
        return false;
    }
}
?&gt; 
            Validators are processed in order. Each validator is processed,
            unless a validator created with a true
             breakChainOnFailure  value fails its validation. Be
            sure to specify your validators in a reasonable order.
         
            After a failed validation, you can retrieve the error codes and
            messages from the validator chain:
         &lt;?php
$errors   = $element-&gt;getErrors();
$messages = $element-&gt;getMessages();
?&gt; 
            (Note: error messages returned are an associative array of error
            code / error message pairs.)
         
            In addition to validators, you can specify that an element is
            required, using  setRequired(true) . By default, this
            flag is false, meaning that your validator chain will be skipped if
            no value is passed to  isValid() . You can modify this
            behavior in a number of ways:
         
                    By default, when an element is required, a flag,
                    &#39;allowEmpty&#39;, is also true. This means that if a value
                    evaluating to empty is passed to  isValid() , the
                    validators will be skipped. You can toggle this flag using
                    the accessor  setAllowEmpty($flag) ; when the
                    flag is false, then if a value is passed, the validators
                    will still run.
                 
                    By default, if an element is required, but does not contain
                    a &#39;NotEmpty&#39; validator,  isValid()  will add one
                    to the top of the stack, with the
                     breakChainOnFailure  flag set. This makes the
                    required flag have semantic meaning: if no value is passed,
                    we immediately invalidate the submission and notify the
                    user, and prevent other validators from running on what we
                    already know is invalid data.
                 
                    If you do not want this behavior, you can turn it off by
                    passing a false value to
                     setAutoInsertNotEmptyValidator($flag) ; this
                    will prevent  isValid()  from placing the
                    &#39;NotEmpty&#39; validator in the validator chain.
                 
            For more information on validators, see the  Zend_Validate
                documentation .
         Using Zend_Form_Elements as general-purpose validators Zend_Form_Element  implements
                 Zend_Validate_Interface , meaning an element may
                also be used as a validator in other, non-form related
                validation chains.
             
            Methods associated with validation include:
         setRequired($flag)  and
                     isRequired()  allow you to set and retrieve the
                    status of the &#39;required&#39; flag. When set to boolean  true , this
                    flag requires that the element be in the data processed by
                     Zend_Form .
             setAllowEmpty($flag)  and
                     getAllowEmpty()  allow you to modify the
                    behaviour of optional elements (i.e., elements where the
                    required flag is false). When the &#39;allow empty&#39; flag is
                    true, empty values will not be passed to the validator
                    chain.
             setAutoInsertNotEmptyValidator($flag)  allows
                    you to specify whether or not a &#39;NotEmpty&#39; validator will be
                    prepended to the validator chain when the element is
                    required. By default, this flag is true.
             addValidator($nameOrValidator, $breakChainOnFailure = false, array $options = null) addValidators(array $validators) setValidators(array $validators)  (overwrites all validators)
             getValidator($name)  (retrieve a validator object by name)
             getValidators()  (retrieve all validators)
             removeValidator($name)  (remove validator by name)
             clearValidators()  (remove all validators)
             Decorators 
            One particular pain point for many web developers is the creation
            of the XHTML forms themselves. For each element, the developer
            needs to create markup for the element itself, typically a label,
            and, if they&#39;re being nice to their users, markup for displaying
            validation error messages. The more elements on the page, the less
            trivial this task becomes.
         Zend_Form_Element  tries to solve this issue through
            the use of &quot;decorators&quot;. Decorators are simply classes that have
            access to the element and a method for rendering content. For more
            information on how decorators work, please see the section on  Zend_Form_Decorator .
         
            The default decorators used by  Zend_Form_Element  are:
         ViewHelper : specifies a view helper to use
                to render the element. The &#39;helper&#39; element attribute can be
                used to specify which view helper to use. By default,
                 Zend_Form_Element  specifies the &#39;formText&#39; view
                helper, but individual subclasses specify different helpers.
             Errors : appends error messages to the
                element using  Zend_View_Helper_FormErrors . If none are present,
                nothing is appended.
             HtmlTag : wraps the element and errors in
                an HTML &lt;dd&gt; tag.
             Label : prepends a label to the element
                using  Zend_View_Helper_FormLabel , and wraps it in a &lt;dt&gt;
                tag. If no label is provided, just the definition term tag is
                rendered.
             Default Decorators Do Not Need to Be Loaded 
                By default, the default decorators are loaded during object
                initialization. You can disable this by passing the
                &#39;disableLoadDefaultDecorators&#39; option to the constructor:
             &lt;?php
$element = new Zend_Form_Element(&#39;foo&#39;, array(&#39;disableLoadDefaultDecorators&#39; =&gt; true));
 
                This option may be mixed with any other options you pass,
                both as array options or in a  Zend_Config  object.
             
            Since the order in which decorators are registered matters -- first
            decorator registered is executed first -- you will need to make
            sure you register your decorators in an appropriate order, or
            ensure that you set the placement options in a sane fashion. To
            give an example, here is the code that registers the default
            decorators:
         &lt;?php
$this-&gt;addDecorators(array(
    array(&#39;ViewHelper&#39;),
    array(&#39;Errors&#39;),
    array(&#39;HtmlTag&#39;, array(&#39;tag&#39; =&gt; &#39;dd&#39;)),
    array(&#39;Label&#39;, array(&#39;tag&#39; =&gt; &#39;dt&#39;)),
));
?&gt; 
            The initial content is created by the &#39;ViewHelper&#39; decorator, which
            creates the form element itself. Next, the &#39;Errors&#39; decorator
            fetches error messages from the element, and, if any are present,
            passes them to the &#39;FormErrors&#39; view helper to render.  The next
            decorator, &#39;HtmlTag&#39;, wraps the element and errors in an HTML
            &lt;dd&gt; tag.  Finally, the last decorator, &#39;label&#39;, retrieves
            the element&#39;s label and passes it to the &#39;FormLabel&#39; view helper,
            wrapping it in an HTML &lt;dt&gt; tag; the value is prepended to
            the content by default. The resulting output looks basically like
            this:
         
&lt;dt&gt;&lt;label for=&quot;foo&quot; class=&quot;optional&quot;&gt;Foo&lt;/label&gt;&lt;/dt&gt;
&lt;dd&gt;
    &lt;input type=&quot;text&quot; name=&quot;foo&quot; id=&quot;foo&quot; value=&quot;123&quot; /&gt;
    &lt;ul class=&quot;errors&quot;&gt;
        &lt;li&gt;&quot;123&quot; is not an alphanumeric value&lt;/li&gt;
    &lt;/ul&gt;
&lt;/dd&gt;
 
            For more information on decorators, read the  Zend_Form_Decorator
                section .
         Using Multiple Decorators of the Same Type 
                Internally,  Zend_Form_Element  uses a decorator&#39;s
                class as the lookup mechanism when retrieving decorators. As a
                result, you cannot register multiple decorators of the same
                type; subsequent decorators will simply overwrite those that
                existed before.
             
                To get around this, you can use  aliases .
                Instead of passing a decorator or decorator name as the first
                argument to  addDecorator() , pass an array with a
                single element, with the alias pointing to the decorator object
                or name:
             &lt;?php
// Alias to &#39;FooBar&#39;:
$element-&gt;addDecorator(array(&#39;FooBar&#39; =&gt; &#39;HtmlTag&#39;), array(&#39;tag&#39; =&gt; &#39;div&#39;));

// And retrieve later:
$decorator = $element-&gt;getDecorator(&#39;FooBar&#39;);
?&gt; 
                In the  addDecorators()  and
                 setDecorators()  methods, you will need to pass
                the &#39;decorator&#39; option in the array representing the decorator:
             &lt;?php
// Add two &#39;HtmlTag&#39; decorators, aliasing one to &#39;FooBar&#39;:
$element-&gt;addDecorators(
    array(&#39;HtmlTag&#39;, array(&#39;tag&#39; =&gt; &#39;div&#39;)),
    array(
        &#39;decorator&#39; =&gt; array(&#39;FooBar&#39; =&gt; &#39;HtmlTag&#39;),
        &#39;options&#39; =&gt; array(&#39;tag&#39; =&gt; &#39;dd&#39;)
    ),
);

// And retrieve later:
$htmlTag = $element-&gt;getDecorator(&#39;HtmlTag&#39;);
$fooBar  = $element-&gt;getDecorator(&#39;FooBar&#39;);
?&gt; 
            Methods associated with decorators include:
         addDecorator($nameOrDecorator, array $options = null) addDecorators(array $decorators) setDecorators(array $decorators)  (overwrites all decorators)
             getDecorator($name)  (retrieve a decorator object by name)
             getDecorators()  (retrieve all decorators)
             removeDecorator($name)  (remove decorator by name)
             clearDecorators()  (remove all decorators)
             Metadata and Attributes Zend_Form_Element  handles a variety of attributes and
            element metadata. Basic attributes include:
         name : the element name. Uses the
                 setName()  and  getName()  accessors.
             label : the element label. Uses the
                 setLabel()  and  getLabel()  accessors.
             order : the index at which an element
                should appear in the form. Uses the  setOrder()  and
                 getOrder()  accessors.
             value : the current element value. Uses the
                 setValue()  and  getValue()  accessors.
             description : a description of the element;
                often used to provide tooltip or javascript contextual hinting
                describing the purpose of the element. Uses the
                 setDescription()  and  getDescription() 
                accessors.
             required : flag indicating whether or not
                the element is required when performing form validation. Uses
                the  setRequired()  and  getRequired() 
                accessors. This flag is false by default.
             allowEmpty : flag indicating whether or not
                a non-required (optional) element should attempt to validate
                empty values. When true, and the required flag is false, empty
                values are not passed to the validator chain, and presumed true.
                Uses the  setAllowEmpty()  and  getAllowEmpty() 
                accessors. This flag is true by default.
             autoInsertNotEmptyValidator : flag
                indicating whether or not to insert a &#39;NotEmpty&#39; validator when
                the element is required. By default, this flag is true. Set the
                flag with  setAutoInsertNotEmptyValidator($flag)  and
                determine the value with
                 autoInsertNotEmptyValidator() .
             
            Form elements may require additional metadata. For XHTML form
            elements, for instance, you may want to specify attributes such as
            the class or id. To facilitate this are a set of accessors:
         setAttrib($name, $value) : add an attribute
             addAttribs(array $attribs) : add many
                attributes at once
             setAttribs(array $attribs) : like
                addAttribs(), but overwrites
             getAttrib($name) : retrieve a single
                attribute value
             getAttribs() : retrieve all attributes as
                key/value pairs
             removeAttrib($name) : remove a single
                attribute
             clearAttribs() : clear all attributes
             
            Most of the time, however, you can simply access them as object
            properties, as  Zend_Form_Element  utilizes overloading
            to facilitate access to them:
         &lt;?php
// Equivalent to $element-&gt;setAttrib(&#39;class&#39;, &#39;text&#39;):
$element-&gt;class = &#39;text;
?&gt; 
            By default, all attributes are passed to the view helper used by
            the element during rendering, and rendered as HTML attributes of
            the element tag.
         Standard Elements Zend_Form  ships with a number of standard elements; please read the
             Standard Elements 
            chapter for full details.
         Zend_Form_Element Methods Zend_Form_Element  has many, many methods. What follows
            is a quick summary of their signatures, grouped by type:
         Configuration: setOptions(array $options) setConfig(Zend_Config $config) I18N: setTranslator(Zend_Translate_Adapter $translator = null) getTranslator() setDisableTranslator($flag) translatorIsDisabled() Properties: setName($name) getName() setValue($value) getValue() getUnfilteredValue() setLabel($label) getLabel() setDescription($description) getDescription() setOrder($order) getOrder() setRequired($flag) getRequired() setAllowEmpty($flag) getAllowEmpty() setAutoInsertNotEmptyValidator($flag) autoInsertNotEmptyValidator() setIgnore($flag) getIgnore() getType() setAttrib($name, $value) setAttribs(array $attribs) getAttrib($name) getAttribs() Plugin loaders and paths: setPluginLoader(Zend_Loader_PluginLoader_Interface $loader, $type) getPluginLoader($type) addPrefixPath($prefix, $path, $type = null) addPrefixPaths(array $spec) Validation: addValidator($validator, $breakChainOnFailure = false, $options = array()) addValidators(array $validators) setValidators(array $validators) getValidator($name) getValidators() removeValidator($name) clearValidators() isValid($value, $context = null) getErrors() getMessages() Filters: addFilter($filter, $options = array()) addFilters(array $filters) setFilters(array $filters) getFilter($name) getFilters() removeFilter($name) clearFilters() Rendering: setView(Zend_View_Interface $view = null) getView() addDecorator($decorator, $options = null) addDecorators(array $decorators) setDecorators(array $decorators) getDecorator($name) getDecorators() removeDecorator($name) clearDecorators() render(Zend_View_Interface $view = null) Configuration Zend_Form_Element &#39;s constructor accepts either an
            array of options or a  Zend_Config  object containing
            options, and it can also be configured using either
             setOptions()  or  setConfig() . Generally
            speaking, keys are named as follows:
         
                If &#39;set&#39; + key refers to a  Zend_Form_Element 
                method, then the value provided will be passed to that method.
             
                Otherwise, the value will be used to set an attribute.
             
            Exceptions to the rule include the following:
         prefixPath  will be passed to
                 addPrefixPaths() 
             
                    The following setters cannot be set in this way:
                 setAttrib  (though
                             setAttribs   will 
                            work)
                     setConfig setOptions setPluginLoader setTranslator setView 
            As an example, here is a config file that passes configuration for
            every type of configurable data:
         
[element]
name = &quot;foo&quot;
value = &quot;foobar&quot;
label = &quot;Foo:&quot;
order = 10
required = true
allowEmpty = false
autoInsertNotEmptyValidator = true
description = &quot;Foo elements are for examples&quot;
ignore = false
attribs.id = &quot;foo&quot;
attribs.class = &quot;element&quot;
onclick = &quot;autoComplete(this, &#39;/form/autocomplete/element&#39;)&quot; ; sets &#39;onclick&#39; attribute
prefixPaths.decorator.prefix = &quot;My_Decorator&quot;
prefixPaths.decorator.path = &quot;My/Decorator/&quot;
disableTranslator = 0
validators.required.validator = &quot;NotEmpty&quot;
validators.required.breakChainOnFailure = true
validators.alpha.validator = &quot;alpha&quot;
validators.regex.validator = &quot;regex&quot;
validators.regex.options.pattern = &quot;/^[A-F].*/$&quot;
filters.ucase.filter = &quot;StringToUpper&quot;
decorators.element.decorator = &quot;ViewHelper&quot;
decorators.element.options.helper = &quot;FormText&quot;
decorators.label.decorator = &quot;Label&quot;
 Custom Elements 
            You can create your own custom elements by simply extending the
             Zend_Form_Element  class. Common reasons to do so
            include:
         
                Elements that share common validators and/or filters
             
                Elements that have custom decorator functionality
             
            There are two methods typically used to extend an element:
             init() , which can be used to add custom initialization
            logic to your element, and  loadDefaultDecorators() ,
            which can be used to set a list of default decorators used by your
            element.
         
            As an example, let&#39;s say that all text elements in a form you are
            creating need to be filtered with  StringTrim ,
            validated with a common regular expression, and that you want to
            use a custom decorator you&#39;ve created for displaying them,
            &#39;My_Decorator_TextItem&#39;; additionally, you have a number of standard
            attributes, including &#39;size&#39;, &#39;maxLength&#39;, and &#39;class&#39; you wish to
            specify. You could define such an element as follows:
         &lt;?php
class My_Element_Text extends Zend_Form_Element
{
    public function init()
    {
        $this-&gt;addPrefixPath(&#39;My_Decorator&#39;, &#39;My/Decorator/&#39;, &#39;decorator&#39;)
             -&gt;addFilters(&#39;StringTrim&#39;)
             -&gt;addValidator(&#39;Regex&#39;, false, array(&#39;/^[a-z0-9]{6,}$/i&#39;))
             -&gt;addDecorator(&#39;TextItem&#39;)
             -&gt;setAttrib(&#39;size&#39;, 30)
             -&gt;setAttrib(&#39;maxLength&#39;, 45)
             -&gt;setAttrib(&#39;class&#39;, &#39;text&#39;);
    }
}
?&gt; 
            You could then inform your form object about the prefix path for
            such elements, and start creating elements:
         &lt;?php
$form-&gt;addPrefixPath(&#39;My_Element&#39;, &#39;My/Element/&#39;, &#39;element&#39;)
     -&gt;addElement(&#39;foo&#39;, &#39;text&#39;);
?&gt; 
            The &#39;foo&#39; element will now be of type  My_Element_Text ,
            and exhibit the behaviour you&#39;ve outlined.
         
            Another method you may want to override when extending
             Zend_Form_Element  is the
             loadDefaultDecorators()  method. This method
            conditionally loads a set of default decorators for your element;
            you may wish to substitute your own decorators in your extending
            class:
         &lt;?php
class My_Element_Text extends Zend_Form_Element
{
    public function loadDefaultDecorators()
    {
        $this-&gt;addDecorator(&#39;ViewHelper&#39;)
             -&gt;addDecorator(&#39;DisplayError&#39;)
             -&gt;addDecorator(&#39;Label&#39;)
             -&gt;addDecorator(&#39;HtmlTag&#39;, array(&#39;tag&#39; =&gt; &#39;div&#39;, &#39;class&#39; =&gt; &#39;element&#39;));
    }
}
?&gt; 
            There are many ways to customize elements; be sure to read the API
            documentation of  Zend_Form_Element  to know all the
            methods available.
         Creating Forms Using Zend_Form 
        The  Zend_Form  class is used to aggregate form elements,
        display groups, and subforms. It can then perform the following actions
        on those items:
     
            Validation, including retrieving error codes and messages
         
            Value aggregation, including populating items and retrieving both
            filtered and unfiltered values from all items
         
            Iteration over all items, in the order in which they are entered or
            based on the order hints retrieved from each item
         
            Rendering of the entire form, either via a single decorator that
            peforms custom rendering or by iterating over each item in the form
         
        While forms created with  Zend_Form  may be complex, probably
        the best use case is for simple forms; it&#39;s best use is for Rapid
        Application Development and prototyping.
     
        At its most basic, you simply instantiate a form object:
     &lt;?php
// Generic form object:
$form = new Zend_Form();

// Custom form object:
$form = new My_Form()
?&gt; 
        You can optionally pass in configuration, which will be used to set
        object state, as well as to potentially create new elements:
     &lt;?php
// Passing in configuration options:
$form = new Zend_Form($config);
?&gt; Zend_Form  is iterable, and will iterate over elements,
        display groups, and subforms, using the order they were registered and
        any order index each may have. This is useful in cases where you wish to
        render the elements manually in the appropriate order.
     Zend_Form &#39;s magic lies in its ability to serve as a factory
        for elements and display groups, as well as the ability to render itself
        through decorators.
     Plugin Loaders Zend_Form  makes use of
             Zend_Loader_PluginLoader  to allow developers to specify
            locations of alternate elements and decorators. Each has its own
            plugin loader associated with it, and general accessors are used to
            retrieve and modify each.
         
            The following loader types are used with the various plugin loader
            methods: &#39;element&#39; and &#39;decorator&#39;. The type names are case
            insensitive.
         
            The methods used to interact with plugin loaders are as follows:
         setPluginLoader($loader, $type) : $loader is the
                plugin loader object itself, while type is one of the types
                specified above.  This sets the plugin loader for the given type
                to the newly specified loader object.
             getPluginLoader($type) : retrieves the plugin loader
                associated with $type.
             addPrefixPath($prefix, $path, $type = null) : adds a
                prefix/path association to the loader specified by $type. If
                $type is null, it will attempt to add the path to all loaders,
                by appending the prefix with each of &quot;_Element&quot; and
                &quot;_Decorator&quot;; and appending the path with &quot;Element/&quot; and
                &quot;Decorator/&quot;. If you have all your extra form element classes
                under a common hierarchy, this is a convenience method for
                setting the base prefix for them.
             addPrefixPaths(array $spec) : allows you to add many
                paths at once to one or more plugin loaders. It expects each
                array item to be an array with the keys &#39;path&#39;, &#39;prefix&#39;, and
                &#39;type&#39;.
             
            Additionally, you can specify prefix paths for all elements and
            display groups created through a  Zend_Form  instance
            using the following methods:
         addElementPrefixPath($prefix, $path, $type = null) :
                Just like  addPrefixPath() , you must specify a class
                prefix and a path.  $type , when speified, must be
                one of the plugin loader types specified by
                 Zend_Form_Element ; see the  element plugins
                    section  for more information on valid
                 $type  values. If no  $type  is
                specified, the method will assume it is a general prefix for all
                types.
             addDisplayGroupPrefixPath($prefix, $path) :
                Just like  addPrefixPath() , you must specify a class
                prefix and a path; however, since display groups only support
                decorators as plugins, no  $type  is necessary.
             
            Custom elements and decorators are an easy way to share
            functionality between forms and encapsulate custom functionality.
            See the  Custom Label
                example  in the elements documentation for an example of
            how custom elements can be used as replacements for standard
            classes.
         Elements Zend_Form  provides several accessors for adding and
            removing elements from the form. These can take element object
            instances or serve as factories for instantiating the element
            objects themselves.
         
            The most basic method for adding an element is
             addElement() .  This method can take either an object of
            type  Zend_Form_Element  (or of a class extending
             Zend_Form_Element ), or arguments for building a new
            element -- including the element type, name, and any configuration
            options.
         
            As some examples:
         &lt;?php
// Using an element instance:
$element = new Zend_Form_Element_Text(&#39;foo&#39;);
$form-&gt;addElement($element);

// Using a factory
// 
// Creates an element of type Zend_Form_Element_Text with the
// name of &#39;foo&#39;:
$form-&gt;addElement(&#39;text&#39;, &#39;foo&#39;);

// Pass label option to the element:
$form-&gt;addElement(&#39;text&#39;, &#39;foo&#39;, array(&#39;label&#39; =&gt; &#39;Foo:&#39;));
?&gt; addElement() Implements Fluent Interface addElement()  implements a fluent interface; that is
                to say, it returns the  Zend_Form  object, and not
                the element. This is done to allow you to chain together
                multiple addElement() methods or other form methods that
                implement the fluent interface (all setters in Zend_Form
                implement the pattern).
             
                If you wish to return the element instead, use
                 createElement() , which is outlined below. Be aware,
                however, that  createElement()  does not attach the
                element to the form.
             
                Internally,  addElement()  actually uses
                 createElement()  to create the element before
                attaching it to the form.
             
            Once an element has been added to the form, you can retrieve it by
            name. This can be done either by using the  getElement() 
            method or by using overloading to access the element as an object
            property:
         &lt;?php
// getElement():
$foo = $form-&gt;getElement(&#39;foo&#39;);

// As object property:
$foo = $form-&gt;foo;
?&gt; 
            Occasionally, you may want to create an element without attaching it
            to the form (for instance, if you wish to make use of the various
            plugin paths registered with the form, but wish to later attach the
            object to a sub form). The  createElement()  method
            allows you to do so:
         &lt;?php
// $username becomes a Zend_Form_Element_Text object:
$username = $form-&gt;createElement(&#39;text&#39;, &#39;username&#39;);
?&gt; Populating and Retrieving Values 
                After validating a form, you will typically need to retrieve the
                values so you can perform other operations, such as updating a
                database or notifying a web service. You can retrieve all values
                for all elements using  getValues() ;
                 getValue($name)  allows you to retrieve a single
                element&#39;s value by element name:
             &lt;?php
// Get all values:
$values = $form-&gt;getValues();

// Get only &#39;foo&#39; element&#39;s value:
$value = $form-&gt;getValue(&#39;foo&#39;);
?&gt; 
                Sometimes you&#39;ll want to populate the form with specified values
                prior to rendering. This can be done with either the
                 setDefaults()  or  populate() 
                methods:
             &lt;?php
$form-&gt;setDefaults($data);
$form-&gt;populate($data);
?&gt; Global Operations 
                Occasionally you will want certain operations to affect all
                elements. Common scenarios include needing to set plugin prefix
                paths for all elements, setting decorators for all elements, and
                setting filters for all elements. As examples:
             Setting Prefix Paths for All Elements 
                    You can set prefix paths for all elements by type, or using
                    a global prefix. As some examples:
                 &lt;?php
// Set global prefix path:
// Creates paths for prefixes My_Foo_Filter, My_Foo_Validate,
// and My_Foo_Decorator
$form-&gt;addElementPrefixPath(&#39;My_Foo&#39;, &#39;My/Foo/&#39;);

// Just filter paths:
$form-&gt;addElementPrefixPath(&#39;My_Foo_Filter&#39;, &#39;My/Foo/Filter&#39;, &#39;filter&#39;);

// Just validator paths:
$form-&gt;addElementPrefixPath(&#39;My_Foo_Validate&#39;, &#39;My/Foo/Validate&#39;, &#39;validate&#39;);

// Just decorator paths:
$form-&gt;addElementPrefixPath(&#39;My_Foo_Decorator&#39;, &#39;My/Foo/Decorator&#39;, &#39;decorator&#39;);
?&gt; Setting Decorators for All Elements 
                    You can set decorators for all elements.
                     setElementDecorators()  accepts an array of
                    decorators, just like  setDecorators() , and will
                    overwrite any previously set decorators in each element. In
                    this example, we set the decorators to simply a ViewHelper
                    and a Label:
                 &lt;?php
$form-&gt;setElementDecorators(array(
    &#39;ViewHelper&#39;,
    &#39;Label&#39;
));
?&gt; Some Decorators are Inappropriate for Some Elements 
                        While  setElementDecorators()  may seem like
                        a good solution, there are some cases where it may
                        actually end up with unexpected results. For example,
                        the various button elements (Submit, Button, Reset)
                        currently use the label as the value of the button,
                        and only use ViewHelper and DtDdWrapper decorators --
                        preventing an additional label, errors, and hint from
                        being rendered; the example above would duplicate some
                        content (the label).
                     
                        So, use this method wisely, and realize that you may
                        need to manually change some elements&#39; decorators to
                        prevent unwanted output.
                     Setting Filters for All Elements 
                    In many cases, you may want to apply the same filter to all
                    elements; a common case is to  trim()  all values:
                 &lt;?php
$form-&gt;setElementFilters(array(&#39;StringTrim&#39;));
?&gt; Methods For Interacting With Elements 
                The following methods may be used to interact with elements:
             createElement($element, $name = null, $options = null) addElement($element, $name = null, $options = null) addElements(array $elements) setElements(array $elements) getElement($name) getElements() removeElement($name) clearElements() setDefaults(array $defaults) setDefault($name, $value) getValue($name) getValues() getUnfilteredValue($name) getUnfilteredValues() setElementFilters(array $filters) setElementDecorators(array $decorators) addElementPrefixPath($prefix, $path, $type = null) addElementPrefixPaths(array $spec) Display Groups 
            Display groups are a way to create virtual groupings of elements for
            display purposes. All elements remain accessible by name in the
            form, but when iterating over the form or rendering, any elements in
            a display group are rendered together. The most common use case for
            this is for grouping elements in fieldsets.
         
            The base class for display groups is
             Zend_Form_DisplayGroup .  While it can be instantiated
            directly, it is typically best to use  Zend_Form &#39;s
             addDisplayGroup()  method to do so. This method takes an
            array of elements as its first argument, and a name for the display
            group as its second argument. You may optionally pass in an array of
            options or a  Zend_Config  object as the third argument.
         
            Assuming that the elements &#39;username&#39; and &#39;password&#39; are already set
            in the form, the following code would group these elements in a
            &#39;login&#39; display group:
         &lt;?php
$form-&gt;addDisplayGroup(array(&#39;username&#39;, &#39;password&#39;), &#39;login&#39;);
?&gt; 
            You can access display groups using the
             getDisplayGroup()  method, or via overloading using the
            display group&#39;s name:
         &lt;?php
// Using getDisplayGroup():
$login = $form-&gt;getDisplayGroup(&#39;login&#39;);

// Using overloading:
$login = $form-&gt;login;
?&gt; Default Decorators Do Not Need to Be Loaded 
                By default, the default decorators are loaded during object
                initialization. You can disable this by passing the
                &#39;disableLoadDefaultDecorators&#39; option when creating a display
                group:
             &lt;?php
$form-&gt;addDisplayGroup(
    array(&#39;foo&#39;, &#39;bar&#39;), 
    &#39;foobar&#39;, 
    array(&#39;disableLoadDefaultDecorators&#39; =&gt; true)
);
 
                This option may be mixed with any other options you pass,
                both as array options or in a  Zend_Config  object.
             Global Operations 
                Just as with elements, there are some operations which might
                affect all display groups; these include setting decorators and
                setting the plugin path in which to look for decorators.
             Setting Decorator Prefix Path for All Display Groups 
                    By default, display groups inherit whichever decorator paths
                    the form uses; however, if they should look in alternate
                    locations, you can use the
                     addDisplayGroupPrefixPath()  method.
                 &lt;?php
$form-&gt;addDisplayGroupPrefixPath(&#39;My_Foo_Decorator&#39;, &#39;My/Foo/Decorator&#39;);
?&gt; Setting Decorators for All Display Groups 
                    You can set decorators for all display groups.
                     setDisplayGroupDecorators()  accepts an array of
                    decorators, just like  setDecorators() , and will
                    overwrite any previously set decorators in each display
                    group. In this example, we set the decorators to simply a
                    fieldset (the FormElements decorator is necessary to ensure
                    that the elements are iterated):
                 &lt;?php
$form-&gt;setDisplayGroupDecorators(array(
    &#39;FormElements&#39;,
    &#39;Fieldset&#39;
));
?&gt; Using Custom Display Group Classes 
                By default,  Zend_Form  uses the
                 Zend_Form_DisplayGroup  class for display groups.
                You may find you need to extend this class in order to provided
                custom functionality.  addDisplayGroup()  does not
                allow passing in a concrete instance, but does allow specifying
                the class to use as one of its options, using the
                &#39;displayGroupClass&#39; key:
             &lt;?php
// Use the &#39;My_DisplayGroup&#39; class
$form-&gt;addDisplayGroup(
    array(&#39;username&#39;, &#39;password&#39;), 
    &#39;user&#39;,
    array(&#39;displayGroupClass&#39; =&gt; &#39;My_DisplayGroup&#39;)
);
?&gt; 
                If the class has not yet been loaded,  Zend_Form 
                will attempt to do so using  Zend_Loader .
             
                You can also specify a default display group class to use with
                the form such that all display groups created with the form
                object will use that class:
             &lt;?php
// Use the &#39;My_DisplayGroup&#39; class for all display groups:
$form-&gt;setDefaultDisplayGroupClass(&#39;My_DisplayGroup&#39;);
?&gt; 
                This setting may be specified in configurations as
                &#39;defaultDisplayGroupClass&#39;, and will be loaded early to ensure
                all display groups use that class.
             Methods for Interacting With Display Groups 
                The following methods may be used to interact with display
                groups:
             addDisplayGroup(array $elements, $name, $options = null) addDisplayGroups(array $groups) setDisplayGroups(array $groups) getDisplayGroup($name) getDisplayGroups() removeDisplayGroup($name) clearDisplayGroups() setDisplayGroupDecorators(array $decorators) addDisplayGroupPrefixPath($prefix, $path) setDefaultDisplayGroupClass($class) getDefaultDisplayGroupClass($class) Zend_Form_DisplayGroup Methods Zend_Form_DisplayGroup  has the following methods,
                grouped by type:
             Configuration: setOptions(array $options) setConfig(Zend_Config $config) Metadata: setAttrib($key, $value) addAttribs(array $attribs) setAttribs(array $attribs) getAttrib($key) getAttribs() removeAttrib($key) clearAttribs() setName($name) getName() setDescription($value) getDescription() setLegend($legend) getLegend() setOrder($order) getOrder() Elements: createElement($type, $name, array $options = array()) addElement($typeOrElement, $name, array $options = array()) addElements(array $elements) setElements(array $elements) getElement($name) getElements() removeElement($name) clearElements() Plugin loaders: setPluginLoader(Zend_Loader_PluginLoader $loader) getPluginLoader() addPrefixPath($prefix, $path) addPrefixPaths(array $spec) Decorators: addDecorator($decorator, $options = null) addDecorators(array $decorators) setDecorators(array $decorators) getDecorator($name) getDecorators() removeDecorator($name) clearDecorators() Rendering: setView(Zend_View_Interface $view = null) getView() render(Zend_View_Interface $view = null) I18N: setTranslator(Zend_Translate_Adapter $translator = null) getTranslator() setDisableTranslator($flag) translatorIsDisabled() Sub Forms 
            Sub forms serve several purposes:
         
                Creating logical element groups. Since sub forms are simply
                forms, you can validate subforms as individual entities.
             
                Creating multi-page forms. Since sub forms are simply forms, you
                can display a separate sub form per page, building up multi-page
                forms where each form has its own validation logic.  Only once
                all sub forms validate would the form be considered complete.
             
                Display groupings. Like display groups, sub forms, when rendered
                as part of a larger form, can be used to group elements. Be
                aware, however, that the master form object will have no
                awareness of the elements in sub forms.
             
            A sub form may be a  Zend_Form  object, or, more
            typically, a  Zend_Form_SubForm  object. The latter
            contains decorators suitable for inclusion in a larger form (i.e.,
            it does not render additional HTML form tags, but does group
            elements). To attach a sub form, simply add it to the form and give
            it a name:
         &lt;?php
$form-&gt;addSubForm($subForm, &#39;subform&#39;);
?&gt; 
            You can retrieve a sub form using either
             getSubForm($name)  or overloading using the sub form
            name:
         &lt;?php
// Using getSubForm():
$subForm = $form-&gt;getSubForm(&#39;subform&#39;);

// Using overloading:
$subForm = $form-&gt;subform;
?&gt; 
            Sub forms are included in form iteration, though the elements it
            contains are not.
         Global Operations 
                Like elements and display groups, there are some operations that
                might need to affect all sub forms. Unlike display groups and
                elements, however, sub forms inherit most functionality from the
                master form object, and the only real operation that may need to
                be performed globally is setting decorators for sub forms. For
                this purpose, there is the  setSubFormDecorators() 
                method. In the next example, we&#39;ll set the decorator for all
                subforms to be simply a fieldset (the FormElements decorator is
                needed to ensure its elements are iterated):
             &lt;?php
$form-&gt;setSubFormDecorators(array(
    &#39;FormElements&#39;,
    &#39;Fieldset&#39;
));
?&gt; Methods for Interacting With Sub Forms 
                The following methods may be used to interact with sub forms:
             addSubForm(Zend_Form $form, $name, $order = null) addSubForms(array $subForms) setSubForms(array $subForms) getSubForm($name) getSubForms() removeSubForm($name) clearSubForms() setSubFormDecorators(array $decorators) Metadata and Attributes 
            While a form&#39;s usefulness primarily derives from the elements it
            contains, it can also contain other metadata, such as a name (often
            used as a unique ID in the HTML markup); the form action and method;
            the number of elements, groups, and sub forms it contains; and
            arbitrary metadata (usually used to set HTML attributes for the form
            tag itself).
         
            You can set and retrieve a form&#39;s name using the name accessors:
         &lt;?php
// Set the name:
$form-&gt;setName(&#39;registration&#39;);

// Retrieve the name:
$name = $form-&gt;getName();
?&gt; 
            To set the action (url to which the form submits) and method (method
            by which it should submit, e.g., &#39;POST&#39; or &#39;GET&#39;), use the action
            and method accessors:
         &lt;?php
// Set the action and method:
$form-&gt;setAction(&#39;/user/login&#39;)
     -&gt;setMethod(&#39;post&#39;);
?&gt; 
                The method and action are only used internally for rendering,
                and not for any sort of validation.
             Zend_Form  implements the  Countable 
            interface, allowing you to pass it as an argument to count:
         &lt;?php
$numItems = count($form);
?&gt; 
            Setting arbitrary metadata is done through the attribs accessors.
            Since overloading in  Zend_Form  is used to access
            elements, display groups, and sub forms, this is the only method for
            accessing metadata.
         &lt;?php
// Setting attributes:
$form-&gt;setAttrib(&#39;class&#39;, &#39;zend-form&#39;)
     -&gt;addAttribs(array(
         &#39;id&#39;       =&gt; &#39;registration&#39;,
         &#39;onSubmit&#39; =&gt; &#39;validate(this)&#39;,
     ));

// Retrieving attributes:
$class = $form-&gt;getAttrib(&#39;class&#39;);
$attribs = $form-&gt;getAttribs();

// Remove an attribute:
$form-&gt;removeAttrib(&#39;onSubmit&#39;);

// Clear all attributes:
$form-&gt;clearAttribs();
?&gt; Decorators 
            Creating the markup for a form is often a time-consuming task,
            particularly if you plan on re-using the same markup to show things
            such as validation errors, submitted values, etc.
             Zend_Form &#39;s answer to this issue is
             decorators .
         
            Decorators for  Zend_Form  objects can be used to render
            a form. The FormElements decorator will iterate through all items in
            a form -- elements, display groups, and sub forms -- and render
            them, returning the result. Additional decorators may then be used
            to wrap this content, or append or prepend it.
         
            The default decorators for  Zend_Form  are FormElements,
            HtmlTag (wraps in a definition list), and Form; the equivalent code
            for creating them is as follows:
         &lt;?php
$form-&gt;setDecorators(array(
    &#39;FormElements&#39;,
    array(&#39;HtmlTag&#39;, array(&#39;tag&#39; =&gt; &#39;dl&#39;)),
    &#39;Form&#39;
));
?&gt; 
            This creates output like the following:
         
&lt;form action=&quot;/form/action&quot; method=&quot;post&quot;&gt;
&lt;dl&gt;
...
&lt;/dl&gt;
&lt;/form&gt;
 
            Any attributes set on the form object will be used as HTML
            attributes of the  &lt;form&gt;  tag.
         Default Decorators Do Not Need to Be Loaded 
                By default, the default decorators are loaded during object
                initialization. You can disable this by passing the
                &#39;disableLoadDefaultDecorators&#39; option to the constructor:
             &lt;?php
$form = new Zend_Form(array(&#39;disableLoadDefaultDecorators&#39; =&gt; true));
 
                This option may be mixed with any other options you pass,
                both as array options or in a  Zend_Config  object.
             Using Multiple Decorators of the Same Type 
                Internally,  Zend_Form  uses a decorator&#39;s
                class as the lookup mechanism when retrieving decorators. As a
                result, you cannot register multiple decorators of the same
                type; subsequent decorators will simply overwrite those that
                existed before.
             
                To get around this, you can use aliases. Instead of passing a
                decorator or decorator name as the first argument to
                 addDecorator() , pass an array with a single
                element, with the alias pointing to the decorator object or
                name:
             &lt;?php
// Alias to &#39;FooBar&#39;:
$form-&gt;addDecorator(array(&#39;FooBar&#39; =&gt; &#39;HtmlTag&#39;), array(&#39;tag&#39; =&gt; &#39;div&#39;));

// And retrieve later:
$form = $element-&gt;getDecorator(&#39;FooBar&#39;);
?&gt; 
                In the  addDecorators()  and
                 setDecorators()  methods, you will need to pass
                the &#39;decorator&#39; option in the array representing the decorator:
             &lt;?php
// Add two &#39;HtmlTag&#39; decorators, aliasing one to &#39;FooBar&#39;:
$form-&gt;addDecorators(
    array(&#39;HtmlTag&#39;, array(&#39;tag&#39; =&gt; &#39;div&#39;)),
    array(
        &#39;decorator&#39; =&gt; array(&#39;FooBar&#39; =&gt; &#39;HtmlTag&#39;), 
        &#39;options&#39; =&gt; array(&#39;tag&#39; =&gt; &#39;dd&#39;)
    ),
);

// And retrieve later:
$htmlTag = $form-&gt;getDecorator(&#39;HtmlTag&#39;);
$fooBar  = $form-&gt;getDecorator(&#39;FooBar&#39;);
?&gt; 
            You may create your own decorators for generating the form. One
            common use case is if you know the exact HTML you wish to use; your
            decorator could create the exact HTML and simply return it,
            potentially using the decorators from individual elements or display
            groups.
         
            The following methods may be used to interact with decorators:
         addDecorator($decorator, $options = null) addDecorators(array $decorators) setDecorators(array $decorators) getDecorator($name) getDecorators() removeDecorator($name) clearDecorators() Validation 
            A primary use case for forms is validating submitted data.
             Zend_Form  allows you to validate an entire form at once
            or a partial form, as well as to automate validation responses for
            XmlHttpRequests (AJAX).  If the submitted data is not valid, it has
            methods for retrieving the various error codes and messages for
            elements and sub forms failing validations.
         
            To validate a full form, use the  isValid()  method:
         &lt;?php
if (!$form-&gt;isValid($_POST)) {
    // failed validation
}
?&gt; isValid()  will validate every required element, and any
            unrequired element contained in the submitted data.
         
            Sometimes you may need to validate only a subset of the data; for
            this, use  isValidPartial($data) :
         &lt;?php
if (!$form-&gt;isValidPartial($data)) {
    // failed validation
}
?&gt; isValidPartial()  only attempts to validate those items
            in the data for which there are matching elements; if an element is
            not represented in the data, it is skipped.
         
            When validating elements or groups of elements for an AJAX request,
            you will typically be validating a subset of the form, and want the
            response back in JSON.  processAjax()  does precisely
            that:
         &lt;?php
$json = $form-&gt;processAjax($data);
?&gt; 
            You can then simply send the JSON response to the client. If the
            form is valid, this will be a boolean true response. If not, it will
            be a javascript object containing key/message pairs, where each
            &#39;message&#39; is an array of validation error messages.
         
            For forms that fail validation, you can retrieve both error codes
            and error messages, using  getErrors()  and
             getMessages() , respectively:
         &lt;?php
$codes = $form-&gt;getErrors();
$messages = $form-&gt;getMessage();
?&gt; 
                Since the messages returned by  getMessages()  are an
                array of error code/message pairs,  getErrors()  is
                typically not needed.
             
            You can retrieve codes and error messages for individual elements by
            simply passing the element name to each:
         &lt;?php
$codes = $form-&gt;getErrors(&#39;username&#39;);
$messages = $form-&gt;getMessages(&#39;username&#39;);
?&gt; 
                Note: When validating elements,  Zend_Form  sends a
                second argument to each element&#39;s  isValid()  method:
                the array of data being validated. This can then be used by
                individual validators to allow them to utilize other submitted
                values when determining the validity of the data. An example
                would be a registration form that requires both a password and
                password confirmation; the password element could use the
                password confirmation as part of its validation. 
             Methods 
            The following is a full list of methods available to
             Zend_Form , grouped by type:
         Configuration and Options: setOptions(array $options) setConfig(Zend_Config $config) Plugin Loaders and paths: setPluginLoader(Zend_Loader_PluginLoader_Interface $loader, $type = null) getPluginLoader($type = null) addPrefixPath($prefix, $path, $type = null)  addPrefixPaths(array $spec) addElementPrefixPath($prefix, $path, $type = null) addElementPrefixPaths(array $spec) addDisplayGroupPrefixPath($prefix, $path) Metadata: setAttrib($key, $value) addAttribs(array $attribs) setAttribs(array $attribs) getAttrib($key) getAttribs() removeAttrib($key) clearAttribs() setAction($action) getAction() setMethod($method) getMethod() setName($name) getName() Elements: addElement($element, $name = null, $options = null) addElements(array $elements) setElements(array $elements) getElement($name) getElements() removeElement($name) clearElements() setDefaults(array $defaults) setDefault($name, $value) getValue($name) getValues() getUnfilteredValue($name) getUnfilteredValues() setElementFilters(array $filters) setElementDecorators(array $decorators) Sub forms: addSubForm(Zend_Form $form, $name, $order = null) addSubForms(array $subForms) setSubForms(array $subForms) getSubForm($name) getSubForms() removeSubForm($name) clearSubForms() setSubFormDecorators(array $decorators) Display groups: addDisplayGroup(array $elements, $name, $options = null) addDisplayGroups(array $groups) setDisplayGroups(array $groups) getDisplayGroup($name) getDisplayGroups() removeDisplayGroup($name) clearDisplayGroups() setDisplayGroupDecorators(array $decorators) Validation populate(array $values) isValid(array $data) isValidPartial(array $data) processAjax(array $data) persistData() getErrors($name = null) getMessages($name = null) Rendering: setView(Zend_View_Interface $view = null) getView() addDecorator($decorator, $options = null) addDecorators(array $decorators) setDecorators(array $decorators) getDecorator($name) getDecorators() removeDecorator($name) clearDecorators() render(Zend_View_Interface $view = null) I18N: setTranslator(Zend_Translate_Adapter $translator = null) getTranslator() setDisableTranslator($flag) translatorIsDisabled() Configuration Zend_Form  is fully configurable via
             setOptions()  and  setConfig()  (or by
            passing options or a  Zend_Config  object to the
            constructor).  Using these methods, you can specify form elements,
            display groups, decorators, and metadata.
         
            As a general rule, if &#39;set&#39; + the option key refers to a
             Zend_Form  method, then the value provided will be
            passed to that method. If the accessor does not exist, the key is
            assumed to reference an attribute, and will be passed to
             setAttrib() .
         
            Exceptions to the rule include the following:
         prefixPaths  will be passed to
                     addPrefixPaths() 
             elementPrefixPaths  will be passed to
                 addElementPrefixPaths() 
             displayGroupPrefixPaths  will be passed to
                 addDisplayGroupPrefixPaths() 
             the following setters cannot be set in this way: setAttrib (though setAttribs *will* work) setConfig setDefault setOptions setPluginLoader setSubForms setTranslator setView 
            As an example, here is a config file that passes configuration for
            every type of configurable data:
         
[element]
name = &quot;registration&quot;
action = &quot;/user/register&quot;
method = &quot;post&quot;
attribs.class = &quot;zend_form&quot;
attribs.onclick = &quot;validate(this)&quot;

disableTranslator = 0

prefixPaths.element.prefix = &quot;My_Element&quot;
prefixPaths.element.path = &quot;My/Element/&quot;
elementPrefixPaths.validate.prefix = &quot;My_Validate&quot;
elementPrefixPaths.validate.path = &quot;My/Validate/&quot;
displayGroupPrefixPaths.prefix = &quot;My_Group&quot;
displayGroupPrefixPaths.path = &quot;My/Group/&quot;

elements.username.type = &quot;text&quot;
elements.username.options.label = &quot;Username&quot;
elements.username.options.validators.alpha.validator = &quot;Alpha&quot;
elements.username.options.filters.lcase = &quot;StringToLower&quot;
; more elements, of course...

elementFilters.trim = &quot;StringTrim&quot;
;elementDecorators.trim = &quot;StringTrim&quot;

displayGroups.login.elements.username = &quot;username&quot;
displayGroups.login.elements.password = &quot;password&quot;
displayGroupDecorators.elements.decorator = &quot;FormElements&quot;
displayGroupDecorators.fieldset.decorator = &quot;Fieldset&quot;

decorators.elements.decorator = &quot;FormElements&quot;
decorators.fieldset.decorator = &quot;FieldSet&quot;
decorators.fieldset.decorator.options.class = &quot;zend_form&quot;
decorators.form.decorator = &quot;Form&quot;
?&gt; 
            The above could easily be abstracted to an XML or PHP array-based
            configuration file.
         Custom forms 
            An alternative to using configuration-based forms is to subclass
             Zend_Form . This has several benefits:
         
                You can unit test your form easily to ensure validations and
                rendering perform as expected.
             
                Fine-grained control over individual elements.
             
                Re-use of form objects, and greater portability (no need to
                track config files).
             
                Implementing custom functionality.
             
            The most typical use case would be to use the
             init()  method to setup specific form elements and
            configuration:
         &lt;?php
class My_Form_Login extends Zend_Form
{
    public function init()
    {
        $username = new Zend_Form_Element_Text(&#39;username&#39;);
        $username-&gt;class = &#39;formtext&#39;;
        $username-&gt;setLabel(&#39;Username:&#39;)
                 -&gt;setDecorators(array(
                     array(&#39;ViewHelper&#39;, array(&#39;helper&#39; =&gt; &#39;formText&#39;)),
                     array(&#39;Label&#39;, array(&#39;class&#39; =&gt; &#39;label&#39;))
                 ));

        $password = new Zend_Form_Element_Password(&#39;password&#39;);
        $password-&gt;class = &#39;formtext&#39;;
        $password-&gt;setLabel(&#39;Username:&#39;)
                 -&gt;setDecorators(array(
                     array(&#39;ViewHelper&#39;, array(&#39;helper&#39; =&gt; &#39;formPassword&#39;)),
                     array(&#39;Label&#39;, array(&#39;class&#39; =&gt; &#39;label&#39;))
                 ));

        $submit = new Zend_Form_Element_Submit(&#39;login&#39;);
        $submit-&gt;class = &#39;formsubmit&#39;;
        $submit-&gt;setValue(&#39;Login&#39;)
               -&gt;setDecorators(array(
                   array(&#39;ViewHelper&#39;, array(&#39;helper&#39; =&gt; &#39;formSubmit&#39;))
               ));

        $this-&gt;addElements(array(
            $username,
            $password,
            $submit
        ));

        $this-&gt;setDecorators(array(
            &#39;FormElements&#39;,
            &#39;Fieldset&#39;,
            &#39;Form&#39;
        ));
    }
}
?&gt; 
            This form can then be instantiated with simply:
         &lt;?php
$form = new My_Form_Login();
?&gt; 
            and all functionality is already setup and ready; no config files
            needed. (Note that this example is greatly simplified, as it
            contains no validators or filters for the elements.)
         
            Another common reason for extension is to define a set of
            default decorators. You can do this by overriding the
             loadDefaultDecorators()  method:
         &lt;?php
class My_Form_Login extends Zend_Form
{
    public function loadDefaultDecorators()
    {
        $this-&gt;setDecorators(array(
            &#39;FormElements&#39;,
            &#39;Fieldset&#39;,
            &#39;Form&#39;
        ));
    }
}
 Internationalization of Zend_Form 
        Increasingly, developers need to tailor their content for multiple
        languages and regions. Zend_Form aims to make such a task trivial, and
        leverages functionality in both  Zend_Translate  and  Zend_Validate  to do so.
     
        By default, no internationalisation (i18n) is performed. To turn on i18n
        features in  Zend_Form , you will need to instantiate a
         Zend_Translate  object with an appropriate adapter, and
        attach it to  Zend_Form  and/or  Zend_Validate .
        See the  Zend_Translate
            documentation  for more information on creating the translate
        object and translation files
     Translation Can Be Turned Off Per Item 
            You can disable translation for any form, element, display group, or
            sub form by calling its  setDisableTranslator($flag) 
            method or passing a  disableTranslator  option to the
            object. This can be useful when you want to selectively disable
            translation for individual elements or sets of elements.
         Initializing I18n in Forms 
            In order to initialize i18n in forms, you will need either a
             Zend_Translate  object or a
             Zend_Translate_Adapter  object, as detailed in the
             Zend_Translate  documentation.  Once you have a
            translation object, you have several options:
         Easiest:  add it to the registry. All i18n
                    aware components of Zend Framework will autodiscover a translate
                    object that is in the registry under the &#39;Zend_Translate&#39; key
                    and use it to perform translation and/or localization:
                 &lt;?php
// use the &#39;Zend_Translate&#39; key; $translate is a Zend_Translate object:
Zend_Registry::set(&#39;Zend_Translate&#39;, $translate);
?&gt; 
                    This will be picked up by  Zend_Form ,
                     Zend_Validate , and
                     Zend_View_Helper_Translate .
                 
                    If all you are worried about is translating validation error
                    messages, you can register the translation object with
                     Zend_Validate_Abstract :
                 &lt;?php
// Tell all validation classes to use a specific translate adapter:
Zend_Validate_Abstract::setDefaultTranslator($translate);
?&gt; 
                    Alternatively, you can attach to the  Zend_Form 
                    object as a global translator. This has the side effect of also
                    translating validation error messages:
                 &lt;?php
// Tell all form classes to use a specific translate adapter, as well as use
// this adapter to translate validation error messages:
Zend_Form::setDefaultTranslator($translate);
?&gt; 
                    Finally, you can attach a translator to a specific form instance
                    or to specific elements using their  setTranslator() 
                    methods:
                 &lt;?php
// Tell *this* form instance to use a specific translate adapter; it will also
// be used to translate validation error messages for all elements:
$form-&gt;setTranslator($translate);

// Tell *this* element to use a specific translate adapter; it will also be used
// to translate validation error messages for this particular element:
$element-&gt;setTranslator($translate);
?&gt; Standard I18N Targets 
            Now that you&#39;ve attached a translation object to, what exactly can
            you translate by default?
         Validation error messages.  Validation
                    error messages may be translated. To do so, use the various
                    error code constants from the  Zend_Validate 
                    validation classes as the message IDs. For more information
                    on these codes, see the  Zend_Validate 
                    documentation.
                 Labels.  Element labels will be
                    translated, if a translation exists.
                 Fieldset Legends.  Display groups and
                    sub forms render in fieldsets by default. The Fieldset
                    decorator attempts to translate the legend before rendering
                    the fieldset.
                 Form and Element Descriptions.  All form
                    types (element, form, display group, sub form) allow
                    specifying an optional item description. The Description
                    decorator can be used to render this, and by default will
                    take the value and attempt to translate it.
                 Multi-option Values.  For the various
                    items inheriting from  Zend_Form_Element_Multi 
                    (including the MultiCheckbox, Multiselect, and Radio
                    elements), the option values (not keys) will be translated
                    if a translation is available; this means that the option
                    labels presented to the user will be translated.
                 Submit and Button Labels.  The various
                    Submit and Button elements (Button, Submit, and Reset) will
                    translate the label displayed to the user.
                 Zend_Form 
        Zend_Form simplifies form creation and handling in your web
        application.  It accomplishes the following goals:                                        
     Element input filtering and validation Element ordering Element and Form rendering, including escaping Element and form grouping Element and form-level configuration 
        It heavily leverages other Zend Framework components to accomplish its
        goals, including  Zend_Config ,  Zend_Validate ,
         Zend_Filter ,  Zend_Loader_PluginLoader , and
        optionally  Zend_View .
     Zend_Form Quick Start 
        This quick start guide is intended to cover the basics of creating,
        validating, and rendering forms using  Zend_Form .
     Create a form object 
            Creating a form object is very simple: simply instantiate
             Zend_Form :
         &lt;?php
$form = new Zend_Form;
?&gt; 
            For advanced use cases, you may want to create a
             Zend_Form  subclass, but for simple forms, you can
            create a form programmatically using a  Zend_Form 
            object.
         
            If you wish to specify the form action and method (always good
            ideas), you can do so with the  setAction()  and
             setMethod()  accessors:
         &lt;?php
$form-&gt;setAction(&#39;/resource/process&#39;)
     -&gt;setMethod(&#39;post&#39;);
?&gt; 
            The above code sets the form action to the partial URL
            &quot;/resource/process&quot; and the form method to HTTP POST. This will be
            reflected during final rendering.
         
            You can set additional HTML attributes for the
             &lt;form&gt;  tag by using the setAttrib() or
            setAttribs() methods.  For instance, if you wish to set the id, set
            the &quot;id&quot; attribute:
         &lt;?php
$form-&gt;setAttrib(&#39;id&#39;, &#39;login&#39;);
?&gt; Add elements to the form 
            A form is nothing without its elements.  Zend_Form 
            ships with some default elements that render XHTML via
             Zend_View  helpers. These are as follows:
         
                button
             
                checkbox (or many checkboxes at once with multiCheckbox)
             
                hidden
             
                image
             
                password
             
                radio
             
                reset
             
                select (both regular and multi-select types)
             
                submit
             
                text
             
                textarea
             
            You have two options for adding elements to a form: you can
            instantiate concrete elements and pass in these objects, or you can
            pass in simply the element type and have  Zend_Form 
            instantiate an object of the correct type for you.
         
            As some examples:
         &lt;?php
// Instantiating an element and passing to the form object:
$form-&gt;addElement(new Zend_Form_Element_Text(&#39;username&#39;));

// Passing a form element type to the form object:
$form-&gt;addElement(&#39;text&#39;, &#39;username&#39;);
?&gt; 
            By default, these do not have any validators or filters. This means
            you will need to configure your elements with minimally validators,
            and potentially filters. You can either do this (a) before you pass
            the element to the form, (b) via configuration options passed in
            when creating an element via  Zend_Form , or (c) by
            pulling the element from the form object and configuring it after
            the fact.
         
            Let&#39;s first look at creating validators for a concrete element
            instance. You can either pass in  Zend_Validate_* 
            objects, or the name of a validator to utilize:
         &lt;?php
$username = new Zend_Form_Element_Text(&#39;username&#39;);

// Passing a Zend_Validate_* object:
$username-&gt;addValidator(new Zend_Validate_Alnum());

// Passing a validator name:
$username-&gt;addValidator(&#39;alnum&#39;);
?&gt; 
            When using this second option, if the validator can accept
            constructor arguments, you can pass those in an array as the third
            parameter:
         &lt;?php
// Pass a pattern
$username-&gt;addValidator(&#39;regex&#39;, false, array(&#39;/^[a-z]/i&#39;));
?&gt; 
            (The second parameter is used to indicate whether or not failure of
            this validator should prevent later validators from running; by
            default, this is false.)
         
            You may also wish to specify an element as required. This can be
            done using either an accessor or by passing an option when creating
            the element. In the former case:
         &lt;?php
// Make this element required:
$username-&gt;setRequired(true);
?&gt; 
            When an element is required, a &#39;NotEmpty&#39; validator is added to the
            top of the validator chain, ensuring that the element has a value
            when required.
         
            Filters are registered in basically the same way as validators. For
            illustration purposes, let&#39;s add a filter to lowercase the final
            value:
         &lt;?php
$username-&gt;addFilter(&#39;StringtoLower&#39;);
?&gt; 
            So, our final element setup might look like this:
         &lt;?php
$username-&gt;addValidator(&#39;alnum&#39;)
         -&gt;addValidator(&#39;regex&#39;, false, array(&#39;/^[a-z]/&#39;))
         -&gt;setRequired(true)
         -&gt;addFilter(&#39;StringToLower&#39;);

// or, more compactly:
$username-&gt;addValidators(array(&#39;alnum&#39;,
        array(&#39;regex&#39;, false, &#39;/^[a-z]/i&#39;)
    ))
    -&gt;setRequired(true)
    -&gt;addFilters(array(&#39;StringToLower&#39;));
?&gt; 
            Simple as this is, doing this for every single element in a form
            can be a bit tedious. Let&#39;s try option (b) from above. When we
            create a new element using  Zend_Form::addElement()  as
            a factory, we can optionally pass in configuration options. These
            can include validators and filters to utilize. So, to do all of the
            above implicitly, try the following:
         &lt;?php
$form-&gt;addElement(&#39;text&#39;, &#39;username&#39;, array(
    &#39;validators&#39; =&gt; array(
        &#39;alnum&#39;,
        array(&#39;regex&#39;, false, &#39;/^[a-z]/i&#39;)
    ),
    &#39;required&#39; =&gt; true,
    &#39;filters&#39;  =&gt; array(&#39;StringToLower&#39;),
));
?&gt; 
            If you find you are setting up elements using the same options in
            many locations, you may want to consider creating your own
             Zend_Form_Element  subclass and utilizing that class
            instead; this will save you typing in the long-run.
         Render a form 
            Rendering a form is simple. Most elements use a
             Zend_View  helper to render themselves, and thus need a
            view object in order to render.  Other than that, you have two
            options: use the form&#39;s render() method, or simply echo it.
         &lt;?php
// Explicitly calling render(), and passing an optional view object:
echo $form-&gt;render($view);

// Assuming a view object has been previously set via setView():
echo $form;
?&gt; 
            By default,  Zend_Form  and
             Zend_Form_Element  will attempt to use the view object
            initialized in the  ViewRenderer , which means you won&#39;t
            need to set the view manually when using the Zend Framework MVC.
            Rendering a form in a view script is then as simple as:
         
&lt;?= $this-&gt;form ?&gt;
 
            Under the hood,  Zend_Form  uses &quot;decorators&quot; to perform
            rendering. These decorators can replace content, append content, or
            prepend content, and have full introspection to the element passed
            to them. As a result, you can combine multiple decorators to
            achieve custom effects. By default,  Zend_Form_Element 
            actually combines four decorators to achieve its output; setup
            looks something like this:
         &lt;?php
$element-&gt;addDecorators(array(
    &#39;ViewHelper&#39;,
    &#39;Errors&#39;,
    array(&#39;HtmlTag&#39;, array(&#39;tag&#39; =&gt; &#39;dd&#39;)),
    array(&#39;Label&#39;, array(&#39;tag&#39; =&gt; &#39;dt&#39;)),
));
?&gt; 
            (Where &lt;HELPERNAME&gt; is the name of a view helper to use, and varies
            based on the element.)
         
            The above creates output like the following:
         
&lt;dt&gt;&lt;label for=&quot;username&quot; class=&quot;required&quot;&gt;Username&lt;/dt&gt;
&lt;dd&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;123-abc&quot; /&gt;
    &lt;ul class=&quot;errors&quot;&gt;
        &lt;li&gt;&#39;123-abc&#39; has not only alphabetic and digit characters&lt;/li&gt;
        &lt;li&gt;&#39;123-abc&#39; does not match against pattern &#39;/^[a-z]/i&#39;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/dd&gt;
 
            (Albeit not with the same formatting.)
         
            You can change the decorators used by an element if you wish to
            have different output; see the section on decorators for more
            information.
         
            The form itself simply loops through the elements, and dresses them
            in an HTML  &lt;form&gt; . The action and method you
            provided when setting up the form are provided to the
             &lt;form&gt;  tag, as are any attributes you set via
             setAttribs()  and family. 
         
            Elements are looped either in the order in which they were
            registered, or, if your element contains an order attribute, that
            order will be used. You can set an element&#39;s order using:
         &lt;?php
$element-&gt;setOrder(10);
?&gt; 
            Or, when creating an element, by passing it as an option:
         &lt;?php
$form-&gt;addElement(&#39;text&#39;, &#39;username&#39;, array(&#39;order&#39; =&gt; 10));
?&gt; Check if a form is valid 
            After a form is submitted, you will need to check and see if it
            passes validations. Each element is checked against the data
            provided; if a key matching the element name is not present, and
            the item is marked as required, validations are run with a null
            value.
         
            Where does the data come from? You can use  $_POST  or
             $_GET , or any other data source you might have at hand
            (web service requests, for instance):
         &lt;?php
if ($form-&gt;isValid($_POST)) {
    // success!
} else {
    // failure!
}
?&gt; 
            With AJAX requests, you sometimes can get away with validating
            single element, or groups of elements.
             isValidPartial()  will validate a partial form. Unlike
             isValid() , however, if a particular key is not
            present, it will not run validations for that particular element:
         &lt;?php
if ($form-&gt;isValidPartial($_POST)) {
    // elements present all passed validations
} else {
    // one or more elements tested failed validations
}
?&gt; 
            An additional method,  processAjax() , can also be used
            for validating partial forms. Unlike  isValidPartial() ,
            it returns a JSON-formatted string containing error messages on
            failure.
         
            Assuming your validations have passed, you can now fetch the
            filtered values:
         &lt;?php
$values = $form-&gt;getValues();
?&gt; 
            If you need the unfiltered values at any point, use:
         &lt;?php
$unfiltered = $form-&gt;getUnfilteredValues();
?&gt; Get error status 
            So, your form failed validations? In most cases, you can simply
            render the form again, and errors will be displayed when using the
            default decorators:
         &lt;?php
if (!$form-&gt;isValid($_POST)) {
    echo $form;

    // or assign to the view object and render a view...
    $this-&gt;view-&gt;form = $form;
    return $this-&gt;render(&#39;form&#39;);
}
?&gt; 
            If you want to inspect the errors, you have two methods.
             getErrors()  returns an associative array of element
            names / codes (where codes is an array of error codes).
             getMessages()  returns an associative array of element
            names / messages (where messages is an associative array of error
            code / error message pairs). If a given element does not have any
            errors, it will not be included in the array.
         Putting it together 
            Let&#39;s build a simple login form. It will need elements
            representing:
         username password submit 
            For our purposes, let&#39;s assume that a valid username should be
            alphanumeric characters only, start with a letter, have a minimum
            length of 6, and maximum length of 20; they will be normalized to
            lowercase. Passwords must be a minimum of 6 characters.  We&#39;ll
            simply toss the submit value when done, so it can remain
            unvalidated.
         
            We&#39;ll use the power of  Zend_Form &#39;s configuration
            options to build the form:
         &lt;?php


$form = new Zend_Form();
$form-&gt;setAction(&#39;/usr/login&#39;)
     -&gt;setMethod(&#39;post&#39;);

// Create and configure username element:
$username = $form-&gt;createElement(&#39;text&#39;, &#39;username&#39;);
$username-&gt;addValidator(&#39;alnum&#39;)
         -&gt;addValidator(&#39;regex&#39;, false, array(&#39;/^[a-z]+/&#39;))
         -&gt;addValidator(&#39;stringLength&#39;, false, array(6, 20))
         -&gt;setRequired(true)
         -&gt;addFilter(&#39;StringToLower&#39;);

// Create and configure password element:
$password = $form-&gt;createElement(&#39;password&#39;, &#39;password&#39;);
$password-&gt;addValidator(&#39;StringLength&#39;, false, array(6))
         -&gt;setRequired(true);

// Add elements to form:
$form-&gt;addElement($username)
     -&gt;addElement($password)
     // use addElement() as a factory to create &#39;Login&#39; button:
     -&gt;addElement(&#39;submit&#39;, &#39;login&#39;, array(&#39;label&#39; =&gt; &#39;Login&#39;));
?&gt; 
            Next, we&#39;ll create a controller for handling this:
         &lt;?php
class UserController extends Zend_Controller_Action
{
    public function getForm()
    {
        // create form as above
        return $form;
    }

    public function indexAction()
    {
        // render user/form.phtml
        $this-&gt;view-&gt;form = $this-&gt;getForm();
        $this-&gt;render(&#39;form&#39;);
    }

    public function loginAction()
    {
        if (!$this-&gt;getRequest()-&gt;isPost()) {
            return $this-&gt;_forward(&#39;index&#39;);
        }
        $form = $this-&gt;getForm();
        if (!$form-&gt;isValid($_POST)) {
            // Failed validation; redisplay form
            $this-&gt;view-&gt;form = $form;
            return $this-&gt;render(&#39;form&#39;);
        }
        
        $values = $form-&gt;getValues();
        // now try and authenticate....
    }
}
?&gt; 
            And a view script for displaying the form:
         
&lt;h2&gt;Please login:&lt;/h2&gt;
&lt;?= $this-&gt;form ?&gt;
 
            As you&#39;ll note from the controller code, there&#39;s more work to do:
            while the submission may be valid, you may still need to do some
            authentication using  Zend_Auth , for instance.
         Using a Zend_Config object 
            All  Zend_Form  classes are configurable using
             Zend_Config ; you can either pass a
             Zend_Config  object to the constructor or pass it in
            via  setConfig() . Let&#39;s look at how we might create the
            above form using an INI file. First, let&#39;s follow the
            recommendations, and place our configurations into sections
            reflecting the release location, and focus on the &#39;development&#39;
            section. Next, we&#39;ll setup a section for the given controller
            (&#39;user&#39;), and a key for the form (&#39;login&#39;):
         
[development]
; general form metainformation
user.login.action = &quot;/user/login&quot;
user.login.method = &quot;post&quot;

; username element
user.login.elements.username.type = &quot;text&quot;
user.login.elements.username.options.validators.alnum.validator = &quot;alnum&quot;
user.login.elements.username.options.validators.regex.validator = &quot;regex&quot;
user.login.elements.username.options.validators.regex.options.pattern = &quot;/^[a-z]/i&quot;
user.login.elements.username.options.validators.strlen.validator = &quot;StringLength&quot;
user.login.elements.username.options.validators.strlen.options.min = &quot;6&quot;
user.login.elements.username.options.validators.strlen.options.max = &quot;20&quot;
user.login.elements.username.options.required = true
user.login.elements.username.options.filters.lower.filter = &quot;StringToLower&quot;

; password element
user.login.elements.password.type = &quot;password&quot;
user.login.elements.password.options.validators.strlen.validator = &quot;StringLength&quot;
user.login.elements.password.options.validators.strlen.options.min = &quot;6&quot;
user.login.elements.password.options.required = true

; submit element
user.login.elements.submit.type = &quot;submit&quot;
 
            You could then pass this to the form constructor:
         &lt;?php
$config = new Zend_Config_Ini($configFile, &#39;development&#39;);
$form   = new Zend_Form($config-&gt;user-&gt;login);
?&gt; 
            and the entire form will be defined.
         Conclusion 
            Hopefully with this little tutorial, you should now be well on your
            way to unlocking the power and flexibility of
             Zend_Form . Read on for more in-depth information!
         Standard Form Decorators Shipped With Zend Framework Zend_Form  ships with several standard decorators. For more
        information on general decorator usage, see  the Decorators section .
     Zend_Form_Decorator_Callback 
            The Callback decorator can execute an arbitrary callback to
            render content. Callbacks should be specified via the &#39;callback&#39;
            option passed in the decorator configuration, and can be any
            valid PHP callback type. Callbacks should accept three
            arguments,  $content  (the original content passed to
            the decorator),  $element  (the item being
            decorated), and an array of  $options . As an example
            callback:
         &lt;?php
class Util
{
    public static function label($content, $element, array $options)
    {
        return &#39;&lt;span class=&quot;label&quot;&gt;&#39; . $element-&gt;getLabel() . &quot;&lt;/span&gt;&quot;;
    }
}
?&gt; 
            This callback would be specified as  array(&#39;Util&#39;,
                &#39;label&#39;) , and would generate some (bad) HTML markup
            for the label. The Callback decorator would then either replace,
            append, or prepend the original content with the return value of
            this.
         
            The Callback decorator allows specifying a null value for the
            placement option, which will replace the original content with
            the callback return value; &#39;prepend&#39; and &#39;append&#39; are still
            valid as well.
         Zend_Form_Decorator_Description 
            The Description decorator can be used to display a description set
            on a  Zend_Form ,  Zend_Form_Element , or
             Zend_Form_DisplayGroup  item; it pulls the description
            using the object&#39;s  getDescription()  method. Common use
            cases are for providing UI hints for your elements.
         
            By default, if no description is present, no output is generated. If
            the description is present, then it is wrapped in an HTML
             p  tag by default, though you may specify a tag by
            passing a  tag  option when creating the decorator, or
            calling  setTag() . You may additionally specify a class
            for the tag using the  class  option or by calling
             setClass() ; by default, the class &#39;hint&#39; is used.
         
            The description is escaped using the view object&#39;s escaping
            mechanisms by default. You can disable this by passing a
             false  value to the decorator&#39;s &#39;escape&#39; option or
             setEscape()  method.
         Zend_Form_Decorator_DtDdWrapper 
            The default decorators utilize definition lists
            ( &lt;dl&gt; ) to render form elements. Since form
            items can appear in any order, display groups and sub forms can
            be interspersed with other form items. To keep these particular
            item types within the definition list, the DtDdWrapper creates a
            new, empty definition term ( &lt;dt&gt; ) and wraps
            its content in a new definition datum ( &lt;dd&gt; ).
            The output looks something like this:
         
&lt;dt&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;fieldset id=&quot;subform&quot;&gt;
    &lt;legend&gt;User Information&lt;/legend&gt;
    ...
&lt;/fieldset&gt;&lt;/dd&gt;
 
            This decorator replaces the content provided to it by wrapping
            it within the  &lt;dd&gt;  element.
         Zend_Form_Decorator_Errors 
            Element errors get their own decorator with the Errors
            decorator. This decorator proxies to the FormErrors view helper,
            which renders error messages in an unordered list
            ( &lt;ul&gt; ) as list items. The
             &lt;ul&gt;  element receives a class of &quot;errors&quot;.
         
            The Errors decorator can either prepend or append the content
            provided to it.
         Zend_Form_Decorator_Fieldset 
            Display groups and sub forms render their content within
            fieldsets by default. The Fieldset decorator checks for either a
            &#39;legend&#39; option or a  getLegend()  method in the
            registered element, and uses that as a legend if non-empty. Any
            content passed in is wrapped in the HTML fieldset, replacing the
            original content. Any attributes set in the decorated item are
            passed to the fieldset as HTML attributes.
         Zend_Form_Decorator_Form Zend_Form  objects typically need to render an HTML
            form tag. The Form decorator proxies to the Form view helper. It
            wraps any provided content in an HTML form element, using the
             Zend_Form  object&#39;s action and method, and any
            attributes as HTML attributes.
         Zend_Form_Decorator_FormElements 
            Forms, display groups, and sub forms are collections of
            elements. In order to render these elements, they utilize the
            FormElements decorator, which iterates through all items,
            calling  render()  on each and joining them with the
            registered separator. It can either append or prepend content
            passed to it.
         Zend_Form_Decorator_HtmlTag 
            The HtmlTag decorator allows you to utilize HTML tags to
            decorate content; the tag utilized is passed in the &#39;tag&#39;
            option, and any other options are used as HTML attributes to
            that tag. The tag by default is assumed to be block level, and
            replaces the content by wrapping it in the given tag. However,
            you can specify a placement to append or prepend a tag as well.
         Zend_Form_Decorator_Image 
            The Image decorator allows you to create an HTML image input
            ( &lt;input type=&quot;image&quot; ... /&gt; ), and optionally
            render it within another HTML tag.
         
            By default, the decorator uses the element&#39;s src property, which can
            be set with the  setImage()  method, as the image
            source. Additionally, the element&#39;s label will be used as the alt
            tag, and the  imageValue  (manipulated with the Image
            element&#39;s  setImageValue()  and
             getImageValue()  accessors) will be used for the value.
         
            To specify an HTML tag with which to wrap the element, either pass a
            &#39;tag&#39; option to the decorator, or explicitly call
             setTag() .
         Zend_Form_Decorator_Label 
            Form elements typically have labels, and the Label decorator is
            used to render these labels. It proxies to the FormLabel view
            helper, and pulls the element label using the
             getLabel()  method of the element. If no label is
            present, none is rendered. By default, labels are translated when a
            translation adapter exists and a translation for the label exists.
         
            You may optionally specify a &#39;tag&#39; option; if provided, it wraps
            the label in that block-level tag. If the &#39;tag&#39; option is
            present, and no label present, the tag is rendered with no
            content. You can specify the class to use with the tag with the
            &#39;class&#39; option or by calling  setClass() .
         
            Additionally, you can specify prefixes and suffixes to use when
            displaying the element, based on whether or not the label is for an
            optional or required element. Common use cases would be to append a
            &#39;:&#39; to the label, or a &#39;*&#39; indicating an item is required. You can
            do so with the following options and methods:
         optionalPrefix : set the text to prefix the
                    label with when the element is optional. Use the
                     setOptionalPrefix()  and
                     getOptionalPrefix()  accessors to manipulate it.
             optionalSuffix : set the text to append the
                    label with when the element is optional. Use the
                     setOptionalSuffix()  and
                     getOptionalSuffix()  accessors to manipulate it.
             requiredPrefix : set the text to prefix the
                    label with when the element is required. Use the
                     setRequiredPrefix()  and
                     getRequiredPrefix()  accessors to manipulate it.
             requiredSuffix : set the text to append the
                    label with when the element is required. Use the
                     setRequiredSuffix()  and
                     getRequiredSuffix()  accessors to manipulate it.
             
            By default, the Label decorator prepends to the provided
            content; specify a &#39;placement&#39; option of &#39;append&#39; to place it
            after the content.
         Zend_Form_Decorator_ViewHelper 
            Most elements utilize  Zend_View  helpers for
            rendering, and this is done with the ViewHelper decorator. With
            it, you may specify a &#39;helper&#39; tag to explicitly set the view
            helper to utilize; if none is provided, it uses the last segment
            of the element&#39;s class name to determine the helper, prepending
            it with the string &#39;form&#39;: e.g., &#39;Zend_Form_Element_Text&#39; would
            look for a view helper of &#39;formText&#39;. 
         
            Any attributes of the provided element are passed to the view
            helper as element attributes.
         
            By default, this decorator appends content; use the &#39;placement&#39;
            option to specify alternate placement.
         Zend_Form_Decorator_ViewScript 
            Sometimes you may wish to use a view script for creating your
            elements; this way you can have fine-grained control over your
            elements, turn the view script over to a designer, or simply create
            a way to easily override setting based on which module you&#39;re using
            (each module could optionally override element view scripts to suit
            their own needs). The ViewScript decorator solves this problem.
         
            The ViewScript decorator requires a &#39;viewScript&#39; option, either
            provided to the decorator, or as an attribute of the element. It
            then renders that view script as a partial script, meaning each call
            to it has its own variable scope; no variables from the view will be
            injected other than the element itself. Several variables are then
            populated:
         element : the element being decorated
             content : the content passed to the decorator
             decorator : the decorator object itself
             
                    Additionally, all options passed to the decorator via
                     setOptions()  that are not used internally (such
                    as placement, separator, etc.) are passed to the view script
                    as view variables.
             
            As an example, you might have the following element:
         &lt;?php
// Setting the decorator for the element to a single, ViewScript, decorator,
// specifying the viewScript as an option, and some extra options:
$element-&gt;setDecorators(array(array(&#39;ViewScript&#39;, array(
    &#39;viewScript&#39; =&gt; &#39;_element.phtml&#39;,
    &#39;class&#39;      =&gt; &#39;form element&#39;
))));

// OR specifying the viewScript as an element attribute:
$element-&gt;viewScript = &#39;_element.phtml&#39;;
$element-&gt;setDecorators(array(array(&#39;ViewScript&#39;, array(&#39;class&#39; =&gt; &#39;form element&#39;))));
?&gt; 
            You could then have a view script something like this:
         
&lt;div class=&quot;&lt;?= $this-&gt;class ?&gt;&quot;&gt;
    &lt;?= $this-&gt;formLabel($this-&gt;element-&gt;getName(), $this-&gt;element-&gt;getLabel()) ?&gt;
    &lt;?= $this-&gt;{$this-&gt;element-&gt;helper}(
        $this-&gt;element-&gt;getName(),
        $this-&gt;element-&gt;getValue(), 
        $this-&gt;element-&gt;getAttribs()
    ) ?&gt;
    &lt;?= $this-&gt;formErrors($this-&gt;element-&gt;getMessages()) ?&gt;
    &lt;div class=&quot;hint&quot;&gt;&lt;?= $this-&gt;element-&gt;getDescription() ?&gt;&lt;/div&gt;
&lt;/div&gt;
 Replacing content with a view script 
                You may find it useful for the view script to replace the
                content provided to the decorator -- for instance, if you want
                to wrap it. You can do so by specifying a boolean false value
                for the decorator&#39;s &#39;placement&#39; option:
             &lt;?php
// At decorator creation:
$element-&gt;addDecorator(&#39;ViewScript&#39;, array(&#39;placement&#39; =&gt; false));

// Applying to an existing decorator instance:
$decorator-&gt;setOption(&#39;placement&#39;, false);

// Applying to a decorator already attached to an element:
$element-&gt;getDecorator(&#39;ViewScript&#39;)-&gt;setOption(&#39;placement&#39;, false);

// Within a view script used by a decorator:
$this-&gt;decorator-&gt;setOption(&#39;placement&#39;, false);
?&gt; 
            Using the ViewScript decorator is recommended for when you want to
            have very fine-grained control over how your elements are rendered.
         Standard Form Elements Shipped With Zend Framework 
        Zend Framework ships with concrete element classes covering most HTML
        form elements. Most simply specify a particular view helper for use when
        decorating the element, but several offer additional functionality. The
        following is a list of all such classes, as well as descriptions of the
        functionality they offer.
     Zend_Form_Element_Button 
            Used for creating HTML button elements,
             Zend_Form_Element_Button  extends  Zend_Form_Element_Submit ,
            deriving its custom functionality. It specifies the &#39;formButton&#39;
            view helper for decoration.
         
            Like the submit element, it uses the element&#39;s label as the element
            value for display purposes; in other words, to set the text of the
            button, set the value of the element. The label will be translated
            if a translation adapter is present.
         
            Because the label is used as part of the element, the button element
            uses only the  ViewHelper 
            and  DtDdWrapper 
            decorators.
         
            After populating or validating a form, you can check if the given
            button was clicked using the  isChecked()  method.
         Zend_Form_Element_Checkbox 
            HTML checkboxes allow you return a specific value, but basically
            operate as booleans: when it is checked, the value is submitted;
            when it&#39;s not checked, nothing is submitted. Internally,
            Zend_Form_Element_Checkbox enforces this state.
         
            By default, the checked value is &#39;1&#39;, and the unchecked value &#39;0&#39;.
            You can specify the values to use using the
             setCheckedValue()  and  setUncheckedValue() 
            accessors, respectively. Internally, any time you set the value, if
            the provided value matches the checked value, then it is set, but
            any other value causes the unchecked value to be set.
         
            Additionally, setting the value sets the  checked 
            property of the checkbox. You can query this using
             isChecked()  or simply accessing the property. Using the
             setChecked($flag)  method will both set the state of the
            flag as well as set the approriate checked or unchecked value in the
            element. Please use this method when setting the checked state of a
            checkbox element to ensure the value is set properly.
         Zend_Form_Element_Checkbox  uses the &#39;formCheckbox&#39; view
            helper. The checked value is always used to populate it.
         Zend_Form_Element_Hidden 
            Hidden elements merely inject data that should be submitted, but
            which the user should not manipulate.
             Zend_Form_Element_Hidden  accomplishes this through use
            of the &#39;formHidden&#39; view helper.
         Zend_Form_Element_Hash 
            This element provides protection from CSRF attacks on forms,
            ensuring the data is submitted by the user session that generated
            the form and not by a rogue script. Protection is achieved by adding
            a hash element to a form and verifying it when the form is
            submitted.
         
            The name of the hash element should be unique. It is recommended to use
            the  salt  option for the element, two hashes with
            same names and different salts would not collide:
         &lt;?php
$form-&gt;addElement(&#39;hash&#39;, &#39;no_csrf_foo&#39;, array(&#39;salt&#39; =&gt; &#39;unique&#39;));
?&gt; 
            You can set the salt later using the  setSalt($salt) 
            method.
         
            Internally, the element stores a unique identifier using
             Zend_Session_Namespace , and checks for it at
            submission (checking that the TTL has not expired). The &#39;Identical&#39;
            validator is then used to ensure the submitted hash matches the
            stored hash.
         
            The &#39;formHidden&#39; view helper is used to render the element in the
            form.
         Zend_Form_Element_Image 
            Images can be used as form elements, and allow you to specify
            graphical elements as form buttons.
         
            Images need an image source.  Zend_Form_Element_Image 
            allows you to specify this by using the  setImage() 
            accessor (or &#39;image&#39; configuration key). You can also optionally specify a value to use when
            submitting the image using the  setImageValue()  accessor
            (or &#39;imageValue&#39; configuration key). When the value set for the
            element matches the  imageValue , then the accessor
             isChecked()  will return true. 
         
            The Image element uses the 
             Image
                Decorator  for rendering (as well as the standard Errors,
            HtmlTag, and Label decorators). You can optionally specify a tag to
            the  Image  decorator that will then wrap the image
            element.
         Zend_Form_Element_MultiCheckbox 
            Often you have a set of related checkboxes, and you wish to group
            the results. This is much like a  Multiselect ,
            but instead of them being in a dropdown list, you need to show
            checkbox/value pairs.
         Zend_Form_Element_MultiCheckbox  makes this a snap. Like
            all other elements extending the base Multi element, you can specify
            a list of options, and easily validate against that same list. The
            &#39;formMultiCheckbox&#39; view helper ensures that these are returned as
            an array in the form submission.
         
            You may manipulate the various checkbox options using the following
            methods:
         addMultiOption($option, $value) addMultiOptions(array $options) setMultiOptions(array $options) 
                    (overwrites existing options) getMultiOption($option) getMultiOptions() removeMultiOption($option) clearMultiOptions() Zend_Form_Element_Multiselect 
            XHTML  select  elements allow a &#39;multiple&#39; attribute,
            indicating multiple options may be selected for submission, instead
            of the usual one.  Zend_Form_Element_Multiselect  extends
             Zend_Form_Element_Select ,
            and sets the  multiple  attribute to &#39;multiple&#39;. Like
            other classes that inherit from the base
             Zend_Form_Element_Multi  class, you can manipulate the
            options for the select using:
         addMultiOption($option, $value) addMultiOptions(array $options) setMultiOptions(array $options) 
                    (overwrites existing options) getMultiOption($option) getMultiOptions() removeMultiOption($option) clearMultiOptions() 
            If a translation adapter is registered with the form and/or element,
            option values will be translated for display purposes.
         Zend_Form_Element_Password 
            Password elements are basically normal text elements -- except that
            you typically do not want the submitted password displayed in error
            messages or the element itself when the form is re-displayed.
         Zend_Form_Element_Password  achieves this by calling
             setObscureValue(true)  on each validator (ensuring that
            the password is obscured in validation error messages), and using
            the &#39;formPassword&#39; view helper (which does not display the value
            passed to it).
         Zend_Form_Element_Radio 
            Radio elements allow you to specify several options, of which you
            need a single value returned.  Zend_Form_Element_Radio 
            extends the base  Zend_Form_Element_Multi  class,
            allowing you to specify a number of options, and then uses the
             formRadio  view helper to display these.
         
            Like all elements extending the Multi element base class, the
            following methods may be used to manipulate the radio options
            displayed:
         addMultiOption($option, $value) addMultiOptions(array $options) setMultiOptions(array $options) 
                    (overwrites existing options) getMultiOption($option) getMultiOptions() removeMultiOption($option) clearMultiOptions() Zend_Form_Element_Reset 
            Reset buttons are typically used to clear a form, and are not part
            of submitted data. However, as they serve a purpose in the display,
            they are included in the standard elements.
         Zend_Form_Element_Reset  extends  Zend_Form_Element_Submit .
            As such, the label is used for the button display, and will be
            translated if a translation adapter is present. It utilizes only the
            &#39;ViewHelper&#39; and &#39;DtDdWrapper&#39; decorators, as there should never be
            error messages for such elements, nor will a label be necessary.
         Zend_Form_Element_Select 
            Select boxes are a common way of limiting to specific choices for a
            given form datum.  Zend_Form_Element_Select  allows you
            to generate these quickly and easily.
         
            As it extends the base Multi element, the following methods may be
            used to manipulate the select options:
         addMultiOption($option, $value) addMultiOptions(array $options) setMultiOptions(array $options) 
                    (overwrites existing options) getMultiOption($option) getMultiOptions() removeMultiOption($option) clearMultiOptions() Zend_Form_Element_Select  uses the &#39;formSelect&#39; view
            helper for decoration.
         Zend_Form_Element_Submit 
            Submit buttons are used to submit a form. You may use multiple
            submit buttons; you can use the button used to submit the form to
            decide what action to take with the data submitted.
             Zend_Form_Element_Submit  makes this decisioning easy,
            by adding a  isChecked()  method; as only one button
            element will be submitted by the form, after populating or
            validating the form, you can call this method on each submit button
            to determine which one was used.
         Zend_Form_Element_Submit  uses the label as the &quot;value&quot;
            of the submit button, translating it if a translation adapter is
            present.  isChecked()  checks the submitted value against
            the label in order to determine if the button was used.
         
            The  ViewHelper 
            and  DtDdWrapper 
            decorators to render the element. No label decorator is used, as the
            button label is used when rendering the element; also, typically,
            you will not associate errors with a submit element.
         Zend_Form_Element_Text 
            By far the most prevalent type of form element is the text element,
            allowing for limited text entry; it&#39;s an ideal element for most data
            entry.  Zend_Form_Element_Text  simply uses the
            &#39;formText&#39; view helper to display the element.
         Zend_Form_Element_Textarea 
            Textareas are used when large quantities of text are expected, and
            place no limits on the amount of text submitted (other than maximum
            size limits as dictated by your server or PHP).
             Zend_Form_Element_Textarea  uses the &#39;textArea&#39; view
            helper to display such elements, placing the value as the content of
            the element.
         Introduction to Gdata 
        Google Data APIs provide programmatic interface to some of Google&#39;s
        online services.  The Google data Protocol is based upon the
         Atom Publishing Protocol 
        and allows client applications to retrieve data matching queries,
        post data, update data and delete data using standard HTTP and the
        Atom syndication formation.

        The Zend_Gdata component is a PHP 5 interface for accessing Google Data
        from PHP.  The Zend_Gdata component also supports accessing other services
        implementing the Atom Publishing Protocol.
     
        See
         http://code.google.com/apis/gdata/ 
        for more information about Google Data API.
     
        The services that are accessible by Zend_Gdata include the
        following:

         Google Calendar 
                    is a popular online calendar application.
                 Google Spreadsheets 
                    provides an online collaborative spreadsheets tool which
                    can be used as a simple data store for your applications.
                 Google Documents List 
                    provides an online list of all spreadsheets, word processing documents,
                    and presentations stored in a Google account.
                 Google Provisioning 
                    provides the ability to create, retrieve, update, and
                    delete user accounts, nicknames, and email lists on a
                    Google Apps hosted domain.
                 Google Base 
                    provides the ability to retrieve, post, update, and
                    delete items in Google Base.
                 YouTube 
                    provides the ability to search and retrieve videos,
                    comments, favorites, subscriptions, user profiles
                    and more.
                 Picasa Web Albums 
                    provides an online photo sharing application.
                 Google Blogger 
                    is a popular Internet provider of
                    &quot;push-button publishing&quot; and syndication.
                 
                    Google CodeSearch
                    allows you to search public source code from many projects.
                 
                    Google Notebook
                    allows you to view public Notebook content.
                 
     Unsupported services 
            Zend_Gdata does not provide an interface to any other Google
            service, such as Search, Gmail, Translation, or Maps.
            Only services that support the Google Data API are supported.
         Structure of Zend_Gdata 
            Zend_Gata is composed of several types of classes:
             
                        Service classes - inheriting from Zend_Gdata_App.
                        These also include other classes such as Zend_Gdata,
                        Zend_Gdata_Spreadsheets, etc.  These classes enable
                        interacting with APP or GData services and provide the
                        ability to retrieve feeds, retrieve entries, post
                        entries, update entries and delete entries.
                     
                        Query classes - inheriting from Zend_Gdata_Query.
                        These also include other classes for specific services,
                        such as Zend_Gdata_Spreadsheets_ListQuery and
                        Zend_Gdata_Spreadsheets_CellQuery.  Query classes
                        provide methods used to construct a query for data
                        to be retrieved from GData services.  Methods include
                        getters and setters like  setUpdatedMin() ,
                         setStartIndex() , and
                         getPublishedMin() .  The query classes also
                        have a method to generate a URL representing the
                        constructed query --  getQueryUrl .
                        Alternatively, the query string component of the URL
                        can be retrieved used the  getQueryString() 
                        method.
                     
                        Feed classes - inheriting from Zend_Gdata_App_Feed.
                        These also include other classes such as
                        Zend_Gdata_Feed,
                        Zend_Gdata_Spreadsheets_SpreadsheetFeed,
                        and Zend_Gdata_Spreadsheets_ListFeed.
                        These classes represent feeds of entries retrieved
                        from services.  They are primarily used to retrieve
                        data returned from services.
                     
                        Entry classes - inheriting from Zend_Gdata_App_Entry.
                        These also include other classes such as
                        Zend_Gdata_Entry, and Zend_Gdata_Spreadsheets_ListEntry.
                        These classes represent entries retrieved from
                        services or used for constructing data to send to
                        services.  In addition to being able to set the
                        properties of an entry (such as the spreadsheet cell
                        value), you can use an entry object to send update
                        or delete requests to a service.  For example,
                        you can call  $entry-&gt;save()  to save
                        changes made to an entry back to service from which
                        the entry initiated, or  $entry-&gt;delete() 
                        to delete an entry from the server.
                     
                        Other Data model classes - inheriting from
                        Zend_Gdata_App_Extension.  These include classes such
                        as Zend_Gdata_App_Extension_Title (representing the
                        atom:title XML element), Zend_Gdata_Extension_When
                        (representing the gd:when XML element used by the
                        GData Event &quot;Kind&quot;), and
                        Zend_Gdata_Extension_Cell (representing the gs:cell
                        XML element used by Google Spreadsheets).  These
                        classes are used purely to store the data retrieved
                        back from services and for constructing data to be
                        sent to services.  These include getters and setters 
                        such as
                         setText()  to set the child text
                        node of an element,  getText()  to retrieve
                        the text node of an element,  getStartTime() 
                        to retrieve the start time attribute of a When element,
                        and other similiar methods.
                        The data model classes also include methods such as
                         getDOM()  to retrieve a DOM representation
                        of the element and all children and
                         transferFromDOM()  to construct a data
                        model representation of a DOM tree.
                     
         Interacting with Google Services 
            Google data services are based upon the Atom Publishing Protocol
            (APP) and the Atom syndication format.  To interact with APP or
            Google services using the Zend_Gdata component, you need to use
            the service classes such as Zend_Gdata_App, Zend_Gdata,
            Zend_Gdata_Spreadsheets, etc.  These service classes provide
            methods to retrieve data from services as feeds, insert new
            entries into feeds, update entries, and delete entries.
         
            Note: A full example of working with Zend_Gdata is available in the
             demos/Zend/Gdata  directory.  This example is runnable
            from the command-line, but the methods contained within are easily
            portable to a web application.
         Obtaining instances of Zend_Gdata classes 
            The Zend Framework naming standards require that all classes be
            named based upon the directory structure in which they are located.
            For instance, extensions related to Spreadsheets are stored in:
             Zend/Gdata/Spreadsheets/Extension/...  and, as a result
            of this, are named
             Zend_Gdata_Spreadsheets_Extension_... .
            This causes a lot of typing if you&#39;re trying to construct a new
            instance of a spreadsheet cell element!
         
            We&#39;ve implemented a magic factory method in all service classes
            (such as Zend_Gdata_App, Zend_Gdata, Zend_Gdata_Spreadsheets) that
            should make constructing new instances of data model, query and
            other classes much easier.  This magic factory is implemented by
            using the magic  __call  method to intercept all attempts
            to call  $service-&gt;newXXX(arg1, arg2, ...) .  Based off
            the value of XXX, a search is performed in all registered &#39;packages&#39;
            for the desired class.  Here&#39;s some examples:
         &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata_Spreadsheets&#39;);

$ss = new Zend_Gdata_Spreadsheets();

// creates a Zend_Gdata_App_Spreadsheets_CellEntry
$entry = $ss-&gt;newCellEntry();

// creates a Zend_Gdata_App_Spreadsheets_Extension_Cell
$cell = $ss-&gt;newCell();
$cell-&gt;setText(&#39;My cell value&#39;);
$cell-&gt;setRow(&#39;1&#39;);
$cell-&gt;setColumn(&#39;3&#39;);
$entry-&gt;cell = $cell;

// ... $entry can then be used to send an update to a Google Spreadsheet
         
            Each service class in the inheritance tree is responsible for
            registering the appropriate &#39;packages&#39; (directories) which are to
            be searched when calling the magic factory method.
         Google Data Client Authentication 
            Most Google Data services require client applications to
            authenticate against the Google server before accessing
            private data, or saving or deleting data.
            There are two implementations of authentication for Google Data:
             AuthSub  and
             ClientLogin .
            Zend_Gdata offers class interfaces for both of these methods.
         
            Most other types of queries against Google Data services do not
            require authentication.
         Dependencies 
            Zend_Gdata makes use of
             Zend_Http_Client  to send
            requests to google.com and fetch results.  The response to most
            Google Data requests is returned as a subclass of the
            Zend_Gdata_App_Feed or Zend_Gdata_App_Entry classes.
         
            Zend_Gdata assumes your PHP application is running on a host that
            has a direct connection to the Internet.
            The Zend_Gdata client operates by contacting Google Data servers.
         Creating a new Gdata client 
            Create a new object of class Zend_Gdata_App, Zend_Gdata, or one
            of the subclasses available that offer helper methods for
            service-specific behavior.
         
            The single optional parameter to the Zend_Gdata_App constructor
            is an instance of
             Zend_Http_Client .
            If you don&#39;t pass this parameter, Zend_Gdata creates a default
            Zend_Http_Client object, which will not have associated
            credentials to access private feeds.  Specifying the
            Zend_Http_Client object also allows you to
            pass configuration options to that client object.
         &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Http_Client&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata&#39;);

$client = new Zend_Http_Client();
$client-&gt;setConfig( ...options... );

$gdata = new Zend_Gdata($client);
         
            Also see the sections on authentication for methods to
            create an authenticated Zend_Http_Client object.
         Common query parameters 
            You can specify parameters to customize queries with Zend_Gdata.
            Query parameters are specified using subclasses of Zend_Gdata_Query.
            The Zend_Gdata_Query class includes methods to set all query
            parameters used throughout GData services.  Individual services,
            such as Spreadsheets, also provide query classes to defined
            parameters which are custom to the particular service and feeds.
            Spreadsheets includes a CellQuery class to query the Cell Feed
            and a ListQuery class to query the List Feed, as different
            query parameters are applicable to each of those feed types.

            The GData-wide parameters are described below.
         
                    The  q  parameter specifies a full-text
                    query.  The value of the parameter is a string.
                 
                    Set this parameter with the  setQuery() 
                    function.
                 
                    The  alt  parameter specifies the feed type.
                    The value of the parameter can be
                     atom ,
                     rss ,
                     json ,
                    or  json-in-script .
                    If you don&#39;t specify this parameter, the default feed type
                    is  atom .  NOTE: Only the output of the
                    atom feed format can be processed using
                     Zend_Gdata .
                    The  Zend_Http_Client  could be used to retrieve
                    feeds in other formats, using query URLs generated by the
                     Zend_Gdata_Query  class and its subclasses.
                 
                    Set this parameter with the  setAlt() 
                    function.
                 
                    The  maxResults  parameter limits the number
                    of entries in the feed.  The value of the parameter is
                    an integer.  The number of entries returned in the feed
                    will not exceed this value.
                 
                    Set this parameter with the  setMaxResults() 
                    function.
                 
                    The  startIndex  parameter specifies the
                    ordinal number of the first entry returned in the feed.
                    Entries before this number are skipped.
                 
                    Set this parameter with the  setStartIndex() 
                    function.
                 
                    The  updatedMin  and  updatedMax 
                    parameters specify bounds on the entry date.
                    If you specify a value for  updatedMin ,
                    no entries that were updated earlier than the date
                    you specify are included in the feed.  Likewise
                    no entries updated after the date specified by
                     updatedMax  are included.
                 
                    You can use numeric timestamps, or a variety of
                    date/time string representations as the value for
                    these parameters.
                 
                    Set this parameter with the  setUpdatedMin() 
                    and  setUpdatedMax()  functions.
                 
            There is a  get  function for each
             set  function.
         &lt;?php
$query = new Zend_Gdata_Query();
$query-&gt;setMaxResults(10);
echo $query-&gt;getMaxResults();   // returns 10
         
            The Zend_Gdata class also implements &quot;magic&quot; getter and
            setter methods, so you can use the name of the parameter
            as a virtual member of the class.
         &lt;?php
$query = new Zend_Gdata_Query();
$query-&gt;maxResults = 10;
echo $query-&gt;maxResults;        // returns 10
         
            You can clear all parameters with the  resetParameters() 
            function.  This is useful to do if you reuse a Zend_Gdata
            object for multiple queries.
         &lt;?php
$query = new Zend_Gdata_Query();
$query-&gt;maxResults = 10;
// ...get feed...

$query-&gt;resetParameters();      // clears all parameters
// ...get a different feed...
         Fetching a feed 
            Use the  getFeed()  function to retrieve
            a feed from a specified URI.
            This function returns an instance of class specified
            as the second argument to getFeed, which defaults to
            Zend_Gdata_Feed.
         &lt;?php
$gdata = new Zend_Gdata();
$query = new Zend_Gdata_Query(
        &#39;http://www.blogger.com/feeds/blogID/posts/default&#39;);
$query-&gt;setMaxResults(10);
$feed = $gdata-&gt;getFeed($query);
         
            See later sections for special functions in each
            helper class for Google Data services.  These
            functions help you to get feeds from the URI that is
            appropriate for the respective service.
         Working with multi-page feeds 
            When retrieving a feed that contains a large number of entries,
            the feed may be broken up into many smaller &quot;pages&quot; of feeds. When
            this occurs, each page will contain a link to the next page in the
            series. This link can be accessed by calling
             getLink(&#39;next&#39;) . The following example shows how to
            retrieve the next page of a feed:
         &lt;?php
function getNextPage($feed) {
    $nextURL = $feed-&gt;getLink(&#39;next&#39;);
    if ($nextURL !== null) {
        return $gdata-&gt;getFeed($nextURL);
    } else {
        return null;
    }
}
         
            If you would prefer not to work with pages in your application,
            pass the first page of the feed into
             Zend_Gdata_App::retrieveAllEntriesForFeed() , which
            will consolidate all entries from each page into a single feed.
            This example shows how to use this function:
         &lt;?php
$gdata = new Zend_Gdata();
$query = new Zend_Gdata_Query(
        &#39;http://www.blogger.com/feeds/blogID/posts/default&#39;);
$feed = $gdata-&gt;retrieveAllEntriesForFeed($gdata-&gt;getFeed($query));
         
            Keep in mind when calling this function that it may take a long
            time to complete on large feeds. You may need to increase PHP&#39;s
            execution time limit by calling  set_time_limit() .
         Working with data in feeds and entries 
            After retrieving a feed, you can read the data from the feed
            or the entries contained in the feed using either the accessors
            defined in each of the data model classes or the magic
            accessors.  Here&#39;s an example:
         &lt;?php
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
$gdata = new Zend_Gdata($client);
$query = new Zend_Gdata_Query(
        &#39;http://www.blogger.com/feeds/blogID/posts/default&#39;);
$query-&gt;setMaxResults(10);
$feed = $gdata-&gt;getFeed($query);
foreach ($feed as $entry) {
    // using the magic accessor
    echo &#39;Title: &#39; . $entry-&gt;title-&gt;text;
    // using the defined accessors
    echo &#39;Content: &#39; . $entry-&gt;getContent()-&gt;getText();
}
         Updating entries 
            After retrieving an entry, you can update that entry and save
            changes back to the server.  Here&#39;s an example:
         &lt;?php
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
$gdata = new Zend_Gdata($client);
$query = new Zend_Gdata_Query(
        &#39;http://www.blogger.com/feeds/blogID/posts/default&#39;);
$query-&gt;setMaxResults(10);
$feed = $gdata-&gt;getFeed($query);
foreach ($feed as $entry) {
    // update the title to append &#39;NEW&#39;
    echo &#39;Old Title: &#39; . $entry-&gt;title-&gt;text;
    $entry-&gt;title-&gt;text = $entry-&gt;title-&gt;text . &#39; NEW&#39;;

    // update the entry on the server
    $newEntry = $entry-&gt;save();
    echo &#39;New Title: &#39; . $newEntry-&gt;title-&gt;text;
}
         Posting entries to Google servers 
            The Zend_Gdata object has a function  post() 
            with which you can upload data to save new entries
            to Google Data services.
         
            You can use the data model classes for each service to
            construct the appropriate entry to post to Google&#39;s
            services.  The  post()  function will
            accept a child of Zend_Gdata_App_Entry as data to
            post to the service.  The method returns a child
            of Zend_Gdata_App_Entry which represents the state
            of the entry as it was returned from the server.
         
            Alternatively, you could construct the XML structure
            for an entry as a string and pass the string to the
             post()  function.
         &lt;?php
$gdata = new Zend_Gdata($authenticatedHttpClient);

$entry = $gdata-&gt;newEntry();
$entry-&gt;title = $gdata-&gt;newTitle(&#39;Playing football at the park&#39;);
$content = $gdata-&gt;newContent(&#39;We will visit the park and play a few football matches&#39;);
$content-&gt;setType(&#39;text&#39;);
$entry-&gt;content = $content;

$entryResult = $gdata-&gt;insertEntry($entry,
        &#39;http://www.blogger.com/feeds/blogID/posts/default&#39;);

echo &#39;The &lt;id&gt; of the resulting entry is: &#39; . $entryResult-&gt;id-&gt;text;
         
            To post entries, you must be using an authenticated
            Zend_Http_Client that you created using the Zend_Gdata_AuthSub
            or Zend_Gdata_ClientLogin classes.
         Deleting entries on Google servers 
            Option 1: The Zend_Gdata object has a function  delete() 
            with which you can delete entries from Google Data
            services.  Pass the edit URL value from
            a feed entry to the  delete()  method.
         
            Option 2: Alternatively, you can call  $entry-&gt;delete() 
            on an entry retrieved from a Google service.
         &lt;?php
$gdata = new Zend_Gdata($authenticatedHttpClient);
// a Google Data feed
$feedUri = ...;
$feed = $gdata-&gt;getFeed($feedUri);
foreach ($feed as $feedEntry) {
    // Option 1 - delete the entry directly
    $feedEntry-&gt;delete();
    // Option 2 - delete the entry by passing the edit URL to $gdata-&gt;delete()
    // $gdata-&gt;delete($feedEntry-&gt;getEditLink()-&gt;href);
}
         
            To delete entries, you must be using an authenticated
            Zend_Http_Client that you created using the Zend_Gdata_AuthSub
            or Zend_Gdata_ClientLogin classes.
         Authenticating with AuthSub 
        The AuthSub mechanism enables you to write web applications
        that acquire authenticated access Google Data services,
        without having to write code that handles user credentials.
     
        See  http://code.google.com/apis/accounts/AuthForWebApps.html 
        for more information about Google Data AuthSub authentication.
     
        The Google documentation says the ClientLogin mechanism is appropriate
        for &quot;installed applications&quot; whereas the AuthSub mechanism is
        for &quot;web applications.&quot;  The difference is that AuthSub requires
        interaction from the user, and a browser interface that can react
        to redirection requests.  The ClientLogin solution uses PHP code to
        supply the account credentials; the user is not required to enter her
        credentials interactively.
     
        The account credentials supplied via the AuthSub mechanism are
        entered by the user of the web application.  Therefore they must be
        account credentials that are known to that user.
     Registered applications 
            Zend_Gdata currently does not support use of secure tokens, because
            the AuthSub authentication does not support passing a digital certificate
            to acquire a secure token.
         Creating an AuthSub authenticated Http Client 
            Your PHP application should provide a hyperlink to the
            Google URL that performs authentication.  The static function
             Zend_Gdata_AuthSub::getAuthSubTokenUri() 
            provides the correct URL.  The arguments to this function include
            the URL to your PHP applicaion so that Google can redirect the
            user&#39;s browser back to your application after the user&#39;s
            credentials have been verified.
         
            After Google&#39;s authentication server redirects the user&#39;s browser
            back to the current application, a GET request parameter is set,
            called  token .
            The value of this parameter is a single-use token that can be
            used for authenticated access.
            This token can be converted into a multi-use token and stored
            in your session.
         
            Then use the token value in a call to
             Zend_Gdata_AuthSub::getHttpClient() .
            This function returns an instance of Zend_Http_Client,
            with appropriate headers set so that subsequent requests your
            application submits using that Http Client are also authenticated.
         
            Below is an example of PHP code for a web application
            to acquire authentication to use the Google Calendar service
            and create a Zend_Gdata client object using that authenticated
            Http Client.
         &lt;?php
$my_calendar = &#39;http://www.google.com/calendar/feeds/default/private/full&#39;;

if (!isset($_SESSION[&#39;cal_token&#39;])) {
    if (isset($_GET[&#39;token&#39;])) {
        // You can convert the single-use token to a session token.
        $session_token =  Zend_Gdata_AuthSub::getAuthSubSessionToken($_GET[&#39;token&#39;]);
        // Store the session token in our session.
        $_SESSION[&#39;cal_token&#39;] = $session_token;
    } else {
        // Display link to generate single-use token
        $googleUri = Zend_Gdata_AuthSub::getAuthSubTokenUri(
            &#39;http://&#39;. $_SERVER[&#39;SERVER_NAME&#39;] . $_SERVER[&#39;REQUEST_URI&#39;],
            $my_calendar, 0, 1);
        echo &quot;Click &lt;a href=&#39;$googleUri&#39;&gt;here&lt;/a&gt; to authorize this application.&quot;;
        exit();
    }
}

// Create an authenticated HTTP Client to talk to Google.
$client = Zend_Gdata_AuthSub::getHttpClient($_SESSION[&#39;cal_token&#39;]);

// Create a Gdata object using the authenticated Http Client
$cal = new Zend_Gdata_Calendar($client);
         Revoking AuthSub authentication 
            To terminate the authenticated status of a given token, use the
             Zend_Gdata_AuthSub::AuthSubRevokeToken() 
            static function.  Otherwise, the token is still valid for
            some time.
         &lt;?php
// Carefully construct this value to avoid application security problems.
$php_self = htmlentities(substr($_SERVER[&#39;PHP_SELF&#39;], 0, strcspn($_SERVER[&#39;PHP_SELF&#39;], &quot;\n\r&quot;)), ENT_QUOTES);

if (isset($_GET[&#39;logout&#39;])) {
    Zend_Gdata_AuthSub::AuthSubRevokeToken($_SESSION[&#39;cal_token&#39;]);
    unset($_SESSION[&#39;cal_token&#39;]);
    header(&#39;Location: &#39; . $php_self);
    exit();
}
         Security notes 
            The treatment of the  $php_self  variable in the
            example above is a general security guideline, it is not
            specific to Zend_Gdata.  You should always filter content you
            output to http headers.
         
            Regarding revoking authentication tokens, it is recommended to
            do this when the user is finished with her Google Data session.
            The possibility that someone can intercept the token and use
            it for malicious purposes is very small, but nevertheless it is
            a good practice to terminate authenticated access to any service.
         Using Google Calendar 
        You can use the
         Zend_Gdata_Calendar 
        class to view, create, update, and delete events in the online Google Calendar service.
     
        See
         http://code.google.com/apis/calendar/overview.html 
        for more information about the Google Calendar API.
     Connecting To The Calendar Service 
            The Google Calendar API, like all GData APIs, is based off of the Atom Publishing Protoco (APP),
            an XML based format for managing web-based resources. Traffic between a client and the Google
            Calendar servers occurs over HTTP and allows for both authenticated and unauthenticated connections.
         
            Before any transactions can occur, this connection needs to be made. Creating a connection to the
            calendar servers involves two steps: creating an HTTP client and binding a
             Zend_Gdata_Calendar 
            service instance to that client.
         Authentication 
                The Google Calendar API allows access to both public and private calendar feeds. Public feeds
                do not require authentication, but are read-only and offer reduced functionality. Private feeds
                offers the most complete functionality but requires an authenticated connection to the calendar
                servers. There are three authentication schemes that are supported by Google Calendar:
             ClientAuth 
                        provides direct username/password authentication to the
                        calendar servers. Since this scheme requires that users
                        provide your application with their password, this
                        authentication is only recommended when other
                        authentication schemes are insufficient.
                     AuthSub 
                        allows authentication to the calendar servers via a
                        Google proxy server. This provides the same level of
                        convenience as ClientAuth but without the security
                        risk, making this an ideal choice for web-based
                        applications.
                     MagicCookie 
                        allows authentication based on a semi-random URL
                        available from within the Google Calendar interface.
                        This is the simplest authentication scheme to
                        implement, but requires that users manually retrieve
                        their secure URL before they can authenticate, doesn&#39;t
                        provide access to calendar lists, and is limited to
                        read-only access.
                     
                The
                 Zend_Gdata 
                library provides support for all three authentication schemes.
                The rest of this chapter will assume that you are familiar the
                authentication schemes available and how to create an
                appropriate authenticated connection. For more information,
                please see section the
                 Authentication section 
                of this manual or the
                 Authentication Overview in the Google Data API Developer&#39;s Guide .
             Creating A Service Instance 
                In order to interact with Google Calendar, this library provides the
                 Zend_Gdata_Calendar  service class. This class provides a common interface to the
                Google Data and Atom Publishing Protocol models and assists in marshaling requests to and from
                the calendar servers.
             
                Once deciding on an authentication scheme, the next step is to create an instance of
                 Zend_Gdata_Calendar . The class constructor takes an instance of
                 Zend_Http_Client  as a single argument. This provides an interface for AuthSub
                and ClientAuth authentication, as both of these require creation of a special authenticated
                HTTP client. If no arguments are provided, an unauthenticated instance of
                 Zend_Http_Client  will be automatically created.
             The example below shows how to create a Calendar service class using ClientAuth authentication: &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_ClientLogin&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_Calendar&#39;);
Zend_Loader::loadClass(&#39;Zend_Http_Client&#39;);

// Parameters for ClientAuth authentication
$service = Zend_Gdata_Calendar::AUTH_SERVICE_NAME;
$user = &quot;sample.user@gmail.com&quot;;
$pass = &quot;pa$$w0rd&quot;;

// Create an authenticated HTTP client
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);

// Create an instance of the Calendar service
$service = new Zend_Gdata_Calendar($client);
             A Calendar service using AuthSub can be created in a similar, though slightly more lengthy fashion: &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_AuthSub&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_Calendar&#39;);
Zend_Loader::loadClass(&#39;Zend_Http_Client&#39;);

/** Retrieve the current URL so that the AuthSub server knows where to
 * redirect the user after authentication is complete.
 */
function getCurrentUrl()
{
    global $_SERVER;

    // Filter php_self to avoid a security vulnerability.
    $php_request_uri = htmlentities(substr($_SERVER[&#39;REQUEST_URI&#39;], 0, strcspn($_SERVER[&#39;REQUEST_URI&#39;], &quot;\n\r&quot;)), ENT_QUOTES);

    if (isset($_SERVER[&#39;HTTPS&#39;]) &amp;&amp; strtolower($_SERVER[&#39;HTTPS&#39;]) == &#39;on&#39;) {
        $protocol = &#39;https://&#39;;
    } else {
        $protocol = &#39;http://&#39;;
    }
    $host = $_SERVER[&#39;HTTP_HOST&#39;];
    if ($_SERVER[&#39;HTTP_PORT&#39;] != &#39;&#39; &amp;&amp;
        (($protocol == &#39;http://&#39; &amp;&amp; $_SERVER[&#39;HTTP_PORT&#39;] != &#39;80&#39;) ||
        ($protocol == &#39;https://&#39; &amp;&amp; $_SERVER[&#39;HTTP_PORT&#39;] != &#39;443&#39;))) {
        $port = &#39;:&#39; . $_SERVER[&#39;HTTP_PORT&#39;];
    } else {
        $port = &#39;&#39;;
    }
    return $protocol . $host . $port . $php_request_uri;
}

/** Obtain an AuthSub authenticated HTTP client, redirecting the user to the
 *  AuthSub server to login if necessary.
 */
function getAuthSubHttpClient()
{
    global $_SESSION, $_GET;

    // If there is no AuthSub session or one-time token waiting for us,
    // redirect the user to the AuthSub server to get one.
    if (!isset($_SESSION[&#39;sessionToken&#39;]) &amp;&amp; !isset($_GET[&#39;token&#39;])) {
        // Parameters to give to AuthSub server
        $next = getCurrentUrl();
        $scope = &quot;http://www.google.com/calendar/feeds/&quot;;
        $secure = false;
        $session = true;

        // Redirect the user to the AuthSub server to sign in

        $authSubUrl = Zend_Gdata_AuthSub::getAuthSubTokenUri($next, $scope, $secure, $session);
         header(&quot;HTTP/1.0 307 Temporary redirect&quot;);

         header(&quot;Location: &quot; . $authSubUrl);

         exit();
    }

    // Convert an AuthSub one-time token into a session token if needed
    if (!isset($_SESSION[&#39;sessionToken&#39;]) &amp;&amp; isset($_GET[&#39;token&#39;])) {
        $_SESSION[&#39;sessionToken&#39;] =
            Zend_Gdata_AuthSub::getAuthSubSessionToken($_GET[&#39;token&#39;]);
    }

    // At this point we are authenticated via AuthSub and can obtain an
    // authenticated HTTP client instance

    // Create an authenticated HTTP client
    $client = Zend_Gdata_AuthSub::getHttpClient($_SESSION[&#39;sessionToken&#39;]);
    return $client;
}

// -&gt; Script execution begins here &lt;-

// Make sure http://code.google.com/apis/gdata/reference.html#Queriesthat the user has a valid session, so we can record the
// AuthSub session token once it is available.
session_start();

// Create an instance of the Calendar service, redirecting the user
// to the AuthSub server if necessary.
$service = new Zend_Gdata_Calendar(getAuthSubHttpClient());
             Finally, an unauthenticated server can be created for use with either public feeds or MagicCookie authentication: &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_Calendar&#39;);


// Create an instance of the Calendar service using an unauthenticated HTTP client

$service = new Zend_Gdata_Calendar();
             
                Note that MagicCookie authentication is not supplied with the HTTP connection, but is instead
                specified along with the desired visibility when submitting queries. See the section on retrieving
                events below for an example.
             Retrieving A Calendar List 
            The calendar service supports retrieving a list of calendars for the authenticated user. This is
            the same list of calendars which are displayed in the Google Calendar UI, except those marked as
            &quot; hidden &quot; are also available.
         
            The calendar list is always private and must be accessed over an authenticated connection. It is
            not possible to retrieve another user&#39;s calendar list and it cannot be accessed using MagicCookie
            authentication. Attempting to access a calendar list without holding appropriate credentials will
            fail and result in a 401 (Authentication Required) status code.
         &lt;?php
$service = Zend_Gdata_Calendar::AUTH_SERVICE_NAME;
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
$service = new Zend_Gdata_Calendar($client);

try {
    $listFeed= $service-&gt;getCalendarListFeed();
} catch (Zend_Gdata_App_Exception $e) {
    echo &quot;Error: &quot; . $e-&gt;getResponse();
}
         
            Calling  getCalendarListFeed()  creates a new instance of
             Zend_Gdata_Calendar_ListFeed  containing each available calendar as an instance of
             Zend_Gdata_Calendar_ListEntry . After retrieving the feed, you can use the iterator
            and accessors contained within the feed to inspect the enclosed calendars.
         &lt;?php
echo &quot;&lt;h1&gt;Calendar List Feed&lt;/h1&gt;&quot;;
echo &quot;&lt;ul&gt;&quot;;
foreach ($listFeed as $calendar) {
    echo &quot;&lt;li&gt;&quot; . $calendar-&gt;title . &quot; (Event Feed: &quot; . $calendar-&gt;id . &quot;)&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ul&gt;&quot;;
         Retrieving Events 
            Like the list of calendars, events are also retrieved using the  Zend_Gdata_Calendar 
            service class. The event list returned is of type  Zend_Gdata_Calendar_EventFeed 
            and contains each event as an instance of  Zend_Gdata_Calendar_EventEntry . As before,
            the iterator and accessors contained within the event feed instance allow inspection of individual
            events.
         Queries 
                When retrieving events using the Calendar API, specially constructed query URLs are used to
                describe what events should be returned. The  Zend_Gdata_Calendar_EventQuery 
                class simplifies this task by automatically constructing a query URL based on provided
                parameters. A full list of these parameters is available at the
                 Queries section of the Google Data APIs Protocol Reference 
                . However, there are three parameters that are worth special attention:
             User 
                        is used to specify the user whose calendar is being
                        searched for, and is specified as an email address. If
                        no user is provided, &quot;default&quot; will be used instead to
                        indicate the currently authenticated user (if
                        authenticated).
                     Visibility 
                        specifies whether a users public or private calendar
                        should be searched. If using an unauthenticated session
                        and no MagicCookie is available, only the public feed
                        will be available.
                     Projection 
                        specifies how much data should be returned by the
                        server and in what format. In most cases you will want
                        to use the &quot;full&quot; projection. Also available is the
                        &quot;basic&quot; projection, which places most meta-data into
                        each event&#39;s content field as human readable text, and
                        the &quot;composite&quot; projection which includes complete text
                        for any comments alongside each event. The &quot;composite&quot;
                        view is often much larger than the &quot;full&quot; view.
                     Retrieving Events In Order Of Start Time 
                The example below illustrates the use of the  Zend_Gdata_Query  class and specifies
                the private visibility feed, which requires that an authenticated connection is available to
                the calendar servers. If a MagicCookie is being used for authentication, the visibility should
                be instead set to &quot; private-magicCookieValue &quot;, where magicCookieValue is the random
                string obtained when viewing the private XML address in the Google Calendar UI. Events are
                requested chronologically by start time and only events occurring in the future are returned.
             &lt;?php
$query = $service-&gt;newEventQuery();
$query-&gt;setUser(&#39;default&#39;);
// Set to $query-&gt;setVisibility(&#39;private-magicCookieValue&#39;) if using MagicCookie auth
$query-&gt;setVisibility(&#39;private&#39;);
$query-&gt;setProjection(&#39;full&#39;);
$query-&gt;setOrderby(&#39;starttime&#39;);
$query-&gt;setFutureevents(&#39;true&#39;);

// Retrieve the event list from the calendar server
try {
    $eventFeed = $service-&gt;getCalendarEventFeed($query);
} catch (Zend_Gdata_App_Exception $e) {
    echo &quot;Error: &quot; . $e-&gt;getResponse();
}

// Iterate through the list of events, outputting them as an HTML list
echo &quot;&lt;ul&gt;&quot;;
foreach ($eventFeed as $event) {
    echo &quot;&lt;li&gt;&quot; . $event-&gt;title . &quot; (Event ID: &quot; . $event-&gt;id . &quot;)&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ul&gt;&quot;;
             
                Additional properties such as ID, author, when, event status, visibility, web content,
                and content, among others are available within  Zend_Gdata_Calendar_EventEntry .
                Refer to the
                 Zend Framework API Documentation 
                and the
                 Calendar Protocol Reference 
                for a complete list.
             Retrieving Events In A Specified Date Range 
                To print out all events within a certain range, for example from December 1, 2006 through
                December 15, 2007, add the following two lines to the previous sample. Take care to remove
                &quot; $query-&gt;setFutureevents(&#39;true&#39;) &quot;, sinceÂ´ futureevents  will override
                 startMin  and  startMax .
             &lt;?php
$query-&gt;setStartMin(&#39;2006-12-01&#39;);
$query-&gt;setStartMax(&#39;2006-12-16&#39;);
             
                Note that  startMin  is inclusive whereas  startMax 
                is exclusive. As a result, only events through 2006-12-15 23:59:59 will be returned.
             Retrieving Events By Fulltext Query 
                To print out all events which contain a specific word, for example &quot;dogfood&quot;, use the
                 setQuery() 
                method when creating the query.
             &lt;?php
$query-&gt;setQuery(&quot;dogfood&quot;);
             Retrieving Individual Events 
                Individual events can be retrieved by specifying their event ID as part of the query. Instead
                of calling  getCalendarEventFeed() ,  getCalendarEventEntry() 
                should be called instead.
             &lt;?php
$query = $service-&gt;newEventQuery();
$query-&gt;setUser(&#39;default&#39;);
$query-&gt;setVisibility(&#39;private&#39;);
$query-&gt;setProjection(&#39;full&#39;);
$query-&gt;setEvent($eventId);

try {
    $event = $service-&gt;getCalendarEventEntry($query);
} catch (Zend_Gdata_App_Exception $e) {
    echo &quot;Error: &quot; . $e-&gt;getResponse();
}
             
                In a similar fashion, if the event URL is known, it can be passed directly into
                 getCalendarEntry() 
                to retrieve a specific event. In this case, no query object is required since the event
                URL contains all the necessary information to retrieve the event.
             &lt;?php
$eventURL = &quot;http://www.google.com/calendar/feeds/default/private/full/g829on5sq4ag12se91d10uumko&quot;;

try {
    $event = $service-&gt;getCalendarEventEntry($eventURL);
} catch (Zend_Gdata_App_Exception $e) {
    echo &quot;Error: &quot; . $e-&gt;getResponse();
}
             Creating Events Creating Single-Occurrence Events 
                Events are added to a calendar by creating an instance of  Zend_Gdata_EventEntry 
                and populating it with the appropriate data. The calendar service instance
                ( Zend_Gdata_Calendar ) is then used to used to transparently covert the event
                into XML and POST it to the calendar server. Creating events requires either an AuthSub
                or ClientAuth authenticated connection to the calendar server.
             At a minimum, the following attributes should be set: Title 
                        provides the headline that will appear above the event
                        within the Google Calendar UI.
                     When 
                        indicates the duration of the event and, optionally,
                        any reminders that are associated with it. See the next
                        section for more information on this attribute.
                     Other useful attributes that may optionally set include: Author 
                        provides information about the user who created the
                        event.
                     Content 
                        provides additional information about the event which
                        appears when the event details are requested from
                        within Google Calendar.
                     EventStatus 
                        indicates whether the event is confirmed, tentative, or
                        canceled.
                     Hidden 
                        removes the event from the Google Calendar UI.
                     Transparency 
                        indicates whether the event should be consume time on
                        the user&#39;s free/busy list.
                     WebContent 
                        allows links to external content to be provided within
                        an event.
                     Where 
                        indicates the location of the event.
                     Visibility 
                        allows the event to be hidden from the public event
                        lists.
                     
                For a complete list of event attributes, refer to the
                 Zend Framework API Documentation 
                and the
                 Calendar Protocol Reference .
                Attributes that can contain multiple values, such as where, are implemented as arrays and need
                to be created accordingly. Be aware that all of these attributes require objects as parameters.
                Trying instead to populate them using strings or primitives will result in errors during conversion
                to XML.
             
                Once the event has been populated, it can be uploaded to the calendar server by passing it as an
                argument to the calendar service&#39;s  insertEvent()  function.
             &lt;?php
// Create a new entry using the calendar service&#39;s magic factory method
$event= $service-&gt;newEventEntry();

// Populate the event with the desired information
// Note that each attribute is crated as an instance of a matching class
$event-&gt;title = $service-&gt;newTitle(&quot;My Event&quot;);
$event-&gt;where = array($service-&gt;newWhere(&quot;Mountain View, California&quot;));
$event-&gt;content = $service-&gt;newContent(&quot; This is my awesome event. RSVP required.&quot;);

// Set the date using RFC 3339 format.
$startDate = &quot;2008-01-20&quot;;
$startTime = &quot;14:00&quot;;
$endDate = &quot;2008-01-20&quot;;
$endTime = &quot;16:00&quot;;
$tzOffset = &quot;-08&quot;;

$when = $service-&gt;newWhen();
$when-&gt;startTime = &quot;{$startDate}T{$startTime}:00.000{$tzOffset}:00&quot;;
$when-&gt;endTime = &quot;{$endDate}T{$endTime}:00.000{$tzOffset}:00&quot;;
$event-&gt;when = array($when);

// Upload the event to the calendar server
// A copy of the event as it is recorded on the server is returned
$newEvent = $service-&gt;insertEvent($event);
             Event Schedules and Reminders 
                An event&#39;s starting time and duration are determined by the value of its when property, which
                contains the properties  startTime ,  endTime , and  valueString .
                 StartTime  and  EndTime  control the duration of the event, while
                 valueString  provides a way to store a friendly, human readable version of the
                duration such as &quot;This Afternoon&quot;. Note that even when using  valueString ,
                 startTime  and  endTime  still must be be set to valid values.
             
                All-day events can be scheduled by specifying only the date omitting the time when setting
                 startTime 
                and
                 endTime 
                . Likewise, zero-duration events can be specified by omitting the
                 endTime 
                . In all cases, date/time values should be provided in
                 RFC3339 
                format.
             &lt;?php
// Schedule the event to occur on December 05, 2007 at 2 PM PST (UTC-8) with a duration of one hour.
$when = $service-&gt;newWhen();
$when-&gt;startTime = &quot;2007-12-05T14:00:00-08:00&quot;;
$when-&gt;endTime=&quot;2007-12-05T15:00:00:00-08:00&quot;;

// Specify a optional human readable value for the above date
$when-&gt;valueString = &quot;This Afternoon&quot;;

// Apply the when property to an event
$event-&gt;when = $when;
             
                The  when  attribute also controls when reminders are sent to a user. Reminders
                are stored in an array and each event may have up to find reminders associated with it.
             
                For a  reminder  to be valid, it needs to have two attributes set:  method 
                and a time.  Method  can accept one of the following strings: &quot;alert&quot;, &quot;email&quot;,
                or &quot;sms&quot;. The time should be entered as an integer and can be set with either the property
                 minutes ,  hours ,  days , or  absoluteTime .
                However, a valid request may only have one of these attributes set. If a mixed time is
                desired, convert to the most precise unit available. For example, 1 hour and 30 minutes
                should be entered as 90 minutes.
             &lt;?php
// Create a new reminder object. It should be set send an email message to the user 10 minutes beforehand.
$reminder = $service-&gt;newReminder();
$reminder-&gt;method = &quot;email&quot;;
$reminder-&gt;minutes = &quot;10&quot;;

// Apply the reminder to an existing event&#39;s when property
$when = $event-&gt;when[0];
$when-&gt;reminders = array($reminder);
             Creating Recurring Events 
                Recurring events are created the same way as single-occurrence events, except a recurrence
                attribute should be provided instead of a where attribute. The recurrence attribute should
                hold a string describing the event&#39;s recurrence pattern using properties defined in the
                iCalendar standard ( RFC 2445 ).
             
                Exceptions to the recurrence pattern will usually be specified by a distinct
                 recurrenceException  attribute. However, the iCalendar standard provides a
                secondary format for defining recurrences, and the possibility that either may be used
                must be accounted for.
             
                Due to the complexity of parsing recurrence patterns, further information on this them
                is outside the scope of this document. However, more information can be found in the
                 Common Elements section of the Google Data APIs Developer Guide 
                , as well as in RFC 2445.
             &lt;?php
 // Create a new entry using the calendar service&#39;s magic factory method
$event= $service-&gt;newEventEntry();

// Populate the event with the desired information
// Note that each attribute is crated as an instance of a matching class
$event-&gt;title = $service-&gt;newTitle(&quot;My Recurring Event&quot;);
$event-&gt;where = array($service-&gt;newWhere(&quot;Palo Alto, California&quot;));
$event-&gt;content = $service-&gt;newContent(&quot; This is my other awesome event, occurring all-day every Tuesday from 2007-05-01 until 207-09-04. No RSVP required.&quot;);

// Set the duration and frequency by specifying a recurrence pattern.

$recurrence = &quot;DTSTART;VALUE=DATE:20070501\r\n&quot; .
        &quot;DTEND;VALUE=DATE:20070502\r\n&quot; .
        &quot;RRULE:FREQ=WEEKLY;BYDAY=Tu;UNTIL=20070904\r\n&quot;;

$event-&gt;recurrence = $service-&gt;newRecurrence($recurrence);

// Upload the event to the calendar server
// A copy of the event as it is recorded on the server is returned
$newEvent = $service-&gt;insertEvent($event);
             Using QuickAdd 
                QuickAdd is a feature which allows events to be created using free-form text entry.
                For example, the string &quot;Dinner at Joe&#39;s Diner on Thursday&quot; would create an event with
                the title &quot;Dinner&quot;, location &quot;Joe&#39;s Diner&quot;, and date &quot;Thursday&quot;. To take advantage of
                QuickAdd, create a new  QuickAdd  property set to &quot;true&quot; and store the
                freeform text as a  content  property.
             &lt;?php
// Create a new entry using the calendar service&#39;s magic factory method
$event= $service-&gt;newEventEntry();

// Populate the event with the desired information
$event-&gt;content= $service-&gt;newContent(&quot;Dinner at Joe&#39;s Diner on Thursday&quot;);
$event-&gt;quickAdd = $service-&gt;newQuickAdd(&quot;true&quot;);

// Upload the event to the calendar server
// A copy of the event as it is recorded on the server is returned
$newEvent = $service-&gt;insertEvent($event);
             Modifying Events 
            Once an instance of an event has been obtained, the event&#39;s attributes can be locally modified
            in the same way as when creating an event. Once all modifications are complete, calling the event&#39;s
             save()  method will upload the changes to the calendar server and return a copy of
            the event as it was created on the server.
         
            In the event another user has modified the event since the local copy was retrieved,
             save()  will fail and the server will return a 409 (Conflict) status code.
            To resolve this a fresh copy of the event must be retrieved from the server before attempting
            to resubmit any modifications.
         &lt;?php
// Get the first event in the user&#39;s event list
$event = $eventFeed[0];

// Change the title to a new value
$event-&gt;title = $service-&gt;newTitle(&quot;Woof!&quot;);

// Upload the changes to the server
try {
    $event-&gt;save();
} catch (Zend_Gdata_App_Exception $e) {
    echo &quot;Error: &quot; . $e-&gt;getResponse();
}
         Deleting Events 
            Calendar events can be deleted either by calling the calendar service&#39;s
             delete() 
            method and providing the edit URL of an event or by calling an existing event&#39;s own
             delete() 
            method.
         
            In either case, the deleted event will still show up on a user&#39;s private event feed if an
             updateMin  query parameter is provided. Deleted events can be distinguished
            from regular events because they will have their  eventStatus 
            property set to &quot;http://schemas.google.com/g/2005#event.canceled&quot;.
         &lt;?php
// Option 1: Events can be deleted directly
$event-&gt;delete();
         &lt;?php
// Option 2: Events can be deleted supplying the edit URL of the event to the calendar service, if known
$service-&gt;delete($event-&gt;getEditLink()-&gt;href);
         Accessing Event Comments 
            When using the full event view, comments are not directly stored within an entry. Instead,
            each event contains a URL to it&#39;s associated comment feed which must be manually requested.
         
            Working with comments is fundamentally similar to working with events, with the only
            significant difference being that a different feed and event class should be used and thatÂ´
            the additional meta-data for events such as where and when does not exist for comments.
            Specifically, the comment&#39;s author is stored in the  author 
            property, and the comment text is stored in the  content  property.
         &lt;?php
// Extract the comment URL from the first event in a user&#39;s feed list
$event = $eventFeed[0];
$commentUrl = $event-&gt;comments-&gt;feedLink-&gt;url;

// Retrieve the comment list for the event
try {
$commentFeed = $service-&gt;getFeed($commentUrl);
} catch (Zend_Gdata_App_Exception $e) {
    echo &quot;Error: &quot; . $e-&gt;getResponse();
}

// Output each comment as an HTML list
echo &quot;&lt;ul&gt;&quot;;
foreach ($commentFeed as $comment) {
    echo &quot;&lt;li&gt;&lt;em&gt;Comment By: &quot; . $comment-&gt;author-&gt;name &quot;&lt;/em&gt;&lt;br/&gt;&quot; . $comment-&gt;content . &quot;&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ul&gt;&quot;;
         Authenticating with ClientLogin 
        The ClientLogin mechanism enables you to write PHP application
        that acquire authenticated access to Google Services,
        specifying a user&#39;s credentials in the Http Client.
     
        See
          http://code.google.com/apis/accounts/AuthForInstalledApps.html  
        for more information about Google Data ClientLogin authentication.
     
        The Google documentation says the ClientLogin mechanism is appropriate
        for &quot;installed applications&quot; whereas the AuthSub mechanism is
        for &quot;web applications.&quot;  The difference is that AuthSub requires
        interaction from the user, and a browser interface that can react
        to redirection requests.  The ClientLogin solution uses PHP code to
        supply the account credentials; the user is not required to enter her
        credentials interactively.
     
        The account credentials supplied via the ClientLogin mechanism must
        be valid credentials for Google services, but they are not required
        to be those of the user who is using the PHP application.
     Creating a ClientLogin authenticated Http Client 
            The process of creating an authenticated Http client using
            the ClientLogin mechanism is to call the static function
             Zend_Gdata_ClientLogin::getHttpClient() 
            and pass the Google account credentials in plain text.
            The return value of this function is an object of class
            Zend_Http_Client.
         
            The optional third parameter is the name of the Google Data
            service.  For instance, this can be &#39;cl&#39; for Google Calendar.
            The default is &quot;xapi&quot;, which is recognized by Google Data
            servers as a generic service name.
         
            The optional fourth parameter is an instance of Zend_Http_Client.
            This allows you to set options in the client, such as proxy
            server settings.  If you pass  null  for this
            parameter, a generic Zend_Http_Client object is created.
         
            The optional fifth parameter is a short string that Google Data
            servers use to identify the client application for logging
            purposes.  By default this is string &quot;Zend-ZendFramework&quot;;
         
          The optional sixth parameter is a string ID for a 
           CAPTCHA  challenge that has been issued by 
          the server. It is only necessary when logging in after receiving 
          a  CAPTCHA  challenge from a previous
          login attempt.
         
          The optional seventh parameter is a user&#39;s response to a 
           CAPTCHA  challenge that has been issued by 
          the server. It is only necessary when logging in after receiving 
          a  CAPTCHA  challenge from a previous
          login attempt.
         
            Below is an example of PHP code for a web application
            to acquire authentication to use the Google Calendar service
            and create a Zend_Gdata client object using that authenticated
            Zend_Http_Client.
         &lt;?php
// Enter your Google account credentials
$email = &#39;johndoe@gmail.com&#39;;
$passwd = &#39;xxxxxxxx&#39;;
try {
   $client = Zend_Gdata_ClientLogin::getHttpClient($email, $passwd, &#39;cl&#39;);
} catch (Zend_Gdata_App_CaptchaRequiredException $cre) {
    echo &#39;URL of CAPTCHA image: &#39; . $cre-&gt;getCaptchaUrl() . &quot;\n&quot;;
    echo &#39;Token ID: &#39; . $cre-&gt;getCaptchaToken() . &quot;\n&quot;; 
} catch (Zend_Gdata_App_AuthException $ae) {
   echo &#39;Problem authenticating: &#39; . $ae-&gt;exception() . &quot;\n&quot;;
}

$cal = new Zend_Gdata_Calendar($client);
         Terminating a ClientLogin authenticated Http Client 
            There is no method to revoke ClientLogin authentication as there
            is in the AuthSub token-based solution.  The credentials used
            in the ClientLogin authentication are the login and password
            to a Google account, and therefore these can be used repeatedly
            in the future.
         Using Google Documents List Data API 
        The Google Documents List Data API allows client applications to 
        upload documents to Google Documents and list them in the form of 
        Google Data API (&quot;GData&quot;) feeds. Your client application can request
        a list of a user&#39;s documents, and query the content in an existing 
        document.
     
        See
         http://code.google.com/apis/documents/overview.html 
        for more information about the Google Documents List API.
     Get a List of Documents 
            You can get a list of the Google Documents for a particular user by using
            the  getDocumentListFeed  method of the docs
            service.  The service will return a
             Zend_Gdata_Docs_DocumentListFeed  object
            containing a list of documents associated with the authenticated
            user.
         &lt;?php
$service = Zend_Gdata_Docs::AUTH_SERVICE_NAME;
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
$docs = new Zend_Gdata_Docs($client);
$feed = $docs-&gt;getDocumentListFeed();
         
        The resulting  Zend_Gdata_Docs_DocumentListFeed  object 
        represents the response from the server. This feed contains a list of
         Zend_Gdata_Docs_DocumentListEntry  objects 
        ( $feed-&gt;entries ), each of which represents a single 
        Google Document.                                
         Upload a Document 
            You can create a new Google Document by uploading a word
            processing document, spreadsheet, or presentation. This example
            is from the interactive Docs.php sample which comes with the
            library. It demonstrates uploading a file and printing
            information about the result from the server.
         &lt;?php
/**
 * Upload the specified document
 *
 * @param Zend_Gdata_Docs $docs The service object to use for communicating
 *     with the Google Documents server.
 * @param boolean $html True if output should be formatted for display in a
 *     web browser.
 * @param string $originalFileName The name of the file to be uploaded. The
 *     mime type of the file is determined from the extension on this file
 *     name. For example, test.csv is uploaded as a comma seperated volume
 *     and converted into a spreadsheet.
 * @param string $temporaryFileLocation (optional) The file in which the
 *     data for the document is stored. This is used when the file has been
 *     uploaded from the client&#39;s machine to the server and is stored in
 *     a temporary file which does not have an extension. If this parameter
 *     is null, the file is read from the originalFileName.
 */
function uploadDocument($docs, $html, $originalFileName,
                        $temporaryFileLocation) {
  $fileToUpload = $originalFileName;
  if ($temporaryFileLocation) {
    $fileToUpload = $temporaryFileLocation;
  }

  // Upload the file and convert it into a Google Document. The original
  // file name is used as the title of the document and the mime type
  // is determined based on the extension on the original file name.
  $newDocumentEntry = $docs-&gt;uploadFile($fileToUpload, $originalFileName,
      null, Zend_Gdata_Docs::DOCUMENTS_LIST_FEED_URI);

  echo &quot;New Document Title: &quot;;

  if ($html) {
      // Find the URL of the HTML view of this document.
      $alternateLink = &#39;&#39;;
      foreach ($newDocumentEntry-&gt;link as $link) {
          if ($link-&gt;getRel() === &#39;alternate&#39;) {
              $alternateLink = $link-&gt;getHref();
          }
      }
      // Make the title link to the document on docs.google.com.
      echo &quot;&lt;a href=\&quot;$alternateLink\&quot;&gt;\n&quot;;
  }
  echo $newDocumentEntry-&gt;title.&quot;\n&quot;;
  if ($html) {echo &quot;&lt;/a&gt;\n&quot;;}
}
         Searching the documents feed 
            You can search the Document List using some of the  standard
            Google Data API query parameters . Categories are used to 
            restrict the 
            type of document (word processor document, spreadsheet) returned.
            The full-text query string is used to search the content of all 
            the documents. More detailed information on parameters specific 
            to the Documents List can be found in the  Documents List Data API Reference Guide .
         Get a List of Word Processing Documents 
                You can also request a feed containing all of your documents of a specific type. For example, to see a list of your work processing documents, you would perform a category query as follows.
             &lt;?php
$feed = $docs-&gt;getDocumentListFeed(
    &#39;http://docs.google.com/feeds/documents/private/full/-/document&#39;);
             Get a List of Spreadsheets 
                To request a list of your Google Spreadsheets, use the following category query:
             &lt;?php
$feed = $docs-&gt;getDocumentListFeed(
    &#39;http://docs.google.com/feeds/documents/private/full/-/spreadsheet&#39;);
             Performing a text query 
                You can search the content of documents by using a
                 Zend_Gdata_Docs_Query  in your request. A Query object
                can be used to construct the query URI, with the search term being
                passed in as a parameter. Here is an example method which queries
                the documents list for documents which contain the search string:
             &lt;?php
$docsQuery = new Zend_Gdata_Docs_Query();
$docsQuery-&gt;setQuery($query);
$feed = $client-&gt;getDocumentListFeed($docsQuery);
             Catching Gdata Exceptions 
        The  Zend_Gdata_App_Exception  class is a base class
        for exceptions thrown by Zend_Gdata.  You can catch any exception
        thrown by Zend_Gdata by catching Zend_Gdata_App_Exception.
     &lt;?php
try {
    $client = Zend_Gdata_ClientLogin::getHttpClient($username, $password);
} catch(Zend_Gdata_App_Exception $ex) {
    // Report the exception to the user
    die($ex-&gt;getMessage());
}
     
        The following exception subclasses are used by Zend_Gdata:

         Zend_Gdata_App_AuthException 
                    indicates that the user&#39;s account credentials were not valid.
                 Zend_Gdata_App_BadMethodCallException 
                    indicates that a method was called for a service
                    that does not support the method.  For example,
                    the CodeSearch service does not support  post() .
                 Zend_Gdata_App_HttpException 
                    indicates that an HTTP request was not successful.
                    Provides the ability to get the full Zend_Http_Response
                    object to determine the exact cause of the failure in
                    cases where  $e-&gt;getMessage()  does not provide
                    enough details.
                 Zend_Gdata_App_InvalidArgumentException 
                    is thrown when the application provides a value that
                    is not valid in a given context.  For example,
                    specifying a Calendar visibility value of &quot;banana&quot;,
                    or fetching a Blogger feed without specifying
                    any blog name.
                 Zend_Gdata_App_CaptchaRequiredException 
                  is thrown when a ClientLogin attempt receives a
                   CAPTCHA  challenge from the 
                  authentication service. This exception contains a token 
                  ID and a URL to a  CAPTCHA  
                  challenge image. The image is a visual puzzle that 
                  should be displayed to the user. After
                  collecting the user&#39;s response to the challenge 
                  image, the response can be included with the next 
                  ClientLogin attempt.The user can alternatively be 
                  directed to this website:
                   
                  Further information can be found in the 
                   ClientLogin documentation .
                 
     
        You can use these exception subclasses to handle specific exceptions
        differently.  See the API documentation for information on which
        exception subclasses are thrown by which methods in Zend_Gdata.
     &lt;?php
try {
    $client = Zend_Gdata_ClientLogin::getHttpClient($username, $password, $service);
} catch(Zend_Gdata_App_AuthException $authEx) {
    // The user&#39;s credentials were incorrect.
    // It would be appropriate to give the user a second try.
    ...
} catch(Zend_Gdata_App_HttpException $httpEx) {
    // Google Data servers cannot be contacted.
    die($httpEx-&gt;getMessage);}
     Using Google Apps Provisioning 
        Google Apps is a service which allows domain administrators to offer
        their users managed access to Google services such as Mail, Calendar,
        and Docs &amp; Spreadsheets. The Provisioning API offers a programatic
        interface to configure this service. Specifically, this API allows
        administrators the ability to create, retrieve, update, and delete
        user accounts, nicknames, and email lists.
     
        This library implements version 2.0 of the Provisioning API. Access to
        your account via the Provisioning API must be manually enabled for
        each domain using the Google Apps control panel. Only certain
        account types are able to enable this feature.
     
        For more information on the Google Apps Provisioning API, including
        instructions for enabling API access, refer to the  Provisioning
        API V2.0 Reference .
     Authentication 
            The Provisioning API does not support authentication via AuthSub
            and anonymous access is not permitted. All HTTP connections must
            be authenticated using ClientAuth authentication.
             Setting the current domain 
            In order to use the Provisioning API, the domain being
            administered needs to be specified in all request URIs. In order
            to ease development, this information is stored within both the
            Gapps service and query classes to use when constructing
            requests.
         Setting the domain for the service class 
                To set the domain for requests made by the service class,
                either call  setDomain()  or specify the domain
                when instantiating the service class. For example:
             &lt;?php
$domain = &quot;example.com&quot;;
$gdata = new Zend_Gdata_Gapps($client, $domain);
?&gt; Setting the domain for query classes 
                Setting the domain for requests made by query classes is
                similar to setting it for the service class-either call
                 setDomain()  or specify the domain when creating
                the query. For example:
             &lt;?php
$domain = &quot;example.com&quot;;
$query = new Zend_Gdata_Gapps_UserQuery($domain, $arg);
?&gt; 
                When using a service class factory method to create a query,
                the service class will automatically set the query&#39;s domain to
                match its own domain. As a result, it is not necessary to
                specify the domain as part of the constructor arguments.
             &lt;?php
$domain = &quot;example.com&quot;;
$gdata = new Zend_Gdata_Gapps($client, $domain);
$query = $gdata-&gt;newUserQuery($arg);
?&gt; Interacting with users 
            Each user account on a Google Apps hosted domain is represented as
            an instance of Zend_Gdata_Gapps_UserEntry. This class provides
            access to all account properties including name, username,
            password, access rights, and current quota.
         Creating a user account 
                User accounts can be created by calling the
                 createUser()  convenience method:
             &lt;?php
$gdata-&gt;createUser(&#39;foo&#39;, &#39;Random&#39;, &#39;User&#39;, &#39;â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢&#39;);
?&gt; 
                Users can also be created by instantiating UserEntry,
                providing a username, given name, family name, and password,
                then calling  insertUser()  on a service object to
                upload the entry to the server.
             &lt;?php
$user = $gdata-&gt;newUserEntry();
$user-&gt;login = $gdata-&gt;newLogin();
$user-&gt;login-&gt;username = &#39;foo&#39;;
$user-&gt;login-&gt;password = &#39;â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢&#39;;
$user-&gt;name = $gdata-&gt;newName();
$user-&gt;name-&gt;givenName = &#39;Random&#39;;
$user-&gt;name-&gt;familyName = &#39;User&#39;;
$user = $gdata-&gt;insertUser($user);
?&gt; 
                The user&#39;s password should normally be provided as cleartext.
                Optionally, the password can be provided as an SHA-1 digest if
                 login-&gt;passwordHashFunction  is set to &#39;SHA-1&#39;.
             Retrieving a user account 
                Individual user accounts can be retrieved by calling the
                 retrieveUser()  convenience method. If the user is
                not found,  null  will be returned.
             &lt;?php
$user = $gdata-&gt;retrieveUser(&#39;foo&#39;);

echo &#39;Username: &#39; . $user-&gt;login-&gt;userName . &quot;\n&quot;;
echo &#39;Given Name: &#39; . $user-&gt;login-&gt;givenName . &quot;\n&quot;;
echo &#39;Family Name: &#39; . $user-&gt;login-&gt;familyName . &quot;\n&quot;;
echo &#39;Suspended: &#39; . ($user-&gt;login-&gt;suspended ? &#39;Yes&#39; : &#39;No&#39;) . &quot;\n&quot;;
echo &#39;Admin: &#39; . ($user-&gt;login-&gt;admin ? &#39;Yes&#39; : &#39;No&#39;) . &quot;\n&quot;
echo &#39;Must Change Password: &#39; . ($user-&gt;login-&gt;changePasswordAtNextLogin ? &#39;Yes&#39; : &#39;No&#39;) . &quot;\n&quot;;
echo &#39;Has Agreed To Terms: &#39; . ($user-&gt;login-&gt;agreedToTerms ? &#39;Yes&#39; : &#39;No&#39;) . &quot;\n&quot;;
?&gt; 
                Users can also be retrieved by creating an
                instance of Zend_Gdata_Gapps_UserQuery, setting its username
                property to equal the username of the user that is to be
                retrieved, and calling  getUserEntry()  on a
                service object with that query.
             &lt;?php
$query = $gdata-&gt;newUserQuery(&#39;foo&#39;);
$user = $gdata-&gt;getUserEntry($query);

echo &#39;Username: &#39; . $user-&gt;login-&gt;userName . &quot;\n&quot;;
echo &#39;Given Name: &#39; . $user-&gt;login-&gt;givenName . &quot;\n&quot;;
echo &#39;Family Name: &#39; . $user-&gt;login-&gt;familyName . &quot;\n&quot;;
echo &#39;Suspended: &#39; . ($user-&gt;login-&gt;suspended ? &#39;Yes&#39; : &#39;No&#39;) . &quot;\n&quot;;
echo &#39;Admin: &#39; . ($user-&gt;login-&gt;admin ? &#39;Yes&#39; : &#39;No&#39;) . &quot;\n&quot;
echo &#39;Must Change Password: &#39; . ($user-&gt;login-&gt;changePasswordAtNextLogin ? &#39;Yes&#39; : &#39;No&#39;) . &quot;\n&quot;;
echo &#39;Has Agreed To Terms: &#39; . ($user-&gt;login-&gt;agreedToTerms ? &#39;Yes&#39; : &#39;No&#39;) . &quot;\n&quot;;
?&gt; 
                If the specified user cannot be located a ServiceException
                will be thrown with an error code of
                Zend_Gdata_Gapps_Error::ENTITY_DOES_NOT_EXIST.
                ServiceExceptions will be covered in  .
             Retrieving all users in a domain 
                To retrieve all users in a domain, call the
                 retrieveAllUsers()  convenience method.
             &lt;?php
$feed = $gdata-&gt;retrieveAllUsers();

foreach ($feed as $user) {
    echo &quot;  * &quot; . $user-&gt;login-&gt;username . &#39; (&#39; . $user-&gt;name-&gt;givenName .
        &#39; &#39; . $user-&gt;name-&gt;familyName . &quot;)\n&quot;;
}
?&gt; 
                This will create a Zend_Gdata_Gapps_UserFeed object which
                holds each user on the domain. 
             
                Alternatively, call  getUserFeed()  with no 
                options. Keep in mind that on larger
                domains this feed may be paged by the server. For more
                information on paging, see  .
             &lt;?php
$feed = $gdata-&gt;getUserFeed();

foreach ($feed as $user) {
    echo &quot;  * &quot; . $user-&gt;login-&gt;username . &#39; (&#39; . $user-&gt;name-&gt;givenName .
        &#39; &#39; . $user-&gt;name-&gt;familyName . &quot;)\n&quot;;
}

?&gt; Updating a user account 
                The easiest way to update a user account is to retrieve the
                user as described in the previous sections, make any desired
                changes, then call  save()  on that user. Any
                changes made will be propagated to the server.
             &lt;?php
$user = $gdata-&gt;retrieveUser(&#39;foo&#39;);
$user-&gt;name-&gt;givenName = &#39;Foo&#39;;
$user-&gt;name-&gt;familyName = &#39;Bar&#39;;
$user = $user-&gt;save();
?&gt; Resetting a user&#39;s password 
                    A user&#39;s password can be reset to a new value by updating
                    the  login-&gt;password  property.
                 &lt;?php
$user = $gdata-&gt;retrieveUser(&#39;foo&#39;);
$user-&gt;login-&gt;password = &#39;â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢&#39;;
$user = $user-&gt;save();
?&gt; 
                    Note that it is not possible to recover a password in this
                    manner as stored passwords are not made available via the
                    Provisioning API for security reasons.
                 Forcing a user to change their password 
                    A user can be forced to change their password at their
                    next login by setting the
                     login-&gt;changePasswordAtNextLogin  property to
                     true .
                 &lt;?php
$user = $gdata-&gt;retrieveUser(&#39;foo&#39;);
$user-&gt;login-&gt;changePasswordAtNextLogin = true;
$user = $user-&gt;save();
?&gt; 
                    Similarly, this can be undone by setting the
                     login-&gt;changePasswordAtNextLogin  property to
                     false .
                 Suspending a user account 
                    Users can be restricted from logging in without deleting
                    their user account by instead
                     suspending  their user account.
                    Accounts can be suspended or restored by using the
                     suspendUser()  and  restoreUser() 
                    convenience methods:
                 &lt;?php
$gdata-&gt;suspendUser(&#39;foo&#39;);
$gdata-&gt;restoreUser(&#39;foo&#39;);
?&gt; 
                    Alternatively, you can set the UserEntry&#39;s
                     login-&gt;suspended  property to
                     true .
                 &lt;?php
$user = $gdata-&gt;retrieveUser(&#39;foo&#39;);
$user-&gt;login-&gt;suspended = true;
$user = $user-&gt;save();
?&gt; 
                    To restore the user&#39;s access, set the
                     login-&gt;suspended  property to
                     false .
                 Granting administrative rights 
                    Users can be granted the ability to administer your domain
                    by setting their  login-&gt;admin  property to
                     true .
                 &lt;?php
$user = $gdata-&gt;retrieveUser(&#39;foo&#39;);
$user-&gt;login-&gt;admin = true;
$user = $user-&gt;save();
?&gt; 
                    And as expected, setting a user&#39;s  login-&gt;admin 
                    property to  false  revokes their
                    administrative rights.
                 Deleting user accounts 
                Deleting a user account to which you already hold a UserEntry
                is a simple as calling  delete()  on that
                entry.
             &lt;?php
$user = $gdata-&gt;retrieveUser(&#39;foo&#39;);
$user-&gt;delete();
?&gt; 
                If you do not have access to a UserEntry object for an
                account, use the  deleteUser()  convenience method.
             &lt;?php
$gdata-&gt;deleteUser(&#39;foo&#39;);
?&gt; Interacting with nicknames 
            Nicknames serve as email aliases for existing users. Each nickname
            contains precisely two key properties: its name and its owner. Any
            email addressed to a nickname is forwarded to the user who owns
            that nickname.
         
            Nicknames are represented as an instances of
            Zend_Gdata_Gapps_NicknameEntry.
         Creating a nickname 
                Nicknames can be created by calling the
                 createNickname()  convenience method:
             &lt;?php
$gdata-&gt;createNickname(&#39;foo&#39;, &#39;bar&#39;);
?&gt; 
                Nicknames can also be created by instantiating NicknameEntry,
                providing the nickname with a name and an owner, then calling
                 insertNickname()  on a service object to upload
                the entry to the server.
             &lt;?php
$nickname = $gdata-&gt;newNicknameEntry();
$nickname-&gt;login = $gdata-&gt;newLogin(&#39;foo&#39;);
$nickname-&gt;nickname = $gdata-&gt;newNickname(&#39;bar&#39;);
$nickname = $gdata-&gt;insertNickname($nickname);
?&gt; Retrieving a nickname 
                Nicknames can be retrieved by calling the
                 retrieveNickname()  convenience method. This will
                return  null  if a user is not found.
             &lt;?php
$nickname = $gdata-&gt;retrieveNickname(&#39;bar&#39;);

echo &#39;Nickname: &#39; . $nickname-&gt;nickname-&gt;name . &quot;\n&quot;;
echo &#39;Owner: &#39; . $nickname-&gt;login-&gt;username . &quot;\n&quot;;
?&gt; 
                Individual nicknames can also be retrieved by creating an
                instance of Zend_Gdata_Gapps_NicknameQuery, setting its
                nickname property to equal the nickname that is to be
                retrieved, and calling  getNicknameEntry()  on a
                service object with that query.
             &lt;?php
$query = $gdata-&gt;newNicknameQuery(&#39;bar&#39;);
$nickname = $gdata-&gt;getNicknameEntry($query);

echo &#39;Nickname: &#39; . $nickname-&gt;nickname-&gt;name . &quot;\n&quot;;
echo &#39;Owner: &#39; . $nickname-&gt;login-&gt;username . &quot;\n&quot;;
?&gt; 
                As with users, if no corresponding nickname is found a
                ServiceException will be thrown with an error code of
                Zend_Gdata_Gapps_Error::ENTITY_DOES_NOT_EXIST. Again, these
                will be discussed in  .
             Retrieving all nicknames for a user 
                To retrieve all nicknames associated with a given user, call
                the convenience method  retrieveNicknames() .
             &lt;?php
$feed = $gdata-&gt;retrieveNicknames(&#39;foo&#39;);

foreach ($feed as $nickname) {
    echo &#39;  * &#39; . $nickname-&gt;nickname-&gt;name . &quot;\n&quot;;
}
?&gt; 
                This will create a Zend_Gdata_Gapps_NicknameFeed object which
                holds each nickname associated with the specified user.
             
                Alternatively, create a new Zend_Gdata_Gapps_NicknameQuery,
                set its username property to the desired user, and submit the
                query by calling  getNicknameFeed()  on a service
                object.
             &lt;?php
$query = $gdata-&gt;newNicknameQuery();
$query-&gt;setUsername(&#39;foo&#39;);
$feed = $gdata-&gt;getNicknameFeed($query);

foreach ($feed as $nickname) {
    echo &#39;  * &#39; . $nickname-&gt;nickname-&gt;name . &quot;\n&quot;;
}
?&gt; Retrieving all nicknames in a domain 
                To retrieve all nicknames in a feed, simply call the
                convenience method  retrieveAllNicknames() 
             &lt;?php
$feed = $gdata-&gt;retrieveAllNicknames();

foreach ($feed as $nickname) {
    echo &#39;  * &#39; . $nickname-&gt;nickname-&gt;name . &#39; =&gt; &#39; . 
        $nickname-&gt;login-&gt;username . &quot;\n&quot;;
}
?&gt; 
                This will create a Zend_Gdata_Gapps_NicknameFeed object which
                holds each nickname on the domain.
             
                Alternatively, call  getNicknameFeed()  on a 
                service object with no arguments.
             &lt;?php
$feed = $gdata-&gt;getNicknameFeed();

foreach ($feed as $nickname) {
    echo &#39;  * &#39; . $nickname-&gt;nickname-&gt;name . &#39; =&gt; &#39; . 
        $nickname-&gt;login-&gt;username . &quot;\n&quot;;
}
?&gt; Deleting a nickname 
                Deleting a nickname to which you already hold a NicknameEntry
                for is a simple as calling  delete()  on that
                entry.
             &lt;?php
$nickname = $gdata-&gt;retrieveNickname(&#39;bar&#39;);
$nickname-&gt;delete();
?&gt; 
                For nicknames which you do not hold a NicknameEntry for, use
                the  deleteNickname()  convenience method.
             &lt;?php
$gdata-&gt;deleteNickname(&#39;bar&#39;);
?&gt; Interacting with email lists 
            Email lists allow several users to retrieve email addressed to a
            single email address. Users do not need to be a
            member of this domain in order to subscribe to an email list
            provided their complete email address (including domain) is used.
         
            Each email list on a domain is represented as an instance of
            Zend_Gdata_Gapps_EmailListEntry.
         Creating an email list 
                Email lists can be created by calling the
                 createEmailList()  convenience method:
             &lt;?php
$gdata-&gt;createEmailList(&#39;friends&#39;);
?&gt; 
                Email lists can also be created by instantiating
                EmailListEntry, providing a name for the list, then calling
                 insertEmailList()  on a service object to upload
                the entry to the server.
             &lt;?php
$list = $gdata-&gt;newEmailListEntry();
$list-&gt;emailList = $gdata-&gt;newEmailList(&#39;friends&#39;);
$list = $gdata-&gt;insertEmailList($list);
?&gt; Retrieving all email lists to which a recipient is
            subscribed 
                To retrieve all email lists to which a particular recipient is
                subscribed, call the  retrieveEmailLists() 
                convenience method:
             &lt;?php
$feed = $gdata-&gt;retrieveEmailLists(&#39;baz@somewhere.com&#39;);

foreach ($feed as $list) {
    echo &#39;  * &#39; . $list-&gt;emailList-&gt;name . &quot;\n&quot;;
}
?&gt; 
                This will create a Zend_Gdata_Gapps_EmailListFeed object which
                holds each email list associated with the specified recipient.
             
                Alternatively, create a new Zend_Gdata_Gapps_EmailListQuery,
                set its recipient property to the desired email address, and
                submit the query by calling  getEmailListFeed()  on
                a service object.
             &lt;?php
$query = $gdata-&gt;newEmailListQuery();
$query-&gt;setRecipient(&#39;baz@somewhere.com&#39;);
$feed = $gdata-&gt;getEmailListFeed($query);

foreach ($feed as $list) {
    echo &#39;  * &#39; . $list-&gt;emailList-&gt;name . &quot;\n&quot;;
}
?&gt; Retrieving all email lists in a domain 
                To retrieve all email lists in a domain, call the convenience
                method  retrieveAllEmailLists() .
             &lt;?php
$feed = $gdata-&gt;retrieveAllEmailLists();

foreach ($feed as $list) {
    echo &#39;  * &#39; . $list-&gt;emailList-&gt;name . &quot;\n&quot;;
}
?&gt; 
                This will create a Zend_Gdata_Gapps_EmailListFeed object which
                holds each email list on the domain.
             
                Alternatively, call  getEmailListFeed()  on a
                service object with no arguments.
             &lt;?php
$feed = $gdata-&gt;getEmailListFeed();

foreach ($feed as $list) {
    echo &#39;  * &#39; . $list-&gt;emailList-&gt;name . &quot;\n&quot;;
}
?&gt; Deleting an email list 
                To delete an email list, call the deleteEmailList()
                convenience method:
             &lt;?php
$gdata-&gt;deleteEmailList(&#39;friends&#39;);
?&gt; Interacting with email list recipients 
            Each recipient subscribed to an email list is represented by an
            instance of Zend_Gdata_Gapps_EmailListRecipient. Through this
            class, individual recipients can be added and removed from email
            lists.
         Adding a recipient to an email list 
                To add a recipient to an email list, simply call the
                 addRecipientToEmailList()  convenience method:
             &lt;?php
$gdata-&gt;addRecipientToEmailList(&#39;bar@somewhere.com&#39;, &#39;friends&#39;);
?&gt; Retrieving the list of subscribers to an email list 
                The convenience method  retrieveAllRecipients() 
                can be used retrieve teh list of subscribers to an email list:
             &lt;?php
$feed = $gdata-&gt;retrieveAllRecipients(&#39;friends&#39;);

foreach ($feed as $recipient) {
    echo &#39;  * &#39; . $recipient-&gt;who-&gt;email . &quot;\n&quot;;
}
?&gt; 
                Alternatively, construct a new EmailListRecipientQuery, set
                its emailListName property to match the desired email list,
                and call  getEmailListRecipientFeed()  on a service
                object.
             &lt;?php
$query = $gdata-&gt;newEmailListRecipientQuery();
$query-&gt;setEmailListName(&#39;friends&#39;);
$feed = $gdata-&gt;getEmailListRecipientFeed($query);

foreach ($feed as $recipient) {
    echo &#39;  * &#39; . $recipient-&gt;who-&gt;email . &quot;\n&quot;;
}
?&gt; 
                This will create a Zend_Gdata_Gapps_EmailListRecipientFeed
                object which holds each recipient for the selected email list.
             Removing a recipient from an email list 
                To remove a recipient from an email list, call the
                 removeRecipientFromEmailList()  convenience
                method:
             &lt;?php
$gdata-&gt;removeRecipientFromEmailList(&#39;baz@somewhere.com&#39;, &#39;friends&#39;);
?&gt; Handling errors 
            In addition to the standard suite of exceptions thrown by
            Zend_Gdata, requests using the Provisioning API may also throw a
             Zend_Gdata_Gapps_ServiceException . These exceptions
            indicate that a API specific error occurred which prevents the
            request from completing.
         
            Each ServiceException instance may hold one or more Error objects.
            Each of these objects contains an error code, reason, and
            (optionally) the input which triggered the exception. A complete
            list of known error codes is provided in the Zend Framework API
            documentation under Zend_Gdata_Gapps_Error. Additionally, the
            authoritative error list is available online at  Google
            Apps Provisioning API V2.0 Reference: Appendix D .
         
            While the complete list of errors received is available within
            ServiceException as an array by calling  getErrors() ,
            often it is convenient to know if one specific error occurred. For
            these cases the presence of an error can be determined by calling
             hasError() .
         
            The following example demonstrates how to detect if a requested
            resource doesn&#39;t exist and handle the fault gracefully:
         &lt;?php
function retrieveUser ($username) {
    $query = $gdata-&gt;newUserQuery($username);
    try {
        $user = $gdata-&gt;getUserEntry($query);
    } catch (Zend_Gdata_Gapps_ServiceException $e) {
        // Set the user to null if not found
        if ($e-&gt;hasError(Zend_Gdata_Gapps_Error::ENTITY_DOES_NOT_EXIST)) {
            $user = null;
        } else {
            throw $e;
        }
    }
    return $user;
}
?&gt; Using Google Base 
        The Google Base data API is designed to enable developers to do two things:
         
                    Query Google Base data to create applications and mashups.
                 
                    Input and manage Google Base items programmatically.
                 
     
        There are two item feeds: snippets feed and customer items feeds. The snippets feed contains all Google Base data and is available to anyone to query against without a need for authentication. The customer items feed is a customer-specific subset of data and only a customer/owner can access this feed to insert, update, or delete their own data. Queries are constructed the same way against both types of feeds.
     
        See  http://code.google.com/apis/base 
        for more information about the Google Base API.
     Connect To The Base Service 
            The Google Base API, like all GData APIs, is based off of the Atom Publishing Protocol (APP), an XML based format for managing web-based resources. Traffic between a client and the Google Base servers occurs over HTTP and allows for both authenticated and unauthenticated connections.
         
            Before any transactions can occur, this connection needs to be made. Creating a connection to the base servers involves two steps: creating an HTTP client and binding a
             Zend_Gdata_Gbase  service instance to that client.
         Authentication 
                The Google Base API allows access to both public and private base feeds. Public feeds do not require authentication, but are read-only and offer reduced functionality. Private feeds offers the most complete functionality but requires an authenticated connection to the base servers. There are three authentication schemes that are supported by Google Base:
             ClientAuth 
                        provides direct username/password authentication to the base servers. Since this scheme requires that users provide your application with their password, this authentication is only recommended when other authentication schemes are insufficient.
                     AuthSub 
                        allows authentication to the base servers via a Google proxy server. This provides the same level of convenience as ClientAuth but without the security risk, making this an ideal choice for web-based applications.
                     
                The  Zend_Gdata 
                library provides support for all three authentication schemes. The rest of this chapter will assume that you are familiar the authentication schemes available and how to create an appropriate authenticated connection. For more information, please see section  .
                or the
                 Authentication Overview in the Google Data API Developer&#39;s Guide .
             Create A Service Instance 
                In order to interact with Google Base, this library provides the
                 Zend_Gdata_Gbase 
                service class. This class provides a common interface to the Google Data and Atom Publishing Protocol models and assists in marshaling requests to and from the base servers.
             
                Once deciding on an authentication scheme, the next step is to create an instance of
                 Zend_Gdata_Gbase 
                . This class takes in an instance of
                 Zend_Http_Client 
                as a single argument. This provides an interface for AuthSub and ClientAuth authentication, as both of these creation of a special authenticated HTTP client. If no arguments are provided, an unauthenticated instance of
                 Zend_Http_Client 
                will be automatically created.
             
                The example below shows how to create a Base service class using ClientAuth authentication:
             &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata_ClientLogin&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_Gbase&#39;);

// Parameters for ClientAuth authentication
$service = Zend_Gdata_Gbase::AUTH_SERVICE_NAME;
$user = &quot;sample.user@gmail.com&quot;;
$pass = &quot;pa$$w0rd&quot;;

// Create an authenticated HTTP client
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);

// Create an instance of the Base service
$service = new Zend_Gdata_Gbase($client);
 A Base service using AuthSub can be created in a similar, though slightly more lengthy fashion: &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata_AuthSub&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_Gbase&#39;);

/** Retrieve the current URL so that the AuthSub server knows where to
 * redirect the user after authentication is complete.
 */
function getCurrentUrl()
{
    global $_SERVER;

    // Filter php_self to avoid a security vulnerability.
    $php_request_uri = htmlentities(substr($_SERVER[&#39;REQUEST_URI&#39;], 0, strcspn($_SERVER[&#39;REQUEST_URI&#39;], &quot;\n\r&quot;)), ENT_QUOTES);

    if (isset($_SERVER[&#39;HTTPS&#39;]) &amp;&amp; strtolower($_SERVER[&#39;HTTPS&#39;]) == &#39;on&#39;) {
        $protocol = &#39;https://&#39;;
    } else {
        $protocol = &#39;http://&#39;;
    }
    $host = $_SERVER[&#39;HTTP_HOST&#39;];
    if ($_SERVER[&#39;HTTP_PORT&#39;] != &#39;&#39; &amp;&amp;
        (($protocol == &#39;http://&#39; &amp;&amp; $_SERVER[&#39;HTTP_PORT&#39;] != &#39;80&#39;) ||
        ($protocol == &#39;https://&#39; &amp;&amp; $_SERVER[&#39;HTTP_PORT&#39;] != &#39;443&#39;))) {
        $port = &#39;:&#39; . $_SERVER[&#39;HTTP_PORT&#39;];
    } else {
        $port = &#39;&#39;;
    }
    return $protocol . $host . $port . $php_request_uri;
}

/** Obtain an AuthSub authenticated HTTP client, redirecting the user to the
 *  AuthSub server to login if necessary.
 */
function getAuthSubHttpClient()
{
    global $_SESSION, $_GET;

    // If there is no AuthSub session or one-time token waiting for us,
    // redirect the user to the AuthSub server to get one.
    if (!isset($_SESSION[&#39;sessionToken&#39;]) &amp;&amp; !isset($_GET[&#39;token&#39;])) {
        // Parameters to give to AuthSub server
        $next = getCurrentUrl();
        $scope = &quot;http://www.google.com/base/feeds/items/&quot;;
        $secure = false;
        $session = true;

        // Redirect the user to the AuthSub server to sign in

        $authSubUrl = Zend_Gdata_AuthSub::getAuthSubTokenUri($next, $scope, $secure, $session);
         header(&quot;HTTP/1.0 307 Temporary redirect&quot;);

         header(&quot;Location: &quot; . $authSubUrl);

         exit();
    }

    // Convert an AuthSub one-time token into a session token if needed
    if (!isset($_SESSION[&#39;sessionToken&#39;]) &amp;&amp; isset($_GET[&#39;token&#39;])) {
        $_SESSION[&#39;sessionToken&#39;] =
            Zend_Gdata_AuthSub::getAuthSubSessionToken($_GET[&#39;token&#39;]);
    }

    // At this point we are authenticated via AuthSub and can obtain an
    // authenticated HTTP client instance

    // Create an authenticated HTTP client
    $client = Zend_Gdata_AuthSub::getHttpClient($_SESSION[&#39;sessionToken&#39;]);
    return $client;
}

// -&gt; Script execution begins here &lt;-

// Make sure http://code.google.com/apis/gdata/reference.html#Queriesthat the user has a valid session, so we can record the
// AuthSub session token once it is available.
session_start();

// Create an instance of the Base service, redirecting the user
// to the AuthSub server if necessary.
$service = new Zend_Gdata_Gbase(getAuthSubHttpClient());
 Finally, an unauthenticated server can be created for use with snippets feeds: &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata_Gbase&#39;);

// Create an instance of the Base service using an unauthenticated HTTP client
$service = new Zend_Gdata_Gbase();
             Retrieve Items 
            You can query customer items feed or snippets feed to retrieve items. It involves two steps, sending a query and iterating through the returned feed.
         Send a Structured Query 
                You can send a structured query to retrieve items from your own customer items feed or from the public snippets feed.
             
                When retrieveing items using the Base API, specially constructed query URLs are used to describe what events should be returned. The   Zend_Gdata_Gbase_ItemQuery  and  Zend_Gdata_Gbase_SnippetQuery  classes simplify this task by automatically constructing a query URL based on provided parameters. 
             Query Customer Items Feed 
                    To execute a query against the customer items feed, invoke  newItemQuery()  and  getGbaseItemFeed()  methods:
                 &lt;?php
$service = new Zend_Gdata_Gbase($client);
$query = $service-&gt;newItemQuery();
$query-&gt;setBq(&#39;[title:Programming]&#39;);
$query-&gt;setOrderBy(&#39;modification_time&#39;);
$query-&gt;setSortOrder(&#39;descending&#39;);
$query-&gt;setMaxResults(&#39;5&#39;);
$feed = $service-&gt;getGbaseItemFeed($query);
                 
                    A full list of these paremeters is available at the  Query parameters section  of the Customer Items Feed documentation.
                 Query Snippets Feed 
                    To execute a query against the public snippets feed, invoke  newSnippetQuery()  and  getGbaseSnippetFeed()  methods:
                 &lt;?php
$service = new Zend_Gdata_Gbase();
$query = $service-&gt;newSnippetQuery();
$query-&gt;setBq(&#39;[title:Programming]&#39;);
$query-&gt;setOrderBy(&#39;modification_time&#39;);
$query-&gt;setSortOrder(&#39;descending&#39;);
$query-&gt;setMaxResults(&#39;5&#39;);
$feed = $service-&gt;getGbaseSnippetFeed($query);
                 
                    A full list of these paremeters is available at the  Query parameters section  of the Snippets Feed documentation.
                 Iterate through the Items 
                Google Base items can contain item-specific attributes such as  &lt;g:main_ingredient&gt;  and  &lt;g:weight&gt; .
             
                To iterate through all attributes of a given item, invoke  getGbaseAttributes()  and iterate through the results:
             &lt;?php
foreach ($feed-&gt;entries as $entry) {
  // Get all attributes and print out the name and text value of each attribute
  $baseAttributes = $entry-&gt;getGbaseAttributes();
  foreach ($baseAttributes as $attr) {
    echo &quot;Attribute &quot; . $attr-&gt;name . &quot; : &quot; . $attr-&gt;text . &quot;&lt;br&gt;&quot;;
  }
}
             
                Or, you can look for specific attribute name and iterate through the results that match:
             &lt;?php
foreach ($feed-&gt;entries as $entry) {
  // Print all main ingredients &lt;g:main_ingredient&gt;
  $baseAttributes = $entry-&gt;getGbaseAttribute(&quot;main_ingredient&quot;);
  foreach ($baseAttributes as $attr) {
    echo &quot;Main ingredient: &quot; . $attr-&gt;text . &quot;&lt;br&gt;&quot;;
  }
}
             Insert, Update, and Delete Customer Items 
            A customer/owner can access his own Customer Items feed to insert, update, or delete their items. These operations do not apply to the public snippets feed.
         
            You can test a feed operation before it is actually executed by setting the dry-run flag ( $dryRun ) to  true . Once you are sure that you want to submit the data, set it to  false  to execute the operation.
         Insert an Item 
                Items can be added by using the  insertGbaseItem()  method for the Base service:
             &lt;?php
$service = new Zend_Gdata_Gbase($client);
$newEntry = $service-&gt;newItemEntry();

// Add title
$title = &quot;PHP Developer Handbook&quot;;
$newEntry-&gt;title = $service-&gt;newTitle(trim($title));

// Add some content
$content = &quot;Essential handbook for PHP developers.&quot;;
$newEntry-&gt;content = $service-&gt;newContent($content);
$newEntry-&gt;content-&gt;type = &#39;text&#39;;

// Define product type
$itemType = &quot;Products&quot;;
$newEntry-&gt;itemType = $itemType;

// Add item specific attributes
$newEntry-&gt;addGbaseAttribute(&quot;product_type&quot;, &quot;book&quot;, &quot;text&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;price&quot;, &quot;12.99 USD&quot;, &quot;floatUnit&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;quantity&quot;, &quot;10&quot;, &quot;int&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;weight&quot;, &quot;2.2 lbs&quot;, &quot;numberUnit&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;condition&quot;, &quot;New&quot;, &quot;text&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;author&quot;, &quot;John Doe&quot;, &quot;text&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;edition&quot;, &quot;First Edition&quot;, &quot;text&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;pages&quot;, &quot;253&quot;, &quot;number&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;publisher&quot;, &quot;My Press&quot;, &quot;text&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;year&quot;, &quot;2007&quot;, &quot;number&quot;);
$newEntry-&gt;addGbaseAttribute(&quot;payment_accepted&quot;, &quot;Google Checkout&quot;, &quot;text&quot;);

$dryRun = true;
$createdEntry = $service-&gt;insertGbaseItem($newEntry, $dryRun);
             Modify an Item 
                You can update each attribute element of an item as you iterate through them:
             &lt;?php
// Update the title
$newTitle = &quot;PHP Developer Handbook Second Edition&quot;;
$entry-&gt;title = $service-&gt;newTitle($newTitle);

// Find &lt;g:price&gt; attribute and update the price
$baseAttributes = $entry-&gt;getGbaseAttribute(&quot;price&quot;);
if (is_object($baseAttributes[0])) {
  $newPrice = &quot;16.99 USD&quot;;
  $baseAttributes[0]-&gt;text = $newPrice;
}

// Find &lt;g:pages&gt; attribute and update the number of pages
$baseAttributes = $entry-&gt;getGbaseAttribute(&quot;pages&quot;);
if (is_object($baseAttributes[0])) {
  $newPages = &quot;278&quot;;
  $baseAttributes[0]-&gt;text = $newPages;

  // Update the attribute type from &quot;number&quot; to &quot;int&quot;
  if ($baseAttributes[0]-&gt;type == &quot;number&quot;) {
    $newType = &quot;int&quot;;
    $baseAttributes[0]-&gt;type = $newType;
  }
}

// Remove &lt;g:label&gt; attributes
$baseAttributes = $entry-&gt;getGbaseAttribute(&quot;label&quot;);
foreach ($baseAttributes as $note) {
  $entry-&gt;removeGbaseAttribute($note);
}

// Add new attributes
$entry-&gt;addGbaseAttribute(&quot;note&quot;, &quot;PHP 5&quot;, &quot;text&quot;);
$entry-&gt;addGbaseAttribute(&quot;note&quot;, &quot;Web Programming&quot;, &quot;text&quot;);

// Save the changes by invoking save() on the entry object itself
$dryRun = true;
$entry-&gt;save($dryRun);

// Or, save the changes by calling updateGbaseItem() on the service object
// $dryRun = true;
// $service-&gt;updateGbaseItem($entry, $dryRun);

             
                After making the changes, either invoke  save($dryRun)  method on the  Zend_Gdata_Gbase_ItemEntry  object or call  updateGbaseItem($entry, $dryRun)  method on the  Zend_Gdata_Gbase  object to save the changes.
             Delete an Item 
                You can remove an item by calling  deleteGbaseItem()  method:
             &lt;?php
$dryRun = false;
$service-&gt;deleteGbaseItem($entry, $dryRun);
             
                Alternatively, you can invoke  delete()  on the  Zend_Gdata_Gbase_ItemEntry  object:
             &lt;?php
$dryRun = false;
$entry-&gt;delete($dryRun);
             Using Picasa Web Albums 
        Picasa Web Albums is a service which allows users to maintain albums of
        their own pictures, and browse the albums and pictures of others.
        The API offers a programatic interface to this service, allowing
        users to add to, update, and remove from their albums, as well as
        providing the ability to tag and comment on photos.
     
        Access to public albums and photos is not restricted by account,
        however, a user must be logged in for non-read-only access.
     
        For more information on the API, including
        instructions for enabling API access, refer to the  Picasa
        Web Albums Data API Overview .
     Authentication 
            The API provides authentication via AuthSub (recommended)
            and ClientAuth. HTTP connections must be authenticated for write
            support, but non-authenticated connections have read-only access.
         Connecting To The Service 
            The Picasa Web Albums API, like all GData APIs, is based off of the Atom Publishing Protocol (APP),
            an XML based format for managing web-based resources. Traffic between a client and the
            servers occurs over HTTP and allows for both authenticated and unauthenticated connections.
         
            Before any transactions can occur, this connection needs to be made. Creating a connection to the
            Picasa servers involves two steps: creating an HTTP client and binding a
             Zend_Gdata_Photos 
            service instance to that client.
         Authentication 
                The Google Picasa API allows access to both public and private photo feeds. Public feeds
                do not require authentication, but are read-only and offer reduced functionality. Private feeds
                offers the most complete functionality but requires an authenticated connection to the Picasa
                servers. There are three authentication schemes that are supported by Google Picasa :
             ClientAuth 
                        provides direct username/password authentication to the
                        Picasa servers. Since this scheme requires that users
                        provide your application with their password, this
                        authentication is only recommended when other
                        authentication schemes are insufficient.
                     AuthSub 
                        allows authentication to the Picasa servers via a
                        Google proxy server. This provides the same level of
                        convenience as ClientAuth but without the security
                        risk, making this an ideal choice for web-based
                        applications.
                     
                The
                 Zend_Gdata 
                library provides support for both authentication schemes.
                The rest of this chapter will assume that you are familiar the
                authentication schemes available and how to create an
                appropriate authenticated connection. For more information,
                please see section the
                 Authentication section 
                of this manual or the
                 Authentication Overview in the Google Data API Developer&#39;s Guide .
             Creating A Service Instance 
                In order to interact with the servers, this library provides the
                 Zend_Gdata_Photos  service class. This class provides a common interface to the
                Google Data and Atom Publishing Protocol models and assists in marshaling requests to and from
                the servers.
             
                Once deciding on an authentication scheme, the next step is to create an instance of
                 Zend_Gdata_Photos . The class constructor takes an instance of
                 Zend_Http_Client  as a single argument. This provides an interface for AuthSub
                and ClientAuth authentication, as both of these require creation of a special authenticated
                HTTP client. If no arguments are provided, an unauthenticated instance of
                 Zend_Http_Client  will be automatically created.
             The example below shows how to create a service class using ClientAuth authentication: &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_ClientLogin&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_Photos&#39;);
Zend_Loader::loadClass(&#39;Zend_Http_Client&#39;);

// Parameters for ClientAuth authentication
$service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
$user = &quot;sample.user@gmail.com&quot;;
$pass = &quot;pa$$w0rd&quot;;

// Create an authenticated HTTP client
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);

// Create an instance of the service
$service = new Zend_Gdata_Photos($client);
             A service instance using AuthSub can be created in a similar, though slightly more lengthy fashion: &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_AuthSub&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_Photos&#39;);
Zend_Loader::loadClass(&#39;Zend_Http_Client&#39;);

session_start();

/**
 * Returns the full URL of the current page, based upon env variables
 * 
 * Env variables used:
 * $_SERVER[&#39;HTTPS&#39;] = (on|off|)
 * $_SERVER[&#39;HTTP_HOST&#39;] = value of the Host: header
 * $_SERVER[&#39;SERVER_PORT&#39;] = port number (only used if not http/80,https/443)
 * $_SERVER[&#39;REQUEST_URI&#39;] = the URI after the method of the HTTP request
 *
 * @return string Current URL
 */
function getCurrentUrl() 
{
    global $_SERVER;

    /**
     * Filter php_self to avoid a security vulnerability.
     */
    $php_request_uri = htmlentities(substr($_SERVER[&#39;REQUEST_URI&#39;], 0,
    strcspn($_SERVER[&#39;REQUEST_URI&#39;], &quot;\n\r&quot;)), ENT_QUOTES);

    if (isset($_SERVER[&#39;HTTPS&#39;]) &amp;&amp; strtolower($_SERVER[&#39;HTTPS&#39;]) == &#39;on&#39;) {
        $protocol = &#39;https://&#39;;
    } else {
        $protocol = &#39;http://&#39;;
    }
    $host = $_SERVER[&#39;HTTP_HOST&#39;];
    if ($_SERVER[&#39;SERVER_PORT&#39;] != &#39;&#39; &amp;&amp;
        (($protocol == &#39;http://&#39; &amp;&amp; $_SERVER[&#39;SERVER_PORT&#39;] != &#39;80&#39;) ||
        ($protocol == &#39;https://&#39; &amp;&amp; $_SERVER[&#39;SERVER_PORT&#39;] != &#39;443&#39;))) {
            $port = &#39;:&#39; . $_SERVER[&#39;SERVER_PORT&#39;];
    } else {
        $port = &#39;&#39;;
    }
    return $protocol . $host . $port . $php_request_uri;
}

/**
 * Returns the AuthSub URL which the user must visit to authenticate requests 
 * from this application.
 *
 * Uses getCurrentUrl() to get the next URL which the user will be redirected
 * to after successfully authenticating with the Google service.
 *
 * @return string AuthSub URL
 */
function getAuthSubUrl() 
{
    $next = getCurrentUrl();
    $scope = &#39;http://picasaweb.google.com/data&#39;;
    $secure = false;
    $session = true;
    return Zend_Gdata_AuthSub::getAuthSubTokenUri($next, $scope, $secure, 
        $session);
}

/**
 * Returns a HTTP client object with the appropriate headers for communicating
 * with Google using AuthSub authentication.
 *
 * Uses the $_SESSION[&#39;sessionToken&#39;] to store the AuthSub session token after
 * it is obtained.  The single use token supplied in the URL when redirected 
 * after the user succesfully authenticated to Google is retrieved from the 
 * $_GET[&#39;token&#39;] variable.
 *
 * @return Zend_Http_Client
 */
function getAuthSubHttpClient() 
{
    global $_SESSION, $_GET;
    if (!isset($_SESSION[&#39;sessionToken&#39;]) &amp;&amp; isset($_GET[&#39;token&#39;])) {
        $_SESSION[&#39;sessionToken&#39;] = 
            Zend_Gdata_AuthSub::getAuthSubSessionToken($_GET[&#39;token&#39;]);
    } 
    $client = Zend_Gdata_AuthSub::getHttpClient($_SESSION[&#39;sessionToken&#39;]);
    return $client;
}

/**
 * Create a new instance of the service, redirecting the user
 * to the AuthSub server if necessary.
 */
$service = new Zend_Gdata_Photos(getAuthSubHttpClient());
             Finally, an unauthenticated server can be created for use with public feeds: &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata&#39;);
Zend_Loader::loadClass(&#39;Zend_Gdata_Photos&#39;);

// Create an instance of the service using an unauthenticated HTTP client

$service = new Zend_Gdata_Photos();
             Understanding and Constructing Queries 
            The primary method to request data from the service is by constructing a query.  There are query
            classes for each of the following types:
         User 
                    is used to specify the user whose data is being searched for, and is specified as a username.
                    If no user is provided, &quot;default&quot; will be used instead to indicate the currently authenticated
                    user (if authenticated).
                 Album 
                    is used to specify the album which is being searched for, and is specified as either an id,
                    or an album name.
                 Photo 
                    is used to specify the photo which is being searched for, and is specified as an id.
                 A new  UserQuery  can be constructed as followed: &lt;?php
$service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
$service = new Zend_Gdata_Photos($client);

$query = new Zend_Gdata_Photos_UserQuery();
$query-&gt;setUser(&quot;sample.user&quot;);
         
            For each query, a number of parameters limiting the search can be requested, or specified, 
            with get(Parameter) and set(Parameter), respectively.  They are as follows:
         Projection 
                    sets the format of the data returned in the feed, as either &quot;api&quot; or &quot;base&quot;.  Normally,
                    &quot;api&quot; is desired.  The default is &quot;api&quot;.
                 Type 
                    sets the type of element to be returned, as either &quot;feed&quot; or &quot;entry&quot;.  The default is &quot;feed&quot;.
                 Access 
                    sets the visibility of items to be returned, as &quot;all&quot;, &quot;public&quot;, or &quot;private&quot;.  The default is
                    &quot;all&quot;.  Non-public elements will only be returned if the query is searching for the
                    authenticated user.
                 Tag 
                    sets a tag filter for returned items.  When a tag is set, only items tagged with this value
                    will return.
                 Kind 
                    sets the kind of elements to return.  When kind is specified, only entries that match this
                    value will be returned.
                 ImgMax 
                    sets the maximum image size for entries returned.  Only image entries smaller than this value
                    will be returned.
                 Thumbsize 
                    sets the thumbsize of entries that are returned.  Any retrieved entry will have a thumbsize
                    equal to this value.
                 User 
                    sets the user whose data is being searched for.  The default is &quot;default&quot;.
                 AlbumId 
                    sets the id of the album being searched for.  This element only applies to album and photo queries.
                    In the case of photo queries, this specifies the album that contains the requested photo.  The
                    album id is mutually exclusive with the album&#39;s name.  Setting one unsets the other.
                 AlbumName 
                    sets the name of the album being searched for.  This element only applies to the album and photo
                    queries.  In the case of photo queries, this specifies the album that contains the requested photo.
                    The album name is mutually exclusive with the album&#39;s id.  Setting one unsets the other.
                 PhotoId 
                    sets the id of the photo being searched for.  This element only applies to photo queries.
                 Retrieving Feeds And Entries 
            The service has functions to retrieve a feed, or individual entries, for users, albums,
            and individual photos.
         Retrieving A User 
                The service supports retrieving a user feed and list of the user&#39;s content.  If the requested
                user is also the authenticated user, entries marked as &quot; hidden &quot; will also be returned.
             The user feed can be accessed by passing the username to the  getUserFeed  method: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    try {
        $userFeed = $service-&gt;getUserFeed(&quot;sample.user&quot;);
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             Or, the feed can be accessed by constructing a query, first: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $query = new Zend_Gdata_Photos_UserQuery();
    $query-&gt;setUser(&quot;sample.user&quot;);

    try {
        $userFeed = $service-&gt;getUserFeed(null, $query);
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             Constructing a query also provides the ability to request a user entry object: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $query = new Zend_Gdata_Photos_UserQuery();
    $query-&gt;setUser(&quot;sample.user&quot;);
    $query-&gt;setType(&quot;entry&quot;);

    try {
        $userEntry = $service-&gt;getUserEntry($query);
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             Retrieving An Album The service supports retrieving an album feed and a list of the album&#39;s content. 
                The album feed is accessed by constructing a query object and passing it to  getAlbumFeed :
             &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $query = new Zend_Gdata_Photos_AlbumQuery();
    $query-&gt;setUser(&quot;sample.user&quot;);
    $query-&gt;setAlbumId(&quot;1&quot;);

    try {
        $albumFeed = $service-&gt;getAlbumFeed($query);
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             
                Alternatively, the query object can be given an album name with  setAlbumName .  Setting
                the album name is mutually exclusive with setting the album id, and setting one will unset the other.
             Constructing a query also provides the ability to request an album entry object: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $query = new Zend_Gdata_Photos_AlbumQuery();
    $query-&gt;setUser(&quot;sample.user&quot;);
    $query-&gt;setAlbumId(&quot;1&quot;);
    $query-&gt;setType(&quot;entry&quot;);

    try {
        $albumEntry = $service-&gt;getAlbumEntry($query);
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             Retrieving A Photo The service supports retrieving a photo feed and a list of associated comments and tags. 
                The photo feed is accessed by constructing a query object and passing it to  getPhotoFeed :
             &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $query = new Zend_Gdata_Photos_PhotoQuery();
    $query-&gt;setUser(&quot;sample.user&quot;);
    $query-&gt;setAlbumId(&quot;1&quot;);
    $query-&gt;setPhotoId(&quot;100&quot;);

    try {
        $photoFeed = $service-&gt;getPhotoFeed($query);
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             Constructing a query also provides the ability to request a photo entry object: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $query = new Zend_Gdata_Photos_PhotoQuery();
    $query-&gt;setUser(&quot;sample.user&quot;);
    $query-&gt;setAlbumId(&quot;1&quot;);
    $query-&gt;setPhotoId(&quot;100&quot;);
    $query-&gt;setType(&quot;entry&quot;);

    try {
        $photoEntry = $service-&gt;getPhotoEntry($query);
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             Retrieving A Comment 
                The service supports retrieving comments from a feed of a different type.  By setting a query
                to return a kind of &quot;comment&quot;, a feed request can return comments associated with a specific user,
                album, or photo.
             Performing an action on each of the comments on a given photo can be accomplished as follows: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $query = new Zend_Gdata_Photos_PhotoQuery();
    $query-&gt;setUser(&quot;sample.user&quot;);
    $query-&gt;setAlbumId(&quot;1&quot;);
    $query-&gt;setPhotoId(&quot;100&quot;);
    $query-&gt;setKind(&quot;comment&quot;);

    try {
        $photoFeed = $service-&gt;getPhotoFeed($query);
    
        foreach ($photoFeed as $entry) {
            if ($entry instanceof Zend_Gdata_Photos_CommentEntry) {
                // Do something with the comment
            }
        }
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             Retrieving A Tag 
                The service supports retrieving tags from a feed of a different type.  By setting a query
                to return a kind of &quot;tag&quot;, a feed request can return tags associated with a specific photo.
             Performing an action on each of the tags on a given photo can be accomplished as follows: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $query = new Zend_Gdata_Photos_PhotoQuery();
    $query-&gt;setUser(&quot;sample.user&quot;);
    $query-&gt;setAlbumId(&quot;1&quot;);
    $query-&gt;setPhotoId(&quot;100&quot;);
    $query-&gt;setKind(&quot;tag&quot;);

    try {
        $photoFeed = $service-&gt;getPhotoFeed($query);
    
        foreach ($photoFeed as $entry) {
            if ($entry instanceof Zend_Gdata_Photos_TagEntry) {
                // Do something with the tag
            }
        }
    } catch (Zend_Gdata_App_Exception $e) {
        echo &quot;Error: &quot; . $e-&gt;getResponse();
    }
             Creating Entries The service has functions to create albums, photos, comments, and tags. Creating An Album The service supports creating a new album for an authenticated user: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $entry = new Zend_Gdata_Photos_AlbumEntry();
    $entry-&gt;setTitle($service-&gt;newTitle(&quot;test album&quot;));

    $service-&gt;insertAlbumEntry($entry);
             Creating A Photo The service supports creating a new photo for an authenticated user: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    // $photo is the name of a file uploaded via an HTML form

    $fd = $service-&gt;newMediaFileSource($photo[&quot;tmp_name&quot;]);
    $fd-&gt;setContentType($photo[&quot;type&quot;]);

    $entry = new Zend_Gdata_Photos_PhotoEntry();
    $entry-&gt;setMediaSource($fd);
    $entry-&gt;setTitle($service-&gt;newTitle($photo[&quot;name&quot;]));

    $albumQuery = new Zend_Gdata_Photos_AlbumQuery;
    $albumQuery-&gt;setUser(&quot;sample.user&quot;);
    $albumQuery-&gt;setAlbumId(&quot;1&quot;);

    $albumEntry = $service-&gt;getAlbumEntry($albumQuery);

    $service-&gt;insertPhotoEntry($entry, $albumEntry);
             Creating A Comment The service supports creating a new comment for a photo: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $entry = new Zend_Gdata_Photos_CommentEntry();
    $entry-&gt;setTitle($service-&gt;newTitle(&quot;comment&quot;));
    $entry-&gt;setContent($service-&gt;newContent(&quot;comment&quot;));

    $photoQuery = new Zend_Gdata_Photos_PhotoQuery;
    $photoQuery-&gt;setUser(&quot;sample.user&quot;);
    $photoQuery-&gt;setAlbumId(&quot;1&quot;);
    $photoQuery-&gt;setPhotoId(&quot;100&quot;);
    $photoQuery-&gt;setType(&#39;entry&#39;);

    $photoEntry = $service-&gt;getPhotoEntry($photoQuery);

    $service-&gt;insertCommentEntry($entry, $photoEntry);
             Creating A Tag The service supports creating a new tag for a photo: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $entry = new Zend_Gdata_Photos_TagEntry();
    $entry-&gt;setTitle($service-&gt;newTitle(&quot;tag&quot;));

    $photoQuery = new Zend_Gdata_Photos_PhotoQuery;
    $photoQuery-&gt;setUser(&quot;sample.user&quot;);
    $photoQuery-&gt;setAlbumId(&quot;1&quot;);
    $photoQuery-&gt;setPhotoId(&quot;100&quot;);
    $photoQuery-&gt;setType(&#39;entry&#39;);

    $photoEntry = $service-&gt;getPhotoEntry($photoQuery);

    $service-&gt;insertTagEntry($entry, $photoEntry);
             Deleting Entries The service has functions to delete albums, photos, comments, and tags. Deleting An Album The service supports deleting an album for an authenticated user: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $albumQuery = new Zend_Gdata_Photos_AlbumQuery;
    $albumQuery-&gt;setUser(&quot;sample.user&quot;);
    $albumQuery-&gt;setAlbumId(&quot;1&quot;);
    $albumQuery-&gt;setType(&#39;entry&#39;);

    $entry = $service-&gt;getAlbumEntry($albumQuery);

    $service-&gt;deleteAlbumEntry($entry, true);
             Deleting A Photo The service supports deleting a photo for an authenticated user: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $photoQuery = new Zend_Gdata_Photos_PhotoQuery;
    $photoQuery-&gt;setUser(&quot;sample.user&quot;);
    $photoQuery-&gt;setAlbumId(&quot;1&quot;);
    $photoQuery-&gt;setPhotoId(&quot;100&quot;);
    $photoQuery-&gt;setType(&#39;entry&#39;);

    $entry = $service-&gt;getPhotoEntry($photoQuery);

    $service-&gt;deletePhotoEntry($entry, true);
             Deleting A Comment The service supports deleting a comment for an authenticated user: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $photoQuery = new Zend_Gdata_Photos_PhotoQuery;
    $photoQuery-&gt;setUser(&quot;sample.user&quot;);
    $photoQuery-&gt;setAlbumId(&quot;1&quot;);
    $photoQuery-&gt;setPhotoId(&quot;100&quot;);
    $photoQuery-&gt;setType(&#39;entry&#39;);

    $path = $photoQuery-&gt;getQueryUrl() . &#39;/commentid/&#39; . &quot;1000&quot;;

    $entry = $service-&gt;getCommentEntry($path);

    $service-&gt;deleteCommentEntry($entry, true);
             Deleting A Tag The service supports deleting a tag for an authenticated user: &lt;?php
    $service = Zend_Gdata_Photos::AUTH_SERVICE_NAME;
    $client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
    $service = new Zend_Gdata_Photos($client);

    $photoQuery = new Zend_Gdata_Photos_PhotoQuery;
    $photoQuery-&gt;setUser(&quot;sample.user&quot;);
    $photoQuery-&gt;setAlbumId(&quot;1&quot;);
    $photoQuery-&gt;setPhotoId(&quot;100&quot;);
    $photoQuery-&gt;setKind(&quot;tag&quot;);
    $query = $photoQuery-&gt;getQueryUrl();

    $photoFeed = $service-&gt;getPhotoFeed($query);

    foreach ($photoFeed as $entry) {
        if ($entry instanceof Zend_Gdata_Photos_TagEntry) {
            if ($entry-&gt;getContent() == $tagContent) {
                $tagEntry = $entry;
            }
        }
    }

    $service-&gt;deleteTagEntry($tagEntry, true);
             Optimistic Concurrency (Notes On Deletion) 
                GData feeds, including those of the Picasa Web Albums service, implement optimistic concurrency,
                a versioning system that prevents users from overwriting changes, inadvertently.  When
                deleting a entry through the service class, if the entry has been modified since it was
                last fetched, an exception will be thrown, unless explicitly set otherwise (in which case
                the deletion is retried on the updated entry).
             
                An example of how to handle versioning during a deletion is shown by  deleteAlbumEntry :
             &lt;?php
    // $album is the albumEntry to be deleted
    try {
        $this-&gt;delete($album);
    } catch (Zend_Gdata_App_HttpException $e) {
        if ($e-&gt;getResponse-&gt;getStatus() === 409) {
            $entry = new Zend_Gdata_Photos_AlbumEntry($e-&gt;getResponse()-&gt;getBody());
            $this-&gt;delete($entry-&gt;getLink(&#39;edit&#39;)-&gt;href);
        } else {
            throw $e;
        }
    }
             Using Google Spreadsheets 
        The Google Spreadsheets data API allows client applications to view
        and update Spreadsheets content in the form of Google data API feeds.
        Your client application can request a list of a user&#39;s spreadsheets,
        edit or delete content in an existing Spreadsheets worksheet, and
        query the content in an existing Spreadsheets worksheet.
     
        See
         http://code.google.com/apis/spreadsheets/overview.html 
        for more information about the Google Spreadsheets API.
     Create a Spreadsheet 
            The Spreadsheets data API does not currently provide a way to
            programatically create or delete a spreadsheet.
         Get a List of Spreadsheets 
            You can get a list of spreadsheets for a particular user by using
            the  getSpreadsheetFeed  method of the Spreadsheets
            service.  The service will return a
             Zend_Gdata_Spreadsheets_SpreadsheetFeed  object
            containing a list of spreadsheets associated with the authenticated
            user.
         &lt;?php
$service = Zend_Gdata_Spreadsheets::AUTH_SERVICE_NAME;
$client = Zend_Gdata_ClientLogin::getHttpClient($user, $pass, $service);
$spreadsheetService = new Zend_Gdata_Spreadsheets($client);
$feed = $spreadsheetService-&gt;getSpreadsheetFeed();
         Get a List of Worksheets 
            A given spreadsheet may contain multiple worksheets. For each
            spreadsheet, there&#39;s a worksheets metafeed listing all the
            worksheets in that spreadsheet.
         
            Given the spreadsheet key from the &lt;id&gt; of a
             Zend_Gdata_Spreadsheets_SpreadsheetEntry 
            object you&#39;ve already retrieved, you can fetch a feed
            containing a list of worksheets associated with that spreadsheet.
         &lt;?php
$query = new Zend_Gdata_Spreadsheets_DocumentQuery();
$query-&gt;setSpreadsheetKey($spreadsheetKey);
$feed = $spreadsheetService-&gt;getWorksheetFeed($query);
         
            The resulting  Zend_Gdata_Spreadsheets_WorksheetFeed 
            object feed represents the response from the server. Among other
            things, this feed contains a list of
             Zend_Gdata_Spreadsheets_WorksheetEntry  
            objects ( $feed-&gt;entries ), each of which represents a
            single worksheet.
         Interacting With List-based Feeds 
            A given worksheet generally contains multiple rows, each
            containing multiple cells. You can request data from the
            worksheet either as a list-based feed, in which each entry
            represents a row, or as a cell-based feed, in which each
            entry represents a single cell. For information on cell-based
            feeds, see  Interacting with cell-based feeds .
         
            The following sections describe how to get a list-based feed,
            add a row to a worksheet, and send queries with various query
            parameters.
         
            The list feed makes some assumptions about how the data is laid
            out in the spreadsheet.
         
            In particular, the list feed treats the first row of the
            worksheet as a header row; Spreadsheets dynamically creates
            XML elements named after the contents of header-row cells.
            Users who want to provide Gdata feeds should not put any data
            other than column headers in the first row of a worksheet.
         
            The list feed contains all rows after the first row up to the
            first blank row. The first blank row terminates the data set.
            If expected data isn&#39;t appearing in a feed, check the worksheet
            manually to see whether there&#39;s an unexpected blank row in the
            middle of the data. In particular, if the second row of the
            spreadsheet is blank, then the list feed will contain no data.
         
            A row in a list feed is as many columns wide as the worksheet itself.
         Get a List-based Feed 
                To retrieve a worksheet&#39;s list feed, use the
                 getListFeed  method of the Spreadsheets service.
             &lt;?php
$query = new Zend_Gdata_Spreadsheets_ListQuery();
$query-&gt;setSpreadsheetKey($spreadsheetKey);
$query-&gt;setWorksheetId($worksheetId);
$listFeed = $spreadsheetService-&gt;getListFeed($query);
             
                The resulting  Zend_Gdata_Spreadsheets_ListFeed 
                object  $listfeed  represents a response from the
                server. Among other things, this feed contains an array of
                 Zend_Gdata_Spreadsheets_ListEntry  objects
                ( $listFeed-&gt;entries ), each of which represents
                a single row in a worksheet.
             
              Each  Zend_Gdata_Spreadsheets_ListEntry  contains an
              array,  custom , which contains the data for that
              row. You can extract and display this array:
             &lt;?php
$rowData = $listFeed-&gt;entries[1]-&gt;getCustom();
foreach($rowData as $customEntry) {
  echo $customEntry-&gt;getColumnName() . &quot; = &quot; . $customEntry-&gt;getText();
}
             
              An alternate version of this array,  customByName ,
              allows direct access to an entry&#39;s cells by name. This is
              convenient when trying to access a specific header:
             &lt;?php
$customEntry = $listFeed-&gt;entries[1]-&gt;getCustomByName(&#39;my_heading&#39;);
echo $customEntry-&gt;getColumnName() . &quot; = &quot; . $customEntry-&gt;getText();
             Reverse-sort Rows 
                By default, rows in the feed appear in the same order as the
                corresponding rows in the GUI; that is, they&#39;re in order by
                row number. To get rows in reverse order, set the reverse
                properties of the  Zend_Gdata_Spreadsheets_ListQuery 
                object to true:
             &lt;?php
$query = new Zend_Gdata_Spreadsheets_ListQuery();
$query-&gt;setSpreadsheetKey($spreadsheetKey);
$query-&gt;setWorksheetId($worksheetId);
$query-&gt;setReverse(&#39;true&#39;);
$listFeed = $spreadsheetService-&gt;getListFeed($query);
             
                Note that if you want to order (or reverse sort) by a
                particular column, rather than by position in the worksheet,
                you can set the  orderby  value of the
                 Zend_Gdata_Spreadsheets_ListQuery  object to
                 column:&lt;the header of that column&gt; .
             Send a Structured Query 
                You can set a  Zend_Gdata_Spreadsheets_ListQuery &#39;s
                 sq  value to produce a feed with entries that meet
                the specified criteria. For example, suppose you have a worksheet
                containing personnel data, in which each row represents
                information about a single person. You wish to retrieve all rows
                in which the person&#39;s name is &quot;John&quot; and the person&#39;s age is over
                25. To do so, you would set  sq  as follows:
             &lt;?php
$query = new Zend_Gdata_Spreadsheets_ListQuery();
$query-&gt;setSpreadsheetKey($spreadsheetKey);
$query-&gt;setWorksheetId($worksheetId);
$query-&gt;setSpreadsheetQuery(&#39;name=John and age&gt;25&#39;);
$listFeed = $spreadsheetService-&gt;getListFeed($query);
             Add a Row 
                Rows can be added to a spreadsheet by using the
                 insertRow  method of the Spreadsheet service.
             &lt;?php
$insertedListEntry = $spreadsheetService-&gt;insertRow($rowData, $spreadsheetKey, $worksheetId);
             
                The  $rowData  parameter contains an array of column
                keys to data values.  The method returns a
                 Zend_Gdata_Spreadsheets_SpreadsheetsEntry  object
                which represents the inserted row.
             
                Spreadsheets inserts the new row immediately after the last row
                that appears in the list-based feed, which is to say
                immediately before the first entirely blank row.
             Edit a Row 
                Once a  Zend_Gdata_Spreadsheets_ListEntry  object
                is fetched, its rows can be updated by using the
                 updateRow  method of the Spreadsheet service.
             &lt;?php
$updatedListEntry = $spreadsheetService-&gt;updateRow($oldListEntry, $newRowData);
             
                The  $oldListEntry  parameter contains the list entry
                to be updated.   $newRowData  contains an array of
                column keys to data values, to be used as the new row data.
                The method returns a
                 Zend_Gdata_Spreadsheets_SpreadsheetsEntry  object
                which represents the updated row.
             Delete a Row 
                To delete a row, simply invoke  deleteRow  on the
                 Zend_Gdata_Spreadsheets  object with the existing
                entry to be deleted:
             &lt;?php
$spreadsheetService-&gt;deleteRow($listEntry);
             
                Alternatively, you can call the  delete  method of
                the entry itself:
             &lt;?php
$listEntry-&gt;delete();
             Interacting With Cell-based Feeds 
            In a cell-based feed, each entry represents a single cell.
         
            Note that we don&#39;t recommend interacting with both a cell-based
            feed and a list-based feed for the same worksheet at the same time.
         Get a Cell-based Feed 
                To retrieve a worksheet&#39;s cell feed, use the
                 getCellFeed  method of the Spreadsheets service.
             &lt;?php
$query = new Zend_Gdata_Spreadsheets_CellQuery();
$query-&gt;setSpreadsheetKey($spreadsheetKey);
$query-&gt;setWorksheetId($worksheetId);
$cellFeed = $spreadsheetService-&gt;getCellFeed($query);
             
                The resulting  Zend_Gdata_Spreadsheets_CellFeed 
                object  $cellFeed  represents a response from the
                server. Among other things, this feed contains an array of
                 Zend_Gdata_Spreadsheets_CellEntry  objects
                ( $cellFeed&gt;entries ), each of which represents
                a single cell in a worksheet.  You can display this information:
             &lt;?php
foreach($cellFeed as $cellEntry) {
  $row = $cellEntry-&gt;cell-&gt;getRow();
  $col = $cellEntry-&gt;cell-&gt;getColumn();
  $val = $cellEntry-&gt;cell-&gt;getText();
  echo &quot;$row, $col = $val\n&quot;;
}
             Send a Cell Range Query 
                Suppose you wanted to retrieve the cells in the first column
                of a worksheet. You can request a cell feed containing only
                this column as follows:
             &lt;?php
$query = new Zend_Gdata_Spreadsheets_CellQuery();
$query-&gt;setMinCol(1);
$query-&gt;setMaxCol(1);
$query-&gt;setMinRow(2);
$feed = $spreadsheetService-&gt;getCellsFeed($query);
             
                This requests all the data in column 1, starting with row 2.
             Change Contents of a Cell 
                To modify the contents of a cell, call
                 updateCell  with the row, column,
                and new value of the cell.
             &lt;?php
$updatedCell = $spreadsheetService-&gt;updateCell($row, $col, $inputValue, $spreadsheetKey, $worksheetId);
             
                The new data is placed in the specified cell in the worksheet.
                If the specified cell contains data already, it will be
                overwritten.  Note: Use  updateCell  to change
                the data in a cell, even if the cell is empty.
             Using the YouTube data API 
        The YouTube data API offers read-only access to YouTube&#39;s content 
        in the form of Google data (&quot;GData&quot;) feeds.  The API gives access to
        lists of videos matching specific criteria, popular videos, and more.
        It also allows access to public information about YouTube users, including
        playlists, subscriptions and contacts.
     
        For more information on the YouTube data API, please refer
        to the  
        YouTube data API documentation .
     Authentication 
            The YouTube data API currently allows read-only access to public 
            data, so no authentication is required.
             Retrieving video feeds 
            The YouTube data API provides numerous feeds that return a list of 
            videos, such as standard feeds, related videos, video responses, 
            user&#39;s uploads, and user&#39;s favorites. For example, the 
            user&#39;s uploads feed returns all videos uploaded by a specific user. 
            See the  
            reference guide  for a detailed list of all feeds. All the 
            feeds described in this section are &quot;video feeds&quot; -- feeds that return 
            lists of videos.
         Searching for videos by metadata 
                You can retrieve a list of videos that match specified 
                search criteria, using the video feed.  The following query
                looks for videos which contain the word &quot;cat&quot; in their 
                metadata, starting with the 10th video and displaying 20 
                videos per page, ordered by the view count.
             &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Gdata_YouTube&#39;);

$yt = new Zend_Gdata_YouTube();
$query = $yt-&gt;newVideoQuery();
$query-&gt;videoQuery = &#39;cat&#39;;
$query-&gt;startIndex = 10;
$query-&gt;maxResults = 20;
$query-&gt;orderBy = &#39;viewCount&#39;;

echo $query-&gt;queryUrl . &quot;\n&quot;;
$videoFeed = $yt-&gt;getVideoFeed($query); 

foreach ($videoFeed as $videoEntry) {
  echo &quot;---------VIDEO----------\n&quot;;
  echo &quot;Title: &quot; . $videoEntry-&gt;mediaGroup-&gt;title-&gt;text . &quot;\n&quot;;
  echo &quot;\nDescription:\n&quot;;
  echo $videoEntry-&gt;mediaGroup-&gt;description-&gt;text;
  echo &quot;\n\n\n&quot;;
}
?&gt; 
                For more details on the different query parameters, please 
                refer to the  
                Reference Guide .  There are helper functions in
                Zend_Gdata_YouTube_VideoQuery for each of these parameters.
             Searching for videos by categories and tags/keywords 
                Searching for videos in specific categories is done by
                generating a  
                specially formatted URL .  For example, to search for 
                comedy videos which contain the keyword dog:
             
$yt = new Zend_Gdata_YouTube();
$query = $yt-&gt;newVideoQuery();
$query-&gt;category = &#39;Comedy/dog&#39;;

echo $query-&gt;queryUrl . &quot;\n&quot;;
$videoFeed = $yt-&gt;getVideoFeed($query); 
 Retrieving standard feeds 
                The YouTube data API has a number of 
                 
                standard feeds .  These standard feeds can be retrieved
                as Zend_Gdata_YouTube_VideoFeed objects using the specified 
                URLs, but many also have helper methods in Zend_Gdata_YouTube.
             
                To retrieve the top rated videos using the helper method:
             
$yt = new Zend_Gdata_YouTube();

$videoFeed = $yt-&gt;getTopRatedVideoFeed(); 
 
                There are also query parameters to specify the time period
                over which the standard feed is computed.  Only valid with the
                top_rated and most_viewed standard feeds.
             
                For example, to retrieve the top rated videos for today:
             
$yt = new Zend_Gdata_YouTube();
$query = $yt-&gt;newVideoQuery();
$query-&gt;setTime(&#39;today&#39;);
$videoFeed = $yt-&gt;getTopRatedVideoFeed($query); 
 
                Alternatively, you could just retrieve the feed using the
                URL:
             
$yt = new Zend_Gdata_YouTube();
$query = $yt-&gt;newVideoQuery(&#39;http://gdata.youtube.com/feeds/standardfeeds/top_rated&#39;);
$query-&gt;setTime(&#39;today&#39;);
$videoFeed = $yt-&gt;getVideoFeed($query); 
 Retrieving videos uploaded by a user 
                You can retrieve a list of videos uploaded by a particular user
                using a simple helper method. This example retrieves videos 
                uploaded by the user &#39;liz&#39;.
             
$yt = new Zend_Gdata_YouTube();
$videoFeed = $yt-&gt;getUserUploads(&#39;liz&#39;); 
 Retrieving videos favorited by a user 
                You can retrieve a list of a user&#39;s favorite videos
                using a simple helper method. This example retrieves videos 
                favorited by the user &#39;liz&#39;.
             
$yt = new Zend_Gdata_YouTube();
$videoFeed = $yt-&gt;getUserFavorites(&#39;liz&#39;); 
 Retrieving video responses for a video 
                You can retrieve a list of a video&#39;s video responses
                using a simple helper method. This example retrieves video
                response for a video with the ID &#39;abc123813abc&#39;.
             
$yt = new Zend_Gdata_YouTube();
$videoFeed = $yt-&gt;getVideoResponseFeed(&#39;abc123813abc&#39;); 
 Retrieving video comments 
            The comments for each YouTube video can be retrieved in 
            several ways.  To retrieve the comments for the video with 
            the ID &#39;abc123813abc&#39;, use the following code: 
         
$yt = new Zend_Gdata_YouTube();
$commentFeed = $yt-&gt;getVideoCommentFeed(&#39;abc123813abc&#39;); 

foreach ($commentFeed as $commentEntry) {
    echo $commentEntry-&gt;title-&gt;text . &quot;\n&quot;;
    echo $commentEntry-&gt;content-&gt;text . &quot;\n\n\n&quot;;
} 
 
            Comments can also be retrieved for a video if you have
            a copy of the Zend_Gdata_YouTube_VideoEntry object:
         
$yt = new Zend_Gdata_YouTube();
$videoEntry = $yt-&gt;getVideoEntry(&#39;abc123813abc&#39;); 
// we don&#39;t know the video ID in this example, but we do have the URL
$commentFeed = $yt-&gt;getVideoCommentFeed(null, $videoEntry-&gt;comments-&gt;href);
 Retrieving playlist feeds 
            The YouTube data API provides information about users, including
            profiles, playlists, subscriptions, and more.
         Retrieving the playlists of a user 
                The library provides a helper method to retrieve
                the playlists associated with a given user.  To retrieve the
                playlists for the user &#39;liz&#39;:
             
$yt = new Zend_Gdata_YouTube();
$playlistListFeed = $yt-&gt;getPlaylistListFeed(&#39;liz&#39;); 

foreach ($playlistListFeed as $playlistEntry) {
    echo $playlistEntry-&gt;title-&gt;text . &quot;\n&quot;;
    echo $playlistEntry-&gt;description-&gt;text . &quot;\n&quot;;
    echo $playlistEntry-&gt;getPlaylistVideoFeedUrl() . &quot;\n\n\n&quot;;
} 
 Retrieving a specific playlist 
                The library provides a helper method to retrieve
                the videos associated with a given playlist.  To retrieve the
                playlists for a specific playlist entry:
             
$playlistVideoFeed = $yt-&gt;getPlaylistVideoFeed($playlistEntry-&gt;getPlaylistVideoFeedUrl()); 
 Retrieving a list of a user&#39;s subscriptions 
            A user can have several types of subscriptions: channel 
            subscription, tag subscription, or favorites subscription.
            A Zend_Gdata_YouTube_SubscriptionEntry is used to represent
            individual subscriptions.
         
            To retrieve all subscriptions for the user &#39;liz&#39;:
         
$yt = new Zend_Gdata_YouTube();
$subscriptionFeed = $yt-&gt;getSubscriptionFeed(&#39;liz&#39;); 

foreach ($subscriptionFeed as $subscriptionEntry) {
    echo $subscriptionEntry-&gt;title-&gt;text . &quot;\n&quot;;
} 
 Retrieving a user&#39;s profile 
            You can retrieve the public profile information
            for any YouTube user.  To retrieve the profile
            for the user &#39;liz&#39;:
         
$yt = new Zend_Gdata_YouTube();
$userProfile = $yt-&gt;getUserProfile(&#39;liz&#39;); 
echo &quot;username: &quot; . $userProfile-&gt;username-&gt;text . &quot;\n&quot;;
echo &quot;age: &quot; . $userProfile-&gt;age-&gt;text . &quot;\n&quot;;
echo &quot;hometown: &quot; . $userProfile-&gt;hometown-&gt;text . &quot;\n&quot;; 
 Zend_Http_Client - Connection Adapters Overview 
            Zend_Http_Client is based on a connection adapter design. The
            connection adapter is the object in charge of performing the
            actual connection to the server, as well as writing requests
            and reading responses.
            This connection adapter can be replaced, and you can create and
            extend the default connection adapters to suite your special needs,
            without the need to extend or replace the entire HTTP client
            class, and with the same interface.
         
            Currently, the Zend_Http_Client class provides three built-in
            connection adapters:
             Zend_Http_Client_Adapter_Socket  (default)
                     Zend_Http_Client_Adapter_Proxy Zend_Http_Client_Adapter_Test 
         
            The Zend_Http_Client object&#39;s adapter connection adapter is set
            using the &#39;adapter&#39; configuration option. When instantiating the
            client object, you can set the &#39;adapter&#39; configuration option to
            a string containing the adapter&#39;s name (eg. &#39;Zend_Http_Client_Adapter_Socket&#39;)
            or to a variable holding an adapter object (eg  
            new Zend_Http_Client_Adapter_test ). You can also set the
            adapter later, using the Zend_Http_Client-&gt;setConfig() method.
         The Socket Adapter 
            The default connection adapter is the Zend_Http_Client_Adapter_Socket
            adapter - this adapter will be used unless you explicitly set the
            connection adapter. The Socket adapter is based on PHP&#39;s built-in
            fsockopen() function, and does not require any special extensions or
            compilation flags.
         
            The Socket adapter allows several extra configuration options that 
            can be set using  Zend_Http_Client-&gt;setConfig()  or 
            passed to the client constructor. All of them are related to HTTPS
            connections, and are not relevant when connecting to non-secure 
            HTTP servers: 
             Zend_Http_Client_Adapter_Socket configuration parameters Parameter Description Expected Values Default Value ssltransport SSL transport layer (eg. &#39;sslv2&#39;, &#39;tls&#39;) string ssl sslcert PEM encoded SSL certificate file path string &#39;/path/to/cert.pem&#39; sslpassphrase Passphrase for the SSL certificate file string &#39;s0mes3cre7&#39; 
            
             HTTPS SSL Stream Parameters 
                    All the above parameters are related to the SSL layer used 
                    in HTTPS connections. While the default settings should work
                    for most applications, you might need to change them if the
                    server you are connecting to requires special client setup. 
                    If so, you should read the sections about SSL transport 
                    layers and options  here .
                 
         Changing the HTTPS transport layer &lt;?php
// Set the configuration parameters
$config = array(
    &#39;adapter&#39;      =&gt; &#39;Zend_Http_Client_Adapter_Socket&#39;,
    &#39;ssltransport&#39; =&gt; &#39;tls&#39;
);

// Instantiate a client object
$client = Zend_Http_Client(&#39;https://www.example.com&#39;, $config);

// The following request will be sent over a TLS secure connection.
$response = $client-&gt;request();
             
            The result of the example above will be similar to opening a TCP
            connection using the following PHP command:
         fsockopen(&#39;tls://www.example.com&#39;, 443) The Proxy Adapter 
            The Zend_Http_Client_Adapter_Proxy adapter is similar to the default
            Socket adapter - only the connection is made through an HTTP proxy
            server instead of a direct connection to the target server. This
            allows usage of Zend_Http_Client behind proxy servers - which is
            sometimes needed for security or performance reasons.
         
            Using the Proxy adapter requires several additional configuration
            parameters to be set, in addition to the default &#39;adapter&#39; option:
             Zend_Http_Client configuration parameters Parameter Description Expected Type Example Value proxy_host Proxy server address string &#39;proxy.myhost.com&#39; or &#39;10.1.2.3&#39; proxy_port Proxy server TCP port integer 8080 (default) or 81 proxy_user Proxy user name, if required string &#39;shahar&#39; or &#39;&#39; for none (default) proxy_pass Proxy password, if required string &#39;secret&#39; or &#39;&#39; for none (default) proxy_auth Proxy HTTP authentication type string Zend_Http_Client::AUTH_BASIC (default) 
         
            proxy_host should always be set - if it is not set, the client will
            fall back to a direct connection using Zend_Http_Client_Adapter_Socket.
            proxy_port defaults to &#39;8080&#39; - if your proxy listens on a different
            port you must set this one as well.
         
            proxy_user and proxy_pass are only required if your proxy server
            requires you to authenticate. Providing these will add a &#39;Proxy-Authentication&#39;
            header to the request. If your proxy does not require authentication,
            you can leave these two options out.
         
            proxy_auth sets the proxy authentication type, if your proxy server
            requires authentication. Possibly values are similar to the ones
            accepted by the Zend_Http_Client::setAuth() method. Currently, only
            basic authentication (Zend_Http_Client::AUTH_BASIC) is supported.
         Using Zend_Http_Client behind a proxy server &lt;?php
// Set the configuration parameters
$config = array(
    &#39;adapter&#39;    =&gt; &#39;Zend_Http_Client_Adapter_Proxy&#39;,
    &#39;proxy_host&#39; =&gt; &#39;proxy.int.zend.com&#39;,
    &#39;proxy_port&#39; =&gt; 8000,
    &#39;proxy_user&#39; =&gt; &#39;shahar.e&#39;,
    &#39;proxy_pass&#39; =&gt; &#39;bananashaped&#39;
);

// Instantiate a client object
$client = Zend_Http_Client(&#39;http://www.example.com&#39;, $config);

// Continue working...
             
            As mentioned, if proxy_host is not set or is set to a blank string,
            the connection will fall back to a regular direct connection. This
            allows you to easily write your application in a way that allows a
            proxy to be used optionally, according to a configuration parameter.
         The Test Adapter 
            Sometimes, it is very hard to test code that relies on HTTP connections.
            For example, testing an application that pulls an RSS feed from a remote
            server will require a network connection, which is not always available.
         
            For this reason, the Zend_Http_Client_Adapter_Test adapter is
            provided. You can write your application to use Zend_Http_Client,
            and just for testing purposes, for example in your unit testing
            suite, you can replace the default adapter with a Test adapter (a
            mock object), allowing you to run tests without actually
            performing server connections.
         
            The Zend_Http_Client_Adapter_Test adapter provides an additional
            method, setResponse() method. This method takes one parameter,
            which represents an HTTP response as either text or a Zend_Http_Response
            object. Once set, your Test adapter will always return this response,
            without even performing an actual HTTP request.
         Testing Against a Single HTTP Response Stub &lt;?php
// Instantiate a new adapter and client
$adapter = new Zend_Http_Client_Adapter_Test();
$client = Zend_Http_Client(&#39;http://www.example.com&#39;, array(
    &#39;adapter&#39; =&gt; $adapter
));

// Set the expected response
$adapter-&gt;setResponse(
    &quot;HTTP/1.1 200 OK&quot;        . &quot;\r\n&quot; .
    &quot;Content-type: text/xml&quot; . &quot;\r\n&quot; .
                               &quot;\r\n&quot; .
    &#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#39; .
    &#39;&lt;rss version=&quot;2.0&quot; xmlns:content=&quot;http://purl.org/rss/1.0/modules/content/&quot;&#39; .
    &#39;     xmlns:wfw=&quot;http://wellformedweb.org/CommentAPI/&quot;&#39; .
    &#39;     xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;&gt;&#39; .
    &#39;  &lt;channel&gt;&#39; .
    &#39;    &lt;title&gt;Premature Optimization&lt;/title&gt;&#39; .
    // and so on...
    &#39;&lt;/rss&gt;&#39;);

$response = $client-&gt;request(&#39;GET&#39;);
// .. continue parsing $response..
             
            The above example shows how you can preset your HTTP client to
            return the response you need. Then, you can continue testing your
            own code, without being dependent on a network connection, the server&#39;s
            response, etc. In this case, the test would continue to check how
            the application parses the XML in the response body.
         
            Sometimes, a single method call to an object can result in that
            object performing multiple HTTP transactions. In this case, it&#39;s
            not possible to use setResponse() alone because there&#39;s no
            opportunity to set the next response(s) your program might need
            before returning to the caller.
         Testing Against Multiple HTTP Response Stubs &lt;?php
// Instantiate a new adapter and client
$adapter = new Zend_Http_Client_Adapter_Test();
$client = Zend_Http_Client(&#39;http://www.example.com&#39;, array(
    &#39;adapter&#39; =&gt; $adapter
));

// Set the first expected response
$adapter-&gt;setResponse(
    &quot;HTTP/1.1 302 Found&quot;      . &quot;\r\n&quot; .
    &quot;Location: /&quot;             . &quot;\r\n&quot; .
    &quot;Content-Type: text/html&quot; . &quot;\r\n&quot; .
                                &quot;\r\n&quot; .
    &#39;&lt;html&gt;&#39; .
    &#39;  &lt;head&gt;&lt;title&gt;Moved&lt;/title&gt;&lt;/head&gt;&#39; .
    &#39;  &lt;body&gt;&lt;p&gt;This page has moved.&lt;/p&gt;&lt;/body&gt;&#39; .
    &#39;&lt;/html&gt;&#39;);

// Set the next successive response
$adapter-&gt;addResponse(
    &quot;HTTP/1.1 200 OK&quot;         . &quot;\r\n&quot; .
    &quot;Content-Type: text/html&quot; . &quot;\r\n&quot; .
                                &quot;\r\n&quot; .
    &#39;&lt;html&gt;&#39; .
    &#39;  &lt;head&gt;&lt;title&gt;My Pet Store Home Page&lt;/title&gt;&lt;/head&gt;&#39; .
    &#39;  &lt;body&gt;&lt;p&gt;...&lt;/p&gt;&lt;/body&gt;&#39; .
    &#39;&lt;/html&gt;&#39;);

// inject the http client object ($client) into your object
// being tested and then test your object&#39;s behavior below
             
            The setResponse() method clears any responses in the
            Zend_Http_Client_Adapter_Test&#39;s buffer and sets the
            first response that will be returned.  The addResponse()
            method will add successive responses.
         
            The responses will be replayed in the order that they
            were added.  If more requests are made than the number
            of responses stored, the responses will cycle again
            in order.
         
            In the example above, the adapter is configured to test your
            object&#39;s behavior when it encounters a 302 redirect. Depending on
            your application, following a redirect may or may not be desired
            behavior. In our example, we expect that the redirect will be
            followed and we configure the test adapter to help us test this.
            The initial 302 response is set up with the setResponse() method
            and the 200 response to be returned next is added with the
            addResponse() method. After configuring the test adapter, inject
            the HTTP client containing the adapter into your object under test
            and test its behavior.
         Creating your own connection adapters 
            You can create your own connection adapters and use them. You could, for
            example, create a connection adapter that uses persistent sockets,
            or a connection adapter with caching abilities, and use them as
            needed in your application.
         
            In order to do so, you must create your own adapter class that implements
            the Zend_Http_Client_Adapter_Interface interface. The following example
            shows the skeleton of a user-implemented adapter class. All the public
            functions defined in this example must be defined in your adapter as well:
         Creating your own connection adapter &lt;?php
class MyApp_Http_Client_Adapter_BananaProtocol implements Zend_Http_Client_Adapter_Interface
{
    /**
     * Set the configuration array for the adapter
     *
     * @param array $config
     */
    public function setConfig($config = array())
    {
        // This rarely changes - you should usually copy the implementation
        // in Zend_Http_Client_Adapter_Socket.
    }

    /**
     * Connect to the remote server
     *
     * @param string  $host
     * @param int     $port
     * @param boolean $secure
     */
    public function connect($host, $port = 80, $secure = false)
    {
        // Set up the connection to the remote server
    }

    /**
     * Send request to the remote server
     *
     * @param string        $method
     * @param Zend_Uri_Http $url
     * @param string        $http_ver
     * @param array         $headers
     * @param string        $body
     * @return string Request as text
     */
    public function write($method, $url, $http_ver = &#39;1.1&#39;, $headers = array(), $body = &#39;&#39;)
    {
        // Send request to the remote server.
        // This function is expected to return the full request (headers and body) as a string
    }

    /**
     * Read response from server
     *
     * @return string
     */
    public function read()
    {
        // Read response from remote server and return it as a string
    }

    /**
     * Close the connection to the server
     *
     */
    public function close()
    {
        // Close the connection to the remote server - called last.
    }
}

// Then, you could use this adapter:
$client = new Zend_Http_Client(array(
    &#39;adapter&#39; =&gt; &#39;MyApp_Http_Client_Adapter_BananaProtocol&#39;
));
             Zend_Http_Client - Advanced Usage HTTP Redirections 
            By default, Zend_Http_Client automatically handles HTTP redirections,
            and will follow up to 5 redirections. This can be changed by setting
            the &#39;maxredirects&#39; configuration parameter.
         
            According to the HTTP/1.1 RFC, HTTP 301 and 302 responses should be
            treated by the client by resending the same request to the
            specified location - using the same request method. However, most
            clients to not implement this and always use a GET request when
            redirecting. By default, Zend_Http_Client does the same - when
            redirecting on a 301 or 302 response, all GET and POST parameters
            are reset, and a GET request is sent to the new location. This
            behavior can be changed by setting the &#39;strictredirects&#39; configuration
            parameter to boolean TRUE:
             Forcing RFC 2616 Strict Redirections on 301 and 302 Responses &lt;?php
// Strict Redirections
$client-&gt;setConfig(array(&#39;strictredirects&#39; =&gt; true));

// Non-strict Redirections
$client-&gt;setConfig(array(&#39;strictredirects&#39; =&gt; false));
                 
         
            You can always get the number of redirections done after sending a
            request using the getRedirectionsCount() method.
         Adding Cookies and Using Cookie Persistence 
            Zend_Http_Client provides an easy interface for adding cookies
            to your request, so that no direct header modification is
            required. This is done using the setCookie() method. This method
            can be used in several ways:
             Setting Cookies Using setCookie() &lt;?php
// Easy and simple: by providing a cookie name and cookie value
$client-&gt;setCookie(&#39;flavor&#39;, &#39;chocolate chips&#39;);

// By directly providing a raw cookie string (name=value)
// Note that the value must be already URL encoded
$client-&gt;setCookie(&#39;flavor=chocolate%20chips&#39;);

// By providing a Zend_Http_Cookie object
$cookie = Zend_Http_Cookie::fromString(&#39;flavor=chocolate%20chips&#39;);
$client-&gt;setCookie($cookie);
                 
            For more information about Zend_Http_Cookie objects, see
             .
         
            Zend_Http_Client also provides the means for cookie stickiness -
            that is having the client internally store all sent and received
            cookies, and resend them automatically on subsequent requests. This
            is useful, for example when you need to log in to a remote site
            first and receive and authentication or session ID cookie before
            sending further requests.
             Enabling Cookie Stickiness &lt;?php
// To turn cookie stickiness on, set a Cookie Jar
$client-&gt;setCookieJar();

// First request: log in and start a session
$client-&gt;setUri(&#39;http://example.com/login.php&#39;);
$client-&gt;setParameterPost(&#39;user&#39;, &#39;h4x0r&#39;);
$client-&gt;setParameterPost(&#39;password&#39;, &#39;1337&#39;);
$client-&gt;request(&#39;POST&#39;);

// The Cookie Jar automatically stores the cookies set
// in the response, like a session ID cookie.

// Now we can send our next request - the stored cookies
// will be automatically sent.
$client-&gt;setUri(&#39;http://example.com/read_member_news.php&#39;);
$client-&gt;request(&#39;GET&#39;);
                 
            For more information about the Zend_Http_CookieJar class, see
             .
         Setting Custom Request Headers 
            Setting custom headers can be done by using the setHeaders() method.
            This method is quite diverse and can be used in several ways, as
            the following example shows:
             Setting A Single Custom Request Header &lt;?php
// Setting a single header, overwriting any previous value
$client-&gt;setHeaders(&#39;Host&#39;, &#39;www.example.com&#39;);

// Another way of doing the exact same thing
$client-&gt;setHeaders(&#39;Host: www.example.com&#39;);

// Setting several values for the same header (useful mostly for Cookie headers):
$client-&gt;setHeaders(&#39;Cookie&#39;, array(
    &#39;PHPSESSID=1234567890abcdef1234567890abcdef&#39;,
    &#39;language=he&#39;
));
                 
         
            setHeader() can also be easily used to set multiple headers in one
            call, by providing an array of headers as a single parameter:
             Setting Multiple Custom Request Headers &lt;?php
// Setting multiple headers, overwriting any previous value
$client-&gt;setHeaders(array(
    &#39;Host&#39; =&gt; &#39;www.example.com&#39;,
    &#39;Accept-encoding&#39; =&gt; &#39;gzip,deflate&#39;,
    &#39;X-Powered-By&#39; =&gt; &#39;Zend Framework&#39;));

// The array can also contain full array strings:
$client-&gt;setHeaders(array(
    &#39;Host: www.example.com&#39;,
    &#39;Accept-encoding: gzip,deflate&#39;,
    &#39;X-Powered-By: Zend Framework&#39;));
                 
         File Uploads 
            You can upload files through HTTP using the setFileUpload method.
            This method takes a file name as the first parameter, a form name
            as the second parameter, and data as a third optional parameter.
            If the third data parameter is null, the first file name parameter
            is considered to be a real file on disk, and Zend_Http_Client will
            try to read this file and upload it. If the data parameter is not
            null, the first file name parameter will be sent as the file name,
            but no actual file needs to exist on the disk.
            The second form name parameter is always required, and is equivalent
            to the &quot;name&quot; attribute of an &gt;input&lt; tag, if the file was to
            be uploaded through an HTML form.
            A fourth optional parameter provides the file&#39;s content-type. If
            not specified, and Zend_Http_Client reads the file from the disk,
            the mime_content_type function will be used to guess the file&#39;s
            content type, if it is available. In any case, the default MIME
            type will be application/octet-stream.
             Using setFileUpload to Upload Files &lt;?php
// Uploading arbitrary data as a file
$text = &#39;this is some plain text&#39;;
$client-&gt;setFileUpload(&#39;some_text.txt&#39;, &#39;upload&#39;, $text, &#39;text/plain&#39;);

// Uploading an existing file
$client-&gt;setFileUpload(&#39;/tmp/Backup.tar.gz&#39;, &#39;bufile&#39;);

// Send the files
$client-&gt;submit(&#39;POST&#39;);
                 
            In the first example, the $text variable is uploaded and will be
            available as $_FILES[&#39;upload&#39;] on the server side. In the second
            example, the existing file /tmp/Backup.tar.gz is uploaded to the
            server and will be available as $_FILES[&#39;bufile&#39;]. The content type
            will be guesses automatically if possible - and if not, the content
            type will be set to &#39;application/octet-stream&#39;.
         Uploading files 
                When uploading files, the HTTP request content-type is
                automatically set to multipart/form-data. Keep in mind that
                you must send a POST or PUT request in order to upload files.
                Most servers will ignore the requests body on other request
                methods.
             Sending Raw POST Data 
            You can use a Zend_Http_Client to send raw POST data using the
            setRawData() method. This method takes two parameters: the first
            is the data to send in the request body. The second optional
            parameter is the content-type of the data. While this parameter is
            optional, you should usually set it before sending the request -
            either using setRawData(), or with another method: setEncType().
             Sending Raw POST Data &lt;?php
$xml = &#39;&lt;book&gt;&#39; .
       &#39;  &lt;title&gt;Islands in the Stream&lt;/title&gt;&#39; .
       &#39;  &lt;author&gt;Ernest Hemingway&lt;/author&gt;&#39; .
       &#39;  &lt;year&gt;1970&lt;/year&gt;&#39; .
       &#39;&lt;/book&gt;&#39;;

$client-&gt;setRawData($xml, &#39;text/xml&#39;)-&gt;request(&#39;POST&#39;);

// Another way to do the same thing:
$client-&gt;setRawData($xml)-&gt;setEncType(&#39;text/xml&#39;)-&gt;request(&#39;POST&#39;);
                 
            The data should be available on the server side through PHP&#39;s
            $HTTP_RAW_POST_DATA variable or through the php://input stream.
         Using raw POST data 
                Setting raw POST data for a request will override any POST
                parameters or file uploads. You should not try to use both on
                the same request. Keep in mind that most servers will ignore
                the request body unless you send a POST request.
             HTTP Authentication 
            Currently, Zend_Http_Client only supports basic HTTP authentication.
            This feature is utilized using the setAuth() method. The method
            takes 3 parameters: The user name, the password and an optional
            authentication type parameter. As mentioned, currently only basic
            authentication is supported (digest authentication support is
            planned).
             Setting HTTP Authentication User and Password &lt;?php
// Using basic authentication
$client-&gt;setAuth(&#39;shahar&#39;, &#39;myPassword!&#39;, Zend_Http_Client::AUTH_BASIC);

// Since basic auth is default, you can just do this:
$client-&gt;setAuth(&#39;shahar&#39;, &#39;myPassword!&#39;);
                 
         Sending Multiple Requests With the Same Client 
            Zend_Http_Client was also designed specifically to handle several
            consecutive requests with the same object. This is useful in cases
            where a script requires data to be fetched from several places, or
            when accessing a specific HTTP resource requires logging in and
            obtaining a session cookie, for example.
         
            When performing several requests to the same host, it is highly
            recommended to enable the &#39;keepalive&#39; configuration flag. This way,
            if the server supports keep-alive connections, the connection to the
            server will only be closed once all requests are done and the Client
            object is destroyed. This prevents the overhead of opening and
            closing TCP connections to the server.
         
            When you perform several requests with the same client, but want
            to make sure all the request-specific parameters are cleared, you
            should use the resetParameters() method. This ensures that GET and
            POST parameters, request body and request-specific headers are
            reset and are not reused in the next request.
         Reseting parameters 
                Note that non-request specific headers are not reset when the
                resetParameters method is used. As a matter of fact, only the
                &#39;Content-length&#39; and &#39;Content-type&#39; headers are reset. This
                allows you to set-and-forget headers like &#39;Accept-language&#39; and
                &#39;Accept-encoding&#39;
             
            Another feature designed specifically for consecutive requests is
            the Cookie Jar object. Cookie Jars allow you to automatically save
            cookies set by the server in the first request, and send them on
            consecutive requests transparently. This allows, for example, going
            through an authentication request before sending the actual data
            fetching request.
         
            If your application requires one authentication request per user,
            and consecutive requests might be performed in more than one script
            in your application, it might be a good idea to store the Cookie Jar
            object in the user&#39;s session. This way, you will only need to
            authenticate the user once every session.
         Performing consecutive requests with one client &lt;?php
// First, instantiate the client
$client = new Zend_Http_Client(&#39;http://www.example.com/fetchdata.php&#39;, array(
    &#39;keepalive&#39; =&gt; true
));

// Do we have the cookies stored in our session?
if (isset($_SESSION[&#39;cookiejar&#39;]) &amp;&amp;
    $_SESSION[&#39;cookiejar&#39;] instanceof Zend_Http_CookieJar)) {

    $client-&gt;setCookieJar($_SESSION[&#39;cookiejar&#39;]);
} else {
    // If we don&#39;t, authenticate and store cookies
    $client-&gt;setCookieJar();
    $client-&gt;setUri(&#39;http://www.example.com/login.php&#39;);
    $client-&gt;setParameterPost(array(
        &#39;user&#39; =&gt; &#39;shahar&#39;,
        &#39;pass&#39; =&gt; &#39;somesecret&#39;
    ));
    $client-&gt;request(Zend_Http_Client::POST);

    // Now, clear parameters and set the URI to the original one
    // (note that the cookies that were set by the server are now
    // stored in the jar)
    $client-&gt;resetParameters();
    $client-&gt;setUri(&#39;http://www.example.com/fetchdata.php&#39;);
}

$response = $client-&gt;request(Zend_Http_Client::GET);

// Store cookies in session, for next page
$_SESSION[&#39;cookiejar&#39;] = $client-&gt;getCookieJar();
             Zend_Http_Client - Introduction Introduction 
            Zend_Http_Client provides an easy interface for preforming Hyper-Text
            Transfer Protocol (HTTP) requests. Zend_Http_Client supports most simple
            features expected from an HTTP client, as well as some more complex
            features such as HTTP authentication and file uploads. Successful
            requests (and most unsuccessful ones too) return a Zend_Http_Response
            object, which provides access to the response&#39;s headers and body (see
             ).
         
            The class constructor optionally accepts a URL as it&#39;s first parameter
            (can be either a string or a Zend_Uri_Http object), and an optional
            array of configuration parameters. Both can be left out,
            and set later using the setUri() and setConfig() methods.
             Instantiating a Zend_Http_Client object &lt;?php
require_once &#39;Zend/Http/Client.php&#39;;

$client = new Zend_Http_Client(&#39;http://example.org&#39;, array(
    &#39;maxredirects&#39; =&gt; 0,
    &#39;timeout&#39;      =&gt; 30));

// This is actually exactly the same:
$client = new Zend_Http_Client();
$client-&gt;setUri(&#39;http://example.org&#39;);
$client-&gt;setConfig(array(
    &#39;maxredirects&#39; =&gt; 0,
    &#39;timeout&#39;      =&gt; 30));
                 
         Configuration Parameters 
            The constructor and setConfig() method accept an associative array
            of configuration parameters. Setting these parameters is optional,
            as they all have default values.
             Zend_Http_Client configuration parameters Parameter Description Expected Values Default Value maxredirects Maximum number of redirections to follow (0 = none) integer 5 strict When set to false, some validation functions will be skipped. Usually this should not be changed boolean true strictredirects Whether to strictly follow the RFC when redirecting (see  ) boolean false useragent User agent identifier string (sent in request headers) string &#39;Zend_Http_Client&#39; timeout Connection timeout (seconds) integer 10 httpversion HTTP protocol version (usually &#39;1.1&#39; or &#39;1.0&#39;) string &#39;1.1&#39; adapter Connection adapter class to use (see  ) mixed &#39;Zend_Http_Client_Adapter_Socket&#39; keepalive Whether to enable keep-alive connections with the server. Useful and might improve performance if several
                            consecutive requests to the same server are performned. boolean false 
         Performing Basic HTTP Requests 
            Performing simple HTTP requests is very easily done using the
            request() method, and rarely needs more than three lines of code:
             Performing a Simple GET Request &lt;?php
require_once &#39;Zend/Http/Client.php&#39;;

$client = new Zend_Http_Client(&#39;http://example.org&#39;);
$response = $client-&gt;request();
                 
            The request() method takes one optional parameter - the request method.
            This can be either GET, POST, PUT, HEAD, DELETE, TRACE, OPTIONS or
            CONNECT as defined by the HTTP protocol
             
                See RFC 2616 -  .
               .
            For convenience, these are all defined as class constants:
            Zend_Http_Request::GET, Zend_Http_Request::POST and so on.
         
            If no method is specified, the method set by the last setMethod()
            call is used. If setMethod() was never called, the default request
            method is GET (see the above example).
             Using Request Methods Other Than GET &lt;?php
// Preforming a POST request
$response = $client-&gt;request(&#39;POST&#39;);

// Yet another way of preforming a POST request
$client-&gt;setMethod(Zend_Http_Client::POST);
$response = $client-&gt;request();
                 
         Adding GET and POST parameters  
            Adding GET parameters to an HTTP request is quite simple, and can
            be done either by specifying them as part of the URL, or by using
            the setParameterGet() method.
            This method takes the GET parameter&#39;s name as it&#39;s first parameter,
            and the GET parameter&#39;s value as it&#39;s second parameter.
            For convenience, the setParameterGet() method can also accept a
            single associative array of name =&gt; value GET variables - which may
            be more comfortable when several GET parameters need to be set.
             Setting GET Parameters &lt;?php
// Setting a get parameter using the setParameterGet method
$client-&gt;setParameterGet(&#39;knight&#39;, &#39;lancelot&#39;);

// This is equivalent to setting such URL:
$client-&gt;setUri(&#39;http://example.com/index.php?knight=lancelot&#39;);

// Adding several parameters with one call
$client-&gt;setParameterGet(array(
    &#39;first_name&#39;  =&gt; &#39;Bender&#39;,
    &#39;middle_name&#39; =&gt; &#39;Bending&#39;
    &#39;made_in&#39;     =&gt; &#39;Mexico&#39;,
));
                 
         
            While GET parameters can be sent with every request method, POST
            parameters are only sent in the body of POST requests. Adding POST
            parameters to a request is very similar to adding GET parameters,
            and can be done with the setParameterPost() method, which is
            similar to the setParameterGet() method in structure.
             Setting POST Parameters &lt;?php
// Setting a POST parameter
$client-&gt;setParameterPost(&#39;language&#39;, &#39;fr&#39;);

// Setting several POST parameters, one of them with several values
$client-&gt;setParameterPost(array(
    &#39;language&#39;  =&gt; &#39;es&#39;,
    &#39;country&#39;   =&gt; &#39;ar&#39;,
    &#39;selection&#39; =&gt; array(45, 32, 80)
));
                 
            Note that when sending POST requests, you can set both GET and
            POST parameters. On the other hand, while setting POST parameters
            for a non-POST request will not trigger and error, it is useless.
            Unless the request is a POST request, POST parameters are simply
            ignored.
         Accessing Last Request and Response 
            Zend_Http_Client provides methods of accessing the last request
            sent and last response received by the client object.
             Zend_Http_Client-&gt;getLastRequest()  takes no parameters
            and returns the last HTTP request sent by the client as a string.
            Similarly,  Zend_Http_Client-&gt;getLastResponse()  returns
            the last HTTP response received by the client as a
             Zend_Http_Response  object.
         Zend_Http_Cookie and Zend_Http_CookieJar Introduction 
            Zend_Http_Cookie, as expected, is a class that represents an HTTP
            cookie. It provides methods for parsing HTTP response strings,
            collecting cookies, and easily accessing their properties. It also
            allows checking if a cookie matches against a specific scenario, IE
            a request URL, expiration time, secure connection, etc.
         
            Zend_Http_CookieJar is an object usually used by Zend_Http_Client to
            hold a set of Zend_Http_Cookie objects. The idea is that if a
            Zend_Http_CookieJar object is attached to a Zend_Http_Client object,
            all cookies going from and into the client through HTTP requests and
            responses will be stored by the CookieJar object. Then, when the client
            will send another request, it will first ask the CookieJar object for
            all cookies matching the request. These will be added to the request
            headers automatically. This is highly useful in cases where you need to
            maintain a user session over consecutive HTTP requests, automatically
            sending the session ID cookies when required. Additionally, the
            Zend_Http_CookieJar object can be serialized and stored in $_SESSION
            when needed.
         Instantiating Zend_Http_Cookie Objects 
            Instantiating a Cookie object can be done in two ways:
             
                    Through the constructor, using the following syntax:
                     new Zend_Http_Cookie(string $name, string $value, string $domain, [int $expires, [string $path, [boolean $secure]]]); 
                     $name : The name of the cookie (eg. &#39;PHPSESSID&#39;) (required)
                             $value : The value of the cookie  (required)
                             $domain : The cookie&#39;s domain (eg. &#39;.example.com&#39;) (required)
                             $expires : Cookie expiration time, as UNIX time stamp (optional, defaults to null).
                            If not set, cookie will be treated as a &#39;session cookie&#39; with no expiration time.
                             $path : Cookie path, eg. &#39;/foo/bar/&#39; (optional, defaults to &#39;/&#39;)
                             $secure : Boolean, Whether the cookie is to be sent over secure (HTTPS)
                            connections only (optional, defaults to boolean FALSE)
                             
                    By calling the fromString() static method, with a cookie string as represented in the
                    &#39;Set-Cookie&#39; HTTP response header or &#39;Cookie&#39; HTTP request header. In this case, the
                    cookie value must already be encoded. When the cookie string does not contain a &#39;domain&#39;
                    part, you must provide a reference URI according to which the cookie&#39;s domain and path
                    will be set.
                     
             Instantiating a Zend_Http_Cookie object &lt;?php
// First, using the constructor. This cookie will expire in 2 hours
$cookie = new Zend_Http_Cookie(&#39;foo&#39;, &#39;bar&#39;, &#39;.example.com&#39;, time() + 7200, &#39;/path&#39;);

// You can also take the HTTP response Set-Cookie header and use it.
// This cookie is similar to the previous one, only it will not expire, and
// will only be sent over secure connections
$cookie = Zend_Http_Cookie::fromString(&#39;foo=bar; domain=.example.com; path=/path; secure&#39;);

// If the cookie&#39;s domain is not set, you have to manually specify it
$cookie = Zend_Http_Cookie::fromString(&#39;foo=bar; secure;&#39;, &#39;http://www.example.com/path&#39;);
                 
             
                When instantiating a cookie object using the Zend_Http_Cookie::fromString() method, the
                cookie value is expected to be URL encoded, as cookie strings should be. However, when
                using the constructor, the cookie value string is expected to be the real, decoded value.
                 
         
            A cookie object can be transferred back into a string, using the __toString() magic method.
            This method will produce a HTTP request &quot;Cookie&quot; header string, showing the cookie&#39;s name
            and value, and terminated by a semicolon (&#39;;&#39;).
            The value will be URL encoded, as expected in a Cookie header:
             Stringifying a Zend_Http_Cookie object &lt;?php
// Create a new cookie
$cookie = new Zend_Http_Cookie(&#39;foo&#39;, &#39;two words&#39;, &#39;.example.com&#39;, time() + 7200, &#39;/path&#39;);

// Will print out &#39;foo=two+words;&#39; :
echo $cookie-&gt;__toString();

// This is actually the same:
echo (string) $cookie;

// In PHP 5.2 and higher, this also works:
echo $cookie;
                 
         Zend_Http_Cookie getter methods 
            Once a Zend_Http_Cookie object is instantiated, it provides several getter methods to get
            the different properties of the HTTP cookie:
             string getName() : Get the name of the cookie
                     string getValue() : Get the real, decoded value of the cookie
                     string getDomain() : Get the cookie&#39;s domain
                     string getPath() : Get the cookie&#39;s path, which defaults to &#39;/&#39;
                     int getExpiryTime() : Get the cookie&#39;s expiration time, as UNIX time stamp. If
                    the cookie has no expiration time set, will return NULL.
                     
         
            Additionally, several boolean tester methods are provided:
             boolean isSecure() : Check whether the cookie is set to be sent over secure
                    connections only. Generally speaking, if true the cookie should only be sent over HTTPS.
                     boolean isExpired(int $time = null) : Check whether the cookie is expired or not.
                    If the cookie has no expiration time, will always return true. If $time is provided, it will
                    override the current time stamp as the time to check the cookie against.
                     boolean isSessionCookie() : Check whether the cookie is a &quot;session cookie&quot; - that
                    is a cookie with no expiration time, which is meant to expire when the session ends.
                     
         Using getter methods with Zend_Http_Cookie &lt;?php
// First, create the cookie
$cookie = Zend_Http_Cookie::fromString(&#39;foo=two+words; domain=.example.com; path=/somedir; secure; expires=Wednesday, 28-Feb-05 20:41:22 UTC&#39;);

echo $cookie-&gt;getName();   // Will echo &#39;foo&#39;
echo $cookie-&gt;getValue();  // will echo &#39;two words&#39;
echo $cookie-&gt;getDomain(); // Will echo &#39;.example.com&#39;
echo $cookie-&gt;getPath();   // Will echo &#39;/&#39;

echo date(&#39;Y-m-d&#39;, $cookie-&gt;getExpiryTime());
// Will echo &#39;2005-02-28&#39;

echo ($cookie-&gt;isExpired() ? &#39;Yes&#39; : &#39;No&#39;);
// Will echo &#39;Yes&#39;

echo ($cookie-&gt;isExpired(strtotime(&#39;2005-01-01&#39;) ? &#39;Yes&#39; : &#39;No&#39;);
// Will echo &#39;No&#39;

echo ($cookie-&gt;isSessionCookie() ? &#39;Yes&#39; : &#39;No&#39;);
// Will echo &#39;No&#39;
                 Zend_Http_Cookie: Matching against a scenario 
            The only real logic contained in a Zend_Http_Cookie object, is in the match() method.
            This method is used to test a cookie against a given HTTP request scenario, in order
            to tell whether the cookie should be sent in this request or not. The method has
            the following syntax and parameters:
             boolean Zend_Http_Cookie-&gt;match(mixed $uri, [boolean $matchSessionCookies, [int $now]]); 
             mixed $uri : A Zend_Uri_Http object with a domain name and path to be checked.
                    Optionally, a string representing a valid HTTP URL can be passed instead. The cookie will
                    match if the URL&#39;s scheme (HTTP or HTTPS), domain and path all match.
                     boolean $matchSessionCookies : Whether session cookies should be matched or not.
                    Defaults to true. If set to false, cookies with no expiration time will never match.
                     int $now : Time (represented as UNIX time stamp) to check a cookie against
                    for expiration. If not specified, will default to the current time.
                     
             Matching cookies &lt;?php
// Create the cookie object - first, a secure session cookie
$cookie = Zend_Http_Cookie::fromString(&#39;foo=two+words; domain=.example.com; path=/somedir; secure;&#39;);

$cookie-&gt;match(&#39;https://www.example.com/somedir/foo.php&#39;);
// Will return true

$cookie-&gt;match(&#39;http://www.example.com/somedir/foo.php&#39;);
// Will return false, because the connection is not secure

$cookie-&gt;match(&#39;https://otherexample.com/somedir/foo.php&#39;);
// Will return false, because the domain is wrong

$cookie-&gt;match(&#39;https://example.com/foo.php&#39;);
// Will return false, because the path is wrong

$cookie-&gt;match(&#39;https://www.example.com/somedir/foo.php&#39;, false);
// Will return false, because session cookies are not matched

$cookie-&gt;match(&#39;https://sub.domain.example.com/somedir/otherdir/foo.php&#39;);
// Will return true

// Create another cookie object - now, not secure, with expiration time in two hours
$cookie = Zend_Http_Cookie::fromString(&#39;foo=two+words; domain=www.example.com; expires=&#39; . date(DATE_COOKIE, time() + 7200));

$cookie-&gt;match(&#39;http://www.example.com/&#39;);
// Will return true

$cookie-&gt;match(&#39;https://www.example.com/&#39;);
// Will return true - non secure cookies can go over secure connections as well!

$cookie-&gt;match(&#39;http://subdomain.example.com/&#39;);
// Will return false, because the domain is wrong

$cookie-&gt;match(&#39;http://www.example.com/&#39;, true, time() + (3 * 3600));
// Will return false, because we added a time offset of +3 hours to current time
                 
         The Zend_Http_CookieJar Class: Instantiation 
            In most cases, there is no need to directly instantiate a
            Zend_Http_CookieJar object. If you want to attach a new cookie jar
            to your Zend_Http_Client object, just call the
            Zend_Http_Client-&gt;setCookieJar() method, and a new, empty cookie jar
            will be attached to your client. You could later get this cookie jar
            using Zend_Http_Client-&gt;getCookieJar().
         
            If you still wish to manually instantiate a CookieJar object, you
            can do so by calling &quot;new Zend_Http_CookieJar()&quot; directly - the
            constructor method does not take any parameters. Another way to
            instantiate a CookieJar object is to use the static Zend_Http_CookieJar::fromResponse()
            method. This method takes two parameters: a Zend_Http_Response object,
            and a reference URI, as either a string or a Zend_Uri_Http object.
            This method will return a new Zend_Http_CookieJar object, already
            containing the cookies set by the passed HTTP response. The reference
            URI will be used to set the cookie&#39;s domain and path, if they are
            not defined in the Set-Cookie headers.
         Adding Cookies to a Zend_Http_CookieJar object 
            Usually, the Zend_Http_Client object you attached your CookieJar object
            to will automatically add cookies set by HTTP responses to your jar. If
            you wish to manually add cookies to your jar, this can be done by using
            two methods:
             Zend_Http_CookieJar-&gt;addCookie($cookie[, $ref_uri]) : Add a
                    single cookie to the jar. $cookie can be either a Zend_Http_Cookie
                    object or a string, which will be converted automatically into a
                    Cookie object. If a string is provided, you should also provide
                    $ref_uri - which is a reference URI either as a string or
                    Zend_Uri_Http object, to use as the cookie&#39;s default domain and path.
                     Zend_Http_CookieJar-&gt;addCookiesFromResponse($response, $ref_uri) :
                    Add all cookies set in a single HTTP response to the jar. $response is
                    expected to be a Zend_Http_Response object with Set-Cookie headers. $ref_uri
                    is the request URI, either as a string or a Zend_Uri_Http object, according
                    to which the cookies&#39; default domain and path will be set.
                     
         Retrieving Cookies From a Zend_Http_CookieJar object 
            Just like with adding cookies, there is usually no need to manually
            fetch cookies from a CookieJar object. Your Zend_Http_Client object
            will automatically fetch the cookies required for an HTTP request
            for you. However, you can still use 3 provided methods to fetch
            cookies from the jar object:  getCookie() ,
             getAllCookies() , and  getMatchingCookies() .
         
            It is important to note that each one of these methods takes a
            special parameter, which sets the return type of the method. This
            parameter can have 3 values:
             Zend_Http_CookieJar::COOKIE_OBJECT : Return
                    a Zend_Http_Cookie object. If the method returns more than
                    one cookie, an array of objects will be returned.
                     Zend_Http_CookieJar::COOKIE_STRING_ARRAY : Return
                    cookies as strings, in a &quot;foo=bar&quot; format, suitable for sending
                    in a HTTP request &quot;Cookie&quot; header. If more than one cookie is
                    returned, an array of strings is returned.
                     Zend_Http_CookieJar::COOKIE_STRING_CONCAT : Similar to
                    COOKIE_STRING_ARRAY, but if more than one cookie is returned, this
                    method will concatenate all cookies into a single, long string
                    separated by semicolons (;), and return it. This is especially useful
                    if you want to directly send all matching cookies in a single HTTP
                    request &quot;Cookie&quot; header.
                     
         
            The structure of the different cookie-fetching methods is described below:
             Zend_Http_CookieJar-&gt;getCookie($uri, $cookie_name[, $ret_as]) :
                    Get a single cookie from the jar, according to it&#39;s URI (domain and path)
                    and name. $uri is either a string or a Zend_Uri_Http object representing the
                    URI. $cookie_name is a string identifying the cookie name. $ret_as
                    specifies the return type as described above. $ret_type is optional, and
                    defaults to COOKIE_OBJECT.
                     Zend_Http_CookieJar-&gt;getAllCookies($ret_as) : Get all
                    cookies from the jar. $ret_as specifies the return type as described
                    above. If not specified, $ret_type defaults to COOKIE_OBJECT.
                     Zend_Http_CookieJar-&gt;getMatchingCookies($uri[, $matchSessionCookies[, $ret_as[, $now]]]) :
                    Get all cookies from the jar that match a specified scenario, that is a URI and expiration time.
                     $uri  is either a Zend_Uri_Http object or a string specifying the
                            connection type (secure or non-secure), domain and path to match against.
                             $matchSessionCookies  is a boolean telling whether to match session
                            cookies or not. Session cookies are cookies that have no specified expiration
                            time. Defaults to true.
                             $ret_as  specifies the return type as described above. If not
                            specified, defaults to COOKIE_OBJECT.
                             $now  is an integer representing the UNIX time stamp to consider
                            as &quot;now&quot; - that is any cookies who are set to expire before this time will
                            not be matched. If not specified, defaults to the current time.
                             
                    You can read more about cookie matching here:
                     .
                     
         Zend_Http_Response Introduction 
            Zend_Http_Response provides easy access to an HTTP responses
            message, as well as a set of static methods for parsing HTTP
            response messages. Usually, Zend_Http_Response is used as an object
            returned by a Zend_Http_Client request.
         
            In most cases, a Zend_Http_Response object will be instantiated
            using the factory() method, which reads a string containing an HTTP
            response message, and returns a new Zend_Http_Response object:
             Instantiating a Zend_Http_Response object using the factory method &lt;?php
$str = &#39;&#39;;
$sock = fsockopen(&#39;www.example.com&#39;, 80);
$req =     &quot;GET / HTTP/1.1\r\n&quot; .
        &quot;Host: www.example.com\r\n&quot; .
        &quot;Connectoin: close\r\n&quot; .
        &quot;\r\n&quot;;

fwrite($sock, $req);
while ($buff = fread($sock, 1024))
    $str .= $sock;

$response = Zend_Http_Response::factory($str);
                 
         
            You can also use the contractor method to create a new response
            object, by specifying all the parameters of the response:
         
                public function __construct($code, $headers, $body = null, $version = &#39;1.1&#39;, $message = null)
             $code : The HTTP response code (eg. 200, 404, etc.)
                 $headers : An associative array of HTTP response headers (eg. &#39;Host&#39; =&gt; &#39;example.com&#39;)
                 $body : The response body as a string
                 $version : The HTTP response version (usually 1.0 or 1.1)
                 $message : The HTTP response message (eg &#39;OK&#39;, &#39;Internal Server Error&#39;).
                    If not specified, the message will be set according to the response code
                 Boolean Tester Methods 
            Once a Zend_Http_Response object is instantiated, it provides several
            methods that can be used to test the type of the response. These all
            return Boolean true or false:
             Boolean isSuccessful() : Whether the request was successful or not. Returns
                        TRUE for HTTP 1xx and 2xx response codes
                     Boolean isError() : Whether the response code implies an error or not. Returns
                        TRUE for HTTP 4xx (client errors) and 5xx (server errors) response codes
                     Boolean isRedirect() : Whether the response is a redirection response or not. Returns
                        TRUE for HTTP 3xx response codes
                     
             Using the isError() method to validate a response &lt;?php
if ($response-&gt;isError()) {
  echo &quot;Error transmitting data.\n&quot;
  echo &quot;Server reply was: &quot; . $response-&gt;getStatus() . &quot; &quot; . $response-&gt;getMessage() . &quot;\n&quot;;
}
// .. process the response here...
                 
         Accessor Methods 
            The main goal of the response object is to provide easy access to
            various response parameters.
             int getStatus() : Get the HTTP response status code (eg. 200, 504, etc.)
                     string getMessage() : Get the HTTP response status message (eg. &quot;Not Found&quot;,
                        &quot;Authorization Required&quot;)
                     string getBody() : Get the fully decoded HTTP response body
                     string getRawBody() : Get the raw, possibly encoded HTTP response body. If
                        the body was decoded using GZIP encoding for example, it will not be decoded.
                     array getHeaders() : Get the HTTP response headers as an associative array
                        (eg. &#39;Content-type&#39; =&gt; &#39;text/html&#39;)
                     string|array getHeader($header) : Get a specific HTTP response header, specified
                        by $header
                     string getHeadersAsString($status_line = true, $br = &quot;\n&quot;) : Get the entire
                        set of headers as a string. If $status_line is true (default), the first status
                        line (eg. &quot;HTTP/1.1 200 OK&quot;) will also be returned. Lines are broken with the
                        $br parameter (Can be, for example, &quot;&lt;br /&gt;&quot;)
                     string asString($br = &quot;\n&quot;) : Get the entire response message as a string.
                        Lines are broken with the $br parameter (Can be, for example, &quot;&lt;br /&gt;&quot;)
                     
             Using Zend_Http_Response Accessor Methods &lt;?php
if ($response-&gt;getStatus() == 200) {
  echo &quot;The request returned the following information:&lt;br /&gt;&quot;;
  echo $response-&gt;getBody();
} else {
  echo &quot;An error occurred while fetching data:&lt;br /&gt;&quot;;
  echo $response-&gt;getStatus() . &quot;: &quot; . $response-&gt;getMessage();
}
                 
             Always check return value 
                    Since a response can contain several instances of the same header,
                    the getHeader() method and getHeaders() method may return either a
                    single string, or an array of strings for each header. You should
                    always check whether the returned value is a string or array.
                 
             Accessing Response Headers &lt;?php
$ctype = $response-&gt;getHeader(&#39;Content-type&#39;);
if (is_array($ctype)) $ctype = $ctype[0];

$body = $response-&gt;getBody();
if ($ctype == &#39;text/html&#39; || $ctype == &#39;text/xml&#39;) {
  $body = htmlentities($body);
}

echo $body;
                 
         Static HTTP Response Parsers 
            The Zend_Http_Response class also includes several internally-used
            methods for processing and parsing HTTP response messages. These
            methods are all exposed as static methods, which means they can be
            used externally, even if you do not need to instantiate a response
            object, and just want to extract a specific part of the response.
             int Zend_Http_Response::extractCode($response_str) : Extract
                        and return the HTTP response code (eg. 200 or 404) from $response_str
                     string Zend_Http_Response::extractMessage($response_str) : Extract
                        and return the HTTP response message (eg. &quot;OK&quot; or &quot;File Not Found&quot;) from $response_str
                     string Zend_Http_Response::extractVersion($response_str) : : Extract
                        and return the HTTP version (eg. 1.1 or 1.0) from $response_str
                     array Zend_Http_Response::extractHeaders($response_str) : Extract
                        and return the HTTP response headers from $response_str as an array
                     string Zend_Http_Response::extractBody($response_str) : Extract
                        and return the HTTP response body from $response_str
                     string Zend_Http_Response::responseCodeAsText($code = null, $http11 = true) :
                        Get the standard HTTP response message for a response code $code. For example,
                        will return &quot;Internal Server Error&quot; if $code is 500. If $http11 is true (default),
                        will return HTTP/1.1 standard messages - otherwise HTTP/1.0 messages will be returned.
                        If $code is not specified, this method will return all known HTTP response codes as an
                        associative (code =&gt; message) array.
                     
         
            Apart from parser methods, the class also includes a set of decoders for common HTTP
            response transfer encodings:
             string Zend_Http_Response::decodeChunkedBody($body) : Decode
                        a complete &quot;Content-Transfer-Encoding: Chunked&quot; body
                     string Zend_Http_Response::decodeGzip($body) : Decode
                        a &quot;Content-Encoding: gzip&quot; body
                     string Zend_Http_Response::decodeDeflate($body) : Decode
                        a &quot;Content-Encoding: deflate&quot; body
                     
         Introduction 
        The  Zend_InfoCard  component implements relying-party
        support for Information Cards.  Infomation Cards are used for identity
        management on the internet and authentication of users to web sites
        (called relying parties). 
     
        Detailed information about information cards and their importance to the
        internet identity metasystem can be found on the  IdentityBlog 
     Basic Theory of Usage 
            Usage of  Zend_InfoCard  can be done one of two ways:
            either as part of the larger  Zend_Auth  component via
            the  Zend_InfoCard  authentication adapter or as a
            stand-alone component. In both cases an information card can be
            requested from a user by using the following HTML block in your HTML
            login form:
         
&lt;form action=&quot;http://example.com/server&quot; method=&quot;POST&quot;&gt;
  &lt;input type=&#39;image&#39; src=&#39;/images/ic.png&#39; align=&#39;center&#39; 
        width=&#39;120px&#39; style=&#39;cursor:pointer&#39; /&gt;
  &lt;object type=&quot;application/x-informationCard&quot; 
          name=&quot;xmlToken&quot;&gt;
   &lt;param name=&quot;tokenType&quot; 
         value=&quot;urn:oasis:names:tc:SAML:1.0:assertion&quot; /&gt;
   &lt;param name=&quot;requiredClaims&quot; 
         value=&quot;http://.../claims/privatepersonalidentifier 
         http://.../claims/givenname 
         http://.../claims/surname&quot; /&gt;
 &lt;/object&gt;
&lt;/form&gt;
     
            In the example above, the  requiredClaims 
             &lt;param&gt;  tag is used to identify pieces of
            information known as claims (i.e. person&#39;s first name, last name)
            which the web site (a.k.a &quot;relying party&quot;) needs in order a user to
            authenticate using an information card. For your reference, the full
            URI (for instance the  givenname  claim) is as follows:
             http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname 
         
            When the above HTML is activated by a user (clicks on it), the
            browser will bring up a card selection program which not only shows
            them which information cards meet the requirements of the site, but
            also allows them to select which information card to use if multiple
            meet the criteria. This information card is transmitted as an XML
            document to the specified  POST  URL and is ready to be
            processed by the  Zend_InfoCard  component.
         
            Note, Information cards can only be  HTTP POST ed to
            SSL-encrypted URLs. Please consult your web server&#39;s documentation
            on how to set up SSL encryption.
         Using as part of Zend_Auth 
            In order to use the component as part of the  Zend_Auth 
            authentication system, you must use the provided
             Zend_Auth_Adapter_InfoCard  to do so (not available in
            the standalone  Zend_InfoCard  distribution). An example
            of its usage is shown below:
         &lt;?php
require_once &#39;Zend/InfoCard/Auth/Adapter.php&#39;;
require_once &#39;Zend/Auth.php&#39;;

if (isset($_POST[&#39;xmlToken&#39;])) {

    $adapter = new Zend_Auth_Adapter_InfoCard($_POST[&#39;xmlToken&#39;]);
    
    $adapter-&gt;addCertificatePair(&#39;/usr/local/Zend/apache2/conf/server.key&#39;,
                                 &#39;/usr/local/Zend/apache2/conf/server.crt&#39;);
    
    
    $auth = Zend_Auth::getInstance();
    
    $result = $auth-&gt;authenticate($adapter);
    
    switch ($result-&gt;getCode()) {
        case Zend_Auth_Result::SUCCESS:
            $claims = $result-&gt;getIdentity();
            print &quot;Given Name: {$claims-&gt;givenname}&lt;br /&gt;&quot;;
            print &quot;Surname: {$claims-&gt;surname}&lt;br /&gt;&quot;;
            print &quot;Email Address: {$claims-&gt;emailaddress}&lt;br /&gt;&quot;;
            print &quot;PPI: {$claims-&gt;getCardID()}&lt;br /&gt;&quot;;
            break;
        case Zend_Auth_Result::FAILURE_CREDENTIAL_INVALID:
            print &quot;The Credential you provided did not pass validation&quot;;
            break;
        default:
        case Zend_Auth_Result::FAILURE:
            print &quot;There was an error processing your credentials.&quot;;
            break;
    }
    
    if (count($result-&gt;getMessages()) &gt; 0) {
        print &quot;&lt;pre&gt;&quot;;
        var_dump($result-&gt;getMessages());
        print &quot;&lt;/pre&gt;&quot;;
    }
    
    
}

?&gt;
&lt;hr /&gt;
&lt;div id=&quot;login&quot; style=&quot;font-family: arial; font-size: 2em;&quot;&gt;
&lt;p&gt;Simple Login Demo&lt;/p&gt;
 &lt;form method=&quot;post&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Login&quot; /&gt;
   &lt;object type=&quot;application/x-informationCard&quot; name=&quot;xmlToken&quot;&gt;
    &lt;param name=&quot;tokenType&quot; 
          value=&quot;urn:oasis:names:tc:SAML:1.0:assertion&quot; /&gt;
    &lt;param name=&quot;requiredClaims&quot; 
          value=&quot;http://.../claims/givenname 
                 http://.../claims/surname 
                 http://.../claims/emailaddress 
                 http://.../claims/privatepersonalidentifier&quot; /&gt;
  &lt;/object&gt;
 &lt;/form&gt;
&lt;/div&gt;
 
            In the example above, we first create an instance of the
             Zend_Auth_Adapter_InfoCard  and pass the XML data posted
            by the card selector into it. Once an instance has been created you
            must then provide at least one SSL certificate public/private key
            pair used by the web server which received the  HTTP
                POST .  These files are used to validate the destination
            of the information posted to the server and are a requirement when
            using Information Cards. 
         
            Once the adapter has been configured you can then use the standard
             Zend_Auth  facilities to validate the provided
            information card token and authenticate the user by examining the
            identity provided by the  getIdentity()  method.
         Using the Zend_InfoCard component standalone 
            It is also possible to use the Zend_InfoCard component as a
            standalone component by interacting with the
             Zend_InfoCard  class directly. Using the Zend_InfoCard
            class is very similar to its use with the  Zend_Auth 
            component. An example of its use is shown below:
         &lt;?php
require_once &#39;Zend/InfoCard.php&#39;;

if (isset($_POST[&#39;xmlToken&#39;])) {
    $infocard = new Zend_InfoCard();
    $infocard-&gt;addCertificatePair(&#39;/usr/local/Zend/apache2/conf/server.key&#39;,
                                   &#39;/usr/local/Zend/apache2/conf/server.crt&#39;);

    $claims = $infocard-&gt;process($_POST[&#39;xmlToken&#39;]);
    
    if($claims-&gt;isValid()) {
        print &quot;Given Name: {$claims-&gt;givenname}&lt;br /&gt;&quot;;
        print &quot;Surname: {$claims-&gt;surname}&lt;br /&gt;&quot;;
        print &quot;Email Address: {$claims-&gt;emailaddress}&lt;br /&gt;&quot;;
        print &quot;PPI: {$claims-&gt;getCardID()}&lt;br /&gt;&quot;;
    } else {
        print &quot;Error Validating identity: {$claims-&gt;getErrorMsg()}&quot;;
    }
}

?&gt;
&lt;hr /&gt;
&lt;div id=&quot;login&quot; style=&quot;font-family: arial; font-size: 2em;&quot;&gt;
 &lt;p&gt;Simple Login Demo&lt;/p&gt;
 &lt;form method=&quot;post&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Login&quot; /&gt;
   &lt;object type=&quot;application/x-informationCard&quot; name=&quot;xmlToken&quot;&gt;
    &lt;param name=&quot;tokenType&quot; 
          value=&quot;urn:oasis:names:tc:SAML:1.0:assertion&quot; /&gt;
    &lt;param name=&quot;requiredClaims&quot; 
          value=&quot;http://.../claims/givenname 
                 http://.../claims/surname 
                 http://.../claims/emailaddress 
                 http://.../claims/privatepersonalidentifier&quot; /&gt;
   &lt;/object&gt;
 &lt;/form&gt;
&lt;/div&gt;
 
            In the example above we use the  Zend_InfoCard  component
            indepdently to validate the token provided by the user. As was the
            case with the  Zend_Auth_Adapter_InfoCard , we create an
            instance of  Zend_InfoCard  and then set one or more SSL
            certificate public/private key pairs used by the web server. Once
            configured we can use the  process()  method to process
            the information card and return the results
         Working with a Claims object 
            Regardless of if the  Zend_InfoCard  component is used as
            a standalone component or as part of  Zend_Auth  via the
             Zend_Auth_Adapter_InfoCard , in both cases the ultimate
            result of the processing of an information card is a
             Zend_InfoCard_Claims  object. This object contains the
            assertions (a.k.a. claims) made by the submitting user based on the
            data requested by your web site when the user authenticated. As
            shown in the examples above, the validitiy of the information card
            can be ascertained by calling the
             Zend_InfoCard_Claims::isVaild()  method. Claims
            themselves can either be retrieved by simply accessing the
            identifier desired (i.e.  givenname ) as a property of
            the object or through the  getClaim()  method. 
         
            In most cases you will never need to use the  getClaim() 
            method. However, if your  requiredClaims  mandate that
            you request claims from multiple different sources/namespaces then
            you will need to extract them explictally using this method (simply
            pass it the full URI of the claim to retrieve its value from within
            the information card). Generally speaking however, the
             Zend_InfoCard  component will set the default URI for
            claims to be the one used the most frequently within the information
            card itself and the simplified property-access method can be used.
         
            As part of the validation process, it is up to the developer to
            examine the issuing source of the claims contained within the
            information card and decide if that source is a trusted source of
            information. To do so, the  getIssuer()  method is
            provided within the  Zend_InfoCard_Claims  object which
            returns the URI of the issuer of the information card claims.
         Attaching Information Cards to existing accounts 
            It is possible to add support for information cards to an existing
            authentication system by storing the private personal identifier
            (PPI) to a previously traditionally-authenticated account and
            including at least the
             http://schemas.xmlsoap.org/ws/2005/05/identity/claims/privatepersonalidentifier 
            claim as part of the  requiredClaims  of the request. If
            this claim is requested then the  Zend_InfoCard_Claims 
            object will provide a unique identifier for the specific card that
            was submitted by calling the  getCardID()  method.
         
            An example of how to attach an information card to an existing
            traditional-authentication account is shown below:
         &lt;?php
// ... 
public function submitinfocardAction() 
{
    if (!isset($_REQUEST[&#39;xmlToken&#39;])) {
        throw new ZBlog_Exception(&quot;Expected an encrypted token but was not provided&quot;);
    }
    
    $infoCard = new Zend_InfoCard();
    $infoCard-&gt;addCertificatePair(SSL_CERTIFICATE_PRIVATE, SSL_CERTIFICATE_PUB);
    
    try {
        $claims = $infoCard-&gt;process($request[&#39;xmlToken&#39;]);
    } catch(Zend_InfoCard_Exception $e) {
        // TODO Error processing your request
        throw $e;
    }
    
    if ($claims-&gt;isValid()) {
        $db = ZBlog_Data::getAdapter();

        $ppi = $db-&gt;quote($claims-&gt;getCardID());
        $fullname = $db-&gt;quote(&quot;{$claims-&gt;givenname} {$claims-&gt;surname}&quot;);
        
        $query = &quot;UPDATE blogusers 
                     SET ppi = $ppi, 
                         real_name = $fullname 
                   WHERE username=&#39;administrator&#39;&quot;;
        
        try {
            $db-&gt;query($query);
        } catch(Exception $e) {
            // TODO Failed to store in DB
        }
        
        $this-&gt;view-&gt;render();
        return;
    } else {
        throw new ZBlog_Exception(&quot;Infomation card failed security checks&quot;);
    }
}
?&gt; Creating Zend_InfoCard adapters 
            The  Zend_InfoCard  component was designed to allow for
            growth in the information card standard through the use of a modular
            architecture. At this time many of these hooks are unused and can be
            ignored, however there is one aspect which should be implemented in
            any serious information card implementation: The
             Zend_InfoCard_Adapter .
         
            The  Zend_InfoCard  adapter is used as a callback
            mechanism within the component to perform various tasks, such as
            storing and retrieving Assertion IDs for information cards when they
            are processed by the component.  While storing the assertion IDs of
            submitted information cards is not necessary, failing to do so opens
            up the possibility of the authentication scheme being compromised
            through a replay attack. 
         
            To prevent this, one must implement the
             Zend_InfoCard_Adapter_Interface  and then set an
            instance of this interface prior to calling either the
             process()  (standalone) or  authenticate() 
            method (as a  Zend_Auth  adapter. To set this interface
            the  setAdapter()  method is used. In the example below
            we set a  Zend_InfoCard  adapter and use it within our
            application:
         &lt;?php
class myAdapter implements Zend_InfoCard_Adapter_Interface 
{
    public function storeAssertion($assertionURI, $assertionID, $conditions) 
    {
        /* Store the assertion and its conditions by ID and URI */
    }
    
    public function retrieveAssertion($assertionURI, $assertionID) 
    {
        /* Retrieve the assertion by URI and ID */
    }
    
    public function removeAssertion($assertionURI, $assertionID) 
    {
        /* Delete a given assertion by URI/ID */
    }
}

$adapter  = new myAdapter();

$infoCard = new Zend_InfoCard();
$infoCard-&gt;addCertificatePair(SSL_PRIVATE, SSL_PUB);
$infoCard-&gt;setAdapter($adapter);

$claims = $infoCard-&gt;process($_POST[&#39;xmlToken&#39;]);
?&gt; Basic Usage 
        Usage of  Zend_Json  involves using the two public static
        methods available:  Zend_Json::encode()  and
         Zend_Json::decode() .
     &lt;?php
// Retrieve a value:
$phpNative = Zend_Json::decode($encodedValue);

// Encode it to return to the client:
$json = Zend_Json::encode($phpNative);
     Introduction Zend_Json  provides convenience methods for serializing
        native PHP to JSON and decoding JSON to native PHP. For more information
        on JSON,  visit the JSON project
        site .
     
        JSON, JavaScript Object Notation, can be used for data
        interchange between JavaScript and other languages. Since JSON can be
        directly evaluated by JavaScript, it is a more efficient and lightweight
        format than XML for exchanging data with JavaScript clients.
     
        In addition,  Zend_Json  provides a useful way to convert any
        arbitrary XML formatted string into a JSON formatted string. This built-in
        feature will enable PHP developers to transform the enterprise data
        encoded in XML format into JSON format before sending it to browser-based
        Ajax client applications. It provides an easy way to do dynamic data 
        conversion on the server-side code thereby avoiding unnecessary XML
        parsing in the browser-side applications. It offers a nice utility
        function that results in easier application-specific data processing techniques. 
     JSON Objects 
        When encoding PHP objects as JSON, all public properties of that object
        will be encoded in a JSON object.
     
        JSON does not allow object references, so care should be taken not to
        encode objects with recursive references. If you have issues with
        recursion,  Zend_Json::encode()  and
         Zend_Json_Encoder::encode()  allow an optional second
        parameter to check for recursion; if an object is serialized twice, an
        exception will be thrown.
     
        Decoding JSON objects poses an additional difficulty, however, since
        Javascript objects correspond most closesly to PHP&#39;s associative array.
        Some suggest that a class identifier should be passed, and an object
        instance of that class should be created and populated with the
        key/value pairs of the JSON object; others feel this could pose a
        substantial security risk.
     
        By default,  Zend_Json  will decode JSON objects as
        associative arrays. However, if you desire an object returned, you can
        specify this:
     &lt;?php
// Decode JSON objects as PHP objects
$phpNative = Zend_Json::decode($encodedValue, Zend_Json::TYPE_OBJECT);
     
        Any objects thus decoded are returned as  StdClass  objects
        with properties corresponding to the key/value pairs in the JSON
        notation.
     
        The recommendation of the Zend Framework is that the individual
        developer should decide how to decode JSON objects. If an object of a
        specified type should be created, it can be created in the developer
        code and populated with the values decoded using  Zend_Json .
     XML to JSON conversion Zend_Json  provides a convenience method for transforming
        XML formatted data into JSON format. This feature was inspired from an
         
        IBM developerWorks article .
     Zend_Json  includes a static function called  Zend_Json::fromXml() .
        This function will generate JSON from a given XML input. This function takes any aribitrary
        XML string as an input parameter. It also takes an optional boolean input parameter to instruct the
        conversion logic to ignore or not ignore the XML attributes during the conversion process. If this
        optional input parameter is not given, then the default behavior is to ignore the XML attributes.
        This function call is made as shown below:
     
        // fromXml function simply takes a String containing XML contents as input.
        $jsonContents = Zend_Json::fromXml($xmlStringContents, true);?&gt;
     Zend_Json::fromXml()  function does the conversion of the XML formatted string input
        parameter and returns the equivalent JSON formatted string output. In case of any XML input format
        error or conversion logic error, this function will throw an exception. The conversion logic also
        uses recursive techniques to traverse the XML tree. It supports recursion upto 25 levels deep.
        Beyond that depth, it will throw a  Zend_Json_Exception . There are several XML files with varying
        degree of complexity provided in the tests directory of the Zend Framework. They can be used to
        test the functionality of the xml2json feature.
     
        The following is a simple example that shows both the XML input string passed to
        and the JSON output string returned as a result from the
         Zend_Json::fromXml()  function. This example used the optional function parameter as
        not to ignore the XML attributes during the conversion. Hence, you can notice that the
        resulting JSON string includes a representation of the XML attributes present in the XML input string.
     
        XML input string passed to  Zend_Json::fromXml()  function:
     
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;books&gt;
    &lt;book id=&quot;1&quot;&gt;
        &lt;title&gt;Code Generation in Action&lt;/title&gt;
        &lt;author&gt;&lt;first&gt;Jack&lt;/first&gt;&lt;last&gt;Herrington&lt;/last&gt;&lt;/author&gt;
        &lt;publisher&gt;Manning&lt;/publisher&gt;
    &lt;/book&gt;

    &lt;book id=&quot;2&quot;&gt;
        &lt;title&gt;PHP Hacks&lt;/title&gt;
        &lt;author&gt;&lt;first&gt;Jack&lt;/first&gt;&lt;last&gt;Herrington&lt;/last&gt;&lt;/author&gt;
        &lt;publisher&gt;O&#39;Reilly&lt;/publisher&gt;
    &lt;/book&gt;

    &lt;book id=&quot;3&quot;&gt;
        &lt;title&gt;Podcasting Hacks&lt;/title&gt;
        &lt;author&gt;&lt;first&gt;Jack&lt;/first&gt;&lt;last&gt;Herrington&lt;/last&gt;&lt;/author&gt;
        &lt;publisher&gt;O&#39;Reilly&lt;/publisher&gt;
    &lt;/book&gt;
&lt;/books&gt; ?&gt;
     
        JSON output string returned from  Zend_Json::fromXml()  function:
     
{
   &quot;books&quot; : {
      &quot;book&quot; : [ {
         &quot;@attributes&quot; : {
            &quot;id&quot; : &quot;1&quot;
         },
         &quot;title&quot; : &quot;Code Generation in Action&quot;,
         &quot;author&quot; : {
            &quot;first&quot; : &quot;Jack&quot;, &quot;last&quot; : &quot;Herrington&quot;
         },
         &quot;publisher&quot; : &quot;Manning&quot;
      }, {
         &quot;@attributes&quot; : {
            &quot;id&quot; : &quot;2&quot;
         },
         &quot;title&quot; : &quot;PHP Hacks&quot;, &quot;author&quot; : {
            &quot;first&quot; : &quot;Jack&quot;, &quot;last&quot; : &quot;Herrington&quot;
         },
         &quot;publisher&quot; : &quot;O&#39;Reilly&quot;
      }, {
         &quot;@attributes&quot; : {
            &quot;id&quot; : &quot;3&quot;
         },
         &quot;title&quot; : &quot;Podcasting Hacks&quot;, &quot;author&quot; : {
            &quot;first&quot; : &quot;Jack&quot;, &quot;last&quot; : &quot;Herrington&quot;
         },
         &quot;publisher&quot; : &quot;O&#39;Reilly&quot;
      }
   ]}
}  ?&gt;
     
        More details about this xml2json feature can be found in the original proposal itself.
        Take a look at the
         Zend_xml2json proposal .
     Zend_Layout Advanced Usage Zend_Layout  has a number of use cases for the advanced
        developer who wishes to adapt it for different view implementations,
        file system layouts, and more.
     
        The major points of extension are:
     Custom view objects. Zend_Layout  allows you to utilize any class that
                implements  Zend_View_Interface . 
         Custom front controller plugins. Zend_Layout  ships with a standard front controller
                plugin that automates rendering of layouts prior to returning
                the response. You can substitute your own plugin.
         Custom action helpers. Zend_Layout  ships with a standard action helper
                that should be suitable for most needs as it is a dumb proxy
                to the layout object itself.
         Custom layout script path resolution .
                 Zend_Layout  allows you to use your own  inflector  for layout
                script path resolution, or simply to modify the attached
                inflector to specify your own inflection rules.
         Custom View Objects Zend_Layout  allows you to use any class implementing
             Zend_View_Interface  or extending
             Zend_View_Abstract  for rendering your layout script.
            Simply pass in your custom view object as a parameter to the
            constructor/ startMvc() , or set it using the
             setView()  accessor:
         &lt;?php
$view = new My_Custom_View();
$layout-&gt;setView($view);
?&gt; Not all Zend_View implementations are equal 
                While  Zend_Layout  allows you to use any class
                implementing  Zend_View_Interface , you may run into
                issues if they can not utilize the various
                 Zend_View  helpers, particularly the layout and
                 placeholder 
                helpers. This is because  Zend_Layout  makes
                variables set in the object available via itself and
                 placeholders . 
             
                If you need to use a custom  Zend_View 
                implementation that does not support these helpers, you will
                need to find a way to get the layout variables to the view. This
                can be done by either extending the  Zend_Layout 
                object and altering the  render()  method to pass
                variables to the view, or creating your own plugin class that
                passes them prior to rendering the layout.
             
                Alternately, if your view implementation supports any sort of
                plugin capability, you can access the variables via the
                &#39;Zend_Layout&#39; placeholder, using the  placeholder
                    helper :
             &lt;?php
$placeholders = new Zend_View_Helper_Placeholder();
$layoutVars   = $placeholders-&gt;placeholder(&#39;Zend_Layout&#39;)-&gt;getArrayCopy();
?&gt; Custom Front Controller Plugins 
            When used with the MVC components,  Zend_Layout 
            registers a front controller plugin that renders the layout as the
            last action prior to exiting the dispatch loop. In most cases, the
            default plugin will be suitable, but should you desire to write
            your own, you can specify the name of the plugin class to load by
            passing the  pluginClass  option to the
             startMvc()  method.
         
            Any plugin class you write for this purpose will need to extend
             Zend_Controller_Plugin_Abstract , and should accept a
            layout object instance as an argument to the constructor. Otherwise,
            the details of your implementation are up to you.
         
            The default plugin class used is
             Zend_Layout_Controller_Plugin_Layout .
         Custom Action Helpers 
            When used with the MVC components,  Zend_Layout 
            registers an action controller helper with the helper broker. The
            default helper,
             Zend_Layout_Controller_Action_Helper_Layout , acts as a
            dumb proxy to the layout object instance itself, and should be
            suitable for most use cases.
         
            Should you feel the need to write custom functionality, simply write
            an action helper class extending
             Zend_Controller_Action_Helper_Abstract  and pass the
            class name as the  helperClass  option to the
             startMvc()  method.  Details of the implementation are
            up to you.
         Custom Layout Script Path Resolution: Using the Inflector Zend_Layout  uses  Zend_Filter_Inflector  to
            establish a filter chain for translating a layout name to a layout
            script path. By default, it uses the rules &#39;CamelCaseToDash&#39;
            followed by &#39;StringToLower&#39;, and the suffix &#39;phtml&#39; to transform the
            name to a path. As some examples:
         
                    &#39;foo&#39; will be transformed to &#39;foo.phtml&#39;.
             
                    &#39;FooBarBaz&#39; will be transformed to &#39;foo-bar-baz.phtml&#39;.
             
            You have three options for modifying inflection: modify the
            inflection target and/or view suffix via  Zend_Layout 
            accessors, modify the inflector rules and target of the inflector
            associated with the  Zend_Layout  instance, or create
            your own inflector instance and pass it to
             Zend_Layout::setInflector() .
         Using Zend_Layout accessors to modify the inflector 
                The default  Zend_Layout  inflector uses static
                references for the target and view script suffix, and 
                has accessors for setting these values.
             &lt;?php
// Set the inflector target:
$layout-&gt;setInflectorTarget(&#39;layouts/:script.:suffix&#39;);

// Set the layout view script suffix:
$layout-&gt;setViewSuffix(&#39;php&#39;);
?&gt; Direct modification of Zend_Layout inflector 
                Inflectors have a target and one or more rules. The default
                target used with  Zend_Layout  is &#39;:script.:suffix&#39;;
                &#39;:script&#39; is passed the registered layout name, while &#39;:suffix&#39;
                is a static rule of the inflector.
             
                Let&#39;s say you want the layout script to end in the suffix
                &#39;html&#39;, and that you want to separate MixedCase and camelCased words with
                underscores instead of dashes, and not lowercase the name.
                Additionally, you want it to look in a &#39;layouts&#39; subdirectory
                for the script.
             &lt;?php
$layout-&gt;getInflector()-&gt;setTarget(&#39;layouts/:script.:suffix&#39;)
                       -&gt;setStaticRule(&#39;suffix&#39;, &#39;html&#39;)
                       -&gt;setFilterRule(array(&#39;CamelCaseToUnderscore&#39;));
?&gt; Custom inflectors 
                In most cases, modifying the existing inflector will be enough.
                However, you may have an inflector you wish to use in several
                places, with different objects of different types.
                 Zend_Layout  supports this.
             &lt;?php
$inflector = new Zend_Filter_Inflector(&#39;layouts/:script.:suffix&#39;);
$inflector-&gt;addRules(array(
    &#39;:script&#39; =&gt; array(&#39;CamelCaseToUnderscore&#39;),
    &#39;suffix&#39;  =&gt; &#39;html&#39;
));
$layout-&gt;setInflector($inflector);
?&gt; Inflection can be disabled 
                Inflection can be disabled and enabled using accessors on the
                 Zend_Layout  object. This can be useful if you want
                to specify an absolute path for a layout view script, or know
                that the mechanism you will be using for specifying the layout
                script does not need inflection. Simply use the
                 enableInflection()  and
                 disableInflection()  methods.
             Introduction Zend_Layout  implements a classic Two Step View pattern,
        allowing developers to wrap application content within another view,
        usually representing the site template. Such templates are often termed
         layouts  by other projects, and Zend Framework has
        adopted this term for consistency.
     
        The main goals of  Zend_Layout  are as follows:
     
                Automate selection and rendering of layouts when used with the
                Zend Framework MVC components.
         
                Provide separate scope for layout related variables and content.
         
                Allow configuration, including layout name, layout script
                resolution (inflection), and layout script path.
         
                Allow disabling layouts, changing layout scripts, and other
                states; allow these actions from within action controllers and
                view scripts.
         
                Follow same script resolution rules (inflection) as the  ViewRenderer ,
                but allow them to also use different rules.
         
                Allow usage without Zend Framework MVC components.
         Zend_Layout Configuration Options Zend_Layout  has a variety of configuration options. These
        may be set by calling the appropriate accessors, passing an array or
         Zend_Config  object to the constructor or
         startMvc() , passing an array of options to
         setOptions() , or passing a  Zend_Config  object
        to  setConfig() .
     layout : the layout to use. Uses the
                current inflector to resolve the name provided to the
                appropriate layout view script. By default, this value is
                &#39;layout&#39; and resolves to &#39;layout.phtml&#39;. Accessors
                are  setLayout()  and  getLayout() .
         layoutPath : the base path to layout view
                scripts. Accessors are  setLayoutPath()  and
                 getLayoutPath() .
         contentKey : the layout variable used for
                default content (when used with the MVC). Default value is
                &#39;content&#39;. Accessors are  setContentKey()  and
                 getContentKey() .
         mvcSuccessfulActionOnly : when using the
                MVC, if an action throws an exception and this flag is true, the
                layout will not be rendered (this is to prevent double-rendering
                of the layout when the  ErrorHandler
                plugin  is in use). By default, the flat is true.
                Accessors are  setMvcSuccessfulActionOnly()  and
                 getMvcSuccessfulActionOnly() .
         view : the view object to use when
                rendering. When used with the MVC,  Zend_Layout  will
                attempt to use the view object registered with  the
                    ViewRenderer  if no view object has been passed to it
                explicitly. Accessors are  setView()  and
                 getView() .
         helperClass : the action helper class to use
                when using  Zend_Layout  with the MVC components. By
                default, this is
                 Zend_Layout_Controller_Action_Helper_Layout .
                Accessors are  setHelperClass()  and
                 getHelperClass() .
         pluginClass : the front controller plugin
                class to use when using  Zend_Layout  with the MVC
                components. By default, this is
                 Zend_Layout_Controller_Plugin_Layout .  Accessors
                are  setPluginClass()  and
                 getPluginClass() .
         inflector : the inflector to use when
                resolving layout names to layout view script paths; see  the
                     Zend_Layout  inflector documentation for more
                    details . Accessors are  setInflector() 
                and  getInflector() .
         helperClass and pluginClass must be passed to startMvc() 
            In order for the  helperClass  and
             pluginClass  settings to have effect, they must be
            passed in as options to  startMvc() ; if set later, they
            have no affect.
         Examples 
            The following examples assume the following  $options 
            array and  $config  object:
         &lt;?php
$options = array(
    &#39;layout&#39;     =&gt; &#39;foo&#39;,
    &#39;layoutPath&#39; =&gt; &#39;/path/to/layouts&#39;,
    &#39;contentKey&#39; =&gt; &#39;CONTENT&#39;,           // ignored when MVC not used
);
?&gt; &lt;?php
/**
[layout]
layout = &quot;foo&quot;
layoutPath = &quot;/path/to/layouts&quot;
contentKey = &quot;CONTENT&quot;
*/
$config = new Zend_Config_Ini(&#39;/path/to/layout.ini&#39;, &#39;layout&#39;);
?&gt; Passing options to the constructor or startMvc() 
                Both the constructor and the  startMvc()  static
                method can accept either an array of options or a
                 Zend_Config  object with options in order to
                configure the  Zend_Layout  instance.
             
                First, let&#39;s look at passing an array:
             &lt;?php
// Using constructor:
$layout = new Zend_Layout($options);

// Using startMvc():
$layout = Zend_Layout::startMvc($options);
?&gt; 
                And now using a config object:
             &lt;?php 
$config = new Zend_Config_Ini(&#39;/path/to/layout.ini&#39;, &#39;layout&#39;);

// Using constructor:
$layout = new Zend_Layout($config);

// Using startMvc():
$layout = Zend_Layout::startMvc($config);
?&gt; 
                Basically, this is the easiest way to customize your
                 Zend_Layout  instance.
             Using setOption() and setConfig() 
                Sometimes you need to configure the  Zend_Layout 
                object after it has already been instantiated;
                 setOptions()  and  setConfig()  give you
                a quick and easy way to do so:
             &lt;?php
// Using an array of options:
$layout-&gt;setOptions($options);

// Using a Zend_Config object:
$layout-&gt;setConfig($options);
?&gt; 
                Note, however, that certain options, such as
                 pluginClass  and  helperClass , will have
                no affect when passed using this method; they need to be passed
                to the constructor or  startMvc()  method.
             Using Accessors 
                Finally, you can also configure your  Zend_Layout 
                instance via accessors. All accessors implement a fluent
                interface, meaning their calls may be chained:
             &lt;?php
$layout-&gt;setLayout(&#39;foo&#39;)
       -&gt;setLayoutPath(&#39;/path/to/layouts&#39;)
       -&gt;setContentKey(&#39;CONTENT&#39;);
?&gt; Zend_Layout Quick Start 
        There are two primary use cases for  Zend_Layout : with the
        Zend Framework MVC, and without.
     Layout scripts 
            In both cases, however, you&#39;ll need to create a layout script.
            Layout scripts simply utilize Zend_View (or whatever view
            implementation you are using). Layout variables are registered with
            a  Zend_Layout   placeholder , 
            and may be accessed via the placeholder helper or by fetching them
            as object properties of the layout object via the layout helper.
         
            As an example:
         
&lt;!DOCTYPE html
    PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
    &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;My Site&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php 
    // fetch &#39;content&#39; key using layout helper:
    echo $this-&gt;layout()-&gt;content; 

    // fetch &#39;foo&#39; key using placeholder helper:
    echo $this-&gt;placeholder(&#39;Zend_Layout&#39;)-&gt;foo;

    // fetch layout object and retrieve various keys from it:
    $layout = $this-&gt;layout();
    echo $layout-&gt;bar;
    echo $layout-&gt;baz;
?&gt;
&lt;/body&gt;
&lt;/html&gt;
 
            Because  Zend_Layout  utilizes  Zend_View  for
            rendering, you can also use any view helpers registered, and also
            have access to any previously assigned view variables. Particularly
            useful are the various  placeholder
                helpers , as they allow you to
            retrieve content for areas such as the &lt;head&gt; section,
            navigation, etc.:
         
&lt;!DOCTYPE html
    PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
    &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;?= $this-&gt;headTitle() ?&gt;
    &lt;?= $this-&gt;headScript() ?&gt;
    &lt;?= $this-&gt;headStyle() ?&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;?= $this-&gt;render(&#39;header.phtml&#39;) ?&gt;

    &lt;div id=&quot;nav&quot;&gt;&lt;?= $this-&gt;placeholder(&#39;nav&#39;) ?&gt;&lt;/div&gt;

    &lt;div id=&quot;content&quot;&gt;&lt;?= $this-&gt;layout()-&gt;content ?&gt;&lt;/div&gt;

    &lt;?= $this-&gt;render(&#39;footer.phtml&#39;) ?&gt;
&lt;/body&gt;
&lt;/html&gt;
 Using Zend_Layout with the Zend Framework MVC Zend_Controller  offers a rich set of functionality for
            extension via its  front
            controller plugins  and  action controller
            helpers .  Zend_View  also has  helpers .  Zend_Layout 
            takes advantage of these various extension points when used with the
            MVC components.
         Zend_Layout::startMvc()  creates an instance of
             Zend_Layout  with any optional configuration you provide
            it. It then registers a front controller plugin that renders the
            layout with any application content once the dispatch loop is done,
            and registers an action helper to allow access to the layout object
            from your action controllers. Additionally, you may at any time grab
            the layout instance from within a view script using the
             layout  view helper.
         
            First, let&#39;s look at how to initialize Zend_Layout for use with the
            MVC:
         &lt;?php
// In your bootstrap:
Zend_Layout::startMvc();
?&gt; startMvc()  can take an optional array of options or
             Zend_Config  object to customize the instance; these
            options are detailed in  .
         
            In an action controller, you may then access the layout instance as
            an action helper:
         &lt;?php
class FooController extends Zend_Controller_Action
{
    public function barAction()
    {
        // disable layouts for this action:
        $this-&gt;_helper-&gt;layout-&gt;disableLayout();
    }

    public function bazAction()
    {
        // use different layout script with this action:
        $this-&gt;_helper-&gt;layout-&gt;setLayout(&#39;foobaz&#39;);
    };
}
?&gt; 
            In your view scripts, you can then access the layout object via the
             layout  view helper. This view helper is slightly
            different than others in that it takes no arguments, and returns an
            object instead of a string value. This allows you to immediately
            call methods on the layout object:
         
&lt;?php $this-&gt;layout()-&gt;setLayout(&#39;foo&#39;); // set alternate layout ?&gt;
 
            At any time, you can fetch the  Zend_Layout  instance
            registered with the MVC via the  getMvcInstance()  static
            method:
         &lt;?php
// Returns null if startMvc() has not first been called
$layout = Zend_Layout::getMvcInstance(); 
?&gt; 
            Finally,  Zend_Layout &#39;s front controller plugin has one
            important feature in addition to rendering the layout: it retrieves
            all named segments from the response object and assigns them as
            layout variables, assigning the &#39;default&#39; segment to the variable
            &#39;content&#39;. This allows you to access your application content and
            render it in your view scripts.
         
            As an example, let&#39;s say your code first hits
             FooController::indexAction() , which renders some
            content to the default response segment, and then forwards to
             NavController::menuAction() , which renders content to
            the &#39;nav&#39; response segment. Finally, you forward to
             CommentController::fetchAction()  and fetch some
            comments, but render those to the default response segment as well
            (which appends content to that segment). Your view script could then
            render each separately:
         
&lt;body&gt;
    &lt;!-- renders /nav/menu --&gt;
    &lt;div id=&quot;nav&quot;&gt;&lt;?= $this-&gt;layout()-&gt;nav ?&gt;&lt;/div&gt;

    &lt;!-- renders /foo/index + /comment/fetch --&gt;
    &lt;div id=&quot;content&quot;&gt;&lt;?= $this-&gt;layout()-&gt;content ?&gt;&lt;/div&gt;
&lt;/body&gt;
 
            This feature is particularly useful when used in conjunction with
            the ActionStack  action
            helper  and  plugin ,
            which you can use to setup a stack of actions through
            which to loop, and thus create widgetized pages.
         Using Zend_Layout as a Standalone Component 
            As a standalone component, Zend_Layout does not offer nearly as many
            features or as much convenience as when used with the MVC. However,
            it still has two chief benefits:
         
                    Scoping of layout variables.
             
                    Isolation of layout view script from other view scripts.
             
            When used as a standalone component, simply instantiate the layout
            object, use the various accessors to set state, set variables as
            object properties, and render the layout:
         &lt;?php
$layout = new Zend_Layout();

// Set a layout script path:
$layout-&gt;setLayoutPath(&#39;/path/to/layouts&#39;);

// set some variables:
$layout-&gt;content = $content;
$layout-&gt;nav     = $nav;

// choose a different layout script:
$layout-&gt;setLayout(&#39;foo&#39;);

// render final layout
echo $layout-&gt;render();
?&gt; Sample Layout 
            Sometimes a picture is worth a thousand words. The following is a
            sample layout script showing how it might all come together.
         
            The actual order of elements may vary, depending on the CSS you&#39;ve
            setup; for instance, if you&#39;re using absolute positioning, you may
            be able to have the navigation displayed later in the document, but
            still show up at the top; the same could be said for the sidebar or
            header. The actual mechanics of pulling the content remain the same,
            however.
         Introduction Minimal Functionality 
            Currently this class is designed only to satisfy the limited functionality necessary for the
             Zend_Auth_Adapter_Ldap  authentication adapter.
            Operations such as searching, creating, modifying or renaming entries in the directory are currently not
            supported and will be defined at a later time.
         Zend_Ldap  is a class for performing LDAP operations including but not limited to binding,
        searching and modifying entries in an LDAP directory.
     Theory of Operation 
            This component currently consists of two classes,  Zend_Ldap  and
             Zend_Ldap_Exception . The  Zend_Ldap  class conceptually represents a binding to a
            single LDAP server. The parameters for binding may be provided explicitly or in the form of an options
            array.
         
            Using the  Zend_Ldap  class depends on the type of LDAP server and is best summarized with some
            simple examples.
         
            If you are using OpenLDAP, a simple example looks like the following (note that the
             bindRequiresDn  option is important if you are  not  using AD):

             &lt;?php
require_once &#39;Zend/Ldap.php&#39;;

$options = array(
    &#39;host&#39; =&gt; &#39;s0.foo.net&#39;,
    &#39;username&#39; =&gt; &#39;CN=user1,DC=foo,DC=net&#39;,
    &#39;password&#39; =&gt; &#39;pass1&#39;,
    &#39;bindRequiresDn&#39; =&gt; true,
    &#39;accountDomainName&#39; =&gt; &#39;foo.net&#39;,
    &#39;baseDn&#39; =&gt; &#39;OU=Sales,DC=foo,DC=net&#39;,
);
$ldap = new Zend_Ldap($options);
$acctname = $ldap-&gt;getCanonicalAccountName(&#39;abaker&#39;, Zend_Ldap::ACCTNAME_FORM_DN);
echo &quot;$acctname\n&quot;; 

         
            If you are using Microsoft AD a simple example is:

             &lt;?php
require_once &#39;Zend/Ldap.php&#39;;

$options = array(
    &#39;host&#39; =&gt; &#39;dc1.w.net&#39;,
    &#39;useSsl&#39; =&gt; true,
    &#39;username&#39; =&gt; &#39;user1@w.net&#39;,
    &#39;password&#39; =&gt; &#39;pass1&#39;,
    &#39;accountDomainName&#39; =&gt; &#39;w.net&#39;,
    &#39;accountDomainNameShort&#39; =&gt; &#39;W&#39;,
    &#39;baseDn&#39; =&gt; &#39;CN=Users,DC=w,DC=net&#39;,
);
$ldap = new Zend_Ldap($options);
$acctname = $ldap-&gt;getCanonicalAccountName(&#39;bcarter&#39;, Zend_Ldap::ACCTNAME_FORM_DN);
echo &quot;$acctname\n&quot;; 

            Note that we use the  getCanonicalAccountName()  method to retrieve the account DN here only
            because that is what exercises the most of what little code is currently present in this class.
         Automatic Username Canonicalization When Binding 
                If  bind()  is called with a non-DN username but  bindRequiresDN  is
                 true  and no username in DN form was supplied as an option, the bind will fail. However, if
                a username in DN form is supplied in the options array,  Zend_Ldap  will first bind with
                that username, retrieve the account DN for the username supplied to  bind()  and then re-
                bind with that DN.
             
                This behavior is critical to  Zend_Auth_Adapter_Ldap , which passes the username supplied by
                the user directly to  bind() .
             
                The following example illustrates how the non-DN username &#39; abaker &#39; can be used with
                 bind() :

                 &lt;?php
require_once &#39;Zend/Ldap.php&#39;;

$options = array(
        &#39;host&#39; =&gt; &#39;s0.foo.net&#39;,
        &#39;username&#39; =&gt; &#39;CN=user1,DC=foo,DC=net&#39;,
        &#39;password&#39; =&gt; &#39;pass1&#39;,
        &#39;bindRequiresDn&#39; =&gt; true,
        &#39;accountDomainName&#39; =&gt; &#39;foo.net&#39;,
        &#39;baseDn&#39; =&gt; &#39;OU=Sales,DC=foo,DC=net&#39;,
);
$ldap = new Zend_Ldap($options);
$ldap-&gt;bind(&#39;abaker&#39;, &#39;moonbike55&#39;);
$acctname = $ldap-&gt;getCanonicalAccountName(&#39;abaker&#39;, Zend_Ldap::ACCTNAME_FORM_DN);
echo &quot;$acctname\n&quot;; 

                The  bind()  call in this example sees that the username &#39; abaker &#39; is not in DN
                form, finds  bindRequiresDn  is  true , uses
                &#39; CN=user1,DC=foo,DC=net &#39; and &#39; pass1 &#39; to bind, retrieves the DN for
                &#39; abaker &#39;, unbinds and then rebinds with the newly discovered
                &#39; CN=Alice Baker,OU=Sales,DC=foo,DC=net &#39;.
             Zend_Ldap Options 
                The  Zend_Ldap  component accepts an array of options either supplied to the constructor or
                through the  setOptions()  method. The permitted options are as follows:

                 Zend_Ldap Options Name Description host 
                            The default hostname of LDAP server if not supplied to  connect()  (also may be
                            used when trying to canonicalize usernames in  bind() ).
                         port 
                            Default port of LDAP server if not supplied to  connect() .
                         useSsl 
                            Whether or not the LDAP client should use SSL / TLS encrypted transport. A value of
                             true  is strongly favored in production environments to prevent passwords from
                            be transmitted in clear text. The default value is  false , as servers
                            frequently require that a certificate be installed separately after installation.
                         username 
                            The default credentials username. Some servers require that this be in DN form.
                         password 
                            The default credentials password (used only with username above).
                         bindRequiresDn 
                            If  true , this instructs  Zend_Ldap  to retrieve the DN for the
                            account used to bind if the username is not already in DN form. The default value is
                             false .
                         baseDn 
                            The default base DN used for searching (e.g., for accounts). This option is required for
                            most account related operations and should indicate the DN under which accounts are
                            located.
                         accountCanonicalForm 
                            A small integer indicating the form to which account names should be canonicalized. See the
                             Account Name Canonicalization  section below.
                         accountDomainName 
                            The FQDN domain for which the target LDAP server is an authority (e.g., example.com).
                         accountDomainNameShort 
                            The &#39;short&#39; domain for which the target LDAP server is an authority. This is usually used
                            to specify the NetBIOS domain name for Windows networks but may also be used by non-AD
                            servers.
                         accountFilterFormat 
                            The LDAP search filter used to search for accounts. This string is a
                             printf()  style expression that must
                            contain one &#39; %s &#39; to accomodate the username. The default value is
                            &#39; (&amp;(objectClass=user)(sAMAccountName=%s)) &#39; unless
                             bindRequiresDn  is set to  true , in which case the default is
                            &#39; (&amp;(objectClass=posixAccount)(uid=%s)) &#39;. Users of custom schemas may need
                            to change this option.
                         

             Account Name Canonicalization 
                The  accountDomainName  and  accountDomainNameShort  options are used for two
                purposes: (1) they facilitate multi-domain authentication and failover capability, and (2) they are
                also used to canonicalize usernames. Specifically, names are canonicalized to the form specified by the
                 accountCanonicalForm  option. This option may one of the following values:

                 accountCanonicalForm Name Value Example ACCTNAME_FORM_DN 1 CN=Alice Baker,CN=Users,DC=example,DC=com ACCTNAME_FORM_USERNAME 2 abaker ACCTNAME_FORM_BACKSLASH 3 EXAMPLE\abaker ACCTNAME_FORM_PRINCIPAL 4 abaker@example.com 

             
                The default canonicalization depends on what account domain name options were supplied. If
                 accountDomainNameShort  was supplied, the default  accountCanonicalForm  value
                is  ACCTNAME_FORM_BACKSLASH . Otherwise, if  accountDomainName  was supplied, the
                default is  ACCTNAME_FORM_PRINCIPAL .
             
                Account name canonicalization ensures that the string used to identify an account is consistent
                regardless of what was supplied to  bind() . For example, if the user supplies an account
                name of  abaker@example.com  or just  abaker  and the
                 accountCanonicalForm  is set to 3, the resulting canonicalized name would be
                 EXAMPLE\abaker .
             Multi-domain Authentication and Failover 
                The  Zend_Ldap  component by itself makes no attempt to authenticate with multiple servers.
                However,  Zend_Ldap  is specifically designed to handle this scenario gracefully. The
                required technique is to simply iterate over an array of arrays of server options and attempt to bind
                with each server. As described above  bind()  will automatically canonicalize each name, so
                it does not matter if the user passes  abaker@foo.net  or  W\bcarter  or
                 cdavis  - the  bind()  method will only succeed if the credentials were
                successfully used in the bind.
             
                Consider the following example that illustrates the technique required to implement multi-domain
                authentication and failover:

                 &lt;?php
$acctname = &#39;W\\user2&#39;;
$password = &#39;pass2&#39;;

$multiOptions = array(
    &#39;server1&#39; =&gt; array(
        &#39;host&#39; =&gt; &#39;s0.foo.net&#39;,
        &#39;username&#39; =&gt; &#39;CN=user1,DC=foo,DC=net&#39;,
        &#39;password&#39; =&gt; &#39;pass1&#39;,
        &#39;bindRequiresDn&#39; =&gt; true,
        &#39;accountDomainName&#39; =&gt; &#39;foo.net&#39;,
        &#39;accountDomainNameShort&#39; =&gt; &#39;FOO&#39;,
        &#39;accountCanonicalForm&#39; =&gt; 4, // ACCT_FORM_PRINCIPAL
        &#39;baseDn&#39; =&gt; &#39;OU=Sales,DC=foo,DC=net&#39;,
    ),
    &#39;server2&#39; =&gt; array(
        &#39;host&#39; =&gt; &#39;dc1.w.net&#39;,
        &#39;useSsl&#39; =&gt; true,
        &#39;username&#39; =&gt; &#39;user1@w.net&#39;,
        &#39;password&#39; =&gt; &#39;pass1&#39;,
        &#39;accountDomainName&#39; =&gt; &#39;w.net&#39;,
        &#39;accountDomainNameShort&#39; =&gt; &#39;W&#39;,
        &#39;accountCanonicalForm&#39; =&gt; 4, // ACCT_FORM_PRINCIPAL
        &#39;baseDn&#39; =&gt; &#39;CN=Users,DC=w,DC=net&#39;,
    ),
);

$ldap = new Zend_Ldap();

foreach ($multiOptions as $name =&gt; $options) {

    echo &quot;Trying to bind using server options for &#39;$name&#39;\n&quot;;

    $ldap-&gt;setOptions($options);
    try {
        $ldap-&gt;bind($acctname, $password);
        $acctname = $ldap-&gt;getCanonicalAccountName($acctname);
        echo &quot;SUCCESS: authenticated $acctname\n&quot;;
        return;
    } catch (Zend_Ldap_Exception $zle) {
        echo &#39;  &#39; . $zle-&gt;getMessage() . &quot;\n&quot;;
        if ($zle-&gt;getCode() === Zend_Ldap_Exception::LDAP_X_DOMAIN_MISMATCH) {
            continue;
        }
    }
} 

                If the bind fails for any reason, the next set of server options is tried.
             
                The  getCanonicalAccountName  call gets the canonical account name that the application
                would presumably use to associate data with such as preferences. The
                 accountCanonicalForm = 4  in all server options ensures that the canonical form is
                consistent regardless of which server was ultimately used.
             
                The special  LDAP_X_DOMAIN_MISMATCH  exception occurs when an account name with a domain
                component was supplied (e.g.,  abaker@foo.net  or  FOO\abaker  and not just
                 abaker ) but the domain component did not match either domain in the currently selected
                server options. This exception indicates that the server is not an authority for the account. In this
                case, the bind will not be performed, thereby eliminating unnecessary communication with the server.
                Note that the  continue  instruction has no effect in this example, but in practice for
                error handling and debugging purposes, you will probably want to check for
                 LDAP_X_DOMAIN_MISMATCH  as well as  LDAP_NO_SUCH_OBJECT  and
                 LDAP_INVALID_CREDENTIALS .
             
                The above code is very similar to code used within
                 Zend_Auth_Adapter_Ldap . In fact, we
                recommend that you simply use that authentication adapter for multi-domain + failover LDAP based
                authentication (or copy the code).
             Loading Plugins 
        A number of Zend Framework components are pluggable, and allow loading
        of dynamic functionality by specifying a class prefix and path to class
        files that are not necessarily on the  include_path  or do
        not necessarily follow traditional naming conventions.
         Zend_Loader_PluginLoader  provides common functionality for
        this process.
     
        The basic usage of the  PluginLoader  follows Zend Framework
        naming conventions of one class per file, using the underscore as a
        directory separator when resolving paths. It allows passing an optional
        class prefix to prepend when determining if a particular plugin class is
        loaded. Additionally, paths are searched in LIFO order. Due to the LIFO
        search and the class prefixes, this allows you to namespace your
        plugins, and thus override plugins from paths registered earlier. 
     Basic Use Case 
            First, let&#39;s assume the following directory structure and class
            files, and that the toplevel directory and library directory are on
            the include_path:
         
application/
    modules/
        foo/
            views/
                helpers/
                    FormLabel.php
                    FormSubmit.php
        bar/
            views/
                helpers/
                    FormSubmit.php
library/
    Zend/
        View/
            Helper/
                FormLabel.php
                FormSubmit.php
                FormText.php
 
            Now, let&#39;s create a plugin loader to address the various view
            helper repositories available:
         &lt;?php
$loader = new Zend_Loader_PluginLoader();
$loader-&gt;addPrefixPath(&#39;Zend_View_Helper&#39;, &#39;Zend/View/Helper/&#39;)
       -&gt;addPrefixPath(&#39;Foo_View_Helper&#39;, &#39;application/modules/foo/views/helpers&#39;)
       -&gt;addPrefixPath(&#39;Bar_View_Helper&#39;, &#39;application/modules/bar/views/helpers&#39;);
?&gt; 
            We can then load a given view helper using just the portion of the
            class name following the prefixes as defined when adding the paths:
         &lt;?php
// load &#39;FormText&#39; helper:
$formTextClass = $loader-&gt;load(&#39;FormText&#39;); // &#39;Zend_View_Helper_FormText&#39;;

// load &#39;FormLabel&#39; helper:
$formLabelClass = $loader-&gt;load(&#39;FormLabel&#39;); // &#39;Foo_View_Helper_FormLabel&#39; 

// load &#39;FormSubmit&#39; helper:
$formSubmitClass = $loader-&gt;load(&#39;FormSubmit&#39;); // &#39;Bar_View_Helper_FormSubmit&#39; 
?&gt; 
            Once the class is loaded, we can now instantiate it.
         Multiple paths may be registered for a given prefix 
                In some cases, you may use the same prefix for multiple paths.
                 Zend_Loader_PluginLoader  actually registers an
                array of paths for each given prefix; the last one registered
                will be the first one checked. This is particularly useful if
                you are utilizing incubator components.
             Paths may be defined at instantiation 
                You may optionally provide an array of prefix / path pairs (or
                prefix / paths -- plural paths are allowed) as a parameter to
                the constructor:
             &lt;?php
$loader = new Zend_Loader_PluginLoader(array(
    &#39;Zend_View_Helper&#39; =&gt; &#39;Zend/View/Helper/&#39;,
    &#39;Foo_View_Helper&#39;  =&gt; &#39;application/modules/foo/views/helpers&#39;,
    &#39;Bar_View_Helper&#39;  =&gt; &#39;application/modules/bar/views/helpers&#39;
));
?&gt; Zend_Loader_PluginLoader  also optionally allows you to
            share plugins across plugin-aware objects, without needing to
            utilize a singleton instance. It does so via a static registry.
            Indicate the registry name at instantiation as the second parameter
            to the constructor:
         &lt;?php
// Store plugins in static registry &#39;foobar&#39;:
$loader = new Zend_Loader_PluginLoader(array(), &#39;foobar&#39;);
?&gt; 
            Other components that instantiate the  PluginLoader 
            using the same registry name will then have access to already loaded
            paths and plugins.
         Manipulating Plugin Paths 
            The example in the previous section shows how to add paths to a
            plugin loader. What if you want to determine the paths already
            loaded, or remove one or more?
         getPaths($prefix = null)  returns all paths as
                    prefix / path pairs if no  $prefix  is provided,
                    or just the paths registered for a given prefix if a
                     $prefix  is present.
             clearPaths($prefix = null)  will clear all
                    registered paths by default, or only those associated with a
                    given prefix, if the  $prefix  is provided and
                    present in the stack.
             removePrefixPath($prefix, $path = null)  allows
                    you to selectively remove a specific path associated with a
                    given prefix. If no  $path  is provided, all
                    paths for that prefix are removed. If a  $path 
                    is provided and exists for that prefix, only that path will
                    be removed.
             Testing for Plugins and Retrieving Class Names 
            Sometimes you simply want to determine if a plugin class has been
            loaded before you perform an action.  isLoaded()  takes a
            plugin name, and returns the status.
         
            Another common use case for the  PluginLoader  is to
            determine fully qualified plugin class names of loaded classes;
             getClassName()  provides this functionality.  Typically,
            this would be used in conjunction with  isLoaded() :
         &lt;?php
if ($loader-&gt;isLoaded(&#39;Adapter&#39;)) {
    $class   = $loader-&gt;getClassName(&#39;Adapter&#39;);
    $adapter = call_user_func(array($class, &#39;getInstance&#39;));
}
?&gt; Loading Files and Classes Dynamically 
        The Zend_Loader class includes methods to help you load files dynamically.
     Zend_Loader vs. require_once() 
            The  Zend_Loader  methods are best used if the filename you need to
            load is variable.  For example, if it is based on a parameter from
            user input or method argument.  If you are loading a file or a
            class whose name is constant, there is no benefit to using
             Zend_Loader  over using traditional PHP functions such as
             require_once() .
         Loading Files 
            The static method  Zend_Loader::loadFile()  loads a PHP
            file.  The file loaded may contain any PHP code.
            The method is a wrapper for the PHP function
             include() .
            This method throws  Zend_Exception  on failure, for example
            if the specified file does not exist.
         Example of loadFile() method &lt;?php
Zend_Loader::loadFile($filename, $dirs=null, $once=false);
             
            The  $filename  argument specifies the filename to load,
            which must not contain any path information.
            A security check is performed on  $filename .
            The  $filename  may only contain alphanumeric characters,
            dashes (&quot;-&quot;), underscores (&quot;_&quot;), or periods (&quot;.&quot;).
            No such restriction is placed on the  $dirs  argument.
         
            The  $dirs  argument specifies directories to search for
            the file.  If  NULL , only the  include_path 
            is searched.  If a string or an array, the directory or directories
            specified will be searched, and then the  include_path .
         
            The  $once  argument is a boolean.  If  TRUE ,
             Zend_Loader::loadFile()  uses the PHP function
             include_once() 
            for loading the file, otherwise the PHP function
             include() 
            is used.
         Loading Classes 
            The static method  Zend_Loader::loadClass($class, $dirs) 
            loads a PHP file and then checks for the existance of the class.
         Example of loadClass() method &lt;?php
Zend_Loader::loadClass(&#39;Container_Tree&#39;,
    array(
        &#39;/home/production/mylib&#39;,
        &#39;/home/production/myapp&#39;
    )
);
             
            The string specifying the class is converted to a relative path
            by substituting directory separates for underscores, and appending
            &#39;.php&#39;.  In the example above, &#39;Container_Tree&#39; becomes &#39;Container/Tree.php&#39;.
         
            If  $dirs  is a string or an array,
             Zend_Loader::loadClass()  searches the directories in
            the order supplied.  The first matching file is loaded.  If the file
            does not exist in the specified  $dirs , then the
             include_path  for the PHP environment is searched.
         
            If the file is not found or the class does not exist after the load,
             Zend_Loader::loadClass()  throws a  Zend_Exception .
         Zend_Loader::loadFile()  is used for loading, so the
            class name may only contain alphanumeric characters and the hyphen
            (&#39;-&#39;), underscore (&#39;_&#39;), and period (&#39;.&#39;).
         Testing if a File is Readable 
            The static method  Zend_Loader::isReadable($pathname) 
            returns  TRUE  if a file at the specified pathname exists
            and is readable,  FALSE  otherwise.
         Example of isReadable() method &lt;?php
if (Zend_Loader::isReadable($filename)) {
    // do something with $filename
}
             
            The  $filename  argument specifies the filename to
            check.  This may contain path information.
            This method is a wrapper for the PHP function
             is_readable() .
            The PHP function does not search the  include_path ,
            while  Zend_Loader::isReadable()  does.
         Using the Autoloader 
            The  Zend_Loader  class contains a method you can register with the
            PHP SPL autoloader.   Zend_Loader::autoload()  is the
            callback method.  As a convenience,  Zend_Loader  provides the
             registerAutoload()  function register its
             autoload()  method.  If the  spl_autoload 
            extension is not present in your PHP environment, then
             registerAutoload()  method throws a  Zend_Exception .
         Example of registering the autoloader callback method &lt;?php
Zend_Loader::registerAutoload();
             
            After registering the Zend Framework autoload callback, you can
            reference classes from the Zend Framework without having to load
            them explicitly.  The  autoload()  method uses
             Zend_Loader::loadClass()  automatically when you
            reference a class.
         
            If you have extended the  Zend_Loader  class, you can give an
            optional argument to  registerAutoload() , to specify
            the class from which to register an  autoload()  method.
         Example of registering the autoload callback method from an
                extended class 
                Because of the semantics of static function references in PHP,
                you must implement code for both  loadClass() 
                and  autoload() , and the  autoload() 
                must call  self::loadClass() .  If your
                 autoload()  method delegates to its parent to
                call  self::loadClass() , then it calls the
                method of that name in the parent class, not the subclass.
             &lt;?php
class My_Loader extends Zend_Loader
{
    public static function loadClass($class, $dirs = null)
    {
        parent::loadClass($class, $dirs);
    }

    public static function autoload($class)
    {
        try {
            self::loadClass($class);
            return $class;
        } catch (Exception $e) {
            return false;
        }
    }
}

Zend_Loader::registerAutoload(&#39;My_Loader&#39;);
             
            You can remove an autoload callback.  The
             registerAutoload()  has an optional second argument,
            which is  true  by default.  If this argument is
             false , the autoload callback in unregistered from the
            SPL autoload stack instead of registered.
         Supported Languages for Locales Zend_Locale  provides information for the following languages.
         List of all supported languages Locale Language aa Afar af Afrikaans ak Akan am Amharic ar Arabic as Assamese az Azerbaijani be Belarusian bg Bulgarian bn Bengali bo Tibetan bs Bosnian byn Blin ca Catalan cch Atsam cop Coptic cs Czech cy Welsh da Danish de German dv Divehi dz Dzongkha ee Ewe el Greek en English eo Esperanto es Spanish et Estonian eu Basque fa Persian fi Finnish fil Filipino fo Faroese fr French fur Friulian ga Irish gaa Ga gez Geez gl Gallegan gu Gujarati gv Manx ha Hausa haw Hawaiian he Hebrew hi Hindi hr Croatian hu Hungarian hy Armenian ia Interlingua id Indonesian ig Igbo ii Sichuan Yi is Icelandic it Italian iu Inuktitut ja Japanese ka Georgian kaj Jju kam Kamba kcg Tyap kfo Koro kk Kazakh kl Kalaallisut km Khmer kn Kannada ko Korean kok Konkani kpe Kpelle ku Kurdish kw Cornish ky Kirghiz ln Lingala lo Lao lt Lithuanian lv Latvian mk Macedonian ml Malayalam mn Mongolian mr Marathi ms Malay mt Maltese my Burmese nb Norwegian Bokmal ne Nepali nl Dutch nn Norwegian Nynorsk nr South Ndebele nso Northern Sotho ny Nyanja; Chichewa; Chewa om Oromo or Oriya pa Punjabi pl Polish ps Pashto (Pushto) pt Portuguese ro Romanian ru Russian rw Kinyarwanda sa Sanskrit se Northern Sami sh Serbo-Croatian sid Sidamo sk Slovak sl Slovenian so Somali sq Albanian sr Serbian ss Swati ssy st Southern Sotho sv Swedish sw Swahili syr Syriac ta Tamil te Telugu tg Tajik th Thai ti Tigrinya tig Tigre tn Tswana to Tonga tr Turkish ts Tsonga tt Tatar ug Uighur uk Ukrainian und Unknown or Invalid Language ur Urdu uz Uzbek ve Venda vi Vietnamese wal Walamo wo Wolof xh Xhosa yo Yorubs zh Chinese zu Zulu 
     Supported Regions for Locales Zend_Locale  provides information for the following regions.
         List of all supported regions Locale Region AE United Arab Emirates AF Afghanistan AL Albania AM Armenia AR Argentina AS American Samoa AT Austria AU Australia AZ Azerbaijan BA Bosnia and Herzegovina BD Bangladesh BE Belgium BG Bulgaria BH Bahrain BN Brunei BO Bolivia BR Brazil BT Bhutan BW Botswana BY Belarus BZ Belize CA Canada CD Congo (Kinshasa) CG Congo (Brazzaville) CH Switzerland CL Chile CN China CO Colombia CR Costa Rica CS Serbia And Montenegro CY Cyprus CZ Czech Republic DE Germany DJ Djibouti DK Denmark DO Dominican Republic DZ Algeria EC Ecuador EE Estonia EG Egypt ER Eritrea ES Spain ET Ethiopia FI Finland FO Faroe Islands FR France GB United Kingdom GE Georgia GH Ghana GL Greenland GN Guinea GR Greece GT Guatemala GU Guam HK Hong Kong S.A.R., China HN Honduras HR Croatia HU Hungary ID Indonesia IE Ireland IL Israel IN India IQ Iraq IR Iran IS Iceland IT Italy JM Jamaica JO Jordan JP Japan KE Kenya KG Kyrgyzstan KH Cambodia KR South Korea KW Kuwait KZ Kazakhstan LA Laos LB Lebanon LI Liechtenstein LR Liberia LT Lithuania LU Luxembourg LV Latvia LY Libya MA Morocco MC Monaco ME Montenegro MH Marshall Islands MK Macedonia MM Myanmar MN Mongolia MO Macao S.A.R., China MP Northern Mariana Islands MT Malta MV Maldives MW Malawi MX Mexico MY Malaysia NA Namibia NE Niger NG Nigeria NI Nicaragua NL Netherlands NO Norway NP Nepal NZ New Zealand OM Oman PA Panama PE Peru PH Philippines PK Pakistan PL Poland PR Puerto Rico PT Portugal PY Paraguay QA Qatar RO Romania RS Serbia RU Russia RW Rwanda SA Saudi Arabia SD Sudan SE Sweden SG Singapore SI Slovenia SK Slovakia SN Senegal SO Somalia SV El Salvador SY Syria TG Togo TH Thailand TJ Tajikistan TN Tunisia TO Tonga TR Turkey TT Trinidad and Tobago TW Taiwan TZ Tanzania UA Ukraine UM United States Minor Outlying Islands US United States UY Uruguay UZ Uzbekistan VE Venezuela VI U.S. Virgin Islands VN Vietnam YE Yemen YU Yugoslavian Union ZA South Africa ZW Zimbabwe ZZ Unknown or Invalid Region 
     Working with Dates and Times Zend_Locale_Format  provides several methods for working with dates and times to help convert and
        normalize between different formats for different locales. Use  Zend_Date  for manipulating dates,
        and working with date strings that already conform to
         one of the many internationally recognized standard formats, or one of the localized date formats supported by  Zend_Date 
         
        . Using an existing, pre-defined format offers advantages, including the use of well-tested code, and the
        assurance of some degree of portability and interoperability (depending on the standard used). The examples
        below do not follow these recommendations, since using non-standard date formats would needlessly increase the
        difficulty of understanding these examples.
     Normalizing Dates and Times 
            The  getDate()  method parses strings containing dates in localized formats. The results are
            returned in a structured array, with well-defined keys for each part of the date. In addition, the array
            will contain a key &#39;date_format&#39; showing the format string used to parse the input date string. Since a
            localized date string may not contain all parts of a date/time, the key-value pairs are optional. For
            example, if only the year, month, and day is given, then all time values are supressed from the returned
            array, and vice-versa if only hour, minute, and second were given as input. If no date or time can be found
            within the given input, an exception will be thrown.
         
            If  setOption(array(&#39;fix_date&#39; =&gt; true))  is set the  getDate()  method adds a key &#39;fixed&#39;
            with a whole number value indicating if the input date string required &quot;fixing&quot; by rearranging the day,
            month, or year in the input to fit the format used.
         Key values for getDate() with option &#39;fix_date&#39; value meaning 0 nothing to fix 1 fixed false month 2 swapped day and year 3 swapped month and year 4 swapped month and day 
            For those needing to specify explicitly the format of the date string, the following format token specifiers
            are supported. If an invalid format specifier is used, such as the PHP &#39;i&#39; specifier when in ISO format
            mode, then an error will be thrown by the methods in Zend_Locale_Format that support user-defined formats.
         
            These specifiers (below) are a small subset of the full &quot;ISO&quot; set supported by Zend_Date&#39;s
             toString() . If you need to use PHP  date()  compatible format specifiers, then first
            call  setOptions(array(&#39;format_type&#39; =&gt; &#39;php&#39;)) . And if you want to convert only one special format
            string from PHP  date()  compatible format to &quot;ISO&quot; format use  convertPhpToIsoFormat() .
            Currently, the only practical difference relates to the specifier for minutes (&#39;m&#39; using the ISO default,
            and &#39;i&#39; using the PHP date format).
         Return values getDate() format character Array key Returned value Minimum Maximum d day integer 1 31 M month integer 1 12 y year integer no limit PHP integer&#39;s maximum h hour integer 0 PHP integer&#39;s maximum m minute integer 0 PHP integer&#39;s maximum s second integer 0 PHP integer&#39;s maximum Normalizing a date &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$dateString = Zend_Locale_Format::getDate(&#39;13.04.2006&#39;, array(&#39;date_format&#39; =&gt; &#39;dd.MM.yyyy&#39;));
$dateObject = Zend_Date(&#39;13.04.2006&#39;, array(&#39;date_format&#39; =&gt; &#39;dd.MM.yyyy&#39;)); // creates a Zend_Date object for this date

print_r($dateString); // outputs:

Array
(
    [format] =&gt; dd.MM.yyyy
    [day] =&gt; 13
    [month] =&gt; 4
    [year] =&gt; 2006
)

// alternatively, some types of problems with input data can be automatically corrected
$date2 = Zend_Locale_Format::getDate(&#39;04.13.2006&#39;, array(&#39;date_format&#39; =&gt; &#39;dd.MM.yyyy&#39;, &#39;fix_date&#39; =&gt; true));

print_r($date); // outputs:

Array
(
    [format] =&gt; dd.MM.yyyy
    [day] =&gt; 13
    [month] =&gt; 4
    [year] =&gt; 2006
    [fixed] =&gt; 4
)
             
            Since  getDate()  is &quot;locale-aware&quot;, specifying the  $locale  is sufficient for date
            strings adhering to that locale&#39;s format. The option &#39; fix_date &#39; uses simple tests to
            determine if the day or month is not valid, and then applies heuristics to try and correct any detected
            problems. Note the use of &#39; Zend_Locale_Format::STANDARD &#39; as the value for
            &#39; date_format &#39; to prevent the use of a class-wide default date format set using
             setOptions() . This forces getDate to use the default date format for  $locale .
         Normalizing a date by locale &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$date = Zend_Locale_Format::getDate(&#39;13.04.2006&#39;, array(&#39;date_format&#39; =&gt; Zend_Locale_Format::STANDARD, &#39;locale&#39; =&gt; $locale));

print_r ($date);
             
            A complete date and time is returned when the input contains both a date and time in the expected format.
         Normalizing a date with time &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$date = Zend_Locale_Format::getDate(&#39;13.04.2005 22:14:55&#39;, array(&#39;date_format&#39; =&gt; Zend_Locale_Format::STANDARD, &#39;locale&#39; =&gt; $locale);

print_r ($date);
             
            If a specific format is desired, specify the  $format  argument, without giving a
             $locale . Only single-letter codes (H, m, s, y, M, d), and MMMM and EEEE are supported in the
             $format .
         Normalizing a userdefined date &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$date = Zend_Locale_Format::getDate(&#39;13200504T551422&#39;, array(&#39;date_format&#39; =&gt; &#39;ddyyyyMM ssmmHH&#39;);

print_r ($date);
             
            The format can include the following signs :
         Format definition Format Letter Description d or dd 1 or 2 digit day M or MM 1 or 2 digit month y or yy 1 or 2 digit year yyyy 4 digit year h 1 or 2 digit hour m 1 or 2 digit minute s 1 or 2 digit second 
            Examples for proper formats are
         Example formats Formats Input Output dd.MM.yy 1.4.6 [&#39;day&#39;] =&gt; 1,
                                   [&#39;month&#39;] =&gt; 4,
                                   [&#39;year&#39;] =&gt; 6 dd.MM.yy 01.04.2006 [&#39;day&#39;] =&gt; 1, [&#39;month&#39;] =&gt; 4, [&#39;year&#39;] =&gt; 2006 yyyyMMdd 1.4.6 [&#39;day&#39;] =&gt; 6, [&#39;month&#39;] =&gt; 4, [&#39;year&#39;] =&gt; 1 Database date format 
                To parse a database date value (f.e. MySql or MsSql), use Zend_Date&#39;s ISO_8601 format instead of
                getDate().
             
            The option &#39; fix_date &#39; uses simple tests to determine if the day or month is not
            valid, and then applies heuristics to try and correct any detected problems.  getDate() 
            automatically detects and corrects some kinds of problems with input, such as misplacing the year:
         Automatic correction of input dates &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$date = Zend_Locale_Format::getDate(&#39;41.10.20&#39;, array(&#39;date_format&#39; =&gt; &#39;ddMMyy&#39;, &#39;fix_date&#39; =&gt; true));

// instead of 41 for the day, the 41 will be returned as year value
print_r ($date);
             Testing Dates 
            Use  checkDateFormat($inputString, array(&#39;date_format&#39; =&gt; $format, $locale))  to check if a given string
            contains all expected date parts. The  checkDateFormat()  method uses  getDate() , but without
            the option  &#39;fixdate&#39;  to avoid returning true when the input fails to conform to the date
            format. If errors are detected in the input, such as swapped values for months and days, the
            option  &#39;fixdate&#39;  method will apply heuristics to &quot;correct&quot; dates before determining their
            validity.
         Date testing &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
// using the default date format for &#39;de_AT&#39;, is this a valid date?
if (Zend_Locale_Format::checkDateFormat(&#39;13.Apr.2006&#39;, array(&#39;date_format&#39; =&gt; Zend_Locale_Format::STANDARD, $locale)) {
    print &quot;date&quot;;
} else {
    print &quot;not a date&quot;;
}
             Normalizing a Time 
            Normally, a time will be returned with a date, if the input contains both. If the proper format is not
            known, but the locale relevant to the user input is known, then  getTime()  should be used,
            because it uses the default time format for the selected locale.
         Normalize an unknown time &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
if (Zend_Locale_Format::getTime(&#39;13:44:42&#39;, array(&#39;date_format&#39; =&gt; Zend_Locale_Format::STANDARD, &#39;locale&#39; =&gt; $locale)) {
    print &quot;time&quot;;
} else {
    print &quot;not a time&quot;;
}
             Testing Times 
            Use  checkDateFormat()  to check if a given string contains a proper time.
            The usage is exact the same as with checking Dates, only  date_format 
            should contain the parts which you expect to have.
         Testing a time &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
if (Zend_Locale_Format::checkDateFormat(&#39;13:44:42&#39;, array(&#39;date_format&#39; =&gt; &#39;HH:mm:ss&#39;, &#39;locale&#39; =&gt; $locale)) {
    print &quot;time&quot;;
} else {
    print &quot;not a time&quot;;
}
             Using Zend_Locale Zend_Locale  also provides localized information about locales for each locale,
        including localized names for other locales, days of the week, month names, etc.
     Copying, Cloning, and Serializing Locale Objects 
            Use
             object cloning 
            to duplicate a locale object exactly and efficiently. Most locale-aware methods also accept string
            representations of locales, such as the result of  $locale-&gt;toString() .
         clone &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;ar&#39;);

// Save the $locale object as a serialization
$serializedLocale = $locale-&gt;serialize();
// re-create the original object
$localeObject = unserialize($serializedLocale);

// Obtain a string identification of the locale
$stringLocale = $locale-&gt;toString();

// Make a cloned copy of the $local object
$copiedLocale = clone $locale;

print &quot;copied: &quot;, $copiedLocale-&gt;toString();
print &quot;copied: &quot;, $copiedLocale; // PHP automatically calls toString() via __toString();
             Equality Zend_Locale  also provides a convenience function to compare two locales. All locale-aware
            classes should provide a similar equality check.
         Check for equal locales &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale();
$mylocale = new Zend_Locale(&#39;en_US&#39;);

// Check if locales are equal
if ($locale-&gt;equals($mylocale)) {
    print &quot;Locales are equal&quot;;
}
             Default locales 
            The method  getDefault()  returns an array of relevant locales using information from the user&#39;s
            web browser (if available), information from the environment of the host server, and ZF settings. As with
            the constructor for  Zend_Locale , the first parameter selects a preference of which information
            to consider
             ( BROWSER ,  ENVIRONMENT , or  FRAMEWORK) 
             
            first. The second parameter toggles between returning all matching locales or only the first/best match.
            Locale-aware components normally use only the first locale. A quality rating is included, when available.
         Get default locales &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale();

// Return all default locales
$found = $locale-&gt;getDefault();
print_r($found);

// Return only browser locales
$found2 = $locale-&gt;getDefault(Zend_Locale::BROWSER,TRUE);
print_r($found2);
             
            To obtain only the default locales relevent to the
             BROWSER ,  ENVIRONMENT , or  FRAMEWORK 
            , use the corresponding method:
             getEnvironment() getBrowser() getLocale() 
         Set a new locale 
            A new locale can be set with the function  setLocale() . This function takes a locale string as
            parameter. If no locale is given, a locale is
             automatically selected 
            . Since Zend_Locale objects are &quot;light&quot;, this method exists primarily to cause side-effects for code that
            have references to the existing instance object.
         setLocale &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale();

// Actual locale
print $locale-&gt;toString();

// new locale
$locale-&gt;setLocale(&#39;aa_DJ&#39;);
print $locale-&gt;toString();
             Getting the language and region 
            Use  getLanguage()  to obtain a string containing the two character language code from the string
            locale identifier. Use  getRegion()  to obtain a string containing the two character region code
            from the string locale identifier.
         getLanguage and getRegion &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale();

// if locale is &#39;de_AT&#39; then &#39;de&#39; will be returned as language
print $locale-&gt;getLanguage();

// if locale is &#39;de_AT&#39; then &#39;AT&#39; will be returned as region
print $locale-&gt;getRegion();
             Obtaining localized strings getTranslationList()  gives you access to localized informations of several types. These
            information are useful if you want to display localized data to a customer without the need
            of translating it. They are already available for your usage.
         
            The requested list of information is always returned as named array. If you want to give more than
            one value to a explicit type where you wish to receive values from, you have to give an array
            instead of multiple values.
         getTranslationList &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$list = $locale-&gt;getTranslationList(&#39;language&#39;);

print_r ($list);
// example key -&gt; value pairs...
// [de] -&gt; Deutsch
// [en] -&gt; Englisch

// use one of the returned key as value for the getTranslation() method of another language
print $locale-&gt;getTranslation(&#39;de&#39;, &#39;language&#39;, &#39;zh&#39;);
// returns the translation for the language &#39;de&#39; in chinese
             
            You can receive this informations for all languages. But not all of the informations are completly
            available for all languages. Some of these types are also available through an own function for
            simplicity. See this list for detailed informations.
         Details for getTranslationList($type = null, $locale = null, $value = null) Type Description Language Returns a localized list of all languages. The language part of the locale
                            is returned as key and the translation as value. For your convinience use the
                             getLanguageTranslationList()  method Script Returns a localized list of all scripts. The script is returned as key and the
                            translation as value. For your convinience use the
                             getScriptTranslationList()  method Territory Returns a localized list of all territories. This contains countries,
                            continents and territories. To get only territories and continents
                            use &#39;1&#39; as value. To get only countries use &#39;2&#39; as value. The country part of
                            the locale is used as key where applicable. In the other case the official ISO
                            code for this territory is used. The translated territory is returned as value.
                            For your convinience use the  getCountryTranslationList()  method
                            to receive all countries and the  getTerritoryTranslationList() 
                            method to receive all territories without countries. When you omit the value
                            you will get a list with both. Variant Returns a localized list of known variants of scripts. The variant is
                            returned as key and the translation as value Key Returns a localized list of known keys. This keys are generic values used
                            in translation. These are normally calendar, collation and currency. The key
                            is returned as array key and the translation as value Type Returns a localized list of known types of keys. These are variants of types
                            of calendar representations and types of collations. When you use &#39;collation&#39; as
                            value you will get all types of collations returned. When you use &#39;calendar&#39; as
                            value you will get all types of calendars returned. When you omit the value you
                            will get a list all both returned. The type is used as key and the translation as
                            value Layout Returns a list of rules which describes how to format special text parts Characters Returns a list of allowed characters within this locale Delimiters Returns a list of allowed quoting characters for this locale Measurement Returns a list of known measurement values. This list is depreciated Months Returns a list of all month representations within this locale. There are
                            several different represenations which are all returned as sub array. If you omit
                            the value you will get a list of all months from the &#39;gregorian&#39; calendar returned.
                            You can give any known calendar as value to get a list of months from this calendar
                            returned. Use  Zend_Date  for
                            simplicity Month Returns a localized list of all month names for this locale. If you omit the
                            value you will get the normally used gregorian full name of the months where each
                            month number is used as key and the translated month is returned as value. You
                            can get the months for different calendars and formats if you give an array as value.
                            The first array entry has to be the calendar, the second the used context and the
                            third the width to return. Use  Zend_Date 
                            for simplicity Days Returns a list of all day representations within this locale. There are
                            several different represenations which are all returned as sub array. If you omit
                            the value you will get a list of all days from the &#39;gregorian&#39; calendar returned.
                            You can give any known calendar as value to get a list of days from this calendar
                            returned. Use  Zend_Date  for
                            simplicity Day Returns a localized list of all day names for this locale. If you omit the
                            value you will get the normally used gregorian full name of the days where the
                            english day abbreviation is used as key and the translated day is returned as
                            value. You can get the days for different calendars and formats if you give an
                            array as value. The first array entry has to be the calendar, the second the used
                            context and the third the width to return. Use
                             Zend_Date  for simplicity Week Returns a list of values used for proper week calculations within a locale.
                            Use  Zend_Date  for simplicity Quarters Returns a list of all quarter representations within this locale. There are
                            several different represenations which are all returned as sub array. If you omit
                            the value you will get a list of all quarters from the &#39;gregorian&#39; calendar returned.
                            You can give any known calendar as value to get a list of quarters from this calendar
                            returned Quarter Returns a localized list of all quarter names for this locale. If you omit the
                            value you will get the normally used gregorian full name of the quarters where each
                            quarter number is used as key and the translated quarter is returned as value. You
                            can get the quarters for different calendars and formats if you give an array as
                            value. The first array entry has to be the calendar, the second the used context
                            and the third the width to return Eras Returns a list of all era representations within this locale. If you omit
                            the value you will get a list of all eras from the &#39;gregorian&#39; calendar returned.
                            You can give any known calendar as value to get a list of eras from this calendar
                            returned Era Returns a localized list of all era names for this locale. If you omit the
                            value you will get the normally used gregorian full name of the eras where each
                            era number is used as key and the translated era is returned as value. You
                            can get the eras for different calendars and formats if you give an array as
                            value. The first array entry has to be the calendar and the second the width to
                            return Date Returns a localized list of all date formats for this locale. The name of the
                            dateformat is used as key and the format itself as value.If you omit the value you
                            will get the date formats for the gregorian calendar returned. You can get the
                            date formats for different calendars if you give the wished calendar as string.
                            Use  Zend_Date  for simplicity Time Returns a localized list of all time formats for this locale. The name of the
                            timeformat is used as key and the format itself as value. If you omit the value you
                            will get the time formats for the gregorian calendar returned. You can get the
                            time formats for different calendars if you give the wished calendar as string.
                            Use  Zend_Date  for simplicity DateTime Returns a localized list of all known date-time formats for this locale. The name
                            of the date-time format is used as key and the format itself as value. If you
                            omit the value you will get the date-time formats for the gregorian calendar returned.
                            You can get the date-time formats for different calendars if you give the wished
                            calendar as string. Use  Zend_Date 
                            for simplicity Field Returns a localized list of date fields which can be used to display calendars
                            or date strings like &#39;month&#39; or &#39;year&#39; in a wished language. If you omit the value
                            you will get this list for the gregorian calendar returned. You can get the
                            list for different calendars if you give the wished calendar as string Relative Returns a localized list of relative dates which can be used to display
                            textual relative dates like &#39;yesterday&#39; or &#39;tomorrow&#39; in a wished language.
                            If you omit the value you will get this list for the gregorian calendar
                            returned. You can get the list for different calendars if you give the wished
                            calendar as string Symbols Returns a localized list of characters used for number representations NameToCurrency Returns a localized list of names for currencies. The currency is used as key
                            and the translated name as value. Use
                             Zend_Currency  for simplicity CurrencyToName Returns a list of currencies for localized names. The translated name is used
                            as key and the currency as value. Use
                             Zend_Currency  for simplicity CurrencySymbol Returns a list of known localized currency symbols for currencies. The
                            currency is used as key and the symbol as value. Use
                             Zend_Currency  for simplicity Question Returns a list of localized strings for acceptance (&#39;yes&#39;) and
                            negotation (&#39;no&#39;). Use
                             Zend_Locale&#39;s getQuestion method 
                            for simplicity CurrencyFraction Returns a list of fractions for currency values. The currency is used as key and
                            the fraction as integer value. Use
                             Zend_Currency  for simplicity CurrencyRounding Returns a list of how to round which currency. The currency is used as key and
                            the rounding as integer value. Use
                             Zend_Currency  for simplicity CurrencyToRegion Returns a list of currencies which are known to be used within a region.
                            The ISO3166 value (&#39;region&#39;) is used as array key and the ISO4217 value
                            (&#39;currency&#39;) as array value. Use
                             Zend_Currency  for simplicity RegionToCurrency Returns a list of regions where a currency is used . The ISO4217 value (&#39;currency&#39;)
                            is used as array key and the ISO3166 value (&#39;region&#39;) as array value. When a currency
                            is used in several regions these regions are seperated with a whitespace. Use
                             Zend_Currency  for simplicity RegionToTerritory Returns a list of territories with the countries or sub territories which are
                            included within that territory. The ISO territory code (&#39;territory&#39;) is used as
                            array key and the ISO3166 value (&#39;region&#39;) as array value. When a territory contains
                            several regions these regions are seperated with a whitespace TerritoryToRegion Returns a list of regions and the territories where these regions are located.
                            The ISO3166 code (&#39;region&#39;) is used as array key and the ISO territory code
                            (&#39;territory&#39;) as array value. When a region is located in several territories
                            these territories are seperated with a whitespace ScriptToLanguage Returns a list of scripts which are used within a language. The language code
                            is used as array key and the script code as array value. When a language contains
                            several scripts these scripts are seperated with a whitespace LanguageToScript Returns a list of languages which are using a script. The script code
                            is used as array key and the language code as array value. When a script is used
                            in several languages these languages are seperated with a whitespace TerritoryToLanguage Returns a list of countries which are using a language. The country code
                            is used as array key and the language code as array value. When a language is used in
                            several countries these countries are seperated with a whitespace LanguageToTerritory Returns a list of countries and the languages spoken within these countries.
                            The country code is used as array key and the language code as array value. When
                            a territory is using several languages these languages are seperated with a
                            whitespace TimezoneToWindows Returns a list of windows timezones and the related ISO timezone. The windows
                            timezone is used as array key and the ISO timezone as array value WindowsToTimezone Returns a list of ISO timezones and the related windows timezone. The ISO
                            timezone is used as array key and the windows timezone as array value TerritoryToTimezone Returns a list of regions or territories and the related ISO timezone. The
                            ISO timezone is used as array key and the territory code as array value TimezoneToTerritory Returns a list of timezones and the related region or territory code. The
                            region or territory code is used as array key and the ISO timezone as array
                            value CityToTimezone Returns a localized list of cities which can be used as translation for a
                            related timezone. Not for all timezones is a translation available, but for a
                            user is the real city written in his languages more accurate than the ISO name
                            of this timezone. The ISO timezone is used as array key and the translated
                            city as array value TimezoneToCity Returns a list of timezones for localized city names. The localized city is
                            used as array key and the ISO timezone name as array value 
            If you are in need of a single translated value, you can use the  getTranslation() 
            method. It returns always a string but it accepts some different types than the
             getTranslationList()  method. Also value is the same as before with one difference.
            You have to give the detail you want to get returned as additional value.
         
                Because you have almost always give a value as detail this parameter has to be given
                as first parameter. This differs from the  getTranslationList()  method.
             
            See the following table for detailed informations: 
         Details for getTranslation($value = null, $type = null, $locale = null) Type Description Language Returns a translation for a language. To select the wished translation
                            you must give the language code as value. For your convinience use the
                             getLanguageTranslation($value)  method Script Returns a translation for a script. To select the wished translation you
                            must give the script code as value. For your convinience use the
                             getScriptTranslation($value)  method Territory  or
                             Country Returns a translation for a territory. This can be countries, continents
                            and territories. To select the wished variant you must give the territory
                            code as value. For your convinience use the
                             getCountryTranslation($value)  method. Variant Returns a translation for a script variant. To select the wished variant
                            you must give the variant code as value Key Returns translation for a known keys. This keys are generic values used
                            in translation. These are normally calendar, collation and currency. To
                            select the wished key you must give the key code as value DateChars Returns a character table which contains all characters used when displaying
                            dates DefaultCalendar Returns the default calendar for the given locale. For most locales this
                            will be &#39;gregorian&#39;. Use
                             Zend_Date  for simplicity MonthContext Returns the default context for months which is used within the given
                            calendar. If you omit the value the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity DefaultMonth Returns the default format for months which is used within the given
                            calendar. If you omit the value the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity Month Returns a translation for a month. You have to give the number of the month
                            as integer value. It has to be between 1 and 12. If you want to receive data for
                            other calendars, contexts or formats, then you must give an array instead of an
                            integer with the expected values. The array has to look like this:  array(
                            &#39;calendar&#39;, &#39;context&#39;, &#39;format&#39;, &#39;month number&#39;) . If you give only an
                            integer then the default values are the &#39;gregorian&#39; calendar, the context
                            &#39;format&#39; and the format &#39;wide&#39;. Use
                             Zend_Date  for simplicity DayContext Returns the default context for Â´days which is used within the given
                            calendar. If you omit the value the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity DefaultDay Returns the default format for days which is used within the given
                            calendar. If you omit the value the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity Day Returns a translation for a day. You have to give the english abbreviation
                            of the day as string value (&#39;sun&#39;, &#39;mon&#39;, etc.). If you want to receive data
                            for other calendars, contexts or format, then you must give an array instead of
                            an integer with the expected values. The array has to look like this:
                             array(&#39;calendar&#39;, &#39;context&#39;, &#39;format&#39;, &#39;day abbreviation&#39;) . If you
                            give only an string then the default values are the &#39;gregorian&#39; calendar,
                            the context &#39;format&#39; and the format &#39;wide&#39;. Use
                             Zend_Date  for simplicity Quarter Returns a translation for a quarter. You have to give the number of the
                            quarter as integer and it has to be between 1 and 4. If you want to receive
                            data for other calendars, contexts or formats, then you must give an array
                            instead of an integer with the expected values. The array has to look like this:
                             array(&#39;calendar&#39;, &#39;context&#39;, &#39;format&#39;, &#39;quarter number&#39;) . If you
                            give only an string then the default values are the &#39;gregorian&#39; calendar,
                            the context &#39;format&#39; and the format &#39;wide&#39; Am Returns a translation for &#39;AM&#39; in a expected locale. If you want to receive
                            data for other calendars an string with the expected calendar. If you omit the
                            value then the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity Pm Returns a translation for &#39;PM&#39; in a expected locale. If you want to receive
                            data for other calendars an string with the expected calendar. If you omit the
                            value then the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity Era Returns a translation for an era within a locale. You have to give the era
                            number as string or integer. If you want to receive data for other calendars or
                            formats, then you must give an array instead of the era number with the expected
                            values. The array has to look like this:
                             array(&#39;calendar&#39;, &#39;format&#39;, &#39;era number&#39;) . If you give only an
                            string then the default values are the &#39;gregorian&#39; calendar and the &#39;abbr&#39;
                            format DefaultDate Returns the default date format which is used within the given
                            calendar. If you omit the value the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity Date Returns the date format for an given calendar or format within a locale.
                            If you omit the value then the &#39;gregorian&#39; calendar will be used with the
                            &#39;medium&#39; format. If you give a string then the &#39;gregorian&#39; calendar will be
                            used with the given format. Or you can also give an array which will have to
                            look like this:  array(&#39;calendar&#39;, &#39;format&#39;) . Use
                             Zend_Date  for simplicity DefaultTime Returns the default time format which is used within the given
                            calendar. If you omit the value the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity Time Returns the time format for an given calendar or format within a locale.
                            If you omit the value then the &#39;gregorian&#39; calendar will be used with the
                            &#39;medium&#39; format. If you give a string then the &#39;gregorian&#39; calendar will be
                            used with the given format. Or you can also give an array which will have to
                            look like this:  array(&#39;calendar&#39;, &#39;format&#39;) . Use
                             Zend_Date  for simplicity DateTime Returns the datetime format for the given locale which indicates how to
                            display date with times in the same string within the given calendar. If you
                            omit the value the &#39;gregorian&#39; calendar will be used. Use
                             Zend_Date  for simplicity Field Returns a translated date field which can be used to display calendars or
                            date strings like &#39;month&#39; or &#39;year&#39; in a wished language. You must give the
                            field which has to be returned as string. In this case the &#39;gregorian&#39;
                            calendar will be used. You can get the field for other calendar formats if you
                            give an array which has to look like this:
                             array(&#39;calendar&#39;, &#39;date field&#39;) Relative Returns a translated date which is relative to today which can include date
                            strings like &#39;yesterday&#39; or &#39;tomorrow&#39; in a wished language. You have to give
                            the number of days relative to tomorrow to receive the expected string. Yesterday
                            would be &#39;-1&#39;, tomorrow &#39;1&#39; and so on. This will use the &#39;gregorian&#39; calendar. If
                            you want to get relative dates for other calendars you will have to give an array
                            which has to look like this:  array(&#39;calendar&#39;, &#39;relative days&#39;) . Use
                             Zend_Date  for simplicity DecimalNumber Returns the format for decimal numbers within a given locale. Use
                             Zend_Locale_Format  for simplicity ScientificNumber Returns the format for scientific numbers within a given locale PercentNumber Returns the format for percentage numbers within a given locale CurrencyNumber Returns the format for displaying currency numbers within a given locale. Use
                             Zend_Currency  for simplicity NameToCurrency Returns the translated name for a given currency. The currency has to be
                            given in ISO format which is for example &#39;EUR&#39; for the currency &#39;euro&#39;. Use
                             Zend_Currency  for simplicity CurrencyToName Returns a currency for a given localized name. Use
                             Zend_Currency  for simplicity CurrencySymbol Returns the used symbol for a currency within a given locale. Not for all
                            currencies exists a symbol. Use
                             Zend_Currency  for simplicity Question Returns a localized string for acceptance (&#39;yes&#39;) and
                            negotation (&#39;no&#39;). You have to give either &#39;yes&#39; or &#39;no&#39; as value to receive the
                            expected string. Use
                             Zend_Locale&#39;s getQuestion method 
                            for simplicity CurrencyFraction Returns the fraction to use for a given currency. You must give the currency
                            as ISO value. Use  Zend_Currency 
                            for simplicity CurrencyRounding Returns how to round a given currency. You must give the currency
                            as ISO value. If you omit the currency then the &#39;DEFAULT&#39; rounding will be
                            returned. Use  Zend_Currency 
                            for simplicity CurrencyToRegion Returns the currency for a given region. The region code has to be given
                            as ISO3166 string for example &#39;AT&#39; for austria. Use
                             Zend_Currency  for simplicity RegionToCurrency Returns the regions where a currency is used. The currency has to be given
                            as ISO4217 code for example &#39;EUR&#39; for euro. When a currency is used in multiple
                            regions, these regions are seperated with a whitespace character. Use
                             Zend_Currency  for simplicity RegionToTerritory Returns the regions for a given territory. The territory has to be given as
                            ISO4217 string for example &#39;001&#39; for world. The regions within this territory
                            are seperated with a whitespace character TerritoryToRegion Returns the territories where a given region is located. The region has to be
                            given in ISO3166 string for example &#39;AT&#39; for austria. When a region is located in
                            multiple territories then these territories are seperated with a whitespace
                            character ScriptToLanguage Returns the scripts which are used within a given language. The language has
                            to be given as ISO language code for example &#39;en&#39; for english. When multiple
                            scripts are used within a language then these scripts are seperated with a
                            whitespace character LanguageToScript Returns the languages which are used within a given script. The script has to be
                            given as ISO script code for example &#39;Latn&#39; for latin. When a script is used in
                            multiple languages then these languages are seperated with a whitespace
                            character TerritoryToLanguage Returns the territories where a given language is used. The language has
                            to be given as ISO language code for example &#39;en&#39; for english. When multiple
                            territories exist where this language is used then these territories are
                            seperated with a whitespace character LanguageToTerritory Returns the languages which are used within a given territory. The territory
                            has to be given as ISO3166 code for example &#39;IT&#39; for italia. When a language
                            is used in multiple territories then these territories are seperated with a
                            whitespace character TimezoneToWindows Returns a ISO timezone for a given windows timezone WindowsToTimezone Returns a windows timezone for a given ISO timezone TerritoryToTimezone Returns the territory for a given ISO timezone TimezoneToTerritory Returns the ISO timezone for a given territory CityToTimezone Returns the localized city for a given ISO timezone. Not for all timezones
                            does a city translation exist TimezoneToCity Returns the ISO timezone for a given localized city name. Not for all cities
                            does a timezone exist 
                With Zend Framework 1.5 several old types have been renamed. This has to be done because
                of several new types, some misspelling and to increase the usability. See this table for
                a list of old to new types:  
             Differences between ZF 1.0 and ZF 1.5 Old type New type Country Territory (with value &#39;2&#39;) Calendar Type (with value &#39;calendar&#39;) Month_Short Month (with array(&#39;gregorian&#39;, &#39;format&#39;, &#39;abbreviated&#39;) Month_Narrow Month (with array(&#39;gregorian&#39;, &#39;stand-alone&#39;, &#39;narrow&#39;) Month_Complete Months Day_Short Day (with array(&#39;gregorian&#39;, &#39;format&#39;, &#39;abbreviated&#39;) Day_Narrow Day (with array(&#39;gregorian&#39;, &#39;stand-alone&#39;, &#39;narrow&#39;) DateFormat Date TimeFormat Time Timezones CityToTimezone Currency NameToCurrency Currency_Sign CurrencySymbol Currency_Detail CurrencyToRegion Territory_Detail TerritoryToRegion Language_Detail LanguageToTerritory 
            The example below demonstrates how to obtain the names of things in different languages.
         getTranslationList &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;en_US&#39;);
// prints the names of all countries in German language
print_r($locale-&gt;getTranslationList(&#39;country&#39;, &#39;de&#39;));
             
            The next example shows how to find the name of a language in another language, when the two letter
            iso country code is not known.
         Converting country name in one language to another &lt;?php
require &#39;Zend/Locale.php&#39;;
$locale = new Zend_Locale(&#39;en_US&#39;);
$code2name = $locale-&gt;getLanguageTranslationList();
$name2code = array_flip($code2name);
$frenchCode = $name2code[&#39;French&#39;];
echo $locale-&gt;getLanguageTranslation($frenchCode, &#39;de_AT&#39;);
// output is the German name of the French language
             
            To gain some familiarity with what is available, try the example and examine the output.
         All available translations &lt;?php
// obtain a list of all the translation lists
$lists = $locale-&gt;getTranslationList();

// show all translation lists available (lots of output, all in English language)
foreach ($lists as $list) {
    echo &quot;List $list = &quot;;
    print_r($locale-&gt;getTranslationList($list));
}
             
            To generate a list of all languages known by Zend_Locale, with each language name shown in its own language,
            try the example below in a web page. Similarly,  getCountryTranslationList()  and
             getCountryTranslation()  could be used to create a table mapping your native language names for
            regions to the names of the regions shown in another language. Use a
             try .. catch  block to handle exceptions that occur when using a locale that does not exist. Not
            all languages are also locales. In the example, below exceptions are ignored to prevent early termination.
         All Languages written in their native language &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$sourceLanguage = null; // set to your native language code
$locale = new Zend_Locale($sourceLanguage);
$list = $locale-&gt;getLanguageTranslationList();

foreach($list as $language =&gt; $content) {
    try {
        $output = $locale-&gt;getLanguageTranslation($language, $language);
        if (is_string($output)) {
            print &quot;\n&lt;br&gt;[&quot;.$language.&quot;] &quot;.$output;
        }
    } catch (Exception $e) {
        continue;
    }
}
             Obtaining translations for &quot;yes&quot; and &quot;no&quot; 
            Frequently, programs need to solicit a &quot;yes&quot; or &quot;no&quot; response from the user. Use  getQuestion() 
            to obtain an array containing the correct word(s) or regex strings to use for prompting the user in a
            particular $locale (defaults to the current object&#39;s locale). The returned array will contain the
            following informations :
         yes and no : A generic string representation for yes
                    and no responses. This will contain the first and most generic response from yesarray and
                    noarray.
                 yesarray and noarray : An array with all known yes and
                    no responses. Several languages have more than just two responses. In general this is the
                    full string and it&#39;s abbreviation.
                 yesexpr and noexpr : An generated regex which allows you
                    to handle user response, and search for yes or no.
                 
            All of this informations are of course localized and depend on the set locale. See the following
            example for the informations you can receive:
         getQuestion() &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale();
// Question strings
print_r($locale-&gt;getQuestion(&#39;de&#39;));

- - - Output - - -

Array
(
    [yes] =&gt; ja
    [no] =&gt; nein
    [yesarray] =&gt; Array
        (
            [0] =&gt; ja
            [1] =&gt; j
        )

    [noarray] =&gt; Array
        (
            [0] =&gt; nein
            [1] =&gt; n
        )

    [yesexpr] =&gt; ^([jJ][aA]?)|([jJ]?)
    [noexpr] =&gt; ^([nN]([eE][iI][nN])?)|([nN]?)
)
             
                Until 1.0.3  yesabbr  from the underlaying locale data was also
                available. Since 1.5 this information is no longer standalone available, but you will find the
                information from it within  yesarray .
             Get a list of all known locales 
            Sometimes you will want to get a list of all known locales. This can be used for several tasks
            like the creation of a selectbox. For this purpose you can use the static
             getLocaleList()  method which will return a list of all known locales.
         getLocaleList() &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$localelist = Zend_Locale::getLocaleList();

             
                Note that the locales are returned as key of the array you will receive. The value is always
                a boolean true.
             Introduction Zend_Locale  is the Frameworks answer to the question, &quot;How can the same application be used around
        the whole world?&quot; Most people will say, &quot;That&#39;s easy. Let&#39;s translate all our output to several languages.&quot;
        However, using simple translation tables to map phrases from one language to another is not sufficient.
        Different regions will have different conventions for first names, surnames, salutory titles, formatting of
        numbers, dates, times, currencies, etc.
     
        We need
         Localization 
        and complementary
         Internationalization 
        . Both are often abbreviated to  L10N  and  I18N . Internationalization refers more to
        support for use of systems, regardless of special needs unique to groups of users related by language, region,
        number format conventions, financial conventions, time and date conventions, etc. Localization involves adding
        explicit support to systems for special needs of these unique groups, such as language translation, and support
        for local customs or conventions for communicating plurals, dates, times, currencies, names, symbols, sorting
        and ordering, etc.  L10N  and  I18N  compliment each other. The Zend Framework provides
        support for these through a combination of components, including Zend_Locale, Zend_Date, Zend_Measure,
        Zend_Translate, Zend_Currency, and Zend_TimeSync.
     Zend_Locale and setLocale() PHP&#39;s documentation  states that  setlocale() 
            is not threadsave because it is maintained per process and not per thread. This means that, in
            multithreaded environments, you can have the problem that the locale changes while the script
            never has changed the locale itself. This can lead to unexpected behaviour when you use
             setlocale()  in your scripts.
         
            When you are using  Zend_Locale  you will not have this limitations, because
             Zend_Locale  is not related to or coupled with PHP&#39;s  setlocale() .
         What is Localization 
            Localization means that an application (or homepage) can be used from different users which speak different
            languages. But as you already have expected Localization means more than only translating strings. It
            includes
         Zend_Locale  - Backend support of locales available for localization support within
                    other ZF components.
                 Zend_Translate  - Translating of strings.
                 Zend_Date  - Localization of dates, times.
                 Zend_Calendar  - Localization of calendars (support for non-Gregorian calendar systems)
                 Zend_Currency  - Localization of currencies.
                 Zend_Locale_Format  - Parsing and generating localized numbers.
                 Zend_Locale_Data  - Retrieve localized standard strings as country names, language names
                    and
                     more from the CLDR 
                    .
                 TODO  - Localization of collations
                 What is a Locale? 
            Each computer user makes use of Locales, even when they don&#39;t know it. Applications lacking localization
            support, normally have implicit support for one particular locale (the locale of the author). When a class
            or function makes use of localization, we say it is  locale-aware . How does the code know which
            localization the user is expecting?
         
            A locale string or object identifying a supported locale gives  Zend_Locale  and it&#39;s subclasses
            access to information about the language and region expected by the user. Correct formatting, normalization,
            and conversions are made based on this information.
         How are Locales Represented? 
            Locale identifiers consist of information about the user&#39;s language and preferred/primary geographic region
            (e.g. state or province of home or workplace). The locale identifier strings used in the Zend Framework are
            internationally defined standard abbreviations of language and region, written as
             language_REGION . Both the language and region parts are abbreviated to alphabetic, ASCII
            characters.
         
                Be aware that there exist not only locales with 2 characters as most people think. Also there
                are languages and regions which are not only abbreviated with 2 characters. Therefor you should
                NOT strip the region and language yourself, but use Zend_Locale when you want to strip language
                or region from a locale string. Otherwise you could have unexpected behaviour within your code
                when you do this yourself.
             
            A user from USA would expect the language  English  and the region  USA , yielding the
            locale identifier &quot;en_US&quot;. A user in Germany would expect the language  German  and the region
             Germany , yielding the locale identifier &quot;de_DE&quot;. See the
             list of pre-defined locale and region combinations 
            , if you need to select a specific locale within the Zend Framework.
         Choosing a specific locale &lt;?php
require_once &#39;Zend_Locale&#39;;
$locale = new Zend_Locale(&#39;de_DE&#39;); // German language _ Germany
             
            A German user in America might expect the language  German  and the region  USA , but
            these non-standard mixes are not supported directly as recognized &quot;locales&quot;. Instead, if an invalid
            combination is used, then it will automatically be truncated by dropping the region code. For example,
            &quot;de_IS&quot; would be truncated to &quot;de&quot;, and &quot;xh_RU&quot; would be truncated to &quot;xh&quot;, because neither of these
            combinations are valid. Additionally, if the base language code is not supported (e.g. &quot;zz_US&quot;) or does not
            exist, then a default &quot;root&quot; locale will be used. The &quot;root&quot; locale has default definitions for
            internationally recognized representations of dates, times, numbers, currencies, etc. The truncation process
            depends on the requested information, since some combinations of language and region might be valid for one
            type of data (e.g. dates), but not for another (e.g. currency format).
         
            Beware of historical changes, as ZF components do not know about or attempt to track the numerous timezone
            changes made over many years by many regions. For example,
             we can see a historical list 
            showing dozens of changes made by governments to when and if a particular region observes Daylight Savings
            Time, and even which timezone a particular geographic area belongs. Thus, when performing date math, the
            math performed by ZF components will not adjust for these changes, but instead will give the correct time
            for the timezone using current, modern rules for DST and timezone assignment for geographic regions.
         Selecting the Right Locale 
            For most situations,  new Zend_Locale()  will automatically select the correct locale, with
            preference given to information provided by the user&#39;s web browser. However, if  new
            Zend_Locale(Zend_Locale::ENVIRONMENT)  is used, then preference will be given to using the host
            server&#39;s environment configuration, as described below.
         Automatically selecting a locale &lt;?php
require_once &#39;Zend/Locale.php&#39;;
$locale  = new Zend_Locale();
$locale1 = new Zend_Locale(Zend_Locale::BROWSER);     // default behavior, same as above
$locale2 = new Zend_Locale(Zend_Locale::ENVIRONMENT); // prefer settings on host server
$locale3 = new Zend_Locale(Zend_Locale::FRAMEWORK);   // perfer framework app default settings
             
            The seach algorithm used by  Zend_Locale  for automatic selection of a locale uses three sources
            of information:
             
                        const  Zend_Locale::BROWSER  - The user&#39;s Web browser provides information with each
                        request, which is published by PHP in the global variable  HTTP_ACCEPT_LANGUAGE . If
                        no matching locale can be found, then preference is given to  ENVIRONMENT  and lastly
                         FRAMEWORK .
                     
                        const  Zend_Locale::ENVIRONMENT  - PHP publishes the host server&#39;s locale via the PHP
                        internal function  setlocale() . If no matching locale can be found, then preference
                        is given to FRAMEWORK and lastly BROWSER.
                     
                        const  Zend_Locale::FRAMEWORK  - When the Zend Framework has a standardized way of
                        specifying component defaults (planned, but not yet available), then using this constant during
                        instantiation will give preference to choosing a locale based on these defaults. If no matching
                        locale can be found, then preference is given to  ENVIRONMENT  and lastly
                         BROWSER .
                     
         Usage of automatic Locales Zend_Locale  provides three additionally locales. These locales do not belong to
            any language or region. They are &quot;automatic&quot; locales which means that they have the same effect
            as the method  getDefault()  but without the negative effects like creating an instance. 
            These &quot;automatic&quot; locales can be used anywhere, where also a standard locale and also the
            definition of a locale, it&#39;s string representation, can be used. This offers simplicity for
            situations like working with locales which are provided by a browser.
         
            There are three locales which have a slightly different behaviour:

             &#39;browser&#39;  -  Zend_Locale  should work with the information
                        which is provided by the user&#39;s Web browser. It is published by PHP in the global
                        variable  HTTP_ACCEPT_LANGUAGE .
                     
                        If a user provides more than one locale within his browser,  Zend_Locale 
                        will use the first found locale. If the user does not provide a locale or the script is
                        being called from the commandline the automatic locale  &#39;environment&#39; 
                        will automatically be used and returned.
                     &#39;environment&#39;  -  Zend_Locale  should work with the information
                        which is provided by the host server. It is published by PHP via the internal function
                         setlocale() .
                     
                        If a environment provides more than one locale,  Zend_Locale  will use the
                        first found locale. If the host does not provide a locale the automatic locale
                         &#39;browser&#39;  will automatically be used and returned.
                     &#39;auto&#39;  -  Zend_Locale  should automatically detect any locale
                        which can be worked with. It will first search for a users locale and then, if not
                        successfull, search for the host locale.
                     
                        If no locale can be detected, it will throw an exception and tell you that the
                        automatical detection has been failed.
                     
         Using automatic locales &lt;?php
require_once &#39;Zend/Locale.php&#39;;
require_once &#39;Zend/Date.php&#39;;

// without automatic detection
//$locale = new Zend_Locale(Zend_Locale::BROWSER);
//$date = new Zend_Date($locale);

// with automatic detection
$date = new Zend_Date(&#39;auto&#39;);
             Using a default Locale 
            In some environments it is not possible to detect a locale automatically. You can expect this
            behaviour when you get an request from commandline or the requesting browser has no language tag
            set and additionally your server has the default locale &#39;C&#39; set or another properitary locale.
         
            In such cases  Zend_Locale  will normally throw an exception with a message that
            the automatic detection of any locale was not successfull. You have two options to handle such
            a situation. Either through setting a new locale per hand, or defining a default locale.
         Handling locale exceptions &lt;?php
// within the bootstrap file
require_once &#39;Zend/Locale.php&#39;;

try {
    $locale = new Zend_Locale(&#39;auto&#39;);
} catch (Zend_Locale_Exception $e) {
    $locale = new Zend_Locale(&#39;de&#39;);
}

// within your model/controller
$date = new Zend_Date($locale);
             
            But this has one big negative effect. You will have to set your locale object within
            every class using  Zend_Locale . This could become very unhandy if you are using
            multiple classes.
         
            Since Zend Framework Release 1.5 there is a much better way to handle this. You can set a
            default locale which the static  setDefault()  method. Of course, every unknown
            or not full qualified locale will also throw an exception.  setDefault()  should
            be the first call before you initiate any class using  Zend_Locale . See the
            following example for details:
         Setting a default locale &lt;?php
// within the bootstrap file
require_once &#39;Zend/Locale.php&#39;;

Zend_Locale::setDefault(&#39;de&#39;);

// within your model/controller
$date = new Zend_Date();
             
            In the case that no locale can be detected, automatically the locale
             de  will be used. Otherwise, the detected locale will be used.
         ZF Locale-Aware Classes 
            In the ZF, locale-aware classes rely on  Zend_Locale  to automatically select a locale, as
            explained above. For example, in a ZF web application, constructing a date using  Zend_Date 
            without specifying a locale results in an object with a locale based on information provided by the current
            user&#39;s web browser.
         Dates default to correct locale of web users &lt;?php
require_once &#39;Zend/Date.php&#39;;
$date = new Zend_Date(&#39;2006&#39;,Zend_Date::YEAR);
             
            To override this default behavior, and force locale-aware ZF components to use specific locales, regardless
            of the origin of your website visitors, explicitly specify a locale as the third argument to the
            constructor.
         Overriding default locale selection &lt;?php
require_once &#39;Zend/Date.php&#39;;
require_once &#39;Zend/Measure/Temperature.php&#39;;

$usLocale = new Zend_Locale(&#39;en_US&#39;);
$date = new Zend_Date(&#39;2006&#39;, Zend_Date::YEAR, $usLocale);
$temp = new Zend_Measure_Temperature(&#39;100,10&#39;, Zend_Measure::TEMPERATURE, $usLocale);
             
            If you know many objects should all use the same default locale, explicitly specify the default locale to
            avoid the overhead of each object determining the default locale.
         Performance optimization when using a default locale &lt;?php
require_once &#39;Zend/Date.php&#39;;
require_once &#39;Zend/Measure/Temperature.php&#39;;

$locale = new Zend_Locale();
$date = new Zend_Date(&#39;2006&#39;, Zend_Date::YEAR, $locale);
$temp = new Zend_Measure_Temperature(&#39;100,10&#39;, Zend_Measure::TEMPERATURE, $locale);
             Zend_Locale_Format::setOptions(array $options) 
            The &#39;precision&#39; option of a value is used to truncate or stretch extra digits. A value of &#39;-1&#39; disables
            modification of the number of digits in the fractional part of the value. The &#39;locale&#39; option helps when
            parsing numbers and dates using separators and month names. The date format &#39;format_type&#39; option selects between
            CLDR/ISO date format specifier tokens and PHP&#39;s date() tokens. The &#39;fix_date&#39; option enables or disables
            heuristics that attempt to correct invalid dates. The &#39;number_format&#39; option specifies a default number
            format for use with  toNumber()  (see
             
            ).
         
            The &#39;date_format&#39; option can be used to specify a default date format string, but beware of using getDate(),
            checkdateFormat() and getTime() after using setOptions() with a &#39;date_format&#39;. To use these four methods
            with the default date format for a locale, use array(&#39;date_format&#39; =&gt; null, &#39;locale&#39; =&gt; $locale) for their
            options.
         Dates default to correct locale of web users &lt;?php
require_once &#39;Zend/Locale.php&#39;;
Zend_Locale_Format::setOptions(array(&#39;locale&#39; =&gt; &#39;en_US&#39;, &#39;fix_date&#39; =&gt; true, &#39;format_type&#39; =&gt; &#39;php&#39;));
             
            For working with the standard definitions of a locale the option Zend_Locale_Format::STANDARD can be used.
            Setting the option Zend_Locale_Format::STANDARD for date_format uses the standard definitions from the actual
            set locale. Setting it for number_format uses the standard number format for this locale.
            And setting it for locale uses the standard locale for this environment or browser.
         Using STANDARD definitions for setOptions() &lt;?php
require_once &#39;Zend/Locale.php&#39;;
Zend_Locale_Format::setOptions(array(&#39;locale&#39; =&gt; &#39;en_US&#39;, &#39;date_format&#39; =&gt; &#39;dd.MMMM.YYYY&#39;));
// overriding the global set date format
$date = Zend_Locale_Format::getDate(&#39;2007-04-20, array(&#39;date_format&#39; =&gt; Zend_Locale_Format::STANDARD);

// global setting of the standard locale
Zend_Locale_Format::setOptions(array(&#39;locale&#39; =&gt; Zend_Locale_Format::STANDARD, &#39;date_format&#39; =&gt; &#39;dd.MMMM.YYYY&#39;));
             Speed up Zend_Locale and it&#39;s subclasses Zend_Locale  and it&#39;s subclasses can be speed up by the usage of  Zend_Cache .
            Use the static method  Zend_Locale::setCache($cache)  if you are using
             Zend_Locale .  Zend_Locale_Format  can be speed up the using the option
             cache  within  Zend_Locale_Format::setOptions(array(&#39;cache&#39; =&gt; $adapter)); .
            If you are using both classes you should only set an cache for  Zend_Locale , otherwise
            the data would be cached twice.
         Normalization and Localization Zend_Locale_Format  is a internal component used by Zend_Locale. All locale aware classes use
         Zend_Locale_Format  for normalization and localization of numbers and dates. Normalization involves
        parsing input from a variety of data respresentations, like dates, into a standardized, structured
        representation, such as a PHP array with year, month, and day elements.
     
        The exact same string containing a number or a date might mean different things to people with different customs
        and conventions. Disambiguation of numbers and dates requires rules about how to interpret these strings and
        normalize the values into a standardized data structure. Thus, all methods in  Zend_Locale_Format 
        require a locale in order to parse the input data.
         Default &quot;root&quot; Locale 
                If no locale is specified, then normalization and localization will use the standard &quot;root&quot; locale,
                which might yield unexpected behavior, if the input originated in a different locale, or output for a
                specific locale was expected.
             
     Number normalization: getNumber($input, Array $options) 
            There are many
             number systems 
            different from the common
             decimal system 
            (e.g. &quot;3.14&quot;). Numbers can be normalized with the  getNumber()  function to obtain the standard
            decimal representation. For all number-related discussions in this manual,
             Arabic/European numerals (0,1,2,3,4,5,6,7,8,9) 
            are implied, unless explicitly stated otherwise. The options array may contain a &#39;locale&#39; to define grouping
            and decimal characters. The array may also have a &#39;precision&#39; to truncate excess digits from the result.
         Number normalization &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::getNumber(&#39;13.524,678&#39;, array(&#39;locale&#39; =&gt; $locale, &#39;precision&#39; =&gt; 3));

print $number; // will return 13524.678
             Precision and Calculations 
                Since  getNumber($value, array $options = array())  can normalize extremely large numbers,
                check the result carefully before using finite precision calculations, such as ordinary PHP math
                operations. For example,  if ((string)int_val($number) != $number) { use
                 BCMath 
                or
                 GMP 
                 . Most PHP installations support the BCMath extension.
             
                Also, the precision of the resulting decimal representation can be rounded to a desired length with
                 getNumber()  with the option  &#39;precision&#39; . If no precision is given,
                no rounding occurs. Use only PHP integers to specify the precision.
             
                If the resulting decimal representation should be truncated to a desired length instead of rounded
                the option  &#39;number_format&#39;  can be used instead. Define the length of the decimal
                representation with the desired length of zeros. The result will then not be rounded.
                So if the defined precision within  number_format  is zero the value &quot;1.6&quot; will
                return &quot;1&quot;, not &quot;2. See the example nearby:
             Number normalization with precision &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::getNumber(&#39;13.524,678&#39;, array(&#39;precision&#39; =&gt; 1, &#39;locale&#39; =&gt; $locale));
print $number; // will return 13524.7

$number = Zend_Locale_Format::getNumber(&#39;13.524,678&#39;, array(&#39;number_format&#39; =&gt; &#39;#.00&#39;, &#39;locale&#39; =&gt; $locale));
print $number; // will return 13524.67
                 Number localization toNumber($value, array $options = array())  can localize numbers to the
             supported locales 
            . This function will return a localized string of the given number in a conventional format for a specific
            locale. The &#39;number_format&#39; option explicitly specifies a non-default number format for use with
             toNumber() .
         Number localization &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::toNumber(13547.36, array(&#39;locale&#39; =&gt; $locale));

// will return 13.547,36
print $number;
             Unlimited length toNumber()  can localize numbers with unlimited length. It is not related to integer or
                    float limitations.
                 
            The same way as within  getNumber() ,  toNumber()  handles precision. If no precision
            is given, the complete localized number will be returned.
         Number localization with precision &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::toNumber(13547.3678, array(&#39;precision&#39; =&gt; 2, &#39;locale&#39; =&gt; $locale));

// will return 13.547,37
print $number;
             
            Using the option &#39;number_format&#39; a self defined format for generating a number can be defined.
            The format itself has to be given in CLDR format as described below. The locale is used to get
            seperation, precission and other number formatting signs from it. German for example defines
            &#39;,&#39; as precission seperation and in english the &#39;.&#39; sign is used.
         Format tokens for self generated number formats
             Token Description Example format Generated output #0 Generates a number without precission and seperation #0 1234567 , Generates a seperation with the length from seperation to next seperation or to 0 #,##0 1,234,567 #,##,##0 Generates a standard seperation of 3 and all following seperations with 2 #,##,##0 12,34,567 . Generates a precission #0.# 1234567.1234 0 Generates a precission with a defined length #0.00 1234567.12 Using a self defined number format &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::toNumber(13547.3678, array(&#39;number_format&#39; =&gt; &#39;#,#0.00&#39;, &#39;locale&#39; =&gt; &#39;de&#39;));

// will return 1.35.47,36
print $number;

$number = Zend_Locale_Format::toNumber(13547.3, array(&#39;number_format&#39; =&gt; &#39;#,##0.00&#39;, &#39;locale&#39; =&gt; &#39;de&#39;));

// will return 13.547,30
print $number;
             Number testing isNumber($value, array $options = array())  checks if a given string is a number and returns
            true or false.
         Number testing &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale();
if (Zend_Locale_Format::isNumber(&#39;13.445,36&#39;, array(&#39;locale&#39; =&gt; &#39;de_AT&#39;)) {
    print &quot;Number&quot;;
} else {
    print &quot;not a Number&quot;;
}
             Float value normalization 
            Floating point values can be parsed with the  getFloat($value, array $options = array()) 
            function. A floating point value will be returned.
         Floating point value normalization &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::getFloat(&#39;13.524,678&#39;, array(&#39;precision&#39; =&gt; 2, &#39;locale&#39; =&gt; $locale));

// will return 13524.68
print $number;
             Floating point value localization toFloat()  can localize floating point values. This function will return a localized string of
            the given number.
         Floating point value localization &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::toFloat(13547.3655, array(&#39;precision&#39; =&gt; 1, &#39;locale&#39; =&gt; $locale));

// will return 13.547,4
print $number;
             Floating point value testing isFloat($value, array $options = array())  checks if a given string is a floating point value
            and returns true or false.
         Floating point value testing &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
if (Zend_Locale_Format::isFloat(&#39;13.445,36&#39;, array(&#39;locale&#39; =&gt; $locale)) {
    print &quot;float&quot;;
} else {
    print &quot;not a float&quot;;
}
             Integer value normalization 
            Integer values can be parsed with the  getInteger()  function. A integer value will be returned.
         Integer value normalization &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::getInteger(&#39;13.524,678&#39;, array(&#39;locale&#39; =&gt; $locale));

// will return 13524
print $number;
             Integer point value localization toInteger($value, array $options = array())  can localize integer values. This function will
            return a localized string of the given number.
         Integer value localization &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$number = Zend_Locale_Format::toInteger(13547.3655, array(&#39;locale&#39; =&gt; $locale));

// will return 13.547
print $number;
             Integer value testing isInteger($value, array $options = array())  checks if a given string is a integer value and
            returns true or false.
         Integer value testing &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
if (Zend_Locale_Format::isInteger(&#39;13.445&#39;, array(&#39;locale&#39; =&gt; $locale)) {
    print &quot;integer&quot;;
} else {
    print &quot;not a integer&quot;;
}
             Numeral System Conversion Zend_Locale_Format::convertNumerals()  converts digits between different
             numeral systems 
            , including the standard Arabic/European/Latin numeral system (0,1,2,3,4,5,6,7,8,9), not to be confused with
             Eastern Arabic numerals 
            sometimes used with the Arabic language to express numerals. Attempts to use an unsupported numeral system
            will result in an exception, to avoid accidentally performing an incorrect conversion due to a spelling
            error. All characters in the input, which are not numerals for the selected numeral system, are copied to
            the output with no conversion provided for unit separator characters.   Zend_Locale*  components
            rely on the data provided by CLDR (see their
             
                list of scripts grouped by language ).
         
            In CLDR and hereafter, the Europena/Latin numerals will
            be referred to as &quot;Latin&quot; or by the assigned 4-letter code &quot;Latn&quot;.
            Also, the CLDR refers to this numeral systems as &quot;scripts&quot;.
         
            Suppose a web form collected a numeric input expressed using Eastern Arabic digits &quot;Ù¡â€ŽÙ Ù &quot;.
            Most software and PHP functions expect input using Arabic numerals. Fortunately, converting this input
            to it&#39;s equivalent Latin numerals &quot;100&quot; requires little effort using
             convertNumerals($inputNumeralString, $sourceNumeralSystem, $destNumeralSystem) 
            , which returns the  $input  with numerals in the script  $sourceNumeralSystem 
            converted to the script  $destNumeralSystem .
         Converting numerals from Eastern Arabic scripts to European/Latin scripts &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$arabicScript = &quot;Ù¡â€ŽÙ Ù &quot;;   // Arabic for &quot;100&quot; (one hundred)
$latinScript = Zend_Locale_Format::convertNumerals($arabicScript, &#39;Arab&#39;, &#39;Latn&#39;);

print &quot;\nOriginal:   &quot; . $arabicScript;
print &quot;\nNormalized: &quot; . $latinScript;
             
            Similarly, any of the supported numeral systems may be converted to any other supported numeral system.
         Converting numerals from Latin script to Eastern Arabic script &lt;?php
require_once &#39;Zend/Locale.php&#39;;

$latinScript = &#39;123&#39;;
$arabicScript = Zend_Locale_Format::convertNumerals($latinScript, &#39;Latn&#39;, &#39;Arab&#39;);

print &quot;\nOriginal:  &quot; . $latinScript;
print &quot;\nLocalized: &quot; . $arabicScript;
             Getting 4 letter CLDR script code using a native-language name of the script &lt;?php
function getScriptCode($scriptName, $locale)
{
    $scripts2names = Zend_Locale_Data::getList($locale, &#39;script&#39;);
    $names2scripts = array_flip($scripts2names);
    return $names2scripts[$scriptName];
}
echo getScriptCode(&#39;Latin&#39;, &#39;en&#39;); // outputs &quot;Latn&quot;
echo getScriptCode(&#39;Tamil&#39;, &#39;en&#39;); // outputs &quot;Taml&quot;
echo getScriptCode(&#39;tamoul&#39;, &#39;fr&#39;); // outputs &quot;Taml&quot;
             List of supported numeral systems List of supported numeral systems Notation Name Script Arabic Arab Balinese Bali Bengali Beng Devanagari Deva Gujarati Gujr Gurmukhi Guru Kannada Knda Khmer Khmr Lao Laoo Limbu Limb Malayalam Mlym Mongolian Mong Myanmar Mymr New_Tai_Lue Talu Nko Nkoo Oriya Orya Tamil Taml Telugu Telu Thai Tale Tibetan Tibt Filters 
      A Filter object blocks a message from being written to the log.
     Filtering for All Writers 
        To filter before all writers, you can add any number of Filters to a
        Log object using the  addFilter()  method:

         &lt;?php
$logger = new Zend_Log();

$writer = new Zend_Log_Writer_Stream(&#39;php://output&#39;);
$logger-&gt;addWriter($writer);

$filter = new Zend_Log_Filter_Priority(Zend_Log::CRIT);
$logger-&gt;addFilter($filter);

// blocked
$logger-&gt;info(&#39;Informational message&#39;);

// logged
$logger-&gt;emerg(&#39;Emergency message&#39;);
         

        When you add one or more Filters to the Log object, the message must pass
        through all of the Filters before any Writers receives it.
       Filtering for a Writer Instance 
        To filter only on a specific Writer instance, use the
         addFilter  method of that Writer:

         &lt;?php
$logger = new Zend_Log();

$writer1 = new Zend_Log_Writer_Stream(&#39;/path/to/first/logfile&#39;);
$logger-&gt;addWriter($writer1);

$writer2 = new Zend_Log_Writer_Stream(&#39;/path/to/second/logfile&#39;);
$logger-&gt;addWriter($writer2);

// add a filter only to writer2
$filter = new Zend_Log_Filter_Priority(Zend_Log::CRIT);
$writer2-&gt;addFilter($filter);

// logged to writer1, blocked from writer2
$logger-&gt;info(&#39;Informational message&#39;);

// logged by both writers
$logger-&gt;emerg(&#39;Emergency message&#39;);
         
     Formatters 
    A Formatter is an object that is responsible for taking an  event  array
    describing a log event and outputting a string with a formatted log line.
   
    Some Writers are not line-oriented and cannot use a Formatter.  An example is the
    Database Writer, which inserts the event items directly into database columns.  For
    Writers that cannot support a Formatter, an exception is thrown if you attempt to
    set a Formatter.
   Simple Formatting Zend_Log_Formatter_Simple  is the default formatter.  It is configured
      automatically when you specify no formatter.  The default configuration is equivalent
      to the following:

       &lt;?php
$format = &#39;%timestamp% %priorityName% (%priority%): %message%&#39; . PHP_EOL;
$formatter = new Zend_Log_Formatter_Simple($format);
       
     
      A formatter is set on an individual Writer object using the Writer&#39;s
       setFormatter()  method:

       &lt;?php
$writer = new Zend_Log_Writer_Stream(&#39;php://output&#39;);
$formatter = new Zend_Log_Formatter_Simple(&#39;hello %message%&#39; . PHP_EOL);
$writer-&gt;setFormatter($formatter);

$logger = new Zend_Log();
$logger-&gt;addWriter($writer);

$logger-&gt;info(&#39;there&#39;);

// outputs &quot;hello there&quot;
       
     
      The constructor of  Zend_Log_Formatter_Simple  accepts a single
      parameter: the format string.  This string contains keys surrounded by
      percent signs (e.g.  %message% ).  The format string may
      contain any key from the event data array.
     Formatting to XML Zend_Log_Formatter_Xml  formats log data into XML strings.
      By default, it automatically logs all items in the event data array:

       &lt;?php
$writer = new Zend_Log_Writer_Stream(&#39;php://output&#39;);
$formatter = new Zend_Log_Formatter_Xml();
$writer-&gt;setFormatter($formatter);

$logger = new Zend_Log();
$logger-&gt;addWriter($writer);

$logger-&gt;info(&#39;informational message&#39;);
       
     
      The code above outputs the following XML (space added for clarity):

       
&lt;logEntry&gt;
  &lt;timestamp&gt;2007-04-06T07:24:37-07:00&lt;/timestamp&gt;
  &lt;message&gt;informational message&lt;/message&gt;
  &lt;priority&gt;6&lt;/priority&gt;
  &lt;priorityName&gt;INFO&lt;/priorityName&gt;
&lt;/logEntry&gt;
       
     
      It&#39;s possible to customize the root element as well as specify a mapping
      of XML elements to the items in the event data array.  The constructor
      of  Zend_Log_Formatter_Xml  accepts a string with the name of
      the root element as the first parameter and an associative array with
      the element mapping as the second parameter:

       &lt;?php
$writer = new Zend_Log_Writer_Stream(&#39;php://output&#39;);
$formatter = new Zend_Log_Formatter_Xml(&#39;log&#39;, array(&#39;msg&#39; =&gt; &#39;message&#39;, &#39;level&#39; =&gt; &#39;priorityName&#39;));
$writer-&gt;setFormatter($formatter);

$logger = new Zend_Log();
$logger-&gt;addWriter($writer);

$logger-&gt;info(&#39;informational message&#39;);
       

      The code above changes the root element from its default of
       logEntry  to  log .  It also maps the element
       msg  to the event data item  message .  This
      results in the following output:

       
&lt;log&gt;
  &lt;msg&gt;informational message&lt;/msg&gt;
  &lt;level&gt;INFO&lt;/level&gt;
&lt;/log&gt;
       
     Overview Zend_Log  is a component for general purpose logging.
      It supports multiple log backends, formatting messages sent to the log,
      and filtering messages from being logged. These functions are divided
      into the following objects:

       
            A Log (instance of  Zend_Log ) is the object that your
            application uses the most. You can have as many Log objects as you
            like; they do not interact. A Log object must contain at
            least one Writer, and can optionally contain one or more Filters.
           
            A Writer (inherits from  Zend_Log_Writer_Abstract ) is
            responsible for saving data to storage.
           
            A Filter (implements  Zend_Log_Filter_Interface )
            blocks log data from being saved. A filter may be applied to an
            individual Writer, or to a Log where it is applied before all
            Writers. In either case, filters may be chained.
           
            A Formatter (implements  Zend_Log_Formatter_Interface )
            can format the log data before it is written by a Writer. Each
            Writer has exactly one Formatter.
           
     Creating a Log 
        To get started logging, instantiate a Writer and then pass it to a Log
        instance:

         &lt;?php
$logger = new Zend_Log();
$writer = new Zend_Log_Writer_Stream(&#39;php://output&#39;);

$logger-&gt;addWriter($writer);
         

        It is important to note that the Log must
        have at least one Writer.  You can add any number of Writers using the
        Log&#39;s  addWriter()  method.
       
        Alternatively, you can pass a Writer directly to constructor of Log as
        a shortcut:

         &lt;?php
$writer = new Zend_Log_Writer_Stream(&#39;php://output&#39;);
$logger = new Zend_Log($writer);
         

        The Log is now ready to use.
       Logging Messages 
        To log a message, call the  log()  method of a Log instance
        and pass it the message with a corresponding priority:

       &lt;?php
$logger-&gt;log(&#39;Informational message&#39;, Zend_Log::INFO);
       

      The first parameter of the  log()  method is a string  message  and the second
      parameter is an integer  priority .  The priority must be one of the priorities recognized
      by the Log instance.  This is explained in the next section.
     
      A shortcut is also available. Instead of calling the  log()  method, you can
      call a method by the same name as the priority:

       &lt;?php
$logger-&gt;log(&#39;Informational message&#39;, Zend_Log::INFO);
$logger-&gt;info(&#39;Informational message&#39;);

$logger-&gt;log(&#39;Emergency message&#39;, Zend_Log::EMERG);
$logger-&gt;emerg(&#39;Emergency message&#39;);
       
     Destroying a Log 
      If the Log object is no longer needed, set the variable containing it to
       null  to destroy it. This will automatically call the
       shutdown()  instance method of each attached Writer before
      the Log object is destroyed:

       &lt;?php
$logger = null;
       

      Explicitly destroying the log in this way is optional and is performed
      automatically at PHP shutdown.
     Using Built-in Priorities 
      The  Zend_Log  class defines the following priorities:

       
EMERG   = 0;  // Emergency: system is unusable
ALERT   = 1;  // Alert: action must be taken immediately
CRIT    = 2;  // Critical: critical conditions
ERR     = 3;  // Error: error conditions
WARN    = 4;  // Warning: warning conditions
NOTICE  = 5;  // Notice: normal but significant condition
INFO    = 6;  // Informational: informational messages
DEBUG   = 7;  // Debug: debug messages
       

      These priorities are always available, and a convenience method of the same name
      is available for each one.
     
      The priorities are not arbitrary. They come from the BSD  syslog  protocol,
      which is described in  RFC-3164 .
      The names and corresponding priority numbers are also
      compatible with another PHP logging system,
       PEAR Log ,
      which perhaps promotes interoperability between it and  Zend_Log .
     
      Priority numbers descend in order of importance.  EMERG  (0)
      is the most important priority.  DEBUG  (7) is the least
      important priority of the built-in priorities. You may define priorities
      of lower importance than  DEBUG . When
      selecting the priority for your log message, be aware of this priority
      hierarchy and choose appropriately.
     Adding User-defined Priorities 
      User-defined priorities can be added at runtime using the Log&#39;s
       addPriority()  method:

       &lt;?php
$logger-&gt;addPriority(&#39;FOO&#39;, 8);
       

      The snippet above creates a new priority,  FOO , whose
      value is  8 . The new priority is then available for logging:

       &lt;?php
$logger-&gt;log(&#39;Foo message&#39;, 8);
$logger-&gt;foo(&#39;Foo Message&#39;);
       

      New priorities cannot overwrite existing ones.
     Understanding Log Events 
      When you call the  log()  method or one of its shortcuts, a
      log event is created. This is simply an associative array with data
      describing the event that is passed to the writers. The following keys
      are always created in this array:  timestamp ,
       message ,  priority , and
       priorityName .
     
      The creation of the  event  array is completely transparent.
      However, knowledge of the  event  array is required for adding an
      item that does not exist in the default set above.
     
      To add a new item to every future event, call the  setEventItem() 
      method giving a key and a value:

       &lt;?php
$logger-&gt;setEventItem(&#39;pid&#39;, getmypid());
       

      The example above sets a new item named  pid  and populates
      it with the PID of the current process. Once a new item has been
      set, it is available automatically to all writers along with all of the
      other data event data during logging. An item can be overwritten at any
      time by calling the  setEventItem()  method again.
     
      Setting a new event item with  setEventItem()  causes the
      new item to be sent to all writers of the logger. However, this does
      not guarantee that the writers actually record the item. This is
      because the writers won&#39;t know what to do with it unless a formatter
      object is informed of the new item. Please see the section on Formatters
      to learn more.
     Writers 
    A Writer is an object that inherits from  Zend_Log_Writer_Abstract .  A Writer&#39;s
    responsibility is to record log data to a storage backend.
   Writing to Streams Zend_Log_Writer_Stream  sends log
      data to a  PHP stream .
     
      To write log data to the PHP output buffer, use the URL  php://output .  Alternatively,
      you can may like to send log data directly to a stream like  STDERR 
      ( php://stderr ).

       &lt;?php
$writer = new Zend_Log_Writer_Stream(&#39;php://output&#39;);
$logger = new Zend_Log($writer);

$logger-&gt;info(&#39;Informational message&#39;);
       
     
      To write data to a file, use one of the
       Filesystem
      URLs :

       &lt;?php
$writer = new Zend_Log_Writer_Stream(&#39;/path/to/logfile&#39;);
$logger = new Zend_Log($writer);

$logger-&gt;info(&#39;Informational message&#39;);
       

      By default, the stream opens in the append mode ( &quot;a&quot; ).
      To open it with a different mode, the Zend_Log_Writer_Stream constructor
      accepts an optional second parameter for the mode.
     
      The constructor of  Zend_Log_Writer_Stream  also accepts an existing stream resource:

       &lt;?php
$stream = @fopen(&#39;/path/to/logfile&#39;, &#39;a&#39;, false);
if (! $stream) {
    throw new Exception(&#39;Failed to open stream&#39;);
}

$writer = new Zend_Log_Writer_Stream($stream);
$logger = new Zend_Log($writer);

$logger-&gt;info(&#39;Informational message&#39;);
       

      You cannot specify the mode for existing stream resources. Doing so
      causes a  Zend_Log_Exception  to be thrown.
     Writing to Databases Zend_Log_Writer_Db  writes log information to a database table using
       Zend_Db .  The constructor of  Zend_Log_Writer_Db  receives
      a  Zend_Db_Adapter  instance, a table name, and a mapping of database
      columns to event data items:

       &lt;?php
$params = array (&#39;host&#39;     =&gt; &#39;127.0.0.1&#39;,
                 &#39;username&#39; =&gt; &#39;malory&#39;,
                 &#39;password&#39; =&gt; &#39;******&#39;,
                 &#39;dbname&#39;   =&gt; &#39;camelot&#39;);
$db = Zend_Db::factory(&#39;PDO_MYSQL&#39;, $params);

$columnMapping = array(&#39;lvl&#39; =&gt; &#39;priority&#39;, &#39;msg&#39; =&gt; &#39;message&#39;);
$writer = new Zend_Log_Writer_Db($db, &#39;log_table_name&#39;, $columnMapping);

$logger = new Zend_Log($writer);

$logger-&gt;info(&#39;Informational message&#39;);
       

      The example above writes a single row of log data to the database table named
       log_table_name  table.  The database column named  lvl 
      receives the priority number and the column named  msg  receives the
      log message.
     Stubbing Out the Writer 
      The  Zend_Log_Writer_Null  is a stub that does not write log data to anything.
      It is useful for disabling logging or stubbing out logging during tests:

       &lt;?php
$writer = new Zend_Log_Writer_Null;
$logger = new Zend_Log($writer);

// goes nowhere
$logger-&gt;info(&#39;Informational message&#39;);
       
     Testing with the Mock 
      The  Zend_Log_Writer_Mock  is a very simple writer that records
      the raw data it receives in an array exposed as a public property.

       &lt;?php
$mock = new Zend_Log_Writer_Mock;
$logger = new Zend_Log($mock);

$logger-&gt;info(&#39;Informational message&#39;);

var_dump($mock-&gt;events[0]);

// Array
// (
//    [timestamp] =&gt; 2007-04-06T07:16:37-07:00
//    [message] =&gt; Informational message
//    [priority] =&gt; 6
//    [priorityName] =&gt; INFO
// )
       
     
      To clear the events logged by the mock, simply set  $mock-&gt;events = array() .
     Compositing Writers 
      There is no composite Writer object. However, a Log instance can write
      to any number of Writers. To do this, use the  addWriter() 
      method:

       &lt;?php
$writer1 = new Zend_Log_Writer_Stream(&#39;/path/to/first/logfile&#39;);
$writer2 = new Zend_Log_Writer_Stream(&#39;/path/to/second/logfile&#39;);

$logger = new Zend_Log();
$logger-&gt;addWriter($writer1);
$logger-&gt;addWriter($writer2);

// goes to both writers
$logger-&gt;info(&#39;Informational message&#39;);
       
     Adding Recipients 
        Recipients can be added in three ways:
         addTo() : Adds a recipient to the mail with a &quot;To&quot; header addCc() : Adds a recipient to the mail with a &quot;Cc&quot; header addBcc() : Adds a recipient to the mail not visible in the header. 
     Additional parameter addTo()  and  addCc()  accept a second optional parameter that is used as a
            human-readable name of the recipient for the header.
         Additional Headers 
        Arbitrary mail headers can be set by using the  addHeader()  method. It requires two
        parameters containing the name and the value of the header field. A third optional parameter determines
        if the header should have only one or multiple values:
     Adding E-Mail Message Headers &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();
$mail-&gt;addHeader(&#39;X-MailGenerator&#39;, &#39;MyCoolApplication&#39;);
$mail-&gt;addHeader(&#39;X-greetingsTo&#39;, &#39;Mom&#39;, true); // multiple values
$mail-&gt;addHeader(&#39;X-greetingsTo&#39;, &#39;Dad&#39;, true);
         Attachments 
        Files can be attached to an e-mail using the  createAttachment()  method. The default behaviour
        of  Zend_Mail  is to assume the attachment is a binary object (application/octet-stream),
        should be transferred with base64 encoding, and is handled as an attachment. These assumptions can be
        overridden by passing more parameters to  createAttachment() :
     E-Mail Messages with Attachments &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();
// build message...
$mail-&gt;createAttachment($someBinaryString);
$mail-&gt;createAttachment($myImage, &#39;image/gif&#39;, Zend_Mime::DISPOSITION_INLINE, Zend_Mime::ENCODING_8BIT);
         
        If you want more control over the MIME part generated for this attachment you can use the return value
        of  createAttachment()  to modify its attributes. The  createAttachment()  method
        returns a  Zend_Mime_Part  object:
     &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();

$at = $mail-&gt;createAttachment($myImage);
$at-&gt;type        = &#39;image/gif&#39;;
$at-&gt;disposition = Zend_Mime::DISPOSITION_INLINE;
$at-&gt;encoding    = Zend_Mime::ENCODING_8BIT;
$at-&gt;filename    = &#39;test.gif&#39;;

$mail-&gt;send();
     
        An alternative is to create an instance of  Zend_Mime_Part  and add it with  addAttachment() :
     &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();

$at = new Zend_Mime_Part($myImage);
$at-&gt;type        = &#39;image/gif&#39;;
$at-&gt;disposition = Zend_Mime::DISPOSITION_INLINE;
$at-&gt;encoding    = Zend_Mime::ENCODING_8BIT;
$at-&gt;filename    = &#39;test.gif&#39;;

$mail-&gt;addAttachment($at);

$mail-&gt;send();
     Controlling the MIME Boundary 
        In a multipart message a MIME boundary for separating the different parts of the message is normally
        generated at random. In some cases, however, you might want to specify the MIME boundary that is used.
        This can be done using the  setMimeBoundary()  method, as in the following example:
     Changing the MIME Boundary &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();
$mail-&gt;setMimeBoundary(&#39;=_&#39; . md5(microtime(1) . $someId++);
// build message...
         Character Sets Zend_Mail  does not check for the correct character set of the mail parts. When
        instantiating  Zend_Mail , a charset for the e-mail itself may be given. It defaults to
         iso-8859-1 . The application has to make sure that all parts added to that mail object
        have their content encoded in the correct character set. When creating a new mail part, a different
        charset can be given for each part.
     Only in text format 
            Character sets are only applicable for message parts in text format.
         Using Different Transports 
        In case you want to send different e-mails through different connections, you can also pass the
        transport object directly to  send()  without a prior call to
         setDefaultTransport() . The passed object will override the default transport for the
        actual  send()  request:
     Using Different Transports &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();
// build message...
require_once &#39;Zend/Mail/Transport/Smtp.php&#39;;
$tr1 = new Zend_Mail_Transport_Smtp(&#39;server@example.com&#39;);
$tr2 = new Zend_Mail_Transport_Smtp(&#39;other_server@example.com&#39;);
$mail-&gt;send($tr1);
$mail-&gt;send($tr2);
$mail-&gt;send();  // use default again
         Additional transports 
            Additional transports can be written by implementing  Zend_Mail_Transport_Interface .
         Encoding 
        Text and HTML message bodies are encoded with the quotedprintable mechanism by default. All other
        attachments are encoded via base64 if no other encoding is given in the  addAttachment() 
        call or assigned to the MIME part object later. 7Bit and 8Bit encoding currently only pass on the
        binary content data.
     Zend_Mail_Transport_Smtp  encodes lines starting with one dot or two dots so that the mail
        does not violate the SMTP protocol.
     HTML E-Mail 
        To send an e-mail in HTML format, set the body using the method  setBodyHTML()  instead of
         setBodyText() . The MIME content type will automatically be set to  text/html 
        then. If you use both HTML and Text bodies, a multipart/alternative MIME message will automatically be
        generated:
     Sending HTML E-Mail &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();
$mail-&gt;setBodyText(&#39;My Nice Test Text&#39;);
$mail-&gt;setBodyHtml(&#39;My Nice &lt;b&gt;Test&lt;/b&gt; Text&#39;);
$mail-&gt;setFrom(&#39;somebody@example.com&#39;, &#39;Some Sender&#39;);
$mail-&gt;addTo(&#39;somebody_else@example.com&#39;, &#39;Some Recipient&#39;);
$mail-&gt;setSubject(&#39;TestSubject&#39;);
$mail-&gt;send();
         Introduction Getting started Zend_Mail  provides generalized functionality to compose and send both text and MIME-compliant
            multipart e-mail messages. Mail can be sent with  Zend_Mail  via the default  Zend_Mail_Transport_Sendmail 
            transport or via  Zend_Mail_Transport_Smtp .
         Simple E-Mail with Zend_Mail 
                A simple e-mail consists of some recipients, a subject, a body and a sender. To send such a mail using
                 Zend_Mail_Transport_Sendmail , do the following:
             &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();
$mail-&gt;setBodyText(&#39;This is the text of the mail.&#39;);
$mail-&gt;setFrom(&#39;somebody@example.com&#39;, &#39;Some Sender&#39;);
$mail-&gt;addTo(&#39;somebody_else@example.com&#39;, &#39;Some Recipient&#39;);
$mail-&gt;setSubject(&#39;TestSubject&#39;);
$mail-&gt;send();
             Minimum definitions 
                In order to send an e-mail with  Zend_Mail  you have to specify at least one recipient, a
                sender (e.g., with  setFrom() ), and a message body (text and/or HTML).
             
            For most mail attributes there are &quot;get&quot; methods to read the information stored in the mail object. For
            further details, please refer to the API documentation. A special one is  getRecipients() .
            It returns an array with all recipient e-mail addresses that were added prior to the method call.
         
            For security reasons,  Zend_Mail  filters all header fields to prevent header injection with
            newline ( \n ) characters.
         
            You also can use most methods of the  Zend_Mail  object with a convenient fluent interface. A fluent
            interface means that each method returns a reference to the object on which it was called, so you can
            immediately call another method.
         &lt;?php
require_once &#39;Zend/Mail.php&#39;;
$mail = new Zend_Mail();
$mail-&gt;setBodyText(&#39;This is the text of the mail.&#39;)
    -&gt;setFrom(&#39;somebody@example.com&#39;, &#39;Some Sender&#39;)
    -&gt;addTo(&#39;somebody_else@example.com&#39;, &#39;Some Recipient&#39;)
    -&gt;setSubject(&#39;TestSubject&#39;)
    -&gt;send();
         Configuring the default sendmail transport 
            The default transport for a  Zend_Mail  instance is  Zend_Mail_Transport_Sendmail .
            It is essentially a wrapper to the PHP  mail()  function. 
            If you wish to pass additional parameters to the  mail()  function, 
            simply create a new transport instance and pass your parameters to the constructor. The new transport instance
            can then act as the default  Zend_Mail  transport, or it can be passed to the  send() 
            method of  Zend_Mail .
         Passing additional parameters to the Zend_Mail_Transport_Sendmail transport 
                This example shows how to change the Return-Path of the  mail() 
                function.
             &lt;?php
require_once &#39;Zend/Mail.php&#39;;
require_once &#39;Zend/Mail/Transport/Sendmail.php&#39;;

$tr = new Zend_Mail_Transport_Sendmail(&#39;-freturn_to_me@example.com&#39;);
Zend_Mail::setDefaultTransport($tr);

$mail = new Zend_Mail();
$mail-&gt;setBodyText(&#39;This is the text of the mail.&#39;);
$mail-&gt;setFrom(&#39;somebody@example.com&#39;, &#39;Some Sender&#39;);
$mail-&gt;addTo(&#39;somebody_else@example.com&#39;, &#39;Some Recipient&#39;);
$mail-&gt;setSubject(&#39;TestSubject&#39;);
$mail-&gt;send();
             Safe mode restrictions 
                The optional additional parameters will be cause the  mail()  function to fail
                if PHP is running in safe mode.
             Sending Multiple Mails per SMTP Connection 
        By default a single SMTP transport creates a single connection and
        re-uses it for the lifetime of the script execution. You may send multiple
        e-mails through this SMTP connection. A RSET command is issued before each
        delivery to ensure the correct SMTP handshake is followed.
     Sending Multiple Mails per SMTP Connection &lt;?php
// Load classes
require_once &#39;Zend/Mail.php&#39;;

// Create transport
require_once &#39;Zend/Mail/Transport/Smtp.php&#39;;
$transport = new Zend_Mail_Transport_Smtp(&#39;localhost&#39;);

// Loop through messages
for ($i = 0; $i &gt; 5; $i++) {
    $mail = new Zend_Mail();
    $mail-&gt;addTo(&#39;studio@peptolab.com&#39;, &#39;Test&#39;);
    $mail-&gt;setFrom(&#39;studio@peptolab.com&#39;, &#39;Test&#39;);
    $mail-&gt;setSubject(&#39;Demonstration - Sending Multiple Mails per SMTP Connection&#39;);
    $mail-&gt;setBodyText(&#39;...Your message here...&#39;);
    $mail-&gt;send($transport);
}
         
        If you wish to have a separate connection for each mail
        delivery, you will need to create and destroy your transport before and
        after each  send()  method is called. Or alternatively,
        you can manipulate the connection between each delivery by accessing the
        transport&#39;s protocol object.
     Manually controlling the transport connection &lt;?php

// Load classes
require_once &#39;Zend/Mail.php&#39;;

// Create transport
require_once &#39;Zend/Mail/Transport/Smtp.php&#39;;
$transport = new Zend_Mail_Transport_Smtp();

require_once &#39;Zend/Mail/Protocol/Smtp.php&#39;;
$protocol = new Zend_Mail_Protocol_Smtp(&#39;localhost&#39;);
$protocol-&gt;connect();
$protocol-&gt;helo(&#39;localhost&#39;);

$transport-&amp;gt;setConnection($protocol);

// Loop through messages
for ($i = 0; $i &gt; 5; $i++) {
    $mail = new Zend_Mail();
    $mail-&gt;addTo(&#39;studio@peptolab.com&#39;, &#39;Test&#39;);
    $mail-&gt;setFrom(&#39;studio@peptolab.com&#39;, &#39;Test&#39;);
    $mail-&gt;setSubject(&#39;Demonstration - Sending Multiple Mails per SMTP Connection&#39;);
    $mail-&gt;setBodyText(&#39;...Your message here...&#39;);

    // Manually control the connection
    $protocol-&gt;rset();
    $mail-&gt;send($transport);
}

$protocol-&gt;quit();
$protocol-&gt;disconnect();
         Sending via SMTP 
        To send mail via SMTP,  Zend_Mail_Transport_Smtp  needs to be created and registered with
         Zend_Mail  before the  send()  method is called. For all remaining
         Zend_Mail::send()  calls in the current script, the SMTP transport will then be used:
     Sending E-Mail via SMTP &lt;?php
require_once &#39;Zend/Mail/Transport/Smtp.php&#39;;
$tr = new Zend_Mail_Transport_Smtp(&#39;mail.example.com&#39;);
Zend_Mail::setDefaultTransport($tr);
         
        The  setDefaultTransport()  method and the constructor of
         Zend_Mail_Transport_Smtp  are not expensive. These two lines can be processed at script
        setup time (e.g., config.inc or similar) to configure the behaviour of the  Zend_Mail  class
        for the rest of the script. This keeps configuration information out of the application logic - whether
        mail is sent via SMTP or  mail() , what mail server
        to use, etc.
     SMTP Authentication Zend_Mail  supports the use of SMTP Authentication, which
  can be enabled be passing the &#39;auth&#39; parameter to the configuration array in
  the  Zend_Mail_Transport_Smtp  constructor. The available
  built-in Authentication methods are PLAIN, LOGIN and CRAM-MD5 which all
  expect a &#39;username&#39; and &#39;password&#39; value in the configuration array. Enabling authentication within Zend_Mail_Transport_Smtp &lt;?php
require_once &#39;Zend/Mail.php&#39;;
require_once &#39;Zend/Mail/Transport/Smtp.php&#39;;

$config = array(&#39;auth&#39; =&gt; &#39;login&#39;,
                &#39;username&#39; =&gt; &#39;myusername&#39;,
                &#39;password&#39; =&gt; &#39;password&#39;);

$transport = new Zend_Mail_Transport_Smtp(&#39;mail.server.com&#39;, $config);

$mail = new Zend_Mail();
$mail-&gt;setBodyText(&#39;This is the text of the mail.&#39;);
$mail-&gt;setFrom(&#39;sender@test.com&#39;, &#39;Some Sender&#39;);
$mail-&gt;addTo(&#39;recipient@test.com&#39;, &#39;Some Recipient&#39;);
$mail-&gt;setSubject(&#39;TestSubject&#39;);
$mail-&gt;send($transport);
     Authentication types 
        The authentication type is case-insensitive but has no punctuation.
        E.g. to use CRAM-MD5 you would pass &#39;auth&#39; =&gt; &#39;crammd5&#39; in the
         Zend_Mail_Transport_Smtp  constructor. Securing SMTP Transport Zend_Mail  also supports the use of either TLS or SSL to
  secure a SMTP connection. This can be enabled be passing the &#39;ssl&#39; parameter
  to the configuration array in the  Zend_Mail_Transport_Smtp 
  constructor with a value of either &#39;ssl&#39; or &#39;tls&#39;. A port can optionally be
  supplied, otherwise it defaults to 25 for TLS or 465 for SSL. Enabling a secure connection within
    Zend_Mail_Transport_Smtp &lt;?php
require_once &#39;Zend/Mail.php&#39;;
require_once &#39;Zend/Mail/Transport/Smtp.php&#39;;

$config = array(&#39;ssl&#39; =&gt; &#39;tls&#39;,
                &#39;port&#39; =&gt; 25); // Optional port number supplied

$transport = new Zend_Mail_Transport_Smtp(&#39;mail.server.com&#39;, $config);

$mail = new Zend_Mail();
$mail-&gt;setBodyText(&#39;This is the text of the mail.&#39;);
$mail-&gt;setFrom(&#39;sender@test.com&#39;, &#39;Some Sender&#39;);
$mail-&gt;addTo(&#39;recipient@test.com&#39;, &#39;Some Recipient&#39;);
$mail-&gt;setSubject(&#39;TestSubject&#39;);
$mail-&gt;send($transport);
     Reading Mail Messages Zend_Mail  can read mail messages from several local or remote mail storages. All of them have the
        same basic API to count and fetch messages and some of them implement additional interfaces for not so common
        features. For a feature overview of the implemented storages see the following table.
     Mail Read Feature Overview Feature Mbox Maildir Pop3 IMAP Storage type local local remote remote Fetch message Yes Yes Yes Yes Fetch mime-part emulated emulated emulated emulated Folders Yes  Yes No Yes Create message/folder No todo No todo Flags No Yes No Yes Quota No Yes No No Simple example using Pop3 &lt;?php
$mail = new Zend_Mail_Storage_Pop3(array(&#39;host&#39;     =&gt; &#39;localhost&#39;,
                                         &#39;user&#39;     =&gt; &#39;test&#39;,
                                         &#39;password&#39; =&gt; &#39;test&#39;));

echo $mail-&gt;countMessages() . &quot; messages found\n&quot;;
foreach ($mail as $message) {
    echo &quot;Mail from &#39;{$message-&gt;from}&#39;: {$message-&gt;subject}\n&quot;;
}
         Opening a local storage 
            Mbox and Maildir are the two supported formats for local mail storages, both in their most simple formats.
         
            If you want to read from a Mbox file you only need to give the filename to the constructor of
             Zend_Mail_Storage_Mbox :
         &lt;?php
$mail = new Zend_Mail_Storage_Mbox(array(&#39;filename&#39; =&gt; &#39;/home/test/mail/inbox&#39;));
         Maildir is very similar but needs a dirname: &lt;?php
$mail = new Zend_Mail_Storage_Maildir(array(&#39;dirname&#39; =&gt; &#39;/home/test/mail/&#39;));
         Both constructors throw a  Zend_Mail_Exception  if the storage can&#39;t be read. Opening a remote storage 
            For remote storages the two most popular protocols are supported: Pop3 and Imap. Both need at least a host
            and a user to connect and login. The default password is an empty string, the default port as given in the
            protocol RFC.
         &lt;?php
// connecting with Pop3
$mail = new Zend_Mail_Storage_Pop3(array(&#39;host&#39;     =&gt; &#39;example.com&#39;
                                         &#39;user&#39;     =&gt; &#39;test&#39;,
                                         &#39;password&#39; =&gt; &#39;test&#39;));

// connecting with Imap
$mail = new Zend_Mail_Storage_Imap(array(&#39;host&#39;     =&gt; &#39;example.com&#39;
                                         &#39;user&#39;     =&gt; &#39;test&#39;,
                                         &#39;password&#39; =&gt; &#39;test&#39;));

// example for a none standard port
$mail = new Zend_Mail_Storage_Pop3(array(&#39;host&#39;     =&gt; &#39;example.com&#39;,
                                         &#39;port&#39;     =&gt; 1120
                                         &#39;user&#39;     =&gt; &#39;test&#39;,
                                         &#39;password&#39; =&gt; &#39;test&#39;));
         
            For both storages SSL and TLS are supported. If you use SSL the default port changes as given in the RFC.
         &lt;?php
// examples for Zend_Mail_Storage_Pop3, same works for Zend_Mail_Storage_Imap

// use SSL on different port (default is 995 for Pop3 and 993 for Imap)
$mail = new Zend_Mail_Storage_Pop3(array(&#39;host&#39;     =&gt; &#39;example.com&#39;
                                         &#39;user&#39;     =&gt; &#39;test&#39;,
                                         &#39;password&#39; =&gt; &#39;test&#39;,
                                         &#39;ssl&#39;      =&gt; &#39;SSL&#39;));

// use TLS
$mail = new Zend_Mail_Storage_Pop3(array(&#39;host&#39;     =&gt; &#39;example.com&#39;
                                         &#39;user&#39;     =&gt; &#39;test&#39;,
                                         &#39;password&#39; =&gt; &#39;test&#39;,
                                         &#39;ssl&#39;      =&gt; &#39;TLS&#39;));
         
            Both constructors can throw  Zend_Mail_Exception  or  Zend_Mail_Protocol_Exception 
            (extends  Zend_Mail_Exception ), depending on the type of error.
         Fetching messages and simple methods 
            Once you&#39;ve opened the storage messages can be fetched. You need the message number, which is a counter
            starting with 1 for the first message. To fetch the message you use the method  getMessage() :
         &lt;?php
$message = $mail-&gt;getMessage($messageNum);
         
            Array access is also supported, but won&#39;t supported any additional parameters that could be added to
             getMessage() . As long as you don&#39;t mind and can live with defaults you may use:
         &lt;?php
$message = $mail[$messageNum];
         For iterating over all messages the Iterator interface is implemented: &lt;?php
foreach ($mail as $messageNum =&gt; $message) {
    // do stuff ...
}
         
            To count the messages in the storage you can either use the method  countMessages()  or use array
            access:
         &lt;?php
// method
$maxMessage = $mail-&gt;countMessages();

// array access
$maxMessage = count($mail);
         To remove a mail you use the method  removeMessage()  or again array access: &lt;?php
// method
$mail-&gt;removeMessage($messageNum);

// array access
unset($mail[$messageNum]);
         Working with messages After you fetched the messages with  getMessage()  you want to fetch headers, the content
        or single parts of a multipart message. All headers can be accessed via properties or the method
         getHeader()  if you want more control or have unusual header names. The header names are
        lower-cased internally, thus the case of the header name in the mail message doesn&#39;t matter. Also headers
        with a dash can be written in camel-case. &lt;?php
// get the message object
$message = $mail-&gt;getMessage(1);

// output subject of message
echo $message-&gt;subject . &quot;\n&quot;;

// get content-type header
$type = $message-&gt;contentType;
         If you have multiple headers with the same name i.e. the Received headers you might want it as array
        instead of a string, which is possible with the  getHeader()  method. &lt;?php
// get header as property - the result is always a string, with new lines between the single occurrences in the message
$received = $message-&gt;received;

// the same via getHeader() method
$received = $message-&gt;getHeader(&#39;received&#39;, &#39;string&#39;);

// better an array with a single entry for every occurrences
$received = $message-&gt;getHeader(&#39;received&#39;, &#39;array&#39;);
foreach ($received as $line) {
    // do stuff
}

// if you don&#39;t define a format you&#39;ll get the internal representation (string for single headers, array for multiple)
$received = $message-&gt;getHeader(&#39;received&#39;);
if (is_string($received)) {
    // only one received header found in message
}
         The method  getHeaders()  returns all headers as array with the lower-cased name as
        key and the value as array for multiple headers or as string for single headers. &lt;?php
// dump all headers
foreach ($message-&gt;getHeaders() as $name =&gt; $value) {
    if (is_string($value)) {
        echo &quot;$name: $value\n&quot;;
        continue;
    }
    foreach ($value as $entry) {
        echo &quot;$name: $entry\n&quot;;
    }
}
         If you don&#39;t have a multipart message fetching the content is easy done via
         getContent() . Unlike the headers the content is only fetched when needed (aka late-fetch). &lt;?php
// output message content for HTML
echo &#39;&lt;pre&gt;&#39;;
echo $message-&gt;getContent();
echo &#39;&lt;/pre&gt;&#39;;
         Checking for a multipart message is done with the method  isMultipart() . If you have
        multipart message you can get an instance of  Zend_Mail_Part  with the method
         getPart() .  Zend_Mail_Part  is the base class of  Zend_Mail_Message ,
        so you have the same methods:  getHeader() ,  getHeaders() ,  getContent() ,
         getPart() ,  isMultipart  and the properties for headers. &lt;?php
// get the first none multipart part
$part = $message;
while ($part-&gt;isMultipart()) {
    $part = $message-&gt;getPart(1);
}
echo &#39;Type of this part is &#39; . strtok($part-&gt;contentType, &#39;;&#39;) . &quot;\n&quot;;
echo &quot;Content:\n&quot;;
echo $part-&gt;getContent();
         Zend_Mail_Part  also implements  RecursiveIterator , which makes it easy to scan through all parts. And
        for easy output it also implements the magic method  __toString() , which returns the content. &lt;?php
// output first text/plain part
$foundPart = null;
foreach (new RecursiveIteratorIterator($mail-&gt;getMessage(1)) as $part) {
    try {
        if (strtok($part-&gt;contentType, &#39;;&#39;) == &#39;text/plain&#39;) {
            $foundPart = $part;
            break;
        }
    } catch (Zend_Mail_Exception $e) {
        // ignore
    }
}
if (!$foundPart) {
    echo &#39;no plain text part found&#39;;
} else {
    echo &quot;plain text part: \n&quot; . $foundPart;
}
         Checking for flags Maildir and IMAP support storing flags. The class  Zend_Mail_Storage  has constants for all known
        maildir and IMAP system flags, named  Zend_Mail_Storage::FLAG_&lt;flagname&gt; . To check
        for flags  Zend_Mail_Message  has a method called  hasFlag() . With
         getFlags()  you&#39;ll get all set flags. &lt;?php
// find unread messages
echo &quot;Unread mails:\n&quot;;
foreach ($mail as $message) {
    if ($message-&gt;hasFlag(Zend_Mail_Storage::FLAG_SEEN)) {
        continue;
    }
    // mark recent/new mails
    if ($message-&gt;hasFlag(Zend_Mail_Storage::FLAG_RECENT)) {
        echo &#39;! &#39;;
    } else {
        echo &#39;  &#39;;
    }
    echo $message-&gt;subject . &quot;\n&quot;;
}


// check for known flags
$flags = $message-&gt;getFlags();
echo &quot;Message is flagged as: &quot;;
foreach ($flags as $flag) {
    switch ($flag) {
        case Zend_Mail_Storage::FLAG_ANSWERED:
            echo &#39;Answered &#39;;
            break;
        case Zend_Mail_Storage::FLAG_FLAGGED:
            echo &#39;Flagged &#39;;
            break;

        // ...
        // check for other flags
        // ...

        default:
            echo $flag . &#39;(unknown flag) &#39;;
    }
}
         As IMAP allows user or client defined flags you could get flags, that don&#39;t have a constant in
         Zend_Mail_Storage . Instead they are returned as string and can be checked the same way with
         hasFlag() . &lt;?php
// check message for client defined flags $IsSpam, $SpamTested
if (!$message-&gt;hasFlag(&#39;$SpamTested&#39;)) {
    echo &#39;message has not been tested for spam&#39;;
} else if ($message-&gt;hasFlag(&#39;$IsSpam&#39;)) {
    echo &#39;this message is spam&#39;;
} else {
    echo &#39;this message is ham&#39;;
}
         Using folders 
            All storages, except Pop3, support folders, also called mailboxes. The interface implemented by all storages
            supporting folders is called  Zend_Mail_Storage_Folder_Interface . Also all of these classes have an
            additional optional parameter called  folder , which is the folder selected after login, in the constructor.
         
            For the local storages you need to use separate classes called  Zend_Mail_Storage_Folder_Mbox  or
             Zend_Mail_Storage_Folder_Maildir . Both need one parameter called  dirname  with the name of the base dir.
            The format for maildir is as defined in maildir++ (with a dot as default delimiter), Mbox is a directory
            hierarchy with Mbox files. If you don&#39;t have a Mbox file called INBOX in your Mbox base dir you need to set
            an other folder in the constructor.
         Zend_Mail_Storage_Imap  already supports folders by default. Examples for opening these storages:
         &lt;?php
// mbox with folders
$mail = new Zend_Mail_Storage_Folder_Mbox(array(&#39;dirname&#39; =&gt; &#39;/home/test/mail/&#39;));

// mbox with a default folder not called INBOX, also works
// with Zend_Mail_Storage_Folder_Maildir and Zend_Mail_Storage_Imap
$mail = new Zend_Mail_Storage_Folder_Mbox(array(&#39;dirname&#39; =&gt; &#39;/home/test/mail/&#39;,
                                                &#39;folder&#39;  =&gt; &#39;Archive&#39;));

// maildir with folders
$mail = new Zend_Mail_Storage_Folder_Maildir(array(&#39;dirname&#39; =&gt; &#39;/home/test/mail/&#39;));

// maildir with colon as delimiter, as suggested in Maildir++
$mail = new Zend_Mail_Storage_Folder_Maildir(array(&#39;dirname&#39; =&gt; &#39;/home/test/mail/&#39;
                                                   &#39;delim&#39;   =&gt; &#39;:&#39;));

// imap is the same with and without folders
$mail = new Zend_Mail_Storage_Imap(array(&#39;host&#39;     =&gt; &#39;example.com&#39;
                                         &#39;user&#39;     =&gt; &#39;test&#39;,
                                         &#39;password&#39; =&gt; &#39;test&#39;));
         
            With the method getFolders($root = null) you can get the folder hierarchy starting with the root folder or
            the given folder. It&#39;s returned as instance of  Zend_Mail_Storage_Folder , which implements
             RecursiveIterator  and all children are also instances of  Zend_Mail_Storage_Folder . Each of
            these instances has a local and a global name returned by the methods  getLocalName()  and
             getGlobalName() . The global name is the absolute name from the root folder (including
            delimiters), the local name is the name in the parent folder.
         Mail Folder Names Global Name Local Name /INBOX INBOX /Archive/2005 2005 List.ZF.General General 
            If you use the iterator the key of the current element is the local name. The global name is also returned
            by the magic method  __toString() . Some folders may not be selectable, which means they can&#39;t
            store messages and selecting them results in an error. This can be checked with the method
             isSelectable() . So it&#39;s very easy to output the whole tree in a view:
         &lt;?php
$folders = new RecursiveIteratorIterator($this-&gt;mail-&gt;getFolders(),
                                         RecursiveIteratorIterator::SELF_FIRST);
echo &#39;&lt;select name=&quot;folder&quot;&gt;&#39;;
foreach ($folders as $localName =&gt; $folder) {
    $localName = str_pad(&#39;&#39;, $folders-&gt;getDepth(), &#39;-&#39;, STR_PAD_LEFT) . $localName;
    echo &#39;&lt;option&#39;;
    if (!$folder-&gt;isSelectable()) {
        echo &#39; disabled=&quot;disabled&quot;&#39;;
    }
    echo &#39; value=&quot;&#39; . htmlspecialchars($folder) . &#39;&quot;&gt;&#39;
        . htmlspecialchars($localName) . &#39;&lt;/option&gt;&#39;;
}
echo &#39;&lt;/select&gt;&#39;;
         
            The current selected folders is returned by the method  getSelectedFolder() . Changing the folder
            is done with the method  selectFolder() , which needs the global name as parameter. If you want
            to avoid to write delimiters you can also use the properties of a  Zend_Mail_Storage_Folder  instance:
         &lt;?php
// depending on your mail storage and its settings $rootFolder-&gt;Archive-&gt;2005
// is the same as:
//   /Archive/2005
//  Archive:2005
//  INBOX.Archive.2005
//  ...
$folder = $mail-&gt;getFolders()-&gt;Archive-&gt;2005;
echo &#39;Last folder was &#39; . $mail-&gt;getSelectedFolder() . &quot;new folder is $folder\n&quot;;
$mail-&gt;selectFolder($folder);
         Advanced Use Using NOOP 
                If you&#39;re using a remote storage and have some long tasks you might need to keep the connection alive
                via noop:
             &lt;?php
foreach ($mail as $message) {

    // do some calculations ...

    $mail-&gt;noop(); // keep alive

    // do something else ...

    $mail-&gt;noop(); // keep alive
}
             Caching instances Zend_Mail_Storage_Mbox ,  Zend_Mail_Storage_Folder_Mbox ,  Zend_Mail_Storage_Maildir  and
             Zend_Mail_Storage_Folder_Maildir  implement the magic methods  __sleep()  and
             __wakeup() , which means they are serializable. This avoids parsing the files or directory tree
            more than once. The disadvantage is that your Mbox or Maildir storage should not change. Some easy checks
            are done, like reparsing the current Mbox file if the modification time changes or reparsing the folder
            structure if a folder has vanished (which still results in an error, but you can search for an other folder
            afterwards). It&#39;s better if you have something like a signal file for changes and check it before using the
            cached instance.
             &lt;?php
// there&#39;s no specific cache handler/class used here,
// change the code to match your cache handler
$signal_file = &#39;/home/test/.mail.last_change&#39;;
$mbox_basedir = &#39;/home/test/mail/&#39;;
$cache_id = &#39;example mail cache &#39; . $mbox_basedir . $signal_file;

$cache = new Your_Cache_Class();
if (!$cache-&gt;isCached($cache_id) || filemtime($signal_file) &gt; $cache-&gt;getMTime($cache_id)) {
    $mail = new Zend_Mail_Storage_Folder_Pop3(array(&#39;dirname&#39; =&gt; $mbox_basedir));
} else {
    $mail = $cache-&gt;get($cache_id);
}

// do stuff ...

$cache-&gt;set($cache_id, $mail);
             Extending Protocol Classes 
                Remote storages use two classes:  Zend_Mail_Storage_&lt;Name&gt;  and
                 Zend_Mail_Protocol_&lt;Name&gt; . The protocol class translates the protocol commands and
                responses from and to PHP, like methods for the commands or variables with different structures for
                data. The other/main class implements the common interface.
             
                If you need additional protocol features you can extend the protocol class and use it in the
                constructor of the main class. As an example assume we need to knock different ports before we can
                connect to POP3.
             &lt;?php
require_once &#39;Zend/Loader.php&#39;;
Zend_Loader::loadClass(&#39;Zend_Mail_Storage_Pop3&#39;);

class Example_Mail_Exception extends Zend_Mail_Exception
{
}

class Example_Mail_Protocol_Exception extends Zend_Mail_Protocol_Exception
{
}

class Example_Mail_Protocol_Pop3_Knock extends Zend_Mail_Protocol_Pop3
{
    private $host, $port;

    public function __construct($host, $port = null)
    {
        // no auto connect in this class
        $this-&gt;host = $host;
        $this-&gt;port = $port;
    }

    public function knock($port)
    {
        $sock = @fsockopen($this-&gt;host, $port);
        if ($sock) {
            fclose($sock);
        }
    }

    public function connect($host = null, $port = null, $ssl = false)
    {
        if ($host === null) {
            $host = $this-&gt;host;
        }
        if ($port === null) {
            $port = $this-&gt;port;
        }
        parent::connect($host, $port);
    }
}

class Example_Mail_Pop3_Knock extends Zend_Mail_Storage_Pop3
{
    public function __construct(array $params)
    {
        // ... check $params here! ...
        $protocol = new Example_Mail_Protocol_Pop3_Knock($params[&#39;host&#39;]);

        // do our &quot;special&quot; thing
        foreach ((array)$params[&#39;knock_ports&#39;] as $port) {
            $protocol-&gt;knock($port);
        }

        // get to correct state
        $protocol-&gt;connect($params[&#39;host&#39;], $params[&#39;port&#39;]);
        $protocol-&gt;login($params[&#39;user&#39;], $params[&#39;password&#39;]);

        // initialize parent
        parent::__construct($protocol);
    }
}

$mail = new Example_Mail_Pop3_Knock(array(&#39;host&#39;        =&gt; &#39;localhost&#39;,
                                          &#39;user&#39;        =&gt; &#39;test&#39;,
                                          &#39;password&#39;    =&gt; &#39;test&#39;,
                                          &#39;knock_ports&#39; =&gt; array(1101, 1105, 1111)));
             
                As you see we always assume we&#39;re connected, logged in and, if supported, a folder is selected in the
                constructor of the main class. Thus if you assign your own protocol class you always need to make sure
                that&#39;s done or the next method will fail if the server doesn&#39;t allow it in the current state.
             Using Quota (since 1.5) Zend_Mail_Storage_Writable_Maildir  has support for Maildir++ quotas. It&#39;s disabled by default,
            but it&#39;s possible to use it manually, if the automatic checks are not desired (this means 
             appendMessage() ,  removeMessage()  and  copyMessage()  do no checks
            and do not add entry to the maildirsize file). If enabled an exception is thrown if you try to write
            to the maildir if it&#39;s already over quota.
             
            There are three methods used for quotas:  getQuota() ,  setQuota()  and 
             checkQuota() :
             &lt;?php
$mail = new Zend_Mail_Storage_Writable_Maildir(array(&#39;dirname&#39; =&gt; &#39;/home/test/mail/&#39;));
$mail-&gt;setQuota(true); // true to enable, false to disable
echo &#39;Quota check is now &#39;, $mail-&gt;getQuota() ? &#39;enabled&#39; : &#39;disabled&#39;, &quot;\n&quot;;
// check quota can be used even if quota checks are disabled
echo &#39;You are &#39;, $mail-&gt;checkQuota() ? &#39;over quota&#39; : &#39;not over quota&#39;, &quot;\n&quot;;
             checkQuota()  can also return a more detailed response:
             &lt;?php
$quota = $mail-&gt;checkQuota(true);
echo &#39;You are &#39;, $quota[&#39;over_quota&#39;] ? &#39;over quota&#39; : &#39;not over quota&#39;, &quot;\n&quot;;
echo &#39;You have &#39;, $quota[&#39;count&#39;], &#39; of &#39;, $quota[&#39;quota&#39;][&#39;count&#39;], &#39; messages and use &#39;;
echo $quota[&#39;size&#39;], &#39; of &#39;, $quota[&#39;quota&#39;][&#39;size&#39;], &#39; octets&#39;;
             
            If you want to specify your own quota instead of using the one specified in the maildirsize file you
            can do with  setQuota() :
             &lt;?php
// message count and octet size supported, order does matter
$quota = $mail-&gt;setQuota(array(&#39;size&#39; =&gt; 10000, &#39;count&#39; =&gt; 100));
             
            To add your own quota checks use single letters as key and they are preserved (but obviously not checked).
            It&#39;s also possible to extend   Zend_Mail_Storage_Writable_Maildir  to define your own quota only
            if the maildirsize file is missing (which can happen in Maildir++):
             &lt;?php
class Example_Mail_Storage_Maildir extends Zend_Mail_Storage_Writable_Maildir {
	// getQuota is called with $fromStorage = true by quota checks
	public function getQuota($fromStorage = false) {
		try {
			return parent::getQuota($fromStorage);
		} catch (Zend_Mail_Storage_Exception $e) {
			if (!$fromStorage) {
				// unknown error:
				throw $e;
			}
			// maildirsize file must be missing
			
			list($count, $size) = get_quota_from_somewhere_else();
			return array(&#39;count&#39; =&gt; $count, &#39;size&#39; =&gt; $size);
		}
	}
}
             Creation of Measurements 
        When creating a measurement object,  Zend_Measure_*  methods expect the input/original measurement
        data value as the first parameter. This can be a
         numeric argument 
        , a
         string 
        without units, or a
         localized string  with unit(s) specified.
         
        The second parameter defines the type of the measurement. Both parameters are mandatory. The language may
        optionally be specified as the third parameter.
     Creating measurements from integers and floats 
            In addition to integer data values, floating point types may be used, but
             &quot;simple decimal fractions like 0.1 or 0.7 cannot be converted into their internal binary counterparts without a little loss of precision,&quot; 
            sometimes giving surprising results. Also, do not compare two &quot;float&quot; type numbers for equality.
         Creation using integer and floating values &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

$measurement = 1234.7;
$unit = new Zend_Measure_Length((integer)$measurement, Zend_Measure_Length::STANDARD);
echo $unit;
// outputs &#39;1234 m&#39; (meters)

$unit = new Zend_Measure_Length($measurement, Zend_Measure_Length::STANDARD);
echo $unit;
// outputs &#39;1234.7 m&#39; (meters)
             Creating measurements from strings 
            Many measurements received as input to ZF applications can only be passed to  Zend_Measure_* 
            classes as strings, such as numbers written using
             roman numerals 
            or extremely large binary values that exceed the precision of PHP&#39;s native integer and float types. Since
            integers can be denoted using strings, if there is any risk of losing precision due to limitations of PHP&#39;s
            native integer and float types, using strings instead.  Zend_Measure_Number  uses the BCMath
            extension to support arbitrary precision, as shown in the example below, to avoid limitations in many PHP
            functions, such as
             bin2dec() 
            .
         Creation using strings &lt;?php
require_once &#39;Zend/Measure/Number.php&#39;;

$mystring = &quot;10010100111010111010100001011011101010001&quot;;
$unit = new Zend_Measure_Number($mystring, Zend_Measure_Number::BINARY);

echo $unit;
             
            Usually,  Zend_Measure_*  can automatically extract the desired measurement embedded in an
            arbitrary string. Only the first identifiable number denoted using standard European/Latin digits
            (0,1,2,3,4,5,6,7,8,9) will be used for measurement creation. If there are more numerals later in the string,
            the rest of these numerals will be ignored.
         Arbitrary text input containing measurements &lt;?php
require_once &#39;Zend/Measure/Area.php&#39;;

$mystring = &quot;My house is 125mÂ² in size&quot;;
$unit = new Zend_Measure_Area($mystring, Zend_Measure_Area::STANDARD);
echo $unit; // outputs &quot;125 mÂ²in size&quot;;

$mystring = &quot;My house is 125mÂ² in size, it has 5 rooms of 25mÂ² each.&quot;;
$unit = new Zend_Measure_Area($mystring, Zend_Measure_Area::STANDARD);
echo $unit; // outputs &quot;125 mÂ² in size&quot;;
             Measurements from localized strings 
            When a string is entered in a localized notation, the correct interpretation can not be determined without
            knowing the intended locale. The division of decimal digits with &quot;.&quot; and grouping of thousands with &quot;,&quot; is
            common in the English language, but not so in other languages. For example, the English number &quot;1,234.50&quot;
            would be interpreted as meaning &quot;1.2345&quot; in German. To deal with such problems, the locale-aware
             Zend_Measure_*  family of classes offer the possibility to specify a language or region to
            disambiguate the input data and properly interpret the intended semantic value.
         Localized string &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

$locale = new Zend_Locale(&#39;de&#39;);
$mystring = &quot;The boat is 1,234.50 long.&quot;;
$unit = new Zend_Measure_Length($mystring, Zend_Measure_Length::STANDARD, $locale);
echo $unit; // outputs &quot;1.234 m&quot;


$mystring = &quot;The boat is 1,234.50 long.&quot;;
$unit = new Zend_Measure_Length($mystring, Zend_Measure_Length::STANDARD, &#39;en_US&#39;);
echo $unit; // outputs &quot;1234.50 m&quot;
             Manipulating Measurements 
        Parsing and normalization of input, combined with output to localized notations makes data accessible to users
        in different locales. Many additional methods exist in  Zend_Measure_*  components to manipulate and
        work with this data, after it has been normalized.
     Convert Add and subtract Compare to boolean Compare to greater/smaller Manually change values Manually change types Convert 
            Probably the most important feature is the conversion into different units of measurement. The conversion of
            a unit can be done any number of times using the method  convertTo() . Units of measurement can
            only be converted to other units of the same type (class). Therefore, it is not possible to convert (e.g.) a
            length into a weight, which would might encourage poor programming practices and allow errors to propagate
            without exceptions.
         
            The  convertTo  method accepts an optional parameter. With this parameter you can define
            an precision for the returned output. The standard precision is &#39; 2 &#39;.
         Convert &lt;?php
require_once &#39;Zend/Measure/Weight.php&#39;;

$locale = new Zend_Locale(&#39;de&#39;);
$mystring = &quot;1.234.567,89&quot;;
$unit = new Zend_Measure_Weight($mystring,&#39;POND&#39;, $locale);

print &quot;Kilo:&quot;.$unit-&gt;convertTo(&#39;KILOGRAM&#39;);

// constants are considered &quot;better practice&quot; than strings
print &quot;Ton:&quot;.$unit-&gt;convertTo(Zend_Measure_Weight::TON);

// define a precision for the output
print &quot;Ton:&quot;.$unit-&gt;convertTo(Zend_Measure_Weight::TON, 3);
             Add and subtract 
            Measurements can be added together using  add()  and subtracted using  sub() . Each
            addition will create a new object for the result. The actual object will never be changed by the class. The
            new object will be of the same type as the originating object. Dynamic objects support a fluid style of
            programming, where complex sequences of operations can be nested without risk of side-effects altering the
            input objects.
         Adding units &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

// Define objects
$unit = new Zend_Measure_Length(200, Zend_Measure_Length::CENTIMETER);
$unit2 = new Zend_Measure_Length(1, Zend_Measure_Length::METER);

// Add $unit2 to $unit
$sum = $unit-&gt;add($unit2);

echo $sum; // outputs &quot;300 cm&quot;
                 Automatic conversion 
                Adding one object to another will automatically convert it to the correct unit. It is not neccessary to
                call
                 convertTo() 
                before adding different units.
             Subtract 
                    Subtraction of measurements works just like addition.
                 &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

// Define objects
$unit = new Zend_Measure_Length(200, Zend_Measure_Length::CENTIMETER);
$unit2 = new Zend_Measure_Length(1, Zend_Measure_Length::METER);

// Subtract $unit2 from $unit
$sum = $unit-&gt;sub($unit2);

echo $sum;
                 Compare 
            Measurements can also be compared, but without automatic unit conversion. Thus,  equals() 
            returns  TRUE , only if both the value and the unit of measure are identical.
         Different measurements &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

// Define measurements
$unit = new Zend_Measure_Length(100, Zend_Measure_Length::CENTIMETER);
$unit2 = new Zend_Measure_Length(1, Zend_Measure_Length::METER);

if ($unit-&gt;equals($unit2)) {
    print &quot;Both measurements are identical&quot;;
} else {
    print &quot;These are different measurements&quot;;
}
                 Identical measurements &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

// Define measurements
$unit = new Zend_Measure_Length(100, Zend_Measure_Length::CENTIMETER);
$unit2 = new Zend_Measure_Length(1, Zend_Measure_Length::METER);

$unit2-&gt;setType(Zend_Measure_Length::CENTIMETER);

if ($unit-&gt;equals($unit2)) {
    print &quot;Both measurements are identical&quot;;
} else {
    print &quot;These are different measurements&quot;;
}
                 Compare 
            To determine if a measurement is less than or greater than another, use  compare() , which
            returns 0, -1 or 1 depending on the difference between the two objects. Identical measurements will return
            0. Lesser ones will return a negative, greater ones a positive value.
         Difference &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

$unit = new Zend_Measure_Length(100, Zend_Measure_Length::CENTIMETER);
$unit2 = new Zend_Measure_Length(1, Zend_Measure_Length::METER);
$unit3 = new Zend_Measure_Length(1.2, Zend_Measure_Length::METER);

print &quot;Equal:&quot;.$unit2-&gt;compare($unit);
print &quot;Lesser:&quot;.$unit2-&gt;compare($unit3);
print &quot;Greater:&quot;.$unit3-&gt;compare($unit2);
                 Manually change values 
            To change the value of a measurement explicitly, use  setValue() . to overwrite the current
            value. The parameters are the same as the constructor.
         Changing a value &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

$locale = new Zend_Locale(&#39;de_AT&#39;);
$unit = new Zend_Measure_Length(1,Zend_Measure_Length::METER);

$unit-&gt;setValue(1.2);
echo $unit;

$unit-&gt;setValue(1.2, Zend_Measure_Length::KILOMETER);
echo $unit;

$unit-&gt;setValue(&quot;1.234,56&quot;, Zend_Measure_Length::MILLIMETER,$locale);
echo $unit;
                 Manually change types 
            To change the type of a measurement without altering its value use  setType() .
         Changing the type &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

$unit = new Zend_Measure_Length(1,Zend_Measure_Length::METER);
echo $unit; // outputs &quot;1 m&quot;

$unit-&gt;setType(Zend_Measure_Length::KILOMETER);
echo $unit; // outputs &quot;1000 km&quot;
             Introduction Zend_Measure_*  classes provide a generic and easy way for working with measurements. Using
         Zend_Measure_*  classes, you can convert measurements into different units of the same type. They
        can be added, subtracted and compared against each other. From a given input made in the user&#39;s native language,
        the unit of measurement can be automatically extracted. Numerous units of measurement are supported.
     Converting measurements 
            The following introductory example shows automatic conversion of units of measurement. To convert a
            measurement, its value and its type have to be known. The value can be an integer, a float, or even a string
            containing a number. Conversions are only possible for units of the same type (mass, area, temperature,
            velocity, etc.), not between types.
         &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

$locale = new Zend_Locale(&#39;en&#39;);
$unit = new Zend_Measure_Length(100, Zend_Measure_Length::METER, $locale);

// Convert meters to yards
echo $unit-&gt;convertTo(Zend_Measure_Length::YARD);
         Zend_Measure_*  includes support for many different units of measurement. The units of measurement
        all have a unified notation:  Zend_Measure_&lt;TYPE&gt;::NAME_OF_UNIT , where &lt;TYPE&gt;
        corresponds to a well-known physical or numerical property. . Every unit of measurement consists of a conversion
        factor and a display unit. A detailed list can be found in the chapter
         Types of measurements 
        .
     The  meter  measurement 
            The  meter  is used for measuring lengths, so its type constant can be found in the
             Length  class. To refer to this unit of measurement, the notation  Length::METER 
            must be used. The display unit is  m .
         &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

echo Zend_Measure_Length::STANDARD;  // outputs &#39;Length::METER&#39;
echo Zend_Measure_Length::KILOMETER; // outputs &#39;Length::KILOMETER&#39;

$unit = new Zend_Measure_Length(100,&#39;METER&#39;);
echo $unit;
// outputs &#39;100 m&#39;
         Outputting measurements 
        Measurements can be output in a number of different ways.
     Automatic output Outputting values Output with unit of measurement Output as localized string Automatic output Zend_Measure  supports outputting of strings automatically.
             Automatic output &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

$locale = new Zend_Locale(&#39;de&#39;);
$mystring = &quot;1.234.567,89 Meter&quot;;
$unit = new Zend_Measure_Length($mystring,Zend_Measure_Length::STANDARD, $locale);

echo $unit;
                 
         Measurement output 
                Output can be achieved simply by using
                 echo 
                or
                 print 
                .
             Outputting values 
            The value of a measurement can be output using  getValue() .
             Output a value &lt;?php
require_once &#39;Zend/Measure/Length.php&#39;;

$locale = new Zend_Locale(&#39;de&#39;);
$mystring = &quot;1.234.567,89 Meter&quot;;
$unit = new Zend_Measure_Length($mystring,Zend_Measure_Length::STANDARD, $locale);

echo $unit-&gt;getValue();
                 
         
            The  getValue()  method accepts an optional parameter &#39; round &#39; which allows to
            define a precision for the generated output. The standard precision is &#39; 2 &#39;.
         Output with unit of measurement 
            The function  getType()  returns the current unit of measurement.
             Outputting units &lt;?php
require_once &#39;Zend/Measure/Weight.php&#39;;

$locale = new Zend_Locale(&#39;de&#39;);
$mystring = &quot;1.234.567,89&quot;;
$unit = new Zend_Measure_Weight($mystring,Zend_Measure_Weight::POUND, $locale);

echo $unit-&gt;getType();
                 
         Output as localized string 
            Outputtig a string in a format common in the users&#39; country is usually desirable. For example, the
            measurement &quot;1234567.8&quot; would become &quot;1.234.567,8&quot; for Germany. This functionality will be supported in a
            future release.
         Types of measurements 
        All supported measurement types are listed below, each with an example of the standard usage for such
        measurements.
     List of measurement types Typ Class Standardunit Description Acceleration Zend_Measure_Acceleration Meter per square second |  m/sÂ² 
                     Zend_Measure_Acceleration  covers the
                            physical factor of acceleration.
                         Angle Zend_Measure_Angle Radiant |  rad 
                     Zend_Measure_Angle  covers angular dimensions. Area Zend_Measure_Area Square meter |  mÂ² 
                     Zend_Measure_Area  covers square measures. Binary Zend_Measure_Binary Byte |  b 
                     Zend_Measure_Binary  covers binary convertions. Capacitance Zend_Measure_Capacitance Farad |  F 
                     Zend_Measure_Capacitance  covers physical factor of capacitance.
                         Cooking volumes Zend_Measure_Cooking_Volume Cubic meter |  mÂ³ 
                     Zend_Measure_Cooking_Volume  covers volumes
                            which are used for cooking or written in cookbooks.
                         Cooking weights Zend_Measure_Cooking_Weight Gram |  g 
                     Zend_Measure_Cooking_Weight  covers the weights
                            which are used for cooking or written in cookbooks.
                         Current Zend_Measure_Current Ampere |  A 
                     Zend_Measure_Current  covers the physical factor of current.
                         Density Zend_Measure_Density Kilogram per cubic meter |  kg/mÂ³ 
                     Zend_Measure_Density  covers the physical factor of density.
                         Energy Zend_Measure_Energy Joule |  J 
                     Zend_Measure_Energy  covers the physical factor of energy.
                         Force Zend_Measure_Force Newton |  N 
                     Zend_Measure_Force  covers the physical factor of force.
                         Flow (mass) Zend_Measure_Flow_Mass Kilogram per second |  kg/s 
                     Zend_Measure_Flow_Mass  covers the physical factor of flow rate.
                            The weight of the flowing mass is used as reference point within this class.
                         Flow (mole) Zend_Measure_Flow_Mole Mole per second |  mol/s 
                     Zend_Measure_Flow_Mole  covers the physical factor of flow rate.
                            The density of the flowing mass is used as reference point within this class.
                         Flow (volume) Zend_Measure_Flow_Volume Cubic meter per second |  mÂ³/s 
                     Zend_Measure_Flow_Volume  covers the physical factor of flow rate.
                            The volume of the flowing mass is used as reference point within this class.
                         Frequency Zend_Measure_Frequency Hertz |  Hz 
                     Zend_Measure_Frequency  covers the physical factor of frequency.
                         Illumination Zend_Measure_Illumination Lux |  lx 
                     Zend_Measure_Illumination  covers the physical factor of light density.
                         Length Zend_Measure_Length Meter |  m 
                     Zend_Measure_Length  covers the physical factor of length.
                         Lightness Zend_Measure_Lightness Candela per square meter |  cd/mÂ² 
                     Zend_Measure_Ligntness  covers the physical factor of light energy.
                         Number Zend_Measure_Number Decimal |  (10) 
                     Zend_Measure_Number  converts between number formats.
                         Power Zend_Measure_Power Watt |  W 
                     Zend_Measure_Power  covers the physical factor of power.
                         Pressure Zend_Measure_Pressure Newton per square meter |  N/mÂ² 
                     Zend_Measure_Pressure  covers the physical factor of pressure.
                         Speed Zend_Measure_Speed Meter per second |  m/s 
                     Zend_Measure_Speed  covers the physical factor of speed.
                         Temperature Zend_Measure_Temperature Kelvin |  K 
                     Zend_Measure_Temperature  covers the physical factor of temperature.
                         Torque Zend_Measure_Torque Newton meter |  Nm 
                     Zend_Measure_Torque  covers the physical factor of torque.
                         Viscosity (dynamic) Zend_Measure_Viscosity_Dynamic Kilogram per meter second |  kg/ms 
                     Zend_Measure_Viscosity_Dynamic  covers the physical factor of viscosity.
                            The weight of the fluid is used as reference point within this class.
                         Viscosity (kinematic) Zend_Measure_Viscosity_Kinematic Square meter per second |  mÂ²/s 
                     Zend_Measure_Viscosity_Kinematic  covers the physical factor of viscosity.
                            The distance of the flown fluid is used as reference point within this class.
                         Volume Zend_Measure_Volume Cubic meter |  mÂ³ 
                     Zend_Measure_Volume  covers the physical factor of volume (content).
                         Weight Zend_Measure_Weight Kilogram |  kg 
                     Zend_Measure_Weight  covers the physical factor of weight.
                         Hints for Zend_Measure_Binary 
            Some popular binary conventions, include terms like kilo-, mega-, giga, etc. in normal language use imply
            base 10, such as 1000 or 10Â³. However, in the binary format for computers these terms have to be seen for a
            convertion factor of 1024 instead of 1000. To preclude confusions a few years ago the notation BI was
            introduced. Instead of kilobyte, kibibyte for kilo-binary-byte should be used.
         
            In the class BINARY both notations can be found, such as  KILOBYTE = 1024 - binary conputer conversion
            KIBIBYTE = 1024 - new notation KILO_BINARY_BYTE = 1024 - new , or the notation, long format
             KILOBYTE_SI = 1000 - SI notation for kilo (1000) . DVDs for example are marked with the
            SI-notation, but almost all harddisks are marked in computer binary notation.
         Hints for Zend_Measure_Number 
            The best known number format is the decimal system. Additionaly this class supports the octal system, the
            hexadecimal system, the binary system, the roman number system and some other less popular systems. Note
            that only the decimal part of numbers is handled. Any fractional part will be stripped.
         Roman numbers 
            For the roman numbersystem digits greater 4000 are supported. In reality these digits are shown with a
            crossbeam on top of the digit. As the crossbeam can not be shown within the computer, an underline has to be
            used instead of it.
         &lt;?php
require_once &#39;Zend/Measure/Number.php&#39;;

$great = &#39;_X&#39;;
$locale = new Zend_Locale(&#39;en&#39;);
$unit = new Zend_Measure_Number($great,Zend_Measure_Number::ROMAN, $locale);

// convert to the decimal system
echo $unit-&gt;convertTo(Zend_Measure_Number::DECIMAL);
         Memory Manager Creating a Memory Manager 
            You can create new a memory manager
            ( Zend_Memory_Manager  object) using the
             Zend_Memory::factory($backendName [, $backendOprions]) 
            method.
         
            The first argument  $backendName  is a string that
            names one of the backend implementations supported by Zend_Cache.
         
            The second argument  $backendOptions  is an optional
            backend options array.
         &lt;?php
$backendOptions = array(
    &#39;cache_dir&#39; =&gt; &#39;./tmp/&#39; // Directory where to put the swapped memory blocks
);

$memoryManager = Zend_Memory::factory(&#39;File&#39;, $backendOptions);
         
            Zend_Memory uses  Zend_Cache backends 
            as storage providers.
         
            You may use the special name &#39; None &#39; as a backend name,
            in addition to standard Zend_Cache backends.

             &lt;?php
$memoryManager = Zend_Memory::factory(&#39;None&#39;);
             
         
            If you use &#39; None &#39; as the backend name, then the memory
            manager never swaps memory blocks.  This is useful if you know that
            memory is not limited or the overall size of objects never reaches
            the memory limit.
         
            The &#39; None &#39; backend doesn&#39;t need any option specified.
         Managing Memory Objects 
            This section describes creating and destroying objects in the
            managed memory, and settings to control memory manager behavior.
         Creating Movable Objects 
                Create movable objects (objects, which may be swapped) using
                the  Zend_Memory_Manager::create([$data])  method:
                 &lt;?php
$memObject = $memoryManager-&gt;create($data);
                 

             
                The  $data  argument is optional and used to
                initialize the object value.  If the  $data 
                argument is omitted, the value is an empty string.
             Creating Locked Objects 
                Create locked objects (objects, which are not swapped) using
                the  Zend_Memory_Manager::createLocked([$data])  method:
                 &lt;?php
$memObject = $memoryManager-&gt;createLocked($data);
                 
             
                The  $data  argument is optional and used to
                initialize the object value.  If the  $data 
                argument is omitted, the value is an empty string.
             Destroying Objects 
                Memory objects are automatically destroyed and removed from
                memory when they go out of scope:

                 &lt;?php
function foo()
{
    global $memoryManager, $memList;

    ...

    $memObject1 = $memoryManager-&gt;create($data1);
    $memObject2 = $memoryManager-&gt;create($data2);
    $memObject3 = $memoryManager-&gt;create($data3);

    ...

    $memList[] = $memObject3;

    ...

    unset($memObject2); // $memObject2 is destroyed here

    ...
    // $memObject1 is destroyed here
    // but $memObject2 object is still referenced by $memList and is not destroyed
}
                 
             
                This applies to both movable and locked objects.
             Memory Manager Settings Memory Limit 
                Memory limit is a number of bytes allowed to be used by loaded
                movable objects.
             
                If loading or creation of an object causes memory usage to
                exceed of this limit, then the memory manager swaps some other
                objects.
             
                You can retrieve or set the memory limit setting using the
                 getMemoryLimit()  and  setMemoryLimit($newLimit) 
                methods:
                 &lt;?php
$oldLimit = $memoryManager-&gt;getMemoryLimit();  // Get memory limit in bytes
$memoryManager-&gt;setMemoryLimit($newLimit);     // Set memory limit in bytes
                 
             
                A negative value for memory limit means &#39;no limit&#39;.
             
                The default vaule is two-thirds of the value of
                &#39; memory_limit &#39; in php.ini or &#39;no limit&#39; (-1)
                if &#39; memory_limit &#39; is not set in php.ini.
             MinSize 
                MinSize is a minimal size of memory objects, which may be
                swapped by memory manager.  The memory manager does not swap
                objects that are smaller than this value.  This reduces the
                number of swap/load operations.
             
                You can retrieve or set the minimum size using the
                 getMinSize()  and  setMinSize($newSize) 
                methods:
                 &lt;?php
$oldMinSize = $memoryManager-&gt;getMinSize();  // Get MinSize in bytes
$memoryManager-&gt;setMinSize($newSize);        // Set MinSize limit in bytes
                 
             
                The default minimum size value is 16KB (16384 bytes).
             Memory Objects Movable 
            Create movable memory objects using the  create([$data]) 
            method of the memory manager:
             &lt;?php
$memObject = $memoryManager-&gt;create($data);
             
         
            &quot;Movable&quot; means that such objects may be swapped and unloaded from
            memory and then loaded when application code accesses the object.
         Locked 
            Create locked memory objects using the  createLocked([$data]) 
            method of the memory manager:
             &lt;?php
$memObject = $memoryManager-&gt;createLocked($data);
             
         
            &quot;Locked&quot; means that such objects are never swapped and unloaded
            from memory.
         
            Locked objects provides the same interface as movable objects
            ( Zend_Memory_Container_Interface ).
            So locked object can be used in any place instead of movable objects.
         
            It&#39;s useful if an application or developer can decide, that some
            objects should never be swapped, based on performance considerations.
         
            Access to locked objects is faster, because the memory manager doesn&#39;t
            need to track changes for these objects.
         
            The locked objects class ( Zend_Memory_Container_Locked )
            guarantees virtually the same performance as working with a string
            variable.  The overhead is a single dereference to get the class property.
         Memory container &#39;value&#39; property. 
            Use the memory container (movable or locked) &#39; value &#39;
            property to operate with memory object data:
             &lt;?php
$memObject = $memoryManager-&gt;create($data);

echo $memObject-&gt;value;

$memObject-&gt;value = $newValue;

$memObject-&gt;value[$index] = &#39;_&#39;;

echo ord($memObject-&gt;value[$index1]);

$memObject-&gt;value = substr($memObject-&gt;value, $start, $length);
             
         
            An alternative way to access memory object data is to use the
             getRef() 
            method.  This method  must  be used for PHP
            versions before 5.2.  It also may have to be used in some other
            cases for performance reasons.
         Memory container interface 
            Memory container provides the following methods:
         getRef() method &lt;?php
public function &amp;getRef();
             
                The  getRef()  method returns reference to the object value.
             
                Movable objects are loaded from the cache at this moment if the
                object is not already in memory.  If the object is loaded from
                the cache, this might cause swapping of other objects if the
                memory limit would be exceeded by having all the managed
                objects in memory.
             
                The  getRef()  method  must  be
                used to access memory object data for PHP versions before 5.2.
             
                Tracking changes to data needs additional resources.
                The  getRef()  method returns reference to string,
                which is changed directly by user application.
                So, it&#39;s a good idea to use the  getRef()  method
                for value data processing:
                 &lt;?php
$memObject = $memoryManager-&gt;create($data);

$value = &amp;$memObject-&gt;getRef();

for ($count = 0; $count &lt; strlen($value); $count++) {
    $char = $value[$count];
    ...
}
                 
             touch() method &lt;?php
public function touch();
             
                The  touch()  method should be used in common with
                 getRef() . It signals that object value has been changed:
                 &lt;?php
$memObject = $memoryManager-&gt;create($data);
...

$value = &amp;$memObject-&gt;getRef();

for ($count = 0; $count &lt; strlen($value); $count++) {
    ...
    if ($condition) {
        $value[$count] = $char;
    }
    ...
}

$memObject-&gt;touch();
                 

             lock() method &lt;?php
public function lock();
             
                The  lock()  methods locks object in memory.
                It should be used to prevent swapping of some objects you choose.
                Normally, this is not necessary, because the memory manager uses
                an intelligent algorithm to choose candidates for swapping.
                But if you exactly know, that at at this part of code some
                objects should not be swapped, you may lock them.
             
                Locking objects in memory also guarantees that reference
                returned by the  getRef()  method is valid until you
                unlock the object:
                 &lt;?php
$memObject1 = $memoryManager-&gt;create($data1);
$memObject2 = $memoryManager-&gt;create($data2);
...

$memObject1-&gt;lock();
$memObject2-&gt;lock();

$value1 = &amp;$memObject1-&gt;getRef();
$value2 = &amp;$memObject2-&gt;getRef();

for ($count = 0; $count &lt; strlen($value2); $count++) {
    $value1 .= $value2[$count];
}

$memObject1-&gt;touch();
$memObject1-&gt;unlock();
$memObject2-&gt;unlock();
                 
             unlock() method &lt;?php
public function unlock();
             unlock()  method unlocks object when it&#39;s no longer
                necessary to be locked. See the example above.
             isLocked() method &lt;?php
public function isLocked();
             
                The  isLocked()  method can be used to check if
                object is locked.  It returns  true  if the object
                is locked, or  false  if it is not locked.
                This is always  true  for &quot;locked&quot; objects,
                and may be either  true  or  false 
                for &quot;movable&quot; objects.
             Overview Introduction 
            The Zend_Memory component is intended to manage data in an
            environment with limited memory.
         
            Memory objects (memory containers) are generated by memory manager
            by request and transparently swapped/loaded when it&#39;s necessary.
         
            For example, if creating or loading a managed object would cause
            the total memory usage to exceed the limit you specify, some
            managed objects are copied to cache storage outside of memory.
            In this way, the total memory used by managed objects does not
            exceed the limit you need to enforce.
         
            The memory manager uses
             Zend_Cache backends 
            as storage providers.
         Using Zend_Memory component Zend_Memory::factory()  instantiates the memory
                manager object with specified backend options.
             &lt;?php
require_once &#39;Zend/Memory.php&#39;;

$backendOptions = array(
    &#39;cache_dir&#39; =&gt; &#39;./tmp/&#39; // Directory where to put the swapped memory blocks
);

$memoryManager = Zend_Memory::factory(&#39;File&#39;, $backendOptions);

$loadedFiles = array();

for ($count = 0; $count &lt; 10000; $count++) {
    $f = fopen($fileNames[$count], &#39;rb&#39;);
    $data = fread($f, filesize($fileNames[$count]));
    $fclose($f);

    $loadedFiles[] = $memoryManager-&gt;create($data);
}

echo $loadedFiles[$index1]-&gt;value;

$loadedFiles[$index2]-&gt;value = $newValue;

$loadedFiles[$index3]-&gt;value[$charIndex] = &#39;_&#39;;
             Theory of Operation 
            Zend_Memory component operates with the following concepts:
             Memory manager Memory container Locked memory object Movable memory object 
         Memory manager 
                The memory manager generates memory objects (locked or movable)
                by request of user application and returns them wrapped into
                a memory container object.
             Memory container 
                The memory container has a virtual or actual  value 
                attribute of string type. This attribute contains the data value
                specified at memory object creation time.
             
                You can operate with this  value  attribute as
                an object property:

                 &lt;?php
$memObject = $memoryManager-&gt;create($data);

echo $memObject-&gt;value;

$memObject-&gt;value = $newValue;

$memObject-&gt;value[$index] = &#39;_&#39;;

echo ord($memObject-&gt;value[$index1]);

$memObject-&gt;value = substr($memObject-&gt;value, $start, $length);
                 
             
                    If you are using a PHP version earlier than 5.2, use the
                     getRef() 
                    method instead of accessing the value property directly.
                 Locked memory 
                Locked memory objects are always stored in memory.
                Data stored in locked memory are never swapped to the cache
                backend.
             Movable memory 
                Movable memory objects are transparently swapped and loaded
                to/from the cache backend by Zend_Memory when it&#39;s necessary.
             
                The memory manager doesn&#39;t swap objects with size less than
                the specified minimum, due to performance considerations.
                See  
                for more details.
             Zend_Mime Introduction Zend_Mime  is a support class for handling multipart MIME messages. It is used by  Zend_Mail  and  Zend_Mime_Message  and may be used by applications requiring
            MIME support.
         Static Methods and Constants Zend_Mime  provides a simple set of static helper methods to work with MIME:
         Zend_Mime::isPrintable() : Returns TRUE if the given string contains no unprintable characters,
                FALSE otherwise.
                 Zend_Mime::encodeBase64() : Encodes a string into base64 encoding.
                 Zend_Mime::encodeQuotedPrintable() : Encodes a string with the quoted-printable mechanism.
                 
     Zend_Mime  defines a set of constants commonly used with MIME Messages:
         Zend_Mime::TYPE_OCTETSTREAM : &#39;application/octet-stream&#39;
                 Zend_Mime::TYPE_TEXT : &#39;text/plain&#39;
                 Zend_Mime::TYPE_HTML : &#39;text/html&#39;
                 Zend_Mime::ENCODING_7BIT : &#39;7bit&#39;
                 Zend_Mime::ENCODING_8BIT : &#39;8bit&#39;
                 Zend_Mime::ENCODING_QUOTEDPRINTABLE : &#39;quoted-printable&#39;
                 Zend_Mime::ENCODING_BASE64 : &#39;base64&#39;
                 Zend_Mime::DISPOSITION_ATTACHMENT : &#39;attachment&#39;
                 Zend_Mime::DISPOSITION_INLINE : &#39;inline&#39;
                 
     Instantiating Zend_Mime 
        When Instantiating a  Zend_Mime  Object, a MIME boundary is stored that
        is used for all subsequent non-static method calls on that object.
        If the constructor is called with a string parameter, this value
        is used as a MIME boundary. If not, a random MIME boundary is generated
        during construction time.
     
        A  Zend_Mime  object has the following Methods:
         boundary() : Returns the MIME boundary string.
                 boundaryLine() : Returns the complete MIME boundary line.
                 mimeEnd() : Returns the complete MIME end boundary line.
                 
     Zend_Mime_Message Introduction Zend_Mime_Message  represents a MIME compliant message
      that can contain one or more seperate Parts (Represented as  Zend_Mime_Part  objects). With
       Zend_Mime_Message , MIME compliant multipart messages can be generated from
       Zend_Mime_Part  objects. Encoding and Boundary handling are handled transparently
      by the class.  Zend_Mime_Message  objects can also be reconstructed from given
      strings (experimental). Used by  Zend_Mail .
       Instantiation 
            There is no explicit constructor for  Zend_Mime_Message .
         Adding MIME Parts Zend_Mime_Part 
        Objects can be added to a given  Zend_Mime_Message  object by calling
         -&gt;addPart($part) An array with all  Zend_Mime_Part 
    objects in the  Zend_Mime_Message  is returned
        from the method  -&gt;getParts() .  The Zend_Mime_Part objects
        can then be changed since they are stored in the array as references. If
        parts are added to the array or the sequence is changed, the array needs
        to be given back to the  Zend_Mime_Part 
        object by calling  -&gt;setParts($partsArray) . The function  -&gt;isMultiPart()  will return true if
        more than one part is registered with the  Zend_Mime_Message  object and thus
        the object would generate a Multipart-Mime-Message when generating the
        actual output. Boundary handling Zend_Mime_Message  usually creates and uses its own
         Zend_Mime  Object to generate a boundary. If you need to
        define the boundary or want to change the behaviour of the  Zend_Mime  object
        used by  Zend_Mime_Message , you can instantiate the  Zend_Mime 
        object yourself and then register it to  Zend_Mime_Message .
        Usually you will not need to do this.  -&gt;setMime(Zend_Mime
        $mime)  sets a special instance of  Zend_Mime  to be used
        by this  Zend_Mime_Message -&gt;getMime()  returns the instance of
         Zend_Mime  that will be used to render the message when
         generateMessage()  is called. -&gt;generateMessage()  renders the  Zend_Mime_Message 
        content to a string. parsing a string to create a Zend_Mime_Message object
        (experimental) A given MIME compliant message in string form can be used to
        reconstruct a  Zend_Mime_Message  Object from it.
         Zend_Mime_Message  has a static factory Method to parse this
        String and return a  Zend_Mime_Message  Object. Zend_Mime_Message::createFromMessage($str, $boundary) 
        decodes the given string and returns a  Zend_Mime_Message 
        Object that can then be examined using  -&gt;getParts() Zend_Mime_Part Introduction This class represents a single part of a MIME message. It contains the
      actual content of the message part plus information about its encoding,
      content type and original filename. It provides a method for generating a
      string from the stored data.  Zend_Mime_Part  objects can be
      added to  Zend_Mime_Message  to
      assemble a complete multipart message. Instantiation Zend_Mime_Part  is instantiated with a string that
    represents the content of the new part. The type is assumed to be
    OCTET-STREAM, encoding is 8Bit. After instantiating a
     Zend_Mime_Part , meta information can be set by accessing its
    attributes directly: &lt;?php
public $type = ZMime::TYPE_OCTETSTREAM;
public $encoding = ZMime::ENCODING_8BIT;
public $id;
public $disposition;
public $filename;
public $description;
public $charset;
     Methods for rendering the message part to a string getContent()  returns the encoded content of the
    MimePart as a string using the encoding specified in the attribute
    $encoding. Valid values are ZMime::ENCODING_* Characterset conversions are
    not performed. getHeaders()  returns the Mime-Headers for the
        MimePart as generated from the information in the publicly accessable
        attributes. The attributes of the object need to be set correctly before
        this method is called.
         $charset 
                    has to be set to the actual charset of the content if it is a text type (Text or HTML).
                 $id 
Â´                   may be set to identify a content-id for inline images in a HTML mail.
                 $filename 
                    contains the name the file will get when downloading it.
                 $disposition 
                    defines if the file should be treated as an attachment or if it is used inside
                    the (HTML-) mail (inline).
                 $description 
                    is only used for informational purposes.
                 
     Zend_OpenId_Consumer Basics Zend_OpenId_Consumer  is used to implement the OpenID
        authentication schema on web sites.
     OpenID Authentication 
            From a site developers point of view, the OpenID authentication
            process consists of three steps:
         
                    Show OpenID authentication form.
                 
                    Accept OpenID identity and pass it to the OpenID provider.
                 
                    Verify response from the OpenID provider.
                 
            In actual fact the OpenID authentication protocol performs more
            steps, but most of them are encapsulated inside the
             Zend_OpenId_Consumer , and they are transparent to the
            developer.
         
            The OpenID authentication process is initiated by the end-user by
            filling in their identification into the appropriate form and submiting
            it. The following example shows a simple form that accepts an OpenID
            identifier. Note that the example shows only a login.
         The Simple OpenID Login form &lt;html&gt;&lt;body&gt;
&lt;form method=&quot;post&quot; action=&quot;example-1_2.php&quot;&gt;&lt;fieldset&gt;
&lt;legend&gt;OpenID Login&lt;/legend&gt;
&lt;input type=&quot;text&quot; name=&quot;openid_identifier&quot;&gt;
&lt;input type=&quot;submit&quot; name=&quot;openid_action&quot; value=&quot;login&quot;&gt;
&lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
             
            On submit this form passes the OpenID identity to the following PHP
            script that performs a second step of authentication. The only thing the
            PHP script needs to do in this step is call the
             Zend_OpenId_Consumer::login()  method. The first argument of this
            method is an accepted OpenID identity and the second is a URL of a script
            that handles the third and last step of authentication.
         The Authentication Request Handler &lt;?php
require_once &quot;Zend/OpenId/Consumer.php&quot;;

$consumer = new Zend_OpenId_Consumer();
if (!$consumer-&gt;login($_POST[&#39;openid_identifier&#39;], &#39;example-1_3.php&#39;)) {
    die(&quot;OpenID login failed.&quot;);
}
             
            The  Zend_OpenId_Consumer::login()  performs discovery on
            a given identifier and on success, finds out the address of the identity
            provider and its local identifier. Then, it creates an association to the
            given provider so that both the site and provider know the same secret
            that is used to sign the following messages. Then it passes an
            authentication request to the provider. Note this request redirects the
            end-user&#39;s web browser to an OpenID server site, where users are able to
            continue the authentication process.
         
            An OpenID Server usually asks users for; their password (if they
            weren&#39;t previously logged-in), if the user trusts this site and what
            information may be returned to the site. These interactions are not
            visible to the OpenID-enabled site so there is no what for it to get the
            user&#39;s password or other information that was not opened.
         
            On success,  Zend_OpenId_Consumer::login()  never
            returns, because it performs an HTTP redirection, however in case of error
            it may return false. Errors may occure due to an invalid identity, dead
            provider, communication error, etc
         
            The third step of authentication is initiated by a response from the
            OpenID provider, after it has already authenticated the user&#39;s password.
            This response is passed indirectly, as an HTTP redirection of the
            end-user&#39;s web browser. And the only thing that site must do is to check
            if this response is valid.
         The Authentication Response Verifier &lt;?php
require_once &quot;Zend/OpenId/Consumer.php&quot;;

$consumer = new Zend_OpenId_Consumer();
if ($consumer-&gt;verify($_GET, $id)) {
    echo &quot;VALID $id&quot;;
} else {
    echo &quot;INVALID $id&quot;;
}
             
            This check is performed using the  Zend_OpenId_Consumer::verify 
            method, that takes the whole array of
            the HTTP request&#39;s arguments and checks if this response is properly
            signed by an appropriate OpenID provider. It also may assign
            the claimed OpenID identity that was entered by end-user in the
            first step into the second (optional) argument.
         Combine all Steps in One Page 
            The following example combines all three steps together. It doesn&#39;t
            provide any additional functionality. The only advantage is that now
            developers don&#39;t need to specify any URL&#39;s of scripts that handle the next
            step. By default, all steps use the same URL. However, the script now
            includes a dispatch code that calls appropriate code for each step of
            authentication.
         The Complete OpenID Login Script &lt;?php
require_once &quot;Zend/OpenId/Consumer.php&quot;;

$status = &quot;&quot;;
if (isset($_POST[&#39;openid_action&#39;]) &amp;&amp;
    $_POST[&#39;openid_action&#39;] == &quot;login&quot; &amp;&amp;
    !empty($_POST[&#39;openid_identifier&#39;])) {

    $consumer = new Zend_OpenId_Consumer();
    if (!$consumer-&gt;login($_POST[&#39;openid_identifier&#39;])) {
        $status = &quot;OpenID login failed.&lt;br&gt;&quot;;
    }
} else if (isset($_GET[&#39;openid_mode&#39;])) {
    if ($_GET[&#39;openid_mode&#39;] == &quot;id_res&quot;) {
        $consumer = new Zend_OpenId_Consumer();
        if ($consumer-&gt;verify($_GET, $id)) {
            $status = &quot;VALID $id&quot;;
        } else {
            $status = &quot;INVALID $id&quot;;
        }
    } else if ($_GET[&#39;openid_mode&#39;] == &quot;cancel&quot;) {
        $status = &quot;CANCELED&quot;;
    }
}
?&gt;
&lt;html&gt;&lt;body&gt;
&lt;?php echo &quot;$status&lt;br&gt;&quot;;?&gt;
&lt;form method=&quot;post&quot;&gt;&lt;fieldset&gt;
&lt;legend&gt;OpenID Login&lt;/legend&gt;
&lt;input type=&quot;text&quot; name=&quot;openid_identifier&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;submit&quot; name=&quot;openid_action&quot; value=&quot;login&quot;&gt;
&lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
             
            In addition, this code differenciates between canceled and wrong
            authentication responses. The provider retuns a canceled responce in cases
            when an identity provider doesn&#39;t know the supplied identity or the user
            is not logged-in or they don&#39;t trust the site. A wrong response assumes
            that the responce is wrong or incorrectly signed.
         Realm 
            When an OpenID-enabled site passes authentication requests to a
            provider, it identifies itself with a realm URL. This URL may be
            considered as a root of a trusted site. If the user trusts the URL they
            will also trust to matched and subsequent URLs.
         
            By default, the realm URL is automatically set to the URL of the
            directory where the login script is. This decision is useful for most, but
            not all cases. Sometimes a whole site and not directory is used, or even a
            combination of several servers from one domain.
         
            To implement this ability, developers may pass the realm value as a
            third argument to the  Zend_OpenId_Consumer::login  method. In
            the following example the single interaction asks for trusted access to
            all php.net sites.
         Authentication Request for Specified Realm &lt;?php
require_once &quot;Zend/OpenId/Consumer.php&quot;;

$consumer = new Zend_OpenId_Consumer();
if (!$consumer-&gt;login($_POST[&#39;openid_identifier&#39;], &#39;example-3_3.php&#39;, &#39;http://*.php.net/&#39;)) {
    die(&quot;OpenID login failed.&quot;);
}
             
            The example below only implements the second step of authentication,
            the first and third steps are the same as in the first example.
         Immediate Check 
            In some situations it is necissary to see if a user is already
            logged-in into a trusted OpenID server without any interaction with the
            user. The  Zend_OpenId_Consumer::check  method does precisely
            that. It is executed with exactly the same arguments as
             Zend_OpenId_Consumer::login  but it doesn&#39;t show the user any
            OpenID server pages. Therefore from the users point of view it is
            transparent and it seems as if they never left the site. The third step
            succeedes if user is already logged-in and trusted to the site otherwise
            it will fail.
         Immediate Check without Interaction &lt;?php
require_once &quot;Zend/OpenId/Consumer.php&quot;;

$consumer = new Zend_OpenId_Consumer();
if (!$consumer-&gt;check($_POST[&#39;openid_identifier&#39;], &#39;example-4_3.php&#39;)) {
    die(&quot;OpenID login failed.&quot;);
}
             
            The example below only implements the second step of authentication,
            first and third steps are the same as in the first example.
         Zend_OpenId_Consumer_Storage 
            There are three steps to the OpenID authentication procedure, each
            step is performed by a separate HTTP request. To store information between
            requests  Zend_OpenId_Consumer  uses internal storage.
         
            Developers may not care about this storage because by default
             Zend_OpenId_Consumer  uses file-based storage under /tmp
            similar to PHP sessions. However, this storage may be not suitable in all
            cases. Some may want to store information in a database while others may
            need to use common storage suitable for big web-farms. Fortunately,
            developers may easily replace the default storage with their own. The only
            thing to implement is it&#39;s own storage class as a child of
            the  Zend_OpenId_Consumer_Storage  method and pass it as a first
            argument to the  Zend_OpenId_Consumer  constructor.
         
            The following example demonstrates a simple storage that uses
             Zend_Db  as the backend containing three groups of functions.
            the first is for working with associations, the second is to cache
            discovery information and the third is to check responce uniqueness. The
            class is implemented in such a way that it can be easily used with
            existing or new databases. If necessary, it will create database tables if
            they don&#39;t exist.
         Databse Storage &lt;?php
class DbStorage extends Zend_OpenId_Consumer_Storage
{
    private $_db;
    private $_association_table;
    private $_discovery_table;
    private $_nonce_table;

    public function __construct($db,
                                $association_table = &quot;association&quot;,
                                $discovery_table = &quot;discovery&quot;,
                                $nonce_table = &quot;nonce&quot;)
    {
        $this-&gt;_db = $db;
        $this-&gt;_association_table = $association_table;
        $this-&gt;_discovery_table = $discovery_table;
        $this-&gt;_nonce_table = $nonce_table;
        $tables = $this-&gt;_db-&gt;listTables();
        if (!in_array($association_table, $tables)) {
            $this-&gt;_db-&gt;getConnection()-&gt;exec(
                &quot;create table $association_table (&quot; .
                &quot; url     varchar(256) not null primary key,&quot; .
                &quot; handle  varchar(256) not null,&quot; .
                &quot; macFunc char(16) not null,&quot; .
                &quot; secret  varchar(256) not null,&quot; .
                &quot; expires timestamp&quot; .
                &quot;)&quot;);
        }
        if (!in_array($discovery_table, $tables)) {
            $this-&gt;_db-&gt;getConnection()-&gt;exec(
                &quot;create table $discovery_table (&quot; .
                &quot; id      varchar(256) not null primary key,&quot; .
                &quot; realId  varchar(256) not null,&quot; .
                &quot; server  varchar(256) not null,&quot; .
                &quot; version float,&quot; .
                &quot; expires timestamp&quot; .
                &quot;)&quot;);
        }
        if (!in_array($nonce_table, $tables)) {
            $this-&gt;_db-&gt;getConnection()-&gt;exec(
                &quot;create table $nonce_table (&quot; .
                &quot; nonce   varchar(256) not null primary key,&quot; .
                &quot; created timestamp default current_timestamp&quot; .
                &quot;)&quot;);
        }
    }

    public function addAssociation($url, $handle, $macFunc, $secret, $expires)
    {
        $table = $this-&gt;_association_table;
        $secret = base64_encode($secret);
        $this-&gt;_db-&gt;query(&quot;insert into $table (url, handle, macFunc, secret, expires) &quot; .
                          &quot;values (&#39;$url&#39;, &#39;$handle&#39;, &#39;$macFunc&#39;, &#39;$secret&#39;, $expires)&quot;);
        return true;
    }

    public function getAssociation($url, &amp;$handle, &amp;$macFunc, &amp;$secret, &amp;$expires)
    {
        $table = $this-&gt;_association_table;
        $this-&gt;_db-&gt;query(&quot;delete from $table where expires &lt; &quot; . time());
        $res = $this-&gt;_db-&gt;fetchRow(&quot;select handle, macFunc, secret, expires from $table where url = &#39;$url&#39;&quot;);
        if (is_array($res)) {
            $handle  = $res[&#39;handle&#39;];
            $macFunc = $res[&#39;macFunc&#39;];
            $secret  = base64_decode($res[&#39;secret&#39;]);
            $expires = $res[&#39;expires&#39;];
            return true;
        }
        return false;
    }

    public function getAssociationByHandle($handle, &amp;$url, &amp;$macFunc, &amp;$secret, &amp;$expires)
    {
        $table = $this-&gt;_association_table;
        $this-&gt;_db-&gt;query(&quot;delete from $table where expires &lt; &quot; . time());
        $res = $this-&gt;_db-&gt;fetchRow(&quot;select url, macFunc, secret, expires from $table where handle = &#39;$handle&#39;&quot;);
        if (is_array($res)) {
            $url     = $res[&#39;url&#39;];
            $macFunc = $res[&#39;macFunc&#39;];
            $secret  = base64_decode($res[&#39;secret&#39;]);
            $expires = $res[&#39;expires&#39;];
            return true;
        }
        return false;
    }

    public function delAssociation($url)
    {
        $table = $this-&gt;_association_table;
        $this-&gt;_db-&gt;query(&quot;delete from $table where url = &#39;$url&#39;&quot;);
        return true;
    }

    public function addDiscoveryInfo($id, $realId, $server, $version, $expires)
    {
        $table = $this-&gt;_discovery_table;
        $this-&gt;_db-&gt;query(&quot;insert into $table (id, realId, server, version, expires) &quot; .
                          &quot;values (&#39;$id&#39;, &#39;$realId&#39;, &#39;$server&#39;, $version, $expires)&quot;);
        return true;
    }

    public function getDiscoveryInfo($id, &amp;$realId, &amp;$server, &amp;$version, &amp;$expires)
    {
        $table = $this-&gt;_discovery_table;
        $this-&gt;_db-&gt;query(&quot;delete from $table where expires &lt; &quot; . time());
        $res = $this-&gt;_db-&gt;fetchRow(&quot;select realId, server, version, expires from $table where id = &#39;$id&#39;&quot;);
        if (is_array($res)) {
            $realId  = $res[&#39;realId&#39;];
            $server  = $res[&#39;server&#39;];
            $version = $res[&#39;version&#39;];
            $expires = $res[&#39;expires&#39;];
            return true;
        }
        return false;
    }

    public function delDiscoveryInfo($id)
    {
        $table = $this-&gt;_discovery_table;
        $this-&gt;_db-&gt;query(&quot;delete from $table where id = &#39;$id&#39;&quot;);
        return true;
    }

    public function isUniqueNonce($nonce)
    {
        $table = $this-&gt;_nonce_table;
        try {
            $ret = $this-&gt;_db-&gt;query(&quot;insert into $table (nonce) values (&#39;$nonce&#39;)&quot;);
        } catch (Zend_Db_Statement_Exception $e) {
            return false;
        }
        return true;
    }

    public function purgeNonces($date=null)
    {
    }
}

$db = Zend_Db::factory(&#39;Pdo_Sqlite&#39;,
    array(&#39;dbname&#39;=&gt;&#39;/tmp/openid_consumer.db&#39;));
$storage = new DbStorage($db);
$consumer = new Zend_OpenId_Consumer($storage);
             
            The example doesn&#39;t include OpenID authentication code itself, but
            it is based on the same logic as in the previous or following
            examples.
         Simple Registration Extension 
            In addition to authentication, the OpenID can be used for
            light-weight profile exchange. This feature is not covered by OpenID
            authentication specification but by the OpenID Simple Registration
            Extension protocol. This protocol allows OpenID-enabled sites to ask for
            information about an end-user from OpenID providers. Such information may
            include:
         nickname 
                    - any UTF-8 string that the end user wants to use as a nickname.
                 email 
                    - the email address of the end user as specified in section 3.4.1
                    of RFC2822.
                 fullname 
                    - a UTF-8 string representation of the end user&#39;s full name.
                 dob 
                    - the end user&#39;s date of birth as YYYY-MM-DD. Any values whose
                    representation uses fewer than the specified number of digits
                    should be zero-padded. The length of this value must always be
                    10. If the end user does not want to reveal any particular
                    component of this value, it must be set to zero. For instance,
                    if a end user wants to specify that his date of birth is in 1980,
                    but not the month or day, the value returned shall be &quot;1980-00-00&quot;.
                 gender 
                    - the end user&#39;s gender, &quot;M&quot; for male, &quot;F&quot; for female.
                 postcode 
                    - UTF-8 string that should conform to the end user&#39;s country&#39;s
                    postal system.
                 country 
                    - the End User&#39;s country of residence as specified by ISO3166.
                 language 
                    - end User&#39;s preferred language as specified by ISO639.
                 timezone 
                    - ASCII string from TimeZone database. For example,
                    &quot;Europe/Paris&quot; or &quot;America/Los_Angeles&quot;.
                 
            An OpenID-enabled web site may ask for any combination of these
            fields. It may also strictly require some information and allow end-users
            to provide or hide other information. The following example creates an
            object of the  Zend_OpenId_Extension_Sreg  class that requires
            a  nickname  and optionally ask for
             email  and  fullname .
         Sending Requests with a Simple Registration Extension &lt;?php
require_once &quot;Zend/OpenId/Consumer.php&quot;;
require_once &quot;Zend/OpenId/Extension/Sreg.php&quot;;

$sreg = new Zend_OpenId_Extension_Sreg(array(
    &#39;nickname&#39;=&gt;true,
    &#39;email&#39;=&gt;false,
    &#39;fullname&#39;=&gt;false), null, 1.1);
$consumer = new Zend_OpenId_Consumer();
if (!$consumer-&gt;login($_POST[&#39;openid_identifier&#39;], &#39;example-6_3.php&#39;, null, $sreg)) {
    die(&quot;OpenID login failed.&quot;);
}
             
            As you can see the  Zend_OpenId_Extension_Sreg 
            constructor accepts an array of asked fields. This array has the names of
            fields as indexes and requirements flag as values.
             true  means the field is required and
             false  means the field is optional. The
             Zend_OpenId_Consumer::login  accepts extensions or list of
            extensions as a fourth argument.
         
            On the third step of authentication, the
             Zend_OpenId_Extension_Sreg  object should be passed to
             Zend_OpenId_Consumer::verify . Then on successful authentication
             Zend_OpenId_Extension_Sreg::getProperties  will return an
            associative array of requested fields.
         Verifying Responses with a Simple Registration Extension &lt;?php
require_once &quot;Zend/OpenId/Consumer.php&quot;;
require_once &quot;Zend/OpenId/Extension/Sreg.php&quot;;

$sreg = new Zend_OpenId_Extension_Sreg(array(
    &#39;nickname&#39;=&gt;true,
    &#39;email&#39;=&gt;false,
    &#39;fullname&#39;=&gt;false), null, 1.1);
$consumer = new Zend_OpenId_Consumer();
if ($consumer-&gt;verify($_GET, $id, $sreg)) {
    echo &quot;VALID $id&lt;br&gt;\n&quot;;
    $data = $sreg-&gt;getProperties();
    if (isset($data[&#39;nickname&#39;])) {
        echo &quot;nickname: &quot; . $data[&#39;nickname&#39;] . &quot;&lt;br&gt;\n&quot;;
    }
    if (isset($data[&#39;email&#39;])) {
        echo &quot;email: &quot; . $data[&#39;email&#39;] . &quot;&lt;br&gt;\n&quot;;
    }
    if (isset($data[&#39;fullname&#39;])) {
        echo &quot;fullname: &quot; . $data[&#39;fullname&#39;] . &quot;&lt;br&gt;\n&quot;;
    }
} else {
    echo &quot;INVALID $id&quot;;
}
             
            If  Zend_OpenId_Extension_Sreg  was created without any
            arguments, the user code should check for the existence of the required
            data itself. However, if the object is created with the same list of
            required fields as on the second step, it will automatically check for the
            existence of required data. In this case,  Zend_OpenId_Consumer::verify 
             will return  false  if any of the required fields are
            missing.
         
            By default,  Zend_OpenId_Extension_Sreg  uses version
            1.0, because the specification for version 1.1 is not yet finalized.
            However, some libraries don&#39;t fully support version 1.0. For example,
            www.myopenid.com requires an SREG namespace in requests which is only
            available in 1.1. To work with this server, explicitly set the version to
            1.1 in the  Zend_OpenId_Extension_Sreg  constructor.
         
            The second argument of the  Zend_OpenId_Extension_Sreg 
            constructor is a policy URL, that should be provided to the end-user by
            the identity provider.
         Integration with Zend_Auth 
            Zend Framework provides a special class to support user
            authentication -  Zend_Auth . This class can be used together
            with  Zend_OpenId_Consumer . The following example shows how
             OpenIdAdapter  implements
            the  Zend_Auth_Adapter_Interface  with the
             authenticate  method.This performs an authentication query and
            verification.
         
            The big difference between this adapter and existing ones, is that
            it works on two HTTP requests and includes a dispatch code to perform the
            second or third step of OpenID authentication.
         Zend_Auth Adapter for OpenID &lt;?php
require_once &quot;Zend/OpenId/Consumer.php&quot;;
require_once &quot;Zend/Auth.php&quot;;
require_once &quot;Zend/Auth/Adapter/Interface.php&quot;;

class OpenIdAdapter implements Zend_Auth_Adapter_Interface {
    private $_id = null;

    public function __construct($id = null) {
        $this-&gt;_id = $id;
    }

    public function authenticate() {
        $id = $this-&gt;_id;
        if (!empty($id)) {
            $consumer = new Zend_OpenId_Consumer();
            if (!$consumer-&gt;login($id)) {
                $ret = false;
                $mdg = &quot;Authentication failed.&quot;;
            }
        } else {
            $consumer = new Zend_OpenId_Consumer();
            if ($consumer-&gt;verify($_GET, $id)) {
                $ret = true;
                $msg = &quot;Authentication successful&quot;;
            } else {
                $ret = false;
                $msg = &quot;Authentication failed&quot;;
            }
        }
        return new Zend_Auth_Result($ret, $id, array($msg));
    }
}

$status = &quot;&quot;;
$auth = Zend_Auth::getInstance();
if ((isset($_POST[&#39;openid_action&#39;]) &amp;&amp;
     $_POST[&#39;openid_action&#39;] == &quot;login&quot; &amp;&amp;
     !empty($_POST[&#39;openid_identifier&#39;])) ||
    isset($_GET[&#39;openid_mode&#39;])) {
    $adapter = new OpenIdAdapter(@$_POST[&#39;openid_identifier&#39;]);
    $result = $auth-&gt;authenticate($adapter);
    if ($result-&gt;isValid()) {
        Zend_OpenId::redirect(Zend_OpenId::selfURL());
    } else {
        $auth-&gt;clearIdentity();
        foreach ($result-&gt;getMessages() as $message) {
            $status .= &quot;$message&lt;br&gt;\n&quot;;
        }
    }
} else if ($auth-&gt;hasIdentity()) {
    if (isset($_POST[&#39;openid_action&#39;]) &amp;&amp;
        $_POST[&#39;openid_action&#39;] == &quot;logout&quot;) {
        $auth-&gt;clearIdentity();
    } else {
        $status = &quot;Yoy are logged-in as &quot; . $auth-&gt;getIdentity() . &quot;&lt;br&gt;\n&quot;;
    }
}
?&gt;
&lt;html&gt;&lt;body&gt;
&lt;?php echo &quot;$status&quot;;?&gt;
&lt;form method=&quot;post&quot;&gt;&lt;fieldset&gt;
&lt;legend&gt;OpenID Login&lt;/legend&gt;
&lt;input type=&quot;text&quot; name=&quot;openid_identifier&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;submit&quot; name=&quot;openid_action&quot; value=&quot;login&quot;&gt;
&lt;input type=&quot;submit&quot; name=&quot;openid_action&quot; value=&quot;logout&quot;&gt;
&lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
             
            With  Zend_Auth  the end-user&#39;s identity is saved in the
            session&#39;s data. It may be checked with  Zend_Auth::hasIdentity 
            and  Zend_Auth::getIdentity .
         Integration with Zend_Controller 
            Finally a couple of words about integration into
            Model-View-Controller applications. Such Zend Framework applications are
            implemented using the  Zend_Controller  class and they use
            objects of the  Zend_Controller_Response_Http  class to prepare
            HTTP responses and send them back to the end user&#39;s web-browser.
         Zend_OpenId_Consumer  doesn&#39;t provide any GUI
            capabilities but it performs HTTP redirections on success of
             Zend_OpenId_Consumer::login  and
             Zend_OpenId_Consumer::check . These redirections, may work
            incorrectly or not work at all if some data was already sent to the
            web-browser. To properly perform HTTP redirection in MVC code the real
             Zend_Controller_Response_Http  should be sent to
             Zend_OpenId_Consumer::login  or
             Zend_OpenId_Consumer::check  as the last argument.
         Introduction Zend_OpenId  is a Zend Framework component that provides a
        simple API for building OpenID-enabled sites and identity providers.
     What is OpenID? 
            OpenID is a set of protocols for user-centric digital identities.
            These protocols allow to create an identity online, using an identity
            provider. This identity can be used anywhere that OpenID is supported.
            Using OpenID-enabled sites, web users do not need to remember traditional
            authentication tokens such as username and password. All OpenID-enabled
            sites accept a single OpenID identity. This identity is typically a URL.
            It may be the URL of the user&#39;s personal page, blog or other resource that
            may provide additional information about them. No more need for many
            passwords and different user names - just one identifier for all Internet
            services. OpenID is an open, decentralized, and free user centric
            solution. A user may choose which OpenID provider to use, or even create
            their own personal identity server. No central authority is needed to
            approve or register OpenID-enabled sites or identity providers.
         
            For more information about OpenID visit  OpenID official site 
            and look into the  OpenID Book by Rafeeq
            Rehman .
         How Does it Work? 
            The main purpose of the  Zend_OpenId  components is to
            implement an OpenID authentication protocol as described in the following
            diagram:
         
                    Authentication is initiated by the end-user, who passes their
                    OpenID identifier to the OpenID consumer through a User-Agent.
                 
                    The OpenID consumer performs normalization of the user-supplied
                    identifier, and discovery on it. As result, it gets the following:
                    a claimed identifier, OpenID provider URL and an OpenID protocol
                    version.
                 
                    The OpenID client establishes an optional association with the
                    server using Diffie-Hellman keys. As a result, both parties get
                    a common &quot;shared secret&quot; that is used for signing and verification
                    of the following (subsequent) messages.
                 
                    The OpenID consumer redirects the User-Agent to the OpenID
                    provider&#39;s URL with an OpenID authentication request.
                 
                    The OpenID Provider checks if the user-Agent is already
                    authenticated and offers to do so if needed.
                 
                    The end user enters the required password.
                 
                    The OpenID Provider checks if it is allowed to pass the user
                    identity to the given consumer, and asks the user if needed.
                 
                    The end user allows or disallows passing his identity.
                 
                    The OpenID Provider redirects the User-Agent back to the OpenID
                    consumer with an &quot;authentication approved&quot; or &quot;failed&quot; request.
                 
                    The OpenID consumer verifies the information received from the
                    provider by using the &quot;shared secret&quot; it got on step 3 or by
                    sending additional direct request to the OpenID provider.
                 Zend_OpenId Structure Zend_OpenId  consists of two sub packages. The first one
            is  Zend_OpenId_Consumer  for developing OpenID-enabled sites
            and the second  Zend_OpenId_Provider  for developing OpenID
            servers. They are completely independent of each other and may be used
            separately.
         
            The only common parts of these sub packages are the OpenID Simple
            Registration Extension implemented by
             Zend_OpenId_Extension_Sreg  class and the set of utility
            functions implemented by  Zend_OpenId  class.
         Zend_OpenId  takes advantage of the  GMP extension ,
                where available. Consider enabling the GMP extension for better performance when using
                 Zend_OpenId .
             Supported Standards 
            The  Zend_OpenId  component conforms to the following
            standards:
         
                    OpenID Authentication protocol version 1.1
                 
                    OpenID Authentication protocol version 2.0 draft 11
                 
                    OpenID Simple Registration Extension version 1.0
                 
                    OpenID Simple Registration Extension version 1.1 draft 1
                 Zend_OpenId_Provider 
        The  Zend_OpenId_Provider  is used to implement OpenID
        servers. This chapter provides very basic examples demonstrating how to
        build a working server. However, for implementation of a production OpenID
        server (like  www.myopenid.com ) you
        may be required to deal with more complex issues.
     Quick Start 
            The following identity includes the code for creating a user account
            using  Zend_OpenId_Provider::register . The link element with
             rel=&quot;openid.server&quot;  points to our own server script. If you
            submit this identity to an OpenID-enabled site, it will perform
            authentication on this server.
         
            The code before &lt;html&gt; is just a trick that automatically
            creates a user account. You wont need such code when using real
            identities.
         The Identity &lt;?php
require_once &quot;Zend/OpenId/Provider.php&quot;;
define(&quot;TEST_SERVER&quot;, Zend_OpenId::absoluteURL(&quot;example-8.php&quot;));
define(&quot;TEST_ID&quot;, Zend_OpenId::selfURL());
define(&quot;TEST_PASSWORD&quot;, &quot;123&quot;);
$server = new Zend_OpenId_Provider();
if (!$server-&gt;hasUser(TEST_ID)) {
    $server-&gt;register(TEST_ID, TEST_PASSWORD);
}
?&gt;
&lt;html&gt;&lt;head&gt;
&lt;link rel=&quot;openid.server&quot; href=&quot;&lt;?php echo TEST_SERVER;?&gt;&quot; /&gt;
&lt;/head&gt;&lt;body&gt;
&lt;?php echo TEST_ID;?&gt;
&lt;/body&gt;&lt;/html&gt;
             
            The following identity server script handles two kinds of requests
            from OpenID-enabled sites (for association and authentication). Both of
            them are handled by the same method
             Zend_OpenId_Provider::handle . The two arguments to
             Zend_OpenId_Provider  are URLs of login and trust pages, these
            ask for interaction from the end-user.
         
            On success, the method  Zend_OpenId_Provider::handle 
            returns a string that should be passed back to the OpenID-enabled site. On
            failure, it returns  false  - in this example it will return a
            HTTP 403 response. You will get it if you try to open this page by
            web-browser, because it sends a non-OpenID conformed request.
         Simple Identity Provider &lt;?php
require_once &quot;Zend/OpenId/Provider.php&quot;;
$server = new Zend_OpenId_Provider(&quot;example-8-login.php&quot;, &quot;example-8-trust.php&quot;);
$ret = $server-&gt;handle();
if (is_string($ret)) {
    echo $ret;
} else if ($ret !== true) {
    header(&#39;HTTP/1.0 403 Forbidden&#39;);
    echo &#39;Forbidden&#39;;
}
             
            It is a good idea to use a secure connection (HTTPS) for this and
            especially for the following interactive scripts, to prevent password
            disclosure.
         
            The following script implements a login screen for an identity
            server  Zend_OpenId_Provider  and redirects to this page when a
            required user has not yet logged-in. On this page, users enter a password
            to login.
         
            You should use the password &quot;123&quot; that was used during a tricky user
            registration from an identity script.
         
            On submit, the script calls  Zend_OpenId_Provider::login 
            with the accepted end-user&#39;s identity and password, then redirects it back
            to the main identity provider&#39;s script. On success, the
             Zend_OpenId_Provider::login  establishes a session between the
            end-user and the identity-provider and stores the information about
            logged-in user. So, all following requests from the same end-user won&#39;t
            require login procedure (even if they come from another OpenID enabled
            web-site).
         
            Note that this session is between end-user and identity provider
            only. OpenID enabled sites know nothing about it.
         Simple Login Screen &lt;?php
require_once &quot;Zend/OpenId/Provider.php&quot;;
$server = new Zend_OpenId_Provider();

if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39; &amp;&amp;
    isset($_POST[&#39;openid_action&#39;]) &amp;&amp;
    $_POST[&#39;openid_action&#39;] === &#39;login&#39; &amp;&amp;
    isset($_POST[&#39;openid_identifier&#39;]) &amp;&amp;
    isset($_POST[&#39;openid_password&#39;])) {
    $server-&gt;login($_POST[&#39;openid_identifier&#39;], $_POST[&#39;openid_password&#39;]);
    Zend_OpenId::redirect(&quot;example-8.php&quot;, $_GET);
}
?&gt;
&lt;html&gt;&lt;body&gt;
&lt;form method=&quot;post&quot;&gt;&lt;fieldset&gt;
&lt;legend&gt;OpenID Login&lt;/legend&gt;
&lt;table border=0&gt;
&lt;tr&gt;&lt;td&gt;Name:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;openid_identifier&quot; value=&quot;&lt;?php
echo $_GET[&#39;openid_identity&#39;];
?&gt;&quot;&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Password:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;openid_password&quot; value=&quot;&quot;&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;openid_action&quot; value=&quot;login&quot;&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
             
            The fact that the user is logged-in doesn&#39;t mean that the
            authentication must succeed. The user may decide to trust or not to trust
            particular OpenID enabled sites. The following trust screen allows the
            end-user to make that choise. This choise may be done only for current
            requests or &quot;forever&quot;. In the last case information about
            trusted/untrusted sites is stored in an internal database and all
            following authentication requests from this site will be handled
            automatically, without user interaction.
         Simple Trust Screen &lt;?php
require_once &quot;Zend/OpenId/Provider.php&quot;;
$server = new Zend_OpenId_Provider();

if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;POST&#39; &amp;&amp;
    isset($_POST[&#39;openid_action&#39;]) &amp;&amp;
    $_POST[&#39;openid_action&#39;] === &#39;trust&#39;) {

    if (isset($_POST[&#39;allow&#39;])) {
        if (isset($_POST[&#39;forever&#39;])) {
            $server-&gt;allowSite($server-&gt;getSiteRoot($_GET));
        }
        $server-&gt;respondToConsumer($_GET);
    } else if (isset($_POST[&#39;deny&#39;])) {
        if (isset($_POST[&#39;forever&#39;])) {
            $server-&gt;denySite($server-&gt;getSiteRoot($_GET));
        }
        Zend_OpenId::redirect($_GET[&#39;openid_return_to&#39;], array(&#39;openid.mode&#39;=&gt;&#39;cancel&#39;));
    }
}
?&gt;
&lt;html&gt;&lt;body&gt;
&lt;p&gt;A site identifying as &lt;a href=&quot;&lt;?php echo $server-&gt;getSiteRoot($_GET);?&gt;&quot;&gt;
&lt;?php echo $server-&gt;getSiteRoot($_GET);?&gt;&lt;/a&gt; has asked us for confirmation that
&lt;a href=&quot;&lt;?php echo $server-&gt;getLoggedInUser();?&gt;&quot;&gt;
&lt;?php echo $server-&gt;getLoggedInUser();?&gt;&lt;/a&gt; is your identity URL.&lt;/p&gt;
&lt;form method=&quot;post&quot;&gt;
&lt;input type=&quot;checkbox&quot; name=&quot;forever&quot;&gt;
&lt;label for=&quot;forever&quot;&gt;forever&lt;/label&gt;&lt;br&gt;
&lt;input type=&quot;hidden&quot; name=&quot;openid_action&quot; value=&quot;trust&quot;&gt;
&lt;input type=&quot;submit&quot; name=&quot;allow&quot; value=&quot;Allow&quot;&gt;
&lt;input type=&quot;submit&quot; name=&quot;deny&quot; value=&quot;Deny&quot;&gt;
&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
             
            Production OpenID servers usually support Simple Registration
            Extension that allows consumers to ask some information about user from
            provider. In this case the trust page is usually extended with ability to
            enter requested fields or to select user profile.
         Combine all together 
            It is possible to combine all provider functions in one script. In
            this case login and trust URLs are omitted, and
             Zend_OpenId_Provider  assumes that they point to the same page
            with additional &quot;openid.action&quot; GET argument.
         
            The following example is not complete. It doesn&#39;t provide GUI for
            end-user like it should, but performs automatic login and trusting instead.
            It is done just to simplify the example, and real server must include code
            from previous examples.
         All together &lt;?php
require_once &quot;Zend/OpenId/Provider.php&quot;;
$server = new Zend_OpenId_Provider();

define(&quot;TEST_ID&quot;, Zend_OpenId::absoluteURL(&quot;example-9-id.php&quot;));
define(&quot;TEST_PASSWORD&quot;, &quot;123&quot;);

if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39; &amp;&amp;
    isset($_GET[&#39;openid_action&#39;]) &amp;&amp;
    $_GET[&#39;openid_action&#39;] === &#39;login&#39;) {
    $server-&gt;login(TEST_ID, TEST_PASSWORD);
    unset($_GET[&#39;openid_action&#39;]);
    Zend_OpenId::redirect(Zend_OpenId::selfUrl(), $_GET);
} else if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39; &amp;&amp;
    isset($_GET[&#39;openid_action&#39;]) &amp;&amp;
    $_GET[&#39;openid_action&#39;] === &#39;trust&#39;) {
    unset($_GET[&#39;openid_action&#39;]);
    $server-&gt;respondToConsumer($_GET);
} else {
    $ret = $server-&gt;handle();
    if (is_string($ret)) {
        echo $ret;
    } else if ($ret !== true) {
        header(&#39;HTTP/1.0 403 Forbidden&#39;);
        echo &#39;Forbidden&#39;;
    }
}
             
            If you compare this example with previous example divided to
            separate page, in addition to dispatch code you will see only the one
            difference -  unset($_GET[&#39;openid_action&#39;]) . This
             unset  is necessary to route next request to main
            handler.
         Simple Registration Extension 
            The following identity page makes a trick again. It creates new user
            account and associates it with profile (nickname and password). Such
            tricks aren&#39;t needed in real life where end-user registers on OpenID
            server and fill-in their profiles, but implementing this GUI is not a
            subject of this manual.
         Identity with Profile &lt;?php
require_once &quot;Zend/OpenId/Provider.php&quot;;
require_once &quot;Zend/OpenId/Extension/Sreg.php&quot;;
define(&quot;TEST_SERVER&quot;, Zend_OpenId::absoluteURL(&quot;example-10.php&quot;));
define(&quot;TEST_ID&quot;, Zend_OpenId::selfURL());
define(&quot;TEST_PASSWORD&quot;, &quot;123&quot;);
$server = new Zend_OpenId_Provider();
if (!$server-&gt;hasUser(TEST_ID)) {
    $server-&gt;register(TEST_ID, TEST_PASSWORD);
    $server-&gt;login(TEST_ID, TEST_PASSWORD);
    $sreg = new Zend_OpenId_Extension_Sreg(array(
        &#39;nickname&#39; =&gt;&#39;test&#39;,
        &#39;email&#39; =&gt; &#39;test@test.com&#39;
    ));
    $root = Zend_OpenId::absoluteURL(&quot;.&quot;);
    Zend_OpenId::normalizeUrl($root);
    $server-&gt;allowSite($root, $sreg);
    $server-&gt;logout();
}
?&gt;
&lt;html&gt;&lt;head&gt;
&lt;link rel=&quot;openid.server&quot; href=&quot;&lt;?php echo TEST_SERVER;?&gt;&quot; /&gt;
&lt;/head&gt;&lt;body&gt;
&lt;?php echo TEST_ID;?&gt;
&lt;/body&gt;&lt;/html&gt;
             
            You should pass this identity to OpenID-enabled site (use Simple
            Registration Extension example from previous chapter) and it will use the
            following OpenID server script.
         
            It is a variation from previous &quot;All together&quot; example. It uses the
            same automatic login mechanism, but it doesn&#39;t contain any code for trust
            page. The user already trusts &quot;forever&quot; to example scripts. This trust was
            made by  Zend_OpenId_Provider::alowSite  method in identity
            script. The same method associated profile with trusted URL and this
            profile will be returned automatically on request from this trusted
            URL.
         
            The only thing necessary to make Simple Registration Extension work
            is passing object of  Zend_OpenId_Extension_Sreg  as second
            argument to  Zend_OpenId_Provider::handle .
         Provider with SREG &lt;?php
require_once &quot;Zend/OpenId/Provider.php&quot;;
require_once &quot;Zend/OpenId/Extension/Sreg.php&quot;;
$server = new Zend_OpenId_Provider();
$sreg = new Zend_OpenId_Extension_Sreg();

define(&quot;TEST_ID&quot;, Zend_OpenId::absoluteURL(&quot;example-10-id.php&quot;));
define(&quot;TEST_PASSWORD&quot;, &quot;123&quot;);

if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39; &amp;&amp;
    isset($_GET[&#39;openid_action&#39;]) &amp;&amp;
    $_GET[&#39;openid_action&#39;] === &#39;login&#39;) {
    $server-&gt;login(TEST_ID, TEST_PASSWORD);
    unset($_GET[&#39;openid_action&#39;]);
    Zend_OpenId::redirect(Zend_OpenId::selfUrl(), $_GET);
} else if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39; &amp;&amp;
    isset($_GET[&#39;openid_action&#39;]) &amp;&amp;
    $_GET[&#39;openid_action&#39;] === &#39;trust&#39;) {
   echo &quot;UNTRUSTED DATA&quot; ;
} else {
    $ret = $server-&gt;handle(null, $sreg);
    if (is_string($ret)) {
        echo $ret;
    } else if ($ret !== true) {
        header(&#39;HTTP/1.0 403 Forbidden&#39;);
        echo &#39;Forbidden&#39;;
    }
}
             What Else? 
            Building OpenID servers is less usual tasks then building
            OpenID-enabled sites, so this manual don&#39;t try to cover all
             Zend_OpenId_Provider  features as it was done for
             Zend_OpenId_Consumer .
         
            In two words in additional it provides:
         
                    a set of methods to build end-user&#39;s GUI interface that allows
                    users to register, manage their trusted sites and profiles.
                 
                    an abstraction storage layer to store information about users,
                    their sites and profiles. It also stores associations between
                    provider and OpenID-enabled sites. This layer is very similar
                    to the  Zend_OpenId_Consumer &#39;s one. It also uses
                    file storage by default but may be substituted with another
                    implementation.
                 
                    an abstraction user-association layer that may associate
                    end-user&#39;s web browser with logged-in identity
                 Zend_OpenId_Provider  doesn&#39;t try to cover all possible
            features that can be implemented by OpenID server (like digital
            certificates), but it can be easily extended using
             Zend_OpenId_Extension s or by creating a child class.
         Creating and loading PDF documents. Zend_Pdf  class represents PDF document itself and provides document level
    functionality.
     
    To create new document new  Zend_Pdf  object should be created.
     Zend_Pdf  class also provides two static methods to load existing PDF.
    These are  Zend_Pdf::load()  and  Zend_Pdf::parse()  methods.
    Both of them return Zend_Pdf object as a result or throw an exception if error occurs.
     Create new or load existing PDF document. &lt;?php
...
// Create new PDF document.
$pdf1 = new Zend_Pdf();

// Load PDF document from a file.
$pdf2 = Zend_Pdf::load($fileName);

// Load PDF document from a string.
$pdf3 = Zend_Pdf::parse($pdfString);
...
       
    PDF file format supports incremental document update. Thus each time when document
    is updated, then new revision of the document is created.
    Zend_Pdf module supports retrieving of specified revision.
     
    Revision can be specified as a second parameter for  Zend_Pdf::load()  and
     Zend_Pdf::parse()  methods or requested by  Zend_Pdf::rollback() 
         Zend_Pdf::rollback()  method must be invoked before any changes, applied to the document.
            Otherwise behavior is undefined.
             
    call.
     Requesting specified revision of the PDF document. &lt;?php
...
// Load PDF previouse revision of the document.
$pdf1 = Zend_Pdf::load($fileName, 1);

// Load PDF previouse revision of the document.
$pdf2 = Zend_Pdf::parse($pdfString, 1);

// Load first revision of the document.
$pdf3 = Zend_Pdf::load($fileName);
$revisions = $pdf3-&gt;revisions();
$pdf3-&gt;rollback($revisions - 1);
...
         Drawing. Geometry. 
        PDF uses the same geometry as PostScript. It starts from bottom-left corner of page
        and by default is measured in points (1/72 of an inch).
         
        Page size can be retrieved from a page object:
         &lt;?php
$width  = $pdfPage-&gt;getWidth();
$height = $pdfPage-&gt;getHeight();
             Colors. 
        PDF has a powerful capabilities for colors representation. Zend_Pdf module supports Gray Scale,
        RGB and CMYK color spaces. Any of them can be used in any place, where  Zend_Pdf_Color 
        object is required.  Zend_Pdf_Color_GrayScale ,  Zend_Pdf_Color_Rgb  and
         Zend_Pdf_Color_Cmyk  classes provide this functionality:
         &lt;?php
// $grayLevel (float number). 0.0 (black) - 1.0 (white)
$color1 = new Zend_Pdf_Color_GrayScale($grayLevel);

// $r, $g, $b (float numbers). 0.0 (minimum intensity) - 1.0 (maximum intensity)
$color2 = new Zend_Pdf_Color_Rgb($r, $g, $b);

// $c, $m, $y, $k (float numbers). 0.0 (minimum intensity) - 1.0 (maximum intensity)
$color3 = new Zend_Pdf_Color_Cmyk($c, $m, $y, $k);
         
        HTML style colors are also provided with  Zend_Pdf_Color_Html  class:
         &lt;?php
$color1 = new Zend_Pdf_Color_Html(&#39;#3366FF&#39;);
$color2 = new Zend_Pdf_Color_Html(&#39;silver&#39;);
$color3 = new Zend_Pdf_Color_Html(&#39;forestgreen&#39;);
         Shape Drawing. 
        All drawing operations can be done in a context of PDF page.
         Zend_Pdf_Page  class provides a set of drawing primitives:
         &lt;?php
/**
 * Draw a line from x1,y1 to x2,y2.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function drawLine($x1, $y1, $x2, $y2);
         &lt;?php
/**
 * Draw a rectangle.
 *
 * Fill types:
 * Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - fill rectangle and stroke (default)
 * Zend_Pdf_Page::SHAPE_DRAW_STROKE      - stroke rectangle
 * Zend_Pdf_Page::SHAPE_DRAW_FILL        - fill rectangle
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param integer $fillType
 */
public function drawRectangle($x1, $y1, $x2, $y2, $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE);
         &lt;?php
/**
 * Draw a polygon.
 *
 * If $fillType is Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE or Zend_Pdf_Page::SHAPE_DRAW_FILL,
 * then polygon is automatically closed.
 * See detailed description of these methods in a PDF documentation
 * (section 4.4.2 Path painting Operators, Filling)
 *
 * @param array $x  - array of float (the X co-ordinates of the vertices)
 * @param array $y  - array of float (the Y co-ordinates of the vertices)
 * @param integer $fillType
 * @param integer $fillMethod
 */
public function drawPolygon($x, $y,
                            $fillType = Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE,
                            $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING);
         &lt;?php
/**
 * Draw a circle centered on x, y with a radius of radius.
 *
 * Angles are specified in radians
 *
 * Method signatures:
 * drawCircle($x, $y, $radius);
 * drawCircle($x, $y, $radius, $fillType);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle);
 * drawCircle($x, $y, $radius, $startAngle, $endAngle, $fillType);
 *
 *
 * It&#39;s not a really circle, because PDF supports only cubic Bezier curves.
 * But very good approximation.
 * It differs from a real circle on a maximum 0.00026 radiuses
 * (at PI/8, 3*PI/8, 5*PI/8, 7*PI/8, 9*PI/8, 11*PI/8, 13*PI/8 and 15*PI/8 angles).
 * At 0, PI/4, PI/2, 3*PI/4, PI, 5*PI/4, 3*PI/2 and 7*PI/4 it&#39;s exactly a tangent to a circle.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param mixed $param4
 * @param mixed $param5
 * @param mixed $param6
 */
public function  drawCircle($x, $y, $radius, $param4 = null, $param5 = null, $param6 = null);
         &lt;?php
/**
 * Draw an ellipse inside the specified rectangle.
 *
 * Method signatures:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $fillType);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle, $fillType);
 *
 * Angles are specified in radians
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param mixed $param5
 * @param mixed $param6
 * @param mixed $param7
 */
public function drawEllipse($x1, $y1, $x2, $y2, $param5 = null, $param6 = null, $param7 = null);
         Text Drawing. 
        Text drawing operations also exist in the context of a PDF page. You can draw a single line of text
        at any position on the page by supplying the x and y coordinates of the baseline. Current font and
        current font size are used for text drawing operations (see detailed description below).
         &lt;?php
/**
 * Draw a line of text at the specified position.
 *
 * @param string $text
 * @param float $x
 * @param float $y
 * @param string $charEncoding (optional) Character encoding of source text.
 *   Defaults to current locale.
 * @throws Zend_Pdf_Exception
 */
public function drawText($text, $x, $y, $charEncoding = &#39;&#39;);
         Draw a string on the page. &lt;?php
...
$pdfPage-&gt;drawText(&#39;Hello world!&#39;, 72, 720);
...
             
        By default, text strings are interpreted using the character encoding method of the current locale. If
        you have a string that uses a different encoding method (such as a UTF-8 string read from a file on disk,
        or a MacRoman string obtained from a legacy database), you can indicate the character encoding at draw
        time and Zend_Pdf will handle the conversion for you. You can supply source strings in any encoding
        method supported by PHP&#39;s  iconv()  function:
         Draw a UTF-8-encoded string on the page. &lt;?php
...
// Read a UTF-8-encoded string from disk
$unicodeString = fread($fp, 1024);

// Draw the string on the page
$pdfPage-&gt;drawText($unicodeString, 72, 720, &#39;UTF-8&#39;);
...
             Using fonts. Zend_Pdf_Page::drawText()  uses the page&#39;s current font and font size, which is set with
        the  Zend_Pdf_Page::setFont()  method:
         &lt;?php
/**
 * Set current font.
 *
 * @param Zend_Pdf_Resource_Font $font
 * @param float $fontSize
 */
public function setFont(Zend_Pdf_Resource_Font $font, $fontSize);
         
        PDF documents support PostScript Type 1 and TrueType fonts, as well as two specialized PDF types, Type 3
        and composite fonts. There are also 14 standard Type 1 fonts built-in to every PDF viewer: Courier (4
        styles), Helvetica (4 styles), Times (4 styles), Symbol, and Zapf Dingbats.
         
        Zend_Pdf currently supports the standard 14 PDF fonts as well as your own custom TrueType fonts. Font
        objects are obtained via one of two factory methods:  Zend_Pdf_Font::fontWithName($fontName) 
        for the standard 14 PDF fonts or  Zend_Pdf_Font::fontWithPath($filePath)  for custom fonts.
         Create a standard font. &lt;?php
...
// Create new font
$font = Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_HELVETICA);

// Apply font
$pdfPage-&gt;setFont($font, 36);
...
             
        Constants for the standard 14 PDF font names are defined in the  Zend_Pdf_Font  class:
         Zend_Pdf_Font::FONT_COURIER Zend_Pdf_Font::FONT_COURIER_BOLD Zend_Pdf_Font::FONT_COURIER_ITALIC Zend_Pdf_Font::FONT_COURIER_BOLD_ITALIC Zend_Pdf_Font::FONT_TIMES Zend_Pdf_Font::FONT_TIMES_BOLD Zend_Pdf_Font::FONT_TIMES_ITALIC Zend_Pdf_Font::FONT_TIMES_BOLD_ITALIC Zend_Pdf_Font::FONT_HELVETICA Zend_Pdf_Font::FONT_HELVETICA_BOLD Zend_Pdf_Font::FONT_HELVETICA_ITALIC Zend_Pdf_Font::FONT_HELVETICA_BOLD_ITALIC Zend_Pdf_Font::FONT_SYMBOL Zend_Pdf_Font::FONT_ZAPFDINGBATS 
         
        You can also use any individual TrueType font (which usually has a &#39;.ttf&#39; extension) or an
        OpenType font (&#39;.otf&#39; extension) if it contains TrueType outlines. Currently unsupported,
        but planned for a future release are Mac OS X .dfont files and Microsoft TrueType Collection
        (&#39;.ttc&#39; extension) files.
         
        To use a TrueType font, you must provide the full file path to the font program. If the font
        cannot be read for some reason, or if it is not a TrueType font, the factory method will throw
        an exception:
         Create a TrueType font. &lt;?php
...
// Create new font
$goodDogCoolFont = Zend_Pdf_Font::fontWithPath(&#39;/path/to/GOODDC__.TTF&#39;);

// Apply font
$pdfPage-&gt;setFont($goodDogCoolFont, 36);
...
             
        By default, custom fonts will be embedded in the resulting PDF document. This allows recipients
        to view the page as intended, even if they don&#39;t have the proper fonts installed on their system.
        If you are concerned about file size, you can request that the font program not be embedded by
        passing a &#39;do not embed&#39; option to the factory method:
         Create a TrueType font, but do not embed it in the PDF document. &lt;?php
...
// Create new font
$goodDogCoolFont = Zend_Pdf_Font::fontWithPath(&#39;/path/to/GOODDC__.TTF&#39;,
                                               Zend_Pdf_Font::EMBED_DONT_EMBED);

// Apply font
$pdfPage-&gt;setFont($goodDogCoolFont, 36);
...
             
        If the font program is not embedded but the recipient of the PDF file has the font installed on
        their system, they will see the document as intended. If they do not have the correct font
        installed, the PDF viewer application will do its best to synthesize a replacement.
         
        Some fonts have very specific licensing rules which prevent them from being embedded in PDF
        documents. So you are not caught off-guard by this, if you try to use a font that cannot be
        embedded, the factory method will throw an exception.
         
        You can still use these fonts, but you must either pass the do not embed flag as described above,
        or you can simply suppress the exception:
         Do not throw an exception for fonts that cannot be embeded. &lt;?php
...
$font = Zend_Pdf_Font::fontWithPath(&#39;/path/to/unEmbeddableFont.ttf&#39;,
                                    Zend_Pdf_Font::EMBED_SUPPRESS_EMBED_EXCEPTION);
...
             
        This suppression technique is preferred if you allow an end-user to choose their own fonts. Fonts
        which can be embedded in the PDF document will be; those that cannot, won&#39;t.
         
        Font programs can be rather large, some reaching into the tens of megabytes. By default, all embedded
        fonts are compressed using the Flate compression scheme, resulting in a space savings of 50% on average.
        If, for some reason, you do not want to compress the font program, you can disable it with an option:
         Do not compress an embedded font. &lt;?php
...
$font = Zend_Pdf_Font::fontWithPath(&#39;/path/to/someReallyBigFont.ttf&#39;,
                                    Zend_Pdf_Font::EMBED_DONT_COMPRESS);
...
             
        Finally, when necessary, you can combine the embedding options by using the bitwise OR operator:
         Combining font embedding options. &lt;?php
...
$font = Zend_Pdf_Font::fontWithPath($someUserSelectedFontPath,
                                    (Zend_Pdf_Font::EMBED_SUPPRESS_EMBED_EXCEPTION |
                                     Zend_Pdf_Font::EMBED_DONT_COMPRESS));
...
             Starting in 1.5, Extracting fonts. Zend_Pdf  module provides a possibility to extract fonts from loaded documents. 
         
            It may be useful for incremental document updates. Without this functionality you have to attach and possibly embed 
            font into a document each time you want to update it. 
         Zend_Pdf  and  Zend_Pdf_Page  objects provide special methods to extract all fonts mentioned within 
            a document or a page:
         Extracting fonts from a loaded document. &lt;?php
...
$pdf = Zend_Pdf::load($documentPath);
...
// Get all document fonts
$fontList = $pdf-&gt;extractFonts();
$pdf-&gt;pages[] = ($page = $pdf-&gt;newPage(Zend_Pdf_Page::SIZE_A4));
$yPosition = 700;
foreach ($fontList as $font) {
    $page-&gt;setFont($font, 15);
    $page-&gt;drawText($font-&gt;getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT, &#39;en&#39;, &#39;UTF-8&#39;) 
                  . &#39;:  The quick brown fox jumps over the lazy dog&#39;, 100, $yPosition, &#39;UTF-8&#39;);
    $yPosition -= 30;
}
...
// Get fonts referenced within the first document page
$firstPage = reset($pdf-&gt;pages);
$firstPageFonts = $firstPage-&gt;extractFonts();
...
             Extracting font from a loaded document by specifying font name. &lt;?php
...
$pdf = new Zend_Pdf();
...
$pdf-&gt;pages[] = ($page = $pdf-&gt;newPage(Zend_Pdf_Page::SIZE_A4));

$font = Zend_Pdf_Font::fontWithPath($fontPath);
$page-&gt;setFont($font, $fontSize);
$page-&gt;drawText($text, $x, $y);
...
// This font name should be stored somewhere...
$fontName = $font-&gt;getFontName(Zend_Pdf_Font::NAME_POSTSCRIPT, &#39;en&#39;, &#39;UTF-8&#39;);
...
$pdf-&gt;save($docPath);
...
             &lt;?php
...
$pdf = Zend_Pdf::load($docPath);
...
$pdf-&gt;pages[] = ($page = $pdf-&gt;newPage(Zend_Pdf_Page::SIZE_A4));

$font = $pdf-&gt;extractFont($fontName);  /* $srcPage-&gt;extractFont($fontName) can also be used here */
$page-&gt;setFont($font, $fontSize);
$page-&gt;drawText($text, $x, $y);
...
$pdf-&gt;save($docPath, true /* incremental update mode */);
...
             
            Extracted fonts can be used in the place of any other font with the following limitations:
             Extracted font can be used only in the context of the document from which it was extracted. 
                        Possibly embedded font program is actually not extracted. So extracted font can&#39;t provide 
                        correct font metrics and original font has to be used for text width calculations: 
             &lt;?php
...
$font = $pdf-&gt;extractFont($fontName);
$originalFont = Zend_Pdf_Font::fontWithPath($fontPath);

$page-&gt;setFont($font /* use extracted font for drawing */, $fontSize);
$xPosition = $x;
for ($charIndex = 0; $charIndex &lt; strlen($text); $charIndex++) {
    $page-&gt;drawText($text[$charIndex], xPosition, $y);

    // Use original font for text width calculation
    $xPosition += $originalFont-&gt;widthForGlyph($originalFont-&gt;glyphNumberForCharacter($text[$charIndex]))/$originalFont-&gt;getUnitsPerEm()*$fontSize;
}
...
             
                      
         Image Drawing. Zend_Pdf_Page  class provides drawImage() method to draw image:
         &lt;?php
/**
 * Draw an image at the specified position on the page.
 *
 * @param Zend_Pdf_Resource_Image $image
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function drawImage(Zend_Pdf_Resource_Image $image, $x1, $y1, $x2, $y2);
         
        Image objects should be created with  Zend_Pdf_Image::imageWithPath($filePath)  method
        (JPG, PNG and TIFF images are supported now):
         Image drawing. &lt;?php
...
// load image
$image = Zend_Pdf_Image::imageWithPath(&#39;my_image.jpg&#39;);

$pdfPage-&gt;drawImage($image, 100, 100, 400, 300);
...
             Important! JPEG support requires PHP GD extension to be configured. Important! PNG support requires ZLIB extension to be configured to work with Alpha channel images. 
            Refer to the PHP documentation for detailed information
            ( http://www.php.net/manual/en/ref.image.php ).
            ( http://www.php.net/manual/en/ref.zlib.php ).
         Line drawing style. 
        Line drawing style is defined by line width, line color and line dashing pattern.
        All of this parameters can be assigned by  Zend_Pdf_Page 
        class methods:
         &lt;?php
/** Set line color. */
public function setLineColor(Zend_Pdf_Color $color);

/** Set line width. */
public function setLineWidth(float $width);

/**
 * Set line dashing pattern.
 *
 * Pattern is an array of floats: array(on_length, off_length, on_length, off_length, ...)
 * Phase is shift from the beginning of line.
 *
 * @param array $pattern
 * @param array $phase
 */
public function setLineDashingPattern($pattern, $phase = 0);
         Fill style. Zend_Pdf_Page::drawRectangle() ,  Zend_Pdf_Page::drawPoligon() ,
         Zend_Pdf_Page::drawCircle()  and  Zend_Pdf_Page::drawEllipse()  methods take
         $fillType  argument as an optional parameter. It can be:
         Zend_Pdf_Page::SHAPE_DRAW_STROKE - stroke shape Zend_Pdf_Page::SHAPE_DRAW_FILL - only fill shape Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE - fill and stroke (default behavior) Zend_Pdf_Page::drawPoligon()  methods also takes an additional parameter
         $fillMethod :
         Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING (default behavior) PDF reference  describes this rule as follows:
                 
The nonzero winding number rule determines whether a given point is inside a
path by conceptually drawing a ray from that point to infinity in any direction
and then examining the places where a segment of the path crosses the ray. Starting
with a count of 0, the rule adds 1 each time a path segment crosses the ray
from left to right and subtracts 1 each time a segment crosses from right to left.
After counting all the crossings, if the result is 0 then the point is outside the path;
otherwise it is inside.

Note: The method just described does not specify what to do if a path segment coincides
with or is tangent to the chosen ray. Since the direction of the ray is arbitrary,
the rule simply chooses a ray that does not encounter such problem intersections.
For simple convex paths, the nonzero winding number rule defines the inside
and outside as one would intuitively expect. The more interesting cases are those
involving complex or self-intersecting paths like the ones shown in Figure 4.10
(in a PDF Reference).

For a path consisting of a five-pointed star, drawn with five connected straight
line segments intersecting each other, the rule considers the inside to be the entire
area enclosed by the star, including the pentagon in the center. For a path composed
of two concentric circles, the areas enclosed by both circles are considered
to be inside, provided that both are drawn in the same direction. If the circles are
drawn in opposite directions, only the &quot;doughnut&quot; shape between them is inside,
according to the rule; the &quot;doughnut hole&quot; is outside.
                 
             Zend_Pdf_Page::FILL_METHOD_EVEN_ODD PDF reference  describes this rule as follows:
                 
An alternative to the nonzero winding number rule is the even-odd rule. This rule
determines the &quot;insideness&quot; of a point by drawing a ray from that point in any
direction and simply counting the number of path segments that cross the ray,
regardless of direction. If this number is odd, the point is inside; if even, the point
is outside. This yields the same results as the nonzero winding number rule for
paths with simple shapes, but produces different results for more complex
shapes.

Figure 4.11 (in a PDF Reference) shows the effects of applying the even-odd rule
to complex paths. For the five-pointed star, the rule considers the triangular
points to be inside the path, but not the pentagon in the center. For the two
concentric circles, only the &quot;doughnut&quot; shape between the two circles is considered inside,
regardless of the directions in which the circles are drawn.
                     
             Rotations. 
        PDF page can be rotated before applying any draw operation.
        It can be done by  Zend_Pdf_Page::rotate()  method:
         &lt;?php
/**
 * Rotate the page around ($x, $y) point by specified angle (in radians).
 *
 * @param float $angle
 */
public function rotate($x, $y, $angle);
         Save/restore graphics state. 
        At any time page graphics state (current font, font size, line color, fill color,
        line style, page rotation, clip area) can be saved and then restored. Save operation puts
        data to a graphics state stack, restore operation retrieves it from there.
         
        There are two methods in  Zend_Pdf_Page  class for these operations:
         &lt;?php
/**
 * Save the graphics state of this page.
 * This takes a snapshot of the currently applied style, position, clipping area and
 * any rotation/translation/scaling that has been applied.
 */
public function saveGS();

/**
 * Restore the graphics state that was saved with the last call to saveGS().
 */
public function restoreGS();
         Clipping draw area. 
        PDF and Zend_Pdf module support clipping of draw area.
        Current clip area limits the regions of the page affected by painting operators. It&#39;s a whole page initially.
         Zend_Pdf_Page  class provides a set of methods for clipping operations.
         &lt;?php
/**
 * Intersect current clipping area with a rectangle.
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 */
public function clipRectangle($x1, $y1, $x2, $y2);
         &lt;?php
/**
 * Intersect current clipping area with a polygon.
 *
 * @param array $x  - array of float (the X co-ordinates of the vertices)
 * @param array $y  - array of float (the Y co-ordinates of the vertices)
 * @param integer $fillMethod
 */
public function clipPolygon($x, $y, $fillMethod = Zend_Pdf_Page::FILL_METHOD_NON_ZERO_WINDING);
         &lt;?php
/**
 * Intersect current clipping area with a circle.
 *
 * @param float $x
 * @param float $y
 * @param float $radius
 * @param float $startAngle
 * @param float $endAngle
 */
public function clipCircle($x, $y, $radius, $startAngle = null, $endAngle = null);
         &lt;?php
/**
 * Intersect current clipping area with an ellipse.
 *
 * Method signatures:
 * drawEllipse($x1, $y1, $x2, $y2);
 * drawEllipse($x1, $y1, $x2, $y2, $startAngle, $endAngle);
 *
 * @todo process special cases with $x2-$x1 == 0 or $y2-$y1 == 0
 *
 * @param float $x1
 * @param float $y1
 * @param float $x2
 * @param float $y2
 * @param float $startAngle
 * @param float $endAngle
 */
public function clipEllipse($x1, $y1, $x2, $y2, $startAngle = null, $endAngle = null);
         Styles. Zend_Pdf_Style  class provides styles functionality.
         
        Styles can be used to store a set of graphic state parameters and apply it to a PDF page by one operation:
         &lt;?php
/**
 * Set the style to use for future drawing operations on this page
 *
 * @param Zend_Pdf_Style $style
 */
public function setStyle(Zend_Pdf_Style $style);

/**
 * Return the style, applied to the page.
 *
 * @return Zend_Pdf_Style|null
 */
public function getStyle();
         Zend_Pdf_Style  class provides a set of methods to set or get different graphics state parameters:
         &lt;?php
/**
 * Set line color.
 *
 * @param Zend_Pdf_Color $color
 */
public function setLineColor(Zend_Pdf_Color $color);
         &lt;?php
/**
 * Get line color.
 *
 * @return Zend_Pdf_Color|null
 */
public function getLineColor();
         &lt;?php
/**
 * Set line width.
 *
 * @param float $width
 */
public function setLineWidth($width);
         &lt;?php
/**
 * Get line width.
 *
 * @return float
 */
public function getLineWidth();
         &lt;?php
/**
 * Set line dashing pattern
 *
 * @param array $pattern
 * @param float $phase
 */
public function setLineDashingPattern($pattern, $phase = 0);
         &lt;?php
/**
 * Get line dashing pattern
 *
 * @return array
 */
public function getLineDashingPattern();
         &lt;?php
/**
 * Get line dashing phase
 *
 * @return float
 */
public function getLineDashingPhase();
         &lt;?php
/**
 * Set fill color.
 *
 * @param Zend_Pdf_Color $color
 */
public function setFillColor(Zend_Pdf_Color $color);
         &lt;?php
/**
 * Get fill color.
 *
 * @return Zend_Pdf_Color|null
 */
public function getFillColor();
         &lt;?php
/**
 * Set current font.
 *
 * @param Zend_Pdf_Resource_Font $font
 * @param float $fontSize
 */
public function setFont(Zend_Pdf_Resource_Font $font, $fontSize);
         &lt;?php
/**
 * Modify current font size
 *
 * @param float $fontSize
 */
public function setFontSize($fontSize);
         &lt;?php
/**
 * Get current font.
 *
 * @return Zend_Pdf_Resource_Font $font
 */
public function getFont();
         &lt;?php
/**
 * Get current font size
 *
 * @return float $fontSize
 */
public function getFontSize();
         Introduction. 
    Zend_Pdf module is a PDF (Portable Document Format) manipulation engine written entirely in PHP 5.
    It can load existing documents, create new, modify and save modified documents.
    Thus it can help any PHP-driven application dynamically prepare documents in a PDF by modifying existing template
    or generating document from a scratch.

    Zend_Pdf module supports the following features:
     
            Create new document or load existing one.
             
                PDF V1.4 (Acrobat 5) documents are supported for loading now.
                 
             
            Retrieving specified revision of the document.
             
            Manipulate pages within document. Changing page order, adding new pages, removing pages
            from a document.
             
            Different drawing primitives (lines, rectangles, polygons, circles, ellipses and sectors).
             
            Text drawing using any of the 14 standard (built-in) fonts or your own custom TrueType fonts.
             
            Rotations.
             
            Image drawing.
             
                JPG, PNG [Up to 8bit per channel+Alpha] and TIFF images are supported.
                 
             
            Incremental PDF file update.
             
     Document pages. Page creation. 
            PDF document page abstraction is represented by  Zend_Pdf_Page  class.
         
            PDF pages either are loaded from existing PDF, or created.
         
            New page can be obtained by creating new  Zend_Pdf_Page  object or calling
             Zend_Pdf::newPage()  method, which returns  Zend_Pdf_Page  object.
            The difference is that  Zend_Pdf::newPage()  method creates a page, already attached to
            the document. In difference from unattached pages it can&#39;t be used with several PDF documents,
            but has a little bit better performance.
             
                It&#39;s a limitation of V1.0 version of Zend_Pdf module. It will be eliminated in future versions.
                But unattached pages will always give better (more optimal) result for sharing pages between documents.
                 . It&#39;s your choice, which approach should be used.
         Zend_Pdf::newPage()  method and  Zend_Pdf_Page  constructors take the same
        set of parameters specifying page size. It either the size of page ($x, $y) in a points (1/72 inch),
        or predefined constant, which is treated as a page type:
             Zend_Pdf_Page::SIZE_A4 Zend_Pdf_Page::SIZE_A4_LANDSCAPE Zend_Pdf_Page::SIZE_LETTER Zend_Pdf_Page::SIZE_LETTER_LANDSCAPE 
         
            Document pages are stored in  $pages  public member of  Zend_Pdf  class.
            It&#39;s an array of  Zend_Pdf_Page  objects. It completely defines set and order of document pages
            and can be manipulated as a common array:
         PDF document pages management. &lt;?php
    ...
    // Reverse page order
    $pdf-&gt;pages = array_reverse($pdf-&gt;pages);
    ...
    // Add new page
    $pdf-&gt;pages[] = new Zend_Pdf_Page(Zend_Pdf_Page::SIZE_A4);
    // Add new page
    $pdf-&gt;pages[] = $pdf-&gt;newPage(Zend_Pdf_Page::SIZE_A4);

    // Remove specified page.
    unset($pdf-&gt;pages[$id]);

    ...
             Page cloning. 
            Existing PDF page can be cloned by creating new  Zend_Pdf_Page  object with existing page as a parameter:
         Cloning existing page. &lt;?php
    ...
    // Store template page in a separate variable
    $template = $pdf-&gt;pages[$templatePageIndex];
    ...
    // Add new page
    $page1 = new Zend_Pdf_Page($template);
    $pdf-&gt;pages[] = $page1;
    ...

    // Add another page
    $page2 = new Zend_Pdf_Page($template);
    $pdf-&gt;pages[] = $page2;
    ...

    // Remove source template page from the documents.
    unset($pdf-&gt;pages[$templatePageIndex]);

    ...
             
            It&#39;s useful if you need several pages to be created using one template.
         
                Important! Cloned page shares some PDF resources with a template page, so it can be used only withing the same document
                as a template page. Modified document can be saved as new one.
             Document Info and Metadata. 
        A PDF document may include general information such as the documentâ€™s title,
        author, and creation and modification dates.
     
        Historicaly this information is stored using special Info structure. This structure
        is available for read and writing as an associative array using  properties  public property
        of Zend_Pdf objects:
             &lt;?php
$pdf = Zend_Pdf::load($pdfPath);

echo $pdf-&gt;properties[&#39;Title&#39;] . &quot;\n&quot;;
echo $pdf-&gt;properties[&#39;Author&#39;] . &quot;\n&quot;;

$pdf-&gt;properties[&#39;Title&#39;] = &#39;New Title.&#39;;
$pdf-&gt;save($pdfPath);

             

     
        The following keys are defined by PDF v1.4 (Acrobat 5) standard:

         Title  - string, optional, the documentâ€™s title.
                 Author  - string, optional, the name of the person who created the document.
                 Subject  - string, optional, the subject of the document.
                 Keywords  - string, optional, keywords associated with the document.
                 Creator  - string, optional, if the document was converted to PDF from another format,
                    the name of the application (for example, Adobe FrameMakerÂ®) that created the original document from which
                    it was converted.
                 Producer  - string, optional, if the document was converted to PDF from another format, the
                    name of the application (for example, Acrobat Distiller) that converted it to PDF..
                 CreationDate  - string, optional, the date and time the document was created, in the following form:
                    &quot;D:YYYYMMDDHHmmSSOHH&#39;mm&#39;&quot;, where:
                     YYYY  is the year.
                             MM  is the month.
                             DD  is the day (01â€“31).
                             HH  is the hour (00â€“23).
                             mm is the minute (00â€“59).
                             SS  is the second (00â€“59).
                             O  is the relationship of local time to Universal Time (UT),
                                denoted by one of the characters +, âˆ’, or Z (see below).
                             HH  followed by &#39; is the absolute value of the offset from UT in hours (00â€“23).
                             mm  followed by &#39; is the absolute value of the offset from UT in minutes (00â€“59).
                             
                    The apostrophe character (&#39;) after HH and mm is part of the syntax. All fields after
                    the year are optional. (The prefix D:, although also optional, is strongly recommended.)
                    The default values for MM and DD are both 01; all other numerical
                    fields default to zero values. A plus sign (+) as the value of the O field signifies that
                    local time is later than UT, a minus sign (âˆ’) that local time is earlier than UT, and
                    the letter Z that local time is equal to UT. If no UT information is specified, the
                    relationship of the specified time to UT is considered to be unknown. Whether or
                    not the time zone is known, the rest of the date should be specified in local time.
                 
                    For example, December 23, 1998, at 7:52 PM, U.S. Pacific Standard Time, is represented
                    by the string &quot;D:199812231952âˆ’08&#39;00&#39;&quot;.
                 ModDate  - string, optional, the date and time the document was most recently
                    modified, in the same form as  CreationDate .
                 Trapped  - boolean, optional, indicates whether the document has
                    been modified to include trapping information.
                     true  - The document has been fully trapped; no further trapping is needed.
                             false  - The document has not yet been trapped; any desired trapping must still be done.
                             null  - Either it is unknown whether the document has been
                                trapped or it has been partly but not yet fully trapped; some
                                additional trapping may still be needed.
                             
                 
     
        Since PDF v 1.6 metadata can be stored in the special XML document attached to the PDF
        (XMP -  Extensible Metadata Platform ).
     
        This XML document can be retrieved and attached to the PDF with  Zend_Pdf::getMetadata()  and
         Zend_Pdf::setMetadata($metadata)  methods:
             &lt;?php
$pdf = Zend_Pdf::load($pdfPath);
$metadata = $pdf-&gt;getMetadata();
$metadataDOM = new DOMDocument();
$metadataDOM-&gt;loadXML($metadata);

$xpath = new DOMXPath($metadataDOM);
$pdfPreffixNamespaceURI = $xpath-&gt;query(&#39;/rdf:RDF/rdf:Description&#39;)-&gt;item(0)-&gt;lookupNamespaceURI(&#39;pdf&#39;);
$xpath-&gt;registerNamespace(&#39;pdf&#39;, $pdfPreffixNamespaceURI);

$titleNode = $xpath-&gt;query(&#39;/rdf:RDF/rdf:Description/pdf:Title&#39;)-&gt;item(0);
$title = $titleNode-&gt;nodeValue;
...

$titleNode-&gt;nodeValue = &#39;New title&#39;;
$pdf-&gt;setMetadata($metadataDOM-&gt;saveXML());
$pdf-&gt;save($pdfPath);

             
     
        Common document properties are duplicated in the Info structure and Metadata document (if presented).
        It&#39;s user application responsibility now to keep them syncronized.
     Save changes to the PDF document. 
    There are two methods, which provide saving changes to the PDF document. These are  Zend_Pdf::save()  and
     Zend_Pdf::render()  methods.
     Zend_Pdf::save($filename, $updateOnly = false)  saves the PDF document to a file. If $updateOnly
    is true, then only the new PDF file segment is appended to a file. Otherwise, the file is overwritten.
     Zend_Pdf::render($newSegmentOnly = false)  returns the PDF document as a string.  If
    $newSegmentOnly is true, then only the new PDF file segment is returned.
     Save PDF document. &lt;?php
...
// Load PDF document.
$pdf = Zend_Pdf::load($fileName);
...
// Update document
$pdf-&gt;save($fileName, true);
// Save document as a new file
$pdf-&gt;save($newFileName);

// Return PDF document as a string.
$pdfString = $pdf-&gt;render();

...
         Zend_Pdf module usage example. 
    This section provides an example of module usage.
     
    This example can be found in a  demos/Zend/Pdf/demo.php  file.
     
    There are also  test.pdf  file, which can be used with this demo
    for test purposes.
     Zend_Pdf module usage demo. &lt;?php
/**
 * @package Zend_Pdf
 * @subpackage demo
 */

/** Zend_Pdf */
require_once &#39;Zend/Pdf.php&#39;;

if (!isset($argv[1])) {
    echo &quot;USAGE: php demo.php &lt;pdf_file&gt; [&lt;output_pdf_file&gt;]\n&quot;;
    exit;
}

try {
    $pdf = Zend_Pdf::load($argv[1]);
} catch (Zend_Pdf_Exception $e) {
    if ($e-&gt;getMessage() == &#39;Can not open \&#39;&#39; . $argv[1] . &#39;\&#39; file for reading.&#39;) {
        // Create new PDF if file doesn&#39;t exist
        $pdf = new Zend_Pdf();

        if (!isset($argv[2])) {
            // force complete file rewriting (instead of updating)
            $argv[2] = $argv[1];
        }
    } else {
        // Throw an exception if it&#39;s not the &quot;Can&#39;t open file&quot; exception
        throw $e;
    }
}

//------------------------------------------------------------------------------------
// Reverse page order
$pdf-&gt;pages = array_reverse($pdf-&gt;pages);

// Create new Style
$style = new Zend_Pdf_Style();
$style-&gt;setFillColor(new Zend_Pdf_Color_Rgb(0, 0, 0.9));
$style-&gt;setLineColor(new Zend_Pdf_Color_GrayScale(0.2));
$style-&gt;setLineWidth(3);
$style-&gt;setLineDashingPattern(array(3, 2, 3, 4), 1.6);
$style-&gt;setFont(Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_HELVETICA_BOLD), 32);

// Create new image object
$stampImage = Zend_Pdf_Image::imageWithPath(dirname(__FILE__) . &#39;/stamp.jpg&#39;);

// Mark page as modified
foreach ($pdf-&gt;pages as $page){
    $page-&gt;saveGS();
    $page-&gt;setStyle($style);
    $page-&gt;rotate(0, 0, M_PI_2/3);

    $page-&gt;saveGS();
    $page-&gt;clipCircle(550, -10, 50);
    $page-&gt;drawImage($stampImage, 500, -60, 600, 40);
    $page-&gt;restoreGS();

    $page-&gt;drawText(&#39;Modified by Zend Framework!&#39;, 150, 0);
    $page-&gt;restoreGS();
}

// Add new page generated by Zend_Pdf object (page is attached to the specified document)
$pdf-&gt;pages[] = ($page1 = $pdf-&gt;newPage(&#39;A4&#39;));

// Add new page generated by Zend_Pdf_Page object (page is not attached to the document)
$pdf-&gt;pages[] = ($page2 = new Zend_Pdf_Page(Zend_Pdf_Page::SIZE_LETTER_LANDSCAPE));

// Create new font
$font = Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_HELVETICA);

// Apply font and draw text
$page1-&gt;setFont($font, 36);
$page1-&gt;drawText(&#39;Helvetica 36 text string&#39;, 60, 500);

// Use font object for another page
$page2-&gt;setFont($font, 24);
$page2-&gt;drawText(&#39;Helvetica 24 text string&#39;, 60, 500);

// Use another font
$page2-&gt;setFont(Zend_Pdf_Font::fontWithName(Zend_Pdf_Font::FONT_TIMES_ROMAN), 32);
$page2-&gt;drawText(&#39;Times-Roman 32 text string&#39;, 60, 450);

// Draw rectangle
$page2-&gt;setFillColor(new Zend_Pdf_Color_GrayScale(0.8));
$page2-&gt;setLineColor(new Zend_Pdf_Color_GrayScale(0.2));
$page2-&gt;setLineDashingPattern(array(3, 2, 3, 4), 1.6);
$page2-&gt;drawRectangle(60, 400, 400, 350);

// Draw circle
$page2-&gt;setLineDashingPattern(Zend_Pdf_Page::LINE_DASHING_SOLID);
$page2-&gt;setFillColor(new Zend_Pdf_Color_Rgb(1, 0, 0));
$page2-&gt;drawCircle(85, 375, 25);

// Draw sectors
$page2-&gt;drawCircle(200, 375, 25, 2*M_PI/3, -M_PI/6);
$page2-&gt;setFillColor(new Zend_Pdf_Color_Cmyk(1, 0, 0, 0));
$page2-&gt;drawCircle(200, 375, 25, M_PI/6, 2*M_PI/3);
$page2-&gt;setFillColor(new Zend_Pdf_Color_Rgb(1, 1, 0));
$page2-&gt;drawCircle(200, 375, 25, -M_PI/6, M_PI/6);

// Draw ellipse
$page2-&gt;setFillColor(new Zend_Pdf_Color_Rgb(1, 0, 0));
$page2-&gt;drawEllipse(250, 400, 400, 350);
$page2-&gt;setFillColor(new Zend_Pdf_Color_Cmyk(1, 0, 0, 0));
$page2-&gt;drawEllipse(250, 400, 400, 350, M_PI/6, 2*M_PI/3);
$page2-&gt;setFillColor(new Zend_Pdf_Color_Rgb(1, 1, 0));
$page2-&gt;drawEllipse(250, 400, 400, 350, -M_PI/6, M_PI/6);

// Draw and fill polygon
$page2-&gt;setFillColor(new Zend_Pdf_Color_Rgb(1, 0, 1));
$x = array();
$y = array();
for ($count = 0; $count &lt; 8; $count++) {
    $x[] = 140 + 25*cos(3*M_PI_4*$count);
    $y[] = 375 + 25*sin(3*M_PI_4*$count);
}
$page2-&gt;drawPolygon($x, $y,
                    Zend_Pdf_Page::SHAPE_DRAW_FILL_AND_STROKE,
                    Zend_Pdf_Page::FILL_METHOD_EVEN_ODD);

// Draw line
$page2-&gt;setLineWidth(0.5);
$page2-&gt;drawLine(60, 375, 400, 375);
//------------------------------------------------------------------------------------

if (isset($argv[2])) {
    $pdf-&gt;save($argv[2]);
} else {
    $pdf-&gt;save($argv[1], true /* update */);
}
         Using the Registry 
        The registry is a container for storing objects and values in the
        application space.  By storing the value in the registry, the same
        object is always available throughout your application.
        This mechanism is an alternative to using global storage.
     
        The typical usage of the registry is through static methods in the
        Zend_Registry class.  Alternatively, the class is an array object,
        so you can access elements stored within it with a convenient
        array-like interface.
     Setting Values in the Registry 
            To store an entry in the registry, use the static method
             set() .
         Example of set() method &lt;?php
Zend_Registry::set(&#39;index&#39;, $value);
             
            The value can be an object, an array, or a scalar.
            You can change the value stored in a specific entry of
            the registry by using  set()  to set it
            to a new value.
         
            The index can be a scalar, either string or integer,
            like an ordinary array.
         Getting Values from the Registry 
            To retrieve an entry from the registry, use the static method
             get() .
         Example of get() method &lt;?php
$value = Zend_Registry::get(&#39;index&#39;);
             
            The  getInstance()  method returns the static registry object.
         
            A registry object is iterable.
         Example of iterating over the registry &lt;?php
$registry = Zend_Registry::getInstance();

foreach ($registry as $index =&gt; $value) {
    echo &quot;Registry index $index contains:\n&quot;;
    var_dump($value);
}
             Constructing a Registry Object 
            In addition to accessing the static registry through
            static methods, you can create an instance directly and
            use it as an object.
         
            The registry instance you access through the
            static methods is simply one such instance, and it is
            for convenience that it is stored statically, so you
            can access it from anywhere in your appliation.
         
            Use a traditional  new  constructor to create
            an instance of the registry.  This gives you the opportunity
            to initialize the entries in the registry as an associatve
            array.
         Example of constructing a registry &lt;?php
$registry = new Zend_Registry(array(&#39;index&#39; =&gt; $value));
             
            After constructing this instance, you can use it using
            array-object methods, or you can set this instance
            to become the static instance using the static method
             setInstance() .
         Example of initializing the static registry &lt;?php
$registry = new Zend_Registry(array(&#39;index&#39; =&gt; $value));

Zend_Registry::setInstance($registry);
             
            The  setInstance()  method throws a Zend_Exception
            if the static registry has already been initialized by its
            first access.
         Accessing the Registry as an Array 
            If you have several values to get or set, you may find it
            convenient to access the registry with array notation.
         Example of array access &lt;?php
$registry = Zend_Registry::getInstance();

$registry[&#39;index&#39;] = $value;

var_dump( $registry[&#39;index&#39;] );
             Accessing the Registry as an Object 
            You may also find it convenient to access the registry
            in an object-oriented fashion, using index names as object
            properties.
            To do this, you need to specifically construct the registry
            object using the  ArrayObject::ARRAY_AS_PROPS  option,
            and initialize the static instance.  You must do this before
            the static registry has been accessed for the first time.
             Beware  of using this option,
            since some versions of PHP have bugs when using the registry
            with this option.
         Example of object access &lt;?php
// in your application bootstrap:
$registry = new Zend_Registry(array(), ArrayObject::ARRAY_AS_PROPS)
Zend_Registry::setInstance($registry);
$registry-&gt;tree = &#39;apple&#39;;

.
.
.

// in a different function, elsewhere in your application:
$registry = Zend_Registry::getInstance();

echo $registry-&gt;tree; // echo&#39;s &quot;apple&quot;

$registry-&gt;index = $value;

var_dump($registry-&gt;index);
             Querying if an index exists 
            To find out if a particular index in the registry
            has a value, use the static method  isRegistered() .
         Example of isRegistered() method &lt;?php
if (Zend_Registry::isRegistered($index)) {
    $value = Zend_Registry::get($index);
}
             
            To find out if a particular index in a registry
            array-object has a value, use  isset() 
            like you would with an ordinary array.
         Example of isset() method &lt;?php
$registry = Zend_Registry::getInstance();

// using array-access syntax
if (isset($registry[&#39;index&#39;])) {
    var_dump( $registry[&#39;index&#39;] );
}

// using object-access syntax, if enabled
if (isset($registry-&gt;index)) {
    var_dump( $registry-&gt;index );
}
             Extending the Registry 
            The static registry is an instance of the class Zend_Registry.
            If you want to add functionality to the registry, you can
            create a class that extends Zend_Registry, and then you can
            specify this class as the class to use for the static registry.
            Use the static method  setClassName()  to specify
            the class.  The class must extend Zend_Registry.
         Example of specifying the static registry&#39;s class name &lt;?php
Zend_Registry::setClassName(&#39;My_Registry&#39;);

Zend_Registry::set(&#39;index&#39;, $value);
             
            The registry throws a Zend_Exception if you try to set the
            classname after the registry has been accessed for the first time.
            It is recommended that you specify the classname for your
            static registry in your application bootstrap.
         Unsetting the Static Registry 
            Although it is not normally necessary, you can
            unset the static instance of the registry.
            Use the static method  _unsetInstance() .
         Data loss risk 
                When you use  _unsetInstance() ,
                all data in the static registry are
                discarded and cannot be recovered.
             
            You might use this method, for example, if you want to
            use  setInstance()  or  setClassName() 
            after the static registry object has been initialized.
            Unsetting the static instance allows you to use these methods.
         Example of _unsetInstance() method &lt;?php
Zend_Registry::set(&#39;index&#39;, $value);

Zend_Registry::_unsetInstance();

// change the class
Zend_Registry::setClassName(&#39;My_Registry&#39;);

Zend_Registry::set(&#39;index&#39;, $value);
             Introduction 
        REST Web Services use service-specific XML formats. These ad-hoc
        standards mean that the manner for accessing a REST web service is
        different for each service. REST web services typically use URL
        parameters (GET data) or path information for requesting data and POST
        data for sending data.
     
        The Zend Framework provides both Client and Server capabilities, which,
        when used together allow for a much more &quot;local&quot; interface experience
        via virtual object property access.  The Server component features
        automatic exposition of functions and classes using a meaningful and
        simple XML format. When accessing these services using the Client, it is
        possible to easily retrieve the return data from the remote call. Should
        you wish to use the client with a non-Zend_Rest_Server based service, it
        will still provide easier data access.
     Zend_Rest_Client Introduction 
            Using the  Zend_Rest_Client  is very similar to using
             SoapClient  objects ( SOAP web service extension ).
            You can simply call the REST service procedures as
             Zend_Rest_Client  methods.  Specify the service&#39;s full
            address in the  Zend_Rest_Client  constructor.
         A basic REST request &lt;?php
/**
 * Connect to framework.zend.com server and retrieve a greeting
 */
require_once &#39;Zend/Rest/Client.php&#39;;

$client = new Zend_Rest_Client(&#39;http://framework.zend.com/rest&#39;);

echo $client-&gt;sayHello(&#39;Davey&#39;, &#39;Day&#39;)-&gt;get(); // &quot;Hello Davey, Good Day&quot;
             Differences in calling Zend_Rest_Client  attempts to make remote methods
                look as much like native methods as possible, the only
                difference being that you must follow the method call with one
                of either  get() ,  post() ,
                 put()  or  delete() . This call may be
                made via method chaining or in separate method calls:
             &lt;?php
$client-&gt;sayHello(&#39;Davey&#39;, &#39;Day&#39;);
echo $client-&gt;get();
             Responses 
            All requests made using  Zend_Rest_Client  return a
             Zend_Rest_Client_Response  object. This object has many
            properties that make it easier to access the results.
         
            When the service is based on  Zend_Rest_Server ,
             Zend_Rest_Client  can make several assumptions about the
            response, including response status (success or failure) and return
            type.
         Response Status &lt;?php
$result = $client-&gt;sayHello(&#39;Davey&#39;, &#39;Day&#39;)-&gt;get();

if ($result-&gt;isSuccess()) {
    echo $result; // &quot;Hello Davey, Good Day&quot;
}
             
            In the example above, you can see that we use the request result as
            an object, to call  isSuccess() , and then because of
             __toString() , we can simply  echo  the
            object to get the result.  Zend_Rest_Client_Response 
            will allow you to echo any scalar value. For complex types, you can
            use either array or object notation.
         
            If however, you wish to query a service not using
             Zend_Rest_Server  the
             Zend_Rest_Client_Response  object will behave more like
            a  SimpleXMLElement . However, to make things easier, it
            will automatically query the XML using XPath if the property is not
            a direct descendant of the document root element. Additionally, if
            you access a property as a method, you will receive the PHP value
            for the object, or an array of PHP value results.
         Using Technorati&#39;s Rest Service &lt;?php
require_once &#39;Zend/Rest/Client.php&#39;;

$technorati = new Zend_Rest_Client(&#39;http://api.technorati.com/bloginfo&#39;);
$technorati-&gt;key($key);
$technorati-&gt;url(&#39;http://pixelated-dreams.com&#39;);
$result = $technorati-&gt;get();
echo $result-&gt;firstname() .&#39; &#39;. $result-&gt;lastname();
             Example Technorati Response &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!-- generator=&quot;Technorati API version 1.0 /bloginfo&quot; --&gt;
&lt;!DOCTYPE tapi PUBLIC &quot;-//Technorati, Inc.//DTD TAPI 0.02//EN&quot; &quot;http://api.technorati.com/dtd/tapi-002.xml&quot;&gt;
&lt;tapi version=&quot;1.0&quot;&gt;
    &lt;document&gt;
        &lt;result&gt;
            &lt;url&gt;http://pixelated-dreams.com&lt;/url&gt;
            &lt;weblog&gt;
                &lt;name&gt;Pixelated Dreams&lt;/name&gt;
                &lt;url&gt;http://pixelated-dreams.com&lt;/url&gt;
                &lt;author&gt;
                    &lt;username&gt;DShafik&lt;/username&gt;
                    &lt;firstname&gt;Davey&lt;/firstname&gt;
                    &lt;lastname&gt;Shafik&lt;/lastname&gt;
                &lt;/author&gt;
                &lt;rssurl&gt;http://pixelated-dreams.com/feeds/index.rss2&lt;/rssurl&gt;
                &lt;atomurl&gt;http://pixelated-dreams.com/feeds/atom.xml&lt;/atomurl&gt;
                &lt;inboundblogs&gt;44&lt;/inboundblogs&gt;
                &lt;inboundlinks&gt;218&lt;/inboundlinks&gt;
                &lt;lastupdate&gt;2006-04-26 04:36:36 GMT&lt;/lastupdate&gt;
                &lt;rank&gt;60635&lt;/rank&gt;
            &lt;/weblog&gt;
            &lt;inboundblogs&gt;44&lt;/inboundblogs&gt;
            &lt;inboundlinks&gt;218&lt;/inboundlinks&gt;
        &lt;/result&gt;
    &lt;/document&gt;
&lt;/tapi&gt;
             
            Here we are accessing the  firstname  and
             lastname  properties. Even though these are not
            top-level elements, they are automatically returned when accessed by
            name.
         Multiple items 
                If multiple items are found when accessing a value by name, an
                array of SimpleXMLElements will be returned; accessing via
                method notation will return an array of PHP values.
             Request Arguments 
            Unless you are making a request to a  Zend_Rest_Server 
            based service, chances are you will need to send multiple arguments
            with your request. This is done by calling a method with the name of
            the argument, passing in the value as the first (and only) argument.
            Each of these method calls returns the object itself, allowing for
            chaining, or &quot;fluent&quot; usage. The first call, or the first argument
            if you pass in more than one argument, is always assumed to be the
            method when calling a  Zend_Rest_Server  service.
         Setting Request Arguments &lt;?php
$client = new Zend_Rest_Client(&#39;http://example.org/rest&#39;);

$client-&gt;arg(&#39;value1&#39;);
$client-&gt;arg2(&#39;value2&#39;);
$client-&gt;get();

// or

$client-&gt;arg(&#39;value1&#39;)-&gt;arg2(&#39;value2&#39;)-&gt;get();
             
            Both of the methods in the example above, will result in the
            following get args:
             ?method=arg&amp;arg1=value1&amp;arg=value1&amp;arg2=value2 
         
            You will notice that the first call of
             $client-&gt;arg(&#39;value1&#39;);  resulted in both
             method=arg&amp;arg1=value1  and  arg=value1 ;
            this is so that  Zend_Rest_Server  can understand the
            request properly, rather than requiring pre-existing knowledge of
            the service.
         Strictness of Zend_Rest_Client 
                Any REST service that is strict about the arguments it receives will likely fail
                using  Zend_Rest_Client , because of the behavior described
                above. This is not a common practice and should not cause problems.
             Zend_Rest_Server Introduction 
            Zend_Rest_Server is intended as a fully-featured REST server.
         REST Server Usage Basic Zend_Rest_Server Usage - Classes &lt;?php
require_once &#39;Zend/Rest/Server.php&#39;;
require_once &#39;My/Service/Class.php&#39;;

$server = new Zend_Rest_Server();
$server-&gt;setClass(&#39;My_Service_Class&#39;);
$server-&gt;handle();
             Basic Zend_Rest_Server Usage - Functions &lt;?php
require_once &#39;Zend/Rest/Server.php&#39;;

/**
 * Say Hello
 *
 * @param string $who
 * @param string $when
 * @return string
 */
function sayHello($who, $when)
{
    return &quot;Hello $who, Good $when&quot;;
}

$server = new Zend_Rest_Server();
$server-&gt;addFunction(&#39;sayHello&#39;);
$server-&gt;handle();
             Calling a Zend_Rest_Server Service 
            To call a  Zend_Rest_Server  service, you must supply a
            GET/POST  method  argument with a value that is the
            method you wish to call. You can then follow that up with any number
            of arguments using either the name of the argument (i.e. &quot;who&quot;) or
            using  arg  following by the numeric position of the
            argument (i.e. &quot;arg1&quot;).
         Numeric index 
                Numeric arguments use a 1-based index.
             
            To call  sayHello  from the example above, you can use either:
         ?method=sayHello&amp;who=Davey&amp;when=Day 
            or:
         ?method=sayHello&amp;arg1=Davey&amp;arg2=Day Sending A Custom Status 
            When returning values, to return a custom status, you may return an
            array with a  status  key.
         Returning Custom Status &lt;?php
require_once &#39;Zend/Rest/Server.php&#39;;

/**
 * Say Hello
 *
 * @param string $who
 * @param string $when
 * @return array
 */
function sayHello($who, $when)
{
    return array(&#39;msg&#39; =&gt; &quot;An Error Occurred&quot;, &#39;status&#39; =&gt; false);
}

$server = new Zend_Rest_Server();
$server-&gt;addFunction(&#39;sayHello&#39;);
$server-&gt;handle();
             Returning Custom XML Responses 
            If you wish to return custom XML, simply return a
             DOMDocument ,  DOMElement  or
             SimpleXMLElement  object.
         Return Custom XML &lt;?php
require_once &#39;Zend/Rest/Server.php&#39;;

/**
 * Say Hello
 *
 * @param string $who
 * @param string $when
 * @return SimpleXMLElement
 */
function sayHello($who, $when)
{
    $xml =&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;mysite&gt;
    &lt;value&gt;Hey $who! Hope you&#39;re having a good $when&lt;/value&gt;
    &lt;code&gt;200&lt;/code&gt;
&lt;/mysite&gt;&#39;;

    $xml = simplexml_load_string($xml);
    return $xml;
}

$server = new Zend_Rest_Server();
$server-&gt;addFunction(&#39;sayHello&#39;);

$server-&gt;handle();
             
            The response from the service will be returned without modification
            to the client.
         Advanced Using the index as static property 
            The  Zend_Search_Lucene  object uses the destructor method to commit changes and clean up resources.
         
            It stores added documents in memory and dumps new index segment to disk depending on  MaxBufferedDocs  parameter.
         
            If  MaxBufferedDocs  limit is not reached then there are some &quot;unsaved&quot; documents which are saved as a new segment in the object&#39;s destructor method.
            The index auto-optimization procedure is invoked if necessary depending on the values of the  MaxBufferedDocs ,  MaxMergeDocs  and
             MergeFactor  parameters.
         
            Static object properties (see below) are destroyed  after  the last line of the executed script.

             &lt;?php
class Searcher {
    private static $_index;

    public static function initIndex() {
        self::$_index = Zend_Search_Lucene::open(&#39;path/to/index&#39;);
    }
}

Searcher::initIndex();
             
         
            All the same, the destructor for static properties is correctly invoked at this point in the program&#39;s execution.
         
            One potential problem is exception handling. Exceptions thrown by destructors of static objects don&#39;t have context, because the destructor is executed after the script has already completed.
         
            You might see a &quot;Fatal error: Exception thrown without a stack frame in Unknown on line 0&quot; error message instead of exception description in such cases.
         
            Zend_Search_Lucene provides a workaround to this problem with the  commit()  method. It saves all unsaved changes and frees memory used for storing new segments.
            You are free to use the commit operation any time- or even several times- during script execution. You can still use the  Zend_Search_Lucene  object for searching,
            adding or deleting document after the commit operation. But the  commit()  call guarantees that if there are no document added or deleted after the call to  commit() , then
            the  Zend_Search_Lucene  destructor has nothing to do and will not throw exception:

             &lt;?php
class Searcher {
    private static $_index;

    public static function initIndex() {
        self::$_index = Zend_Search_Lucene::open(&#39;path/to/index&#39;);
    }

    ...

    public static function commit() {
        self::$_index-&gt;commit();
    }
}

Searcher::initIndex();

...

// Script shutdown routine
...
Searcher::commit();
...
             
         Best Practices Field names 
            There are no limitations for field names in Zend_Search_Lucene.
         
            Nevertheless it&#39;s a good idea not to use &#39; id &#39; and &#39; score &#39; names
            to avoid ambiguity in  QueryHit  properties names.
         
            The  Zend_Search_Lucene_Search_QueryHit   id  and  score  properties always refer
            to internal Lucene document id and hit  score .
            If the indexed document has the same stored fields, you have to use the  getDocument()  method to access them:

             &lt;?php
$hits = $index-&gt;find($query);

foreach ($hits as $hit) {
    // Get &#39;title&#39; document field
    $title = $hit-&gt;title;

    // Get &#39;contents&#39; document field
    $contents = $hit-&gt;contents;


    // Get internal Lucene document id
    $id = $hit-&gt;id;

    // Get query hit score
    $score = $hit-&gt;score;


    // Get &#39;id&#39; document field
    $docId = $hit-&gt;getDocument()-&gt;id;

    // Get &#39;score&#39; document field
    $docId = $hit-&gt;getDocument()-&gt;score;

    // Another way to get &#39;title&#39; document field
    $title = $hit-&gt;getDocument()-&gt;title;
}
             
         Indexing performance 
            Indexing performance is a compromise between used resources, indexing time and index quality.
         
            Index quality is completely determined by number of index segments.
         
            Each index segment is entirely independent portion of data. So indexes containing more segments need
            more memory and time for searching.
         
            Index optimization is a process of merging several segments into a new one. A fully optimized index contains
            only one segment.
         
            Full index optimization may be performed with the  optimize()  method:
             &lt;?php
$index = Zend_Search_Lucene::open($indexPath);

$index-&gt;optimize();
             
         
            Index optimization works with data streams and doesn&#39;t take a lot of memory but does require processor resources and time.
         
            Lucene index segments are not updatable by their nature (the update operation requires the segment file
            to be completely rewritten). So adding new document(s) to an index always generates a new segment.
            This, in turn, decreases index quality.
         
            An index auto-optimization process is performed after each segment generation and consists of merging partial segments.
         
            There are three options to control the behavior of auto-optimization
            (see  Index optimization  section):
             MaxBufferedDocs  is the number of documents that can be buffered in memory before a new segment is generated
                          and written to the hard drive. MaxMergeDocs  is the maximum number of documents merged by auto-optimization process
                          into a new segment. MergeFactor  determines how often auto-optimization is performed. 
             
                    All these options are Zend_Search_Lucene object properties- not index properties. They affect only current
                     Zend_Search_Lucene  object behavior and may vary for different scripts.
                 
         MaxBufferedDocs  doesn&#39;t have any effect if you index only one document per script execution. On the other hand, it&#39;s very important
            for batch indexing. Greater values increase indexing performance, but also require more memory.
         
            There is simply no way to calculate the best value for the  MaxBufferedDocs  parameter because it depends on average document size, the
            analyzer in use and allowed memory.
         
            A good way to find the right value is to perform several tests with the largest document you expect to be added to the index
             memory_get_usage()  and  memory_get_peak_usage()  may be used to control
            memory usage. . It&#39;s a best practice not to use more than a half of the allowed memory.
         MaxMergeDocs  limits the segment size (in terms of documents). It therefore also limits auto-optimization time by guaranteeing
            that the  addDocument()  method is not executed more than a certain number of times. This is very important for interactive applications.
         
            Lowering the  MaxMergeDocs  parameter also may improve batch indexing performance. Index auto-optimization is an iterative process
            and is performed from bottom up. Small segments are merged into larger segment, which are in turn merged into even larger segments and
            so on. Full index optimization is achieved when only one large segment file remains.
         
            Small segments generally decrease index quality. Many small segments may also trigger
            the &quot;Too many open files&quot; error determined by OS limitations  Zend_Search_Lucene keeps each segment file opened
            to improve search performance. .
         
            in general, background index optimization should be performed for interactive indexing mode and  MaxMergeDocs  shouldn&#39;t be
            too low for batch indexing.
         MergeFactor  affects auto-optimization frequency. Lower values increase the quality of unoptimized indexes. Larger values increase
            indexing performance, but also increase the number of merged segments. This again may trigger the &quot;Too many open files&quot; error.
         MergeFactor  groups index segments by their size:
             Not greater than  MaxBufferedDocs . Greater than  MaxBufferedDocs , but not greater than
                                 MaxBufferedDocs * MergeFactor . Greater than  MaxBufferedDocs * MergeFactor , but not greater than
                 MaxBufferedDocs * MergeFactor * MergeFactor . ... 
         
            Zend_Search_Lucene checks during each  addDocument()  call to see if merging any segments may move the newly created segment
            into the next group. If yes, then merging is performed.
         
            So an index with N groups may contain  MaxBufferedDocs  + (N-1)* MergeFactor  segments and contains at least
             MaxBufferedDocs * MergeFactor (N-1)  documents.
         
            This gives good approximation for the number of segments in the index:
         NumberOfSegments   &lt;=  MaxBufferedDocs  +  MergeFactor *log
             MergeFactor  ( NumberOfDocuments / MaxBufferedDocs )
         MaxBufferedDocs  is determined by allowed memory. This allows for the appropriate merge factor to get a reasonable
            number of segments.
         
            Tuning the  MergeFactor  parameter is more effective for batch indexing performance than  MaxMergeDocs . But it&#39;s also more course-grained.
            So use the estimation above for tuning  MergeFactor , then play with  MaxMergeDocs  to get best batch indexing performance.
         Index during Shut Down 
            The  Zend_Search_Lucene  instance performs some work at exit time if any documents were added to the index but not written to a new segment.
         
            It also may trigger an auto-optimization process.
         
            The index object is automatically closed when it, and all returned QueryHit objects, go out of scope.
         
            If index object is stored in global variable than it&#39;s closed only at the end of script execution This also
            may occur if the index or QueryHit instances are referred to in some cyclical data structures, because PHP garbage collects objects
            with cyclic references only at the end of script execution. .
         
            PHP exception processing is also shut down at this moment.
         
            It doesn&#39;t prevent normal index shutdown process, but may prevent accurate error diagnostic if any error occurs during shutdown.
         
            There are two ways with which you may avoid this problem.
         
            The first is to force going out of scope:
             &lt;?php
$index = Zend_Search_Lucene::open($indexPath);

...

unset($index);
             
         
            And the second is to perform a commit operation before the end of script execution:
             &lt;?php
$index = Zend_Search_Lucene::open($indexPath);

$index-&gt;commit();
             
            This possibility is also described in the &quot; Advanced. Using index as static property &quot;
            section.
         Retrieving documents by unique id 
            It&#39;s a common practice to store some unique document id in the index. Examples include url, path, or database id.
         Zend_Search_Lucene  provides a  termDocs()  method for retrieving documents containing specified terms.
         
            This is more efficient than using the  find()  method:
             &lt;?php
// Retrieving documents with find() method using a query string
$query = $idFieldName . &#39;:&#39; . $docId;
$hits  = $index-&gt;find($query);
foreach ($hits as $hit) {
    $title    = $hit-&gt;title;
    $contents = $hit-&gt;contents;
    ...
}
...

// Retrieving documents with find() method using the query API
$term = new Zend_Search_Lucene_Index_Term($docId, idFieldName);
$query = new Zend_Search_Lucene_Search_Query_Term($term);
$hits  = $index-&gt;find($query);
foreach ($hits as $hit) {
    $title    = $hit-&gt;title;
    $contents = $hit-&gt;contents;
    ...
}

...

// Retrieving documents with termDocs() method
$term = new Zend_Search_Lucene_Index_Term($docId, idFieldName);
$docIds  = $index-&gt;termDocs($term);
foreach ($docIds as $id) {
    $doc = $index-&gt;getDocument($id);
    $title    = $doc-&gt;title;
    $contents = $doc-&gt;contents;
    ...
}
             
         Memory Usage 
            Zend_Search_Lucene is a relatively memory-intensive module.
         
            It uses memory to cache some information and optimize searching and indexing performance.
         
            The memory required differs for different modes.
         
            The terms dictionary index is loaded during the search. It&#39;s actually each 128 th 
             The Lucene file format allows you to configure this number, but Zend_Search_Lucene doesn&#39;t expose this
            in its API. Nevertheless you still have the ability to configure this value if the index is prepared with another
            Lucene implementation.  term of the full dictionary.
         
            Thus memory usage is increased if you have a high number of unique terms. This may happen if you use untokenized phrases as a field values
            or index a large volume of non-text information.
         
            An unoptimized index consists of several segments. It also increases memory usage. Segments are independent, so each segment contains
            its own terms dictionary and terms dictionary index. If an index consists of  N  segments it may increase memory
            usage by  N  times in worst case. Perform index optimization to merge all segments into one to avoid such memory consumption.
         
            Indexing uses the same memory as searching plus memory for buffering documents. The amount of memory used may be managed with
             MaxBufferedDocs  parameter.
         
            Index optimization (full or partial) uses stream-style data processing and doesn&#39;t require a lot of memory.
         Encoding 
            Zend_Search_Lucene works with UTF-8 strings internally. So all strings returned by Zend_Search_Lucene are UTF-8 encoded.
         
            You shouldn&#39;t be concerned with encoding if you work with pure ASCII data, but you should be careful if this is not the case.
         
            Wrong encoding may cause error notices at the encoding conversion time or loss of data.
         
            Zend_Search_Lucene offers a wide range of encoding possibilities for indexed documents and parsed queries.
         
            Encoding may be explicitly specified as an optional parameter of field creation methods:
             &lt;?php
$doc = new Zend_Search_Lucene_Document();
$doc-&gt;addField(Zend_Search_Lucene_Field::Text(&#39;title&#39;, $title, &#39;iso-8859-1&#39;));
$doc-&gt;addField(Zend_Search_Lucene_Field::UnStored(&#39;contents&#39;, $contents, &#39;utf-8&#39;));
             
            This is the best way to avoid ambiguity in the encoding used.
         
            If optional encoding parameter is omitted, then the current locale is used. The current locale may contain character encoding data
            in addition to the language specification:
             &lt;?php
setlocale(LC_ALL, &#39;fr_FR&#39;);
...

setlocale(LC_ALL, &#39;de_DE.iso-8859-1&#39;);
...

setlocale(LC_ALL, &#39;ru_RU.UTF-8&#39;);
...
             
         
            The same approach is used to set query string encoding.
         
            If encoding is not specified, then the current locale is used to determine the encoding.
         
            Encoding may be passed as an optional parameter, if the query is parsed explicitly before search:
             &lt;?php
$query = Zend_Search_Lucene_Search_QueryParser::parse($queryStr, &#39;iso-8859-5&#39;);
$hits = $index-&gt;find($query);
...
             
         
            The default encoding may also be specified with  setDefaultEncoding()  method:
             &lt;?php
Zend_Search_Lucene_Search_QueryParser::setDefaultEncoding(&#39;iso-8859-1&#39;);
$hits = $index-&gt;find($queryStr);
...
             
            The empty string implies &#39;current locale&#39;.
         
            If the correct encoding is specified it can be correctly processed by analyzer. The actual behavior depends on which analyzer is used.
            See the  Character Set  documentation section for details.
         Index maintenance 
            It should be clear that Zend_Search_Lucene as well as any other Lucene implementation does not comprise a &quot;database&quot;.
         
            Indexes should not be used for data storage. They do not provide partial backup/restore functionality, journaling, logging, transactions
            and many other feautures associated with database management systems.
         
            Nevertheless, Zend_Search_Lucene attempts to keep indexes in a consistent state at all times.
         
            Index backup and restoration should be performed by copying the contents of the index folder.
         
            If index corruption occures for any reason, the corrupted index should be restored or completely rebuilt.
         
            So it&#39;s a good idea to backup large indexes and store changelogs to perform manual restoration and roll-forward operations
            if necessary. This practice dramatically reduces index restoration time.
         Character Set UTF-8 and single-byte character set support 
            Zend_Search_Lucene works with the UTF-8 charset internally. Index files store
            unicode data in Java&#39;s &quot;modified UTF-8 encoding&quot;. Zend_Search_Lucene core
            completely supports this encoding with one exception.
             
                   Zend_Search_Lucene supports only Basic Multilingual Plane
                   (BMP) characters (from 0x0000 to 0xFFFF) and doesn&#39;t support
                   &quot;supplementary characters&quot; (characters whose code points are
                   greater than 0xFFFF)
                
                   Java 2 represents these characters as a pair of char (16-bit)
                   values, the first from the high-surrogates range (0xD800-0xDBFF),
                   the second from the low-surrogates range (0xDC00-0xDFFF). Then
                   they are encoded as usual UTF-8 characters in six bytes.
                   Standard UTF-8 representation uses four bytes for supplementary
                   characters.
                
         
            Actual input data encoding may be specified through Zend_Search_Lucene API. Data will
            be automatically converted into UTF-8 encoding.
         Default text analyzer. 
            However, the default text analyzer (which is also used within query parser) uses
            ctype_alpha() for tokenizing text and queries.
         
            ctype_alpha() is not UTF-8 compatible, so the analyzer converts text to &#39;ASCII//TRANSLIT&#39; encoding before
            indexing. The same processing is transparently performed during query parsing.
             
                   Conversion to &#39;ASCII//TRANSLIT&#39; may depend on current locale and OS.
                
         
                Default analyzer doesn&#39;t treats numbers as parts of terms. Use corresponding &#39;Num&#39; analyzer if you don&#39;t want words 
                to be broken by numbers.  
             UTF-8 compatible text analyzers. 
            Zend_Search_Lucene also contains a set of UTF-8 compatible analyzers:  Zend_Search_Lucene_Analysis_Analyzer_Common_Utf8 ,
             Zend_Search_Lucene_Analysis_Analyzer_Common_Utf8Num ,  Zend_Search_Lucene_Analysis_Analyzer_Common_Utf8_CaseInsensitive ,
             Zend_Search_Lucene_Analysis_Analyzer_Common_Utf8Num_CaseInsensitive .
         
             Any of this analyzers can be enabled with the code like this:

             &lt;?php
Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new Zend_Search_Lucene_Analysis_Analyzer_Common_Utf8());
             
         
                UTF-8 compatible analyzers were improved in ZF 1.5. Early versions of analyzers assumed 
                all non-ascii characters are letters. New analyzers implementation has more accurate behavior. 
             
                This may need you to re-build index to have data and search queries tokenized in the same way, otherwise search engine
                may return wrong result sets.  
             
            All of these analyzers need PCRE (Perl-compatible regular expressions) library to be compiled with UTF-8 support turned on. 
            PCRE UTF-8 support is turned on for the PCRE library sources bandled with PHP source code distribution, but if shared libraru is used
            instead of bandled with PHP sources, then UTF-8 support state may depend on you operation system. 
         
             Use the following code to check, if PCRE UTF-8 suppor is enabled:

             &lt;?php
if (@preg_match(&#39;/\pL/u&#39;, &#39;a&#39;) == 1) {
    echo &quot;PCRE unicode support is turned on.\n&quot;;
} else {
    echo &quot;PCRE unicode support is turned off.\n&quot;;
}
             
         
            Case insensitive versions of UTF-8 compatible analyzers also need  mbstring  extension to be enabled. 
         
            If you don&#39;t want mbstring extension to be turned on, but need case insensitive search, you may use the following approach: normalize source data before indexing
            and query string before searching by converting them to lowercase:
        
             &lt;?php
// Indexing
setlocale(LC_CTYPE, &#39;de_DE.iso-8859-1&#39;);

...

Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new Zend_Search_Lucene_Analysis_Analyzer_Common_Utf8());

...

$doc = new Zend_Search_Lucene_Document();

$doc-&gt;addField(Zend_Search_Lucene_Field::UnStored(&#39;contents&#39;, strtolower($contents)));

// Title field for search through (indexed, unstored)
$doc-&gt;addField(Zend_Search_Lucene_Field::UnStored(&#39;title&#39;, strtolower($title)));

// Title field for retrieving (unindexed, stored)
$doc-&gt;addField(Zend_Search_Lucene_Field::UnIndexed(&#39;_title&#39;, $title));
             

             &lt;?php
// Searching
setlocale(LC_CTYPE, &#39;de_DE.iso-8859-1&#39;);

...

Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new Zend_Search_Lucene_Analysis_Analyzer_Common_Utf8());

...

$hits = $index-&gt;find(strtolower($query));
             
         Extensibility Text Analysis 
            The  Zend_Search_Lucene_Analysis_Analyzer  class is used by the indexer to tokenize document
            text fields.
         
            The  Zend_Search_Lucene_Analysis_Analyzer::getDefault()  and  
            Zend_Search_Lucene_Analysis_Analyzer::setDefault()  methods are used
            to get and set the default analyzer.
         
            You can assign your own text analyzer or choose it from the set of predefined analyzers:
             Zend_Search_Lucene_Analysis_Analyzer_Common_Text  and
             Zend_Search_Lucene_Analysis_Analyzer_Common_Text_CaseInsensitive  (default).
            Both of them interpret tokens as sequences of letters.
             Zend_Search_Lucene_Analysis_Analyzer_Common_Text_CaseInsensitive  converts all tokens
            to lower case.
         
            To switch between analyzers:
         &lt;?php
Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new Zend_Search_Lucene_Analysis_Analyzer_Common_Text());
...
$index-&gt;addDocument($doc);
         
            The  Zend_Search_Lucene_Analysis_Analyzer_Common  class is designed to be an ancestor of all user
            defined analyzers. User should only define the  reset()  and  nextToken()  methods,
            which takes its string from the $_input member and returns tokens one by one
            (a  null  value indicates the end of the stream).
         
            The  nextToken()  method should call the  normalize()  method on each
            token. This will allow you to use token filters with your analyzer.
         
            Here is an example of a custom analyzer, which accepts words with digits as terms:

             Custom text Analyzer. &lt;?php
/** Here is a custom text analyser, which treats words with digits as one term */


/** Zend_Search_Lucene_Analysis_Analyzer hierarchy */
require_once &#39;Zend/Search/Lucene/Analysis/Analyzer.php&#39;;

class My_Analyzer extends Zend_Search_Lucene_Analysis_Analyzer_Common
{
    private $_position;

    /**
     * Reset token stream
     */
    public function reset()
    {
        $this-&gt;_position = 0;
    }

    /**
     * Tokenization stream API
     * Get next token
     * Returns null at the end of stream
     *
     * @return Zend_Search_Lucene_Analysis_Token|null
     */
    public function nextToken()
    {
        if ($this-&gt;_input === null) {
            return null;
        }

        while ($this-&gt;_position &lt; strlen($this-&gt;_input)) {
            // skip white space
            while ($this-&gt;_position &lt; strlen($this-&gt;_input) &amp;&amp;
                   !ctype_alnum( $this-&gt;_input[$this-&gt;_position] )) {
                $this-&gt;_position++;
            }

            $termStartPosition = $this-&gt;_position;

            // read token
            while ($this-&gt;_position &lt; strlen($this-&gt;_input) &amp;&amp;
                   ctype_alnum( $this-&gt;_input[$this-&gt;_position] )) {
                $this-&gt;_position++;
            }

            // Empty token, end of stream.
            if ($this-&gt;_position == $termStartPosition) {
                return null;
            }

            $token = new Zend_Search_Lucene_Analysis_Token(
                                      substr($this-&gt;_input,
                                             $termStartPosition,
                                             $this-&gt;_position - $termStartPosition),
                                      $termStartPosition,
                                      $this-&gt;_position);
            $token = $this-&gt;normalize($token);
            if ($token !== null) {
                return $token;
            }
            // Continue if token is skipped
        }

        return null;
    }
}

Zend_Search_Lucene_Analysis_Analyzer::setDefault(
    new My_Analyzer());
                 
         Tokens Filtering 
            The  Zend_Search_Lucene_Analysis_Analyzer_Common  analyzer also offers a token filtering
            mechanism.
         
            The  Zend_Search_Lucene_Analysis_TokenFilter  class provides an abstract interface for such filters.
            Your own filters should extend this class either directly or indirectly.
         
            Any custom filter must implement the  normalize()  method which may transform input token or signal that
            the current token should be skipped.
         
            There are three filters already defined in the analysis subpackage:
             Zend_Search_Lucene_Analysis_TokenFilter_LowerCase Zend_Search_Lucene_Analysis_TokenFilter_ShortWords Zend_Search_Lucene_Analysis_TokenFilter_StopWords 
         
            The  LowerCase  filter is already used for
             Zend_Search_Lucene_Analysis_Analyzer_Common_Text_CaseInsensitive  analyzer
            by default.
         
            The  ShortWords  and  StopWords  filters may be used with pre-defined or custom
            analyzers like this:
             &lt;?php
$stopWords = array(&#39;a&#39;, &#39;an&#39;, &#39;at&#39;, &#39;the&#39;, &#39;and&#39;, &#39;or&#39;, &#39;is&#39;, &#39;am&#39;);
$stopWordsFilter = new Zend_Search_Lucene_Analysis_TokenFilter_StopWords($stopWords);

$analyzer = new Zend_Search_Lucene_Analysis_Analyzer_Common_TextNum_CaseInsensitive();
$analyzer-&gt;addFilter($stopWordsFilter);

Zend_Search_Lucene_Analysis_Analyzer::setDefault($analyzer);
             
             &lt;?php
$shortWordsFilter = new Zend_Search_Lucene_Analysis_TokenFilter_ShortWords();

$analyzer = new Zend_Search_Lucene_Analysis_Analyzer_Common_TextNum_CaseInsensitive();
$analyzer-&gt;addFilter($shortWordsFilter);

Zend_Search_Lucene_Analysis_Analyzer::setDefault($analyzer);
             
         
            The  Zend_Search_Lucene_Analysis_TokenFilter_StopWords  constructor takes an array of stop-words
            as an input. But stop-words may be also loaded from a file:
             &lt;?php
$stopWordsFilter = new Zend_Search_Lucene_Analysis_TokenFilter_StopWords();
$stopWordsFilter-&gt;loadFromFile($my_stopwords_file);

$analyzer = new Zend_Search_Lucene_Analysis_Analyzer_Common_TextNum_CaseInsensitive();
$analyzer-&gt;addFilter($stopWordsFilter);

Zend_Search_Lucene_Analysis_Analyzer::setDefault($analyzer);
             
            This file should be a common text file with one word in each line. The &#39;#&#39; character marks a line as a comment.
         
            The  Zend_Search_Lucene_Analysis_TokenFilter_ShortWords  constructor has one optional argument.
            This is the word length limit, set by default to 2.
         Scoring Algorithms 
            The score of a document  d  for a query  q  
            is defined as follows:
         score(q,d) = sum( tf(t in d) * idf(t) * getBoost(t.field in d) * lengthNorm(t.field in d)  ) *
            coord(q,d) * queryNorm(q) 
            tf(t in d) -  Zend_Search_Lucene_Search_Similarity::tf($freq)  - a score factor based on the frequency of a term or phrase in a document.
         
            idf(t) -  Zend_Search_Lucene_Search_Similarity::tf($term, $reader)  - a score factor for a simple term with the specified index.
         
            getBoost(t.field in d) - the boost factor for the term field.
         
            lengthNorm($term) - the normalization value for a field given the total
            number of terms contained in a field. This value is stored within the index.
            These values, together with field boosts, are stored in an index and multiplied
            into scores for hits on each field by the search code.
         
            Matches in longer fields are less precise, so implementations of this method
            usually return smaller values when numTokens is large, and larger values when numTokens is small.
         
            coord(q,d) -  Zend_Search_Lucene_Search_Similarity::coord($overlap, $maxOverlap)  - a
            score factor based on the fraction of all query terms that a document contains.
         
            The presence of a large portion of the query terms indicates a better match
            with the query, so implementations of this method usually return larger values
            when the ratio between these parameters is large and smaller values when
            the ratio between them is small.
         
            queryNorm(q) -  the normalization value for a query given the sum of the squared weights
            of each of the query terms. This value is then multiplied into the weight of each query
            term.
         
            This does not affect ranking, but rather just attempts to make scores from different
            queries comparable.
         
            The scoring algorithm can be customized by defining your own Similarity class. To do this
            extend the Zend_Search_Lucene_Search_Similarity class as defined below, then use
            the  Zend_Search_Lucene_Search_Similarity::setDefault($similarity);  method to set it as default.
         &lt;?php
class MySimilarity extends Zend_Search_Lucene_Search_Similarity {
    public function lengthNorm($fieldName, $numTerms) {
        return 1.0/sqrt($numTerms);
    }

    public function queryNorm($sumOfSquaredWeights) {
        return 1.0/sqrt($sumOfSquaredWeights);
    }

    public function tf($freq) {
        return sqrt($freq);
    }

    /**
     * It&#39;s not used now. Computes the amount of a sloppy phrase match,
     * based on an edit distance.
     */
    public function sloppyFreq($distance) {
        return 1.0;
    }

    public function idfFreq($docFreq, $numDocs) {
        return log($numDocs/(float)($docFreq+1)) + 1.0;
    }

    public function coord($overlap, $maxOverlap) {
        return $overlap/(float)$maxOverlap;
    }
}

$mySimilarity = new MySimilarity();
Zend_Search_Lucene_Search_Similarity::setDefault($mySimilarity);
         Storage Containers 
        The abstract class  Zend_Search_Lucene_Storage_Directory  defines directory functionality.
         
        The  Zend_Search_Lucene  constructor uses either a string or a
         Zend_Search_Lucene_Storage_Directory  object
        as an input.
         
        The  Zend_Search_Lucene_Storage_Directory_Filesystem  class implements directory
        functionality for a file system.
         
        If a string is used as an input for the  Zend_Search_Lucene  constructor, then the index
        reader ( Zend_Search_Lucene  object) treats it as a file system path and instantiates
        the  Zend_Search_Lucene_Storage_Directory_Filesystem  object.
         
        You can define your own directory implementation by extending the
         Zend_Search_Lucene_Storage_Directory  class.
         Zend_Search_Lucene_Storage_Directory  methods:
         &lt;?php
abstract class Zend_Search_Lucene_Storage_Directory {
/**
 * Closes the store.
 *
 * @return void
 */
abstract function close();


/**
 * Creates a new, empty file in the directory with the given $filename.
 *
 * @param string $name
 * @return void
 */
abstract function createFile($filename);


/**
 * Removes an existing $filename in the directory.
 *
 * @param string $filename
 * @return void
 */
abstract function deleteFile($filename);


/**
 * Returns true if a file with the given $filename exists.
 *
 * @param string $filename
 * @return boolean
 */
abstract function fileExists($filename);


/**
 * Returns the length of a $filename in the directory.
 *
 * @param string $filename
 * @return integer
 */
abstract function fileLength($filename);


/**
 * Returns the UNIX timestamp $filename was last modified.
 *
 * @param string $filename
 * @return integer
 */
abstract function fileModified($filename);


/**
 * Renames an existing file in the directory.
 *
 * @param string $from
 * @param string $to
 * @return void
 */
abstract function renameFile($from, $to);


/**
 * Sets the modified time of $filename to now.
 *
 * @param string $filename
 * @return void
 */
abstract function touchFile($filename);


/**
 * Returns a Zend_Search_Lucene_Storage_File object for a given $filename in the directory.
 *
 * @param string $filename
 * @return Zend_Search_Lucene_Storage_File
 */
abstract function getFileObject($filename);

}
         
        The  getFileObject($filename)  method of a  Zend_Search_Lucene_Storage_Directory 
        instance returns a  Zend_Search_Lucene_Storage_File  object.
         
        The  Zend_Search_Lucene_Storage_File  abstract class implements file abstraction and index
        file reading primitives.
         
        You must also extend  Zend_Search_Lucene_Storage_File  for your directory implementation.
         
        Only two methods of  Zend_Search_Lucene_Storage_File  must be overridden in your
        implementation:
         &lt;?php
class MyFile extends Zend_Search_Lucene_Storage_File {
    /**
     * Sets the file position indicator and advances the file pointer.
     * The new position, measured in bytes from the beginning of the file,
     * is obtained by adding offset to the position specified by whence,
     * whose values are defined as follows:
     * SEEK_SET - Set position equal to offset bytes.
     * SEEK_CUR - Set position to current location plus offset.
     * SEEK_END - Set position to end-of-file plus offset. (To move to
     * a position before the end-of-file, you need to pass a negative value
     * in offset.)
     * Upon success, returns 0; otherwise, returns -1
     *
     * @param integer $offset
     * @param integer $whence
     * @return integer
     */
    public function seek($offset, $whence=SEEK_SET) {
        ...
    }

    /**
     * Read a $length bytes from the file and advance the file pointer.
     *
     * @param integer $length
     * @return string
     */
    protected function _fread($length=1) {
        ...
    }
}
         Building Indexes Creating a New Index 
            Index creation and updating capabilities are implemented within the Zend_Search_Lucene component, as well as the Java Lucene project.
            You can use either of these options to create indexes that Zend_Search_Lucene can search.
         
            The PHP code listing below provides an example of how to index a file
            using Zend_Search_Lucene indexing API:
         &lt;?php
// Create index
$index = Zend_Search_Lucene::create(&#39;/data/my-index&#39;);

$doc = new Zend_Search_Lucene_Document();

// Store document URL to identify it in the search results
$doc-&gt;addField(Zend_Search_Lucene_Field::Text(&#39;url&#39;, $docUrl));

// Index document contents
$doc-&gt;addField(Zend_Search_Lucene_Field::UnStored(&#39;contents&#39;, $docContent));

// Add document to the index
$index-&gt;addDocument($doc);
         
            Newly added documents are immediately searchable in the index.
         Updating Index 
            The same procedure is used to update an existing index. The only difference
            is that the open() method is called instead of the create() method:
         &lt;?php
// Open existing index
$index = Zend_Search_Lucene::open(&#39;/data/my-index&#39;);

$doc = new Zend_Search_Lucene_Document();
// Store document URL to identify it in search result.
$doc-&gt;addField(Zend_Search_Lucene_Field::Text(&#39;url&#39;, $docUrl));
// Index document content
$doc-&gt;addField(Zend_Search_Lucene_Field::UnStored(&#39;contents&#39;, $docContent));

// Add document to the index.
$index-&gt;addDocument($doc);
         Updating Documents 
            The Lucene index file format doesn&#39;t support document updating.
            Documents should be removed and re-added to the index to effectively update them.
         Zend_Search_Lucene::delete()  method operates with an internal index document id. It can be retrieved
            from a query hit by &#39;id&#39; property:
         &lt;?php
$removePath = ...;
$hits = $index-&gt;find(&#39;path:&#39; . $removePath);
foreach ($hits as $hit) {
    $index-&gt;delete($hit-&gt;id);
}
         Retrieving Index Size 
            There are two methods to retrieve the size of an index in Zend_Search_Lucene.
         Zend_Search_Lucene::maxDoc()  returns one greater than the largest possible document number.
             It&#39;s actually the overall number of the documents in the index including deleted documents, 
             so it has a synonym:  Zend_Search_Lucene::count() .
         Zend_Search_Lucene::numDocs()  returns the total number of non-deleted documents.
         &lt;?php
$indexSize = $index-&gt;count();
$documents = $index-&gt;numDocs();
         Zend_Search_Lucene::isDeleted($id)  method may be used to check if a document is deleted.
         &lt;?php
for ($count = 0; $count &lt; $index-&gt;maxDoc(); $count++) {
    if ($index-&gt;isDeleted($count)) {
        echo &quot;Document #$id is deleted.\n&quot;;
    }
}
         
            Index optimization removes deleted documents and squeezes documents&#39; IDs in to a smaller range.
            A document&#39;s internal id may therefore change during index optimization.
         Index optimization 
            A Lucene index consists of many segments. Each segment is a completely independent set of data.
         
            Lucene index segment files can&#39;t be updated by design. A segment update needs full segment
            reorganization. See Lucene index file formats for details
            ( http://lucene.apache.org/java/2_0_0/fileformats.html )
             The currently supported Lucene index file format is version 2.1. .
            New documents are added to the index by creating new segment.
         
            Increasing number of segments reduces quality of the index, but index optimization restores it.
            Optimization essentially merges several segments into a new one. This process also doesn&#39;t update segments.
            It generates one new large segment and updates segment list (&#39;segments&#39; file).
         
            Full index optimization can be trigger by calling the  Zend_Search_Lucene::optimize()  method. It merges all
            index segments into one new segment:
         &lt;?php
// Open existing index
$index = Zend_Search_Lucene::open(&#39;/data/my-index&#39;);

// Optimize index.
$index-&gt;optimize();
         
            Automatic index optimization is performed to keep indexes in a consistent state.
         
            Automatic optimization is an iterative process managed by several index options. It merges very small segments
            into larger ones, then merges these larger segments into even larger segments and so on.
         MaxBufferedDocs  auto-optimization option MaxBufferedDocs  is a minimal number of documents required before
                the buffered in-memory documents are written into a new segment.
             MaxBufferedDocs  can be retrieved or set by  $index-&gt;getMaxBufferedDocs()  or
                 $index-&gt;setMaxBufferedDocs($maxBufferedDocs)  calls.
             
                Default value is 10.
             MaxMergeDocs  auto-optimization option MaxMergeDocs  is a largest number of documents ever merged by addDocument().
                Small values (e.g., less than 10.000) are best for interactive indexing, as this limits the length
                of pauses while indexing to a few seconds. Larger values are best for batched indexing and speedier
                searches.
             MaxMergeDocs  can be retrieved or set by  $index-&gt;getMaxMergeDocs()  or
                 $index-&gt;setMaxMergeDocs($maxMergeDocs)  calls.
             
                Default value is PHP_INT_MAX.
             MergeFactor  auto-optimization option MergeFactor  determines how often segment indices are merged by addDocument().
                With smaller values, less RAM is used while indexing, and searches on unoptimized indices are faster,
                but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches
                on unoptimized indices are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch
                index creation, and smaller values (&lt; 10) for indices that are interactively maintained.
             MergeFactor  is a good estimation for average number of segments merged by one auto-optimization pass.
                Too large values produce large number of segments while they are not merged into new one. It may be a cause of
                &quot;failed to open stream: Too many open files&quot; error message. This limitation is system dependent.
             MergeFactor  can be retrieved or set by  $index-&gt;getMergeFactor()  or
                 $index-&gt;setMergeFactor($mergeFactor)  calls.
             
                Default value is 10.
             
                Lucene Java and Luke (Lucene Index Toolbox -  http://www.getopt.org/luke/luke-0.6/ )
                can also be used to optimize an index. Luke v0.6 must be used to be compatible with Zend_Search_Lucene component. Later Luke versions are
                based on Lucene v2.1 which uses the newer index file format. Full Luke project information can be found here -
                 http://www.getopt.org/luke/ 
             Permissions 
            By default, index files are available for reading and writing by everyone.
         
            It&#39;s possible to override this with the  Zend_Search_Lucene_Storage_Directory_Filesystem::setDefaultFilePermissions()  method:
         &lt;?php
// Get current default file permissions
$currentPermissions = Zend_Search_Lucene_Storage_Directory_Filesystem::getDefaultFilePermissions();

// Give read-writing permissions only for current user and group
Zend_Search_Lucene_Storage_Directory_Filesystem::setDefaultFilePermissions(0660);
         Limitations Index size 
                Index size is limited by 2GB for 32-bit platforms.
             
                Use 64-bit platforms for larger indices.
             Supported Filesystems 
                Zend_Search_Lucene uses  flock()  to provide concurrent searching, index updating and optimization.
             
                According to the PHP  documentation ,
                &quot; flock()  will not work on NFS and many other networked file systems&quot;.
             
                Do not use networked file systems with Zend_Search_Lucene.
             Interoperating with Java Lucene File Formats 
          Zend_Search_Lucene index file formats are binary compatible with Java Lucene
          version 1.4 and greater.
         
          A detailed description of this format is available here:
           
           The currently supported Lucene index file format version is v2.1. .
         Index Directory 
        After index creation, the index directory will contain several files:
         
                The  segments  file is a list of index segments.
                 
                The  *.cfs  files contain index segments.
                Note! An optimized index always has only one segment.
                 
                The  deletable  file is a list of files that are no longer used
                by the index, but which could not be deleted.
                 Java Source Code 
            The Java program listing below provides an example of how to index a file
            using Java Lucene:
         
/**
* Index creation:
*/
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.document.*;

import java.io.*

...

IndexWriter indexWriter = new IndexWriter(&quot;/data/my_index&quot;,
                                          new SimpleAnalyzer(), true);

...

String filename = &quot;/path/to/file-to-index.txt&quot;
File f = new File(filename);

Document doc = new Document();
doc.add(Field.Text(&quot;path&quot;, filename));
doc.add(Field.Keyword(&quot;modified&quot;,DateField.timeToString(f.lastModified())));
doc.add(Field.Text(&quot;author&quot;, &quot;unknown&quot;));
FileInputStream is = new FileInputStream(f);
Reader reader = new BufferedReader(new InputStreamReader(is));
doc.add(Field.Text(&quot;contents&quot;, reader));

indexWriter.addDocument(doc);
         Overview Introduction Zend_Search_Lucene is a general purpose text search engine written entirely in PHP 5.
            Since it stores its index on the filesystem and does not require a database
            server, it can add search capabilities to almost any PHP-driven website.
            Zend_Search_Lucene supports the following features: Ranked searching - best results returned first 
                       Many powerful query types: phrase queries, wildcard queries,
                       proximity queries, range queries and more
                         
                             Term, multi-term, phrase queries, boolean expressions and subqueries are supported at this time.
                            
                     Search by specific field (e.g., title, author, contents) 

            Zend_Search_Lucene was derived from the Apache Lucene project.  The currently supported Lucene version is 2.2.
             
                   Lucene 2.1 index format support (which is also used in Lucene 2.2) is included in the current &quot;trunk&quot; branch. 
                   It is available via SVN in current nightly snapshots.
                
                   We hope to include Lucene 2.1 index format support in ZF 1.5.0. The current release (ZF V1.0.4) works with
                   Lucene 1.9-2.0 index formats.
                .
            For more information on Lucene, visit   ( ).
         
                Previous Zend_Search_Lucene implementations support the Lucene 1.9 index format. 
             
                Currently any index created using these versions is automatically upgraded to Lucene 2.1 format after the Zend_Search_Lucene update and
                will not be compatible with previous Zend_Search_Lucene versions.
             Document and Field Objects 
                Zend_Search_Lucene operates with documents as atomic objects for indexing.  A document is
                divided into named fields, and fields have content that can be searched.
             
                A document is represented by the Zend_Search_Lucene_Document class, and this objects of this class contain
                instances of Zend_Search_Lucene_Field that represent the fields on the document.
             
                It is important to note that any information can be added to the index.
                Application-specific information or metadata can be stored in the document
                fields, and later retrieved with the document during search.
             
                It is the responsibility of your application to control the indexer.
                This means that data can be indexed from any source
                that is accessible by your application.  For example, this could be the
                filesystem, a database, an HTML form, etc.
             Zend_Search_Lucene_Field  class provides several static methods to create fields with
                different characteristics:
             &lt;?php
$doc = new Zend_Search_Lucene_Document();

// Field is not tokenized, but is indexed and stored within the index.
// Stored fields can be retrived from the index.
$doc-&gt;addField(Zend_Search_Lucene_Field::Keyword(&#39;doctype&#39;,
                                                 &#39;autogenerated&#39;));

// Field is not tokenized nor indexed, but is stored in the index.
$doc-&gt;addField(Zend_Search_Lucene_Field::UnIndexed(&#39;created&#39;,
                                                   time()));

// Binary String valued Field that is not tokenized nor indexed,
// but is stored in the index.
$doc-&gt;addField(Zend_Search_Lucene_Field::Binary(&#39;icon&#39;,
                                                $iconData));

// Field is tokenized and indexed, and is stored in the index.
$doc-&gt;addField(Zend_Search_Lucene_Field::Text(&#39;annotation&#39;,
                                              &#39;Document annotation text&#39;));

// Field is tokenized and indexed, but is not stored in the index.
$doc-&gt;addField(Zend_Search_Lucene_Field::UnStored(&#39;contents&#39;,
                                                  &#39;My document content&#39;));
             
                Each of these methods (excluding the  Zend_Search_Lucene_Field::Binary()  method) has an optional
                 $encoding  parameter for specifying input data encoding.
             
                Encoding may differ for different documents as well as for different fields within one document:

                 &lt;?php
$doc = new Zend_Search_Lucene_Document();
$doc-&gt;addField(Zend_Search_Lucene_Field::Text(&#39;title&#39;, $title, &#39;iso-8859-1&#39;));
$doc-&gt;addField(Zend_Search_Lucene_Field::UnStored(&#39;contents&#39;, $contents, &#39;utf-8&#39;));
                 
             
                If encoding parameter is omitted, then the current locale is used at processing time. For example:
                 &lt;?php
setlocale(LC_ALL, &#39;de_DE.iso-8859-1&#39;);
...
$doc-&gt;addField(Zend_Search_Lucene_Field::UnStored(&#39;contents&#39;, $contents));
                 
             
                Fields are always stored and returned from the index in UTF-8 encoding. Any required conversion to UTF-8 happens
                automatically.
             
                Text analyzers ( see below ) may also convert text
                to some other encodings. Actually, the default analyzer converts text to &#39;ASCII//TRANSLIT&#39; encoding.
                Be careful, however; this translation may depend on current locale.
             
                Fields&#39; names are defined at your discretion in the  addField()  method.
             
                Java Lucene uses the &#39;contents&#39; field as a default field to search.
                Zend_Search_Lucene searches through all fields by default, but the behavior is configurable.
                See the  &quot;Default search field&quot;  chapter for details.
             Understanding Field Types Keyword  fields are stored and indexed, meaning that they can be searched as well
                    as displayed in search results. They are not split up into separate words by tokenization.
                    Enumerated database fields usually translate well to Keyword fields in Zend_Search_Lucene.
                 UnIndexed  fields are not searchable, but they are returned with search hits.  Database
                    timestamps, primary keys, file system paths, and other external identifiers are good
                    candidates for UnIndexed fields.
                 Binary  fields are not tokenized or indexed, but are stored for retrieval with search hits.
                    They can be used to store any data encoded as a binary string, such as an image icon.
                 Text  fields are stored, indexed, and tokenized. Text fields are appropriate for storing
                    information like subjects and titles that need to be searchable as well as returned with
                    search results.
                 UnStored  fields are tokenized and indexed, but not stored in the index. Large amounts of
                    text are best indexed using this type of field. Storing data creates a larger index on
                    disk, so if you need to search but not redisplay the data, use an UnStored field.
                    UnStored fields are practical when using a Zend_Search_Lucene index in
                    combination with a relational database. You can index large data fields with UnStored
                    fields for searching, and retrieve them from your relational database by using a separate
                    field as an identifier.
                Zend_Search_Lucene_Field Types Field Type Stored Indexed Tokenized Binary Keyword Yes Yes No No UnIndexed Yes No No No Binary Yes No No Yes Text Yes Yes Yes No UnStored No Yes Yes No HTML documents 
            Zend_Search_Lucene offers a HTML parsing feature. Documents can be created directly from a HTML file or string:
             &lt;?php
$doc = Zend_Search_Lucene_Document_Html::loadHTMLFile($filename);
$index-&gt;addDocument($doc);
...
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$index-&gt;addDocument($doc);
             
         Zend_Search_Lucene_Document_Html  class uses the  DOMDocument::loadHTML()  and
             DOMDocument::loadHTMLFile()  methods to parse the source HTML, so it doesn&#39;t need HTML to be well formed or
            to be XHTML. On the other hand, it&#39;s sensitive to the encoding specied by the &quot;meta http-equiv&quot; header tag.
         Zend_Search_Lucene_Document_Html  class recognizes document title, body and document header meta tags.
         
            The &#39;title&#39; field is actually the /html/head/title value. It&#39;s stored within the index, tokenized and available for search.
         
            The &#39;body&#39; field is the actual body content of the HTML file or string. It doesn&#39;t include scripts, comments or attributes.
         
            The  loadHTML()  and  loadHTMLFile()  methods of  Zend_Search_Lucene_Document_Html  class
            also have second optional argument. If it&#39;s set to true, then body content is also stored within index and can
            be retrieved from the index. By default, the body is tokenized and indexed, but not stored.
         
            Other document header meta tags produce additional document fields. The field &#39;name&#39; is taken from &#39;name&#39; attribute, and
            the &#39;content&#39; attribute populates the field &#39;value&#39;. Both are tokenized, indexed and stored, so documents may be searched by their meta tags
            (for example, by keywords).
         
            Parsed documents may be augmented by the programmer with any other field:
             &lt;?php
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$doc-&gt;addField(Zend_Search_Lucene_Field::UnIndexed(&#39;created&#39;,
                                                   time()));
$doc-&gt;addField(Zend_Search_Lucene_Field::UnIndexed(&#39;updated&#39;,
                                                   time()));
$doc-&gt;addField(Zend_Search_Lucene_Field::Text(&#39;annotation&#39;,
                                              &#39;Document annotation text&#39;));
$index-&gt;addDocument($doc);
             
         
            Document links are not included in the generated document, but may be retrieved with
            the  Zend_Search_Lucene_Document_Html::getLinks()  and  Zend_Search_Lucene_Document_Html::getHeaderLinks() 
            methods:
             &lt;?php
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$linksArray = $doc-&gt;getLinks();
$headerLinksArray = $doc-&gt;getHeaderLinks();
             
         Query Construction API 
        In addition to parsing a string query automatically it&#39;s also possible to construct them with the query API.
     
        User queries can be combined with queries created through the query API. Simply use the query parser to construct a query from a string:
         &lt;?php
$query = Zend_Search_Lucene_Search_QueryParser::parse($queryString);
         
     Query Parser Exceptions 
        The query parser may generate two types of exceptions:
         Zend_Search_Lucene_Exception  is thrown if something goes wrong in the query parser itself.
                 Zend_Search_Lucene_Search_QueryParserException  is thrown when there is an error in the query syntax.
                 
        It&#39;s a good idea to catch Zend_Search_Lucene_Search_QueryParserExceptions and handle it appropriately:
         &lt;?php
try {
    $query = Zend_Search_Lucene_Search_QueryParser::parse($queryString);
} catch (Zend_Search_Lucene_Search_QueryParserException $e) {
    echo &quot;Query syntax error: &quot; . $e-&gt;getMessage() . &quot;\n&quot;;
}
             
         
            The same technique should be used for the find() method of a Zend_Search_Lucene object.
         
            Starting in 1.5, query parsing exceptions are suppressed by default. If query doesn&#39;t conform query language,
            then it&#39;s tokenized using current default analyzer and all tokenized terms are used for searching.
            
            Use  Zend_Search_Lucene_Search_QueryParser::dontSuppressQueryParsingExceptions()  method
            to turn exceptions on.
             Zend_Search_Lucene_Search_QueryParser::suppressQueryParsingExceptions()  and 
             Zend_Search_Lucene_Search_QueryParser::queryParsingExceptionsSuppressed()  methods are also
            intended to manage exceptions handling behavior.
            
         Term Query 
            Term queries can be used for searching with a single term.
         
        Query string:
         word1
         or 
        Query construction by API:
         &lt;?php
$term  = new Zend_Search_Lucene_Index_Term(&#39;word1&#39;, &#39;field1&#39;);
$query = new Zend_Search_Lucene_Search_Query_Term($term);
$hits  = $index-&gt;find($query);
         
            The term field is optional. Zend_Search_Lucene searches through all indexed fields in each document if the field is not specified:
             &lt;?php
$term  = new Zend_Search_Lucene_Index_Term(&#39;word1&#39;);  // Search for &#39;word1&#39; in all indexed fields
$query = new Zend_Search_Lucene_Search_Query_Term($term);
$hits  = $index-&gt;find($query);
             
         Multi-Term Query 
            Multi-term queries can be used for searching with a set of terms.
         
            Each term in a set can be defined as  required ,
             prohibited , or  neither .

             required  means that documents not matching this term will not match
                        the query;
                     prohibited  means that documents matching this term will not match
                        the query;
                     neither , in which case matched documents are neither prohibited
                        from, nor required to, match the term. A document must match at least 1 term, however, to
                        match the query.
                     
         
            If optional terms are added to a query with required terms,
            both queries will have the same result set but the optional terms may affect the score of the matched documents.
         
            Both search methods can be used for multi-term queries.
         
            Query string:
         +word1 author:word2 -word3
         
                    &#39;+&#39; is used to define a required term.
                 
                    &#39;-&#39; is used to define a prohibited term.
                 
                    &#39;field:&#39; prefix is used to indicate a document field for a search.
                    If it&#39;s omitted, then all fields are searched.
                 or 
        Query construction by API:
         &lt;?php
$query = new Zend_Search_Lucene_Search_Query_MultiTerm();

$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word1&#39;), true);
$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word2&#39;, &#39;author&#39;), null);
$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word3&#39;), false);

$hits  = $index-&gt;find($query);
         
            It&#39;s also possible to specify terms list within MultiTerm query constructor:
             &lt;?php
$terms = array(new Zend_Search_Lucene_Index_Term(&#39;word1&#39;),
               new Zend_Search_Lucene_Index_Term(&#39;word2&#39;, &#39;author&#39;),
               new Zend_Search_Lucene_Index_Term(&#39;word3&#39;));
$signs = array(true, null, false);

$query = new Zend_Search_Lucene_Search_Query_MultiTerm($terms, $signs);

$hits  = $index-&gt;find($query);
             
         
            The  $signs  array contains information about the term type:
             true  is used to define required term.
                     false  is used to define prohibited term.
                     null  is used to define a term that is neither required nor prohibited.
                     
         Boolean Query 
            Boolean queries allow to construct query using other queries and boolean operators.
         
            Each subquery in a set can be defined as  required ,
             prohibited , or  optional .

             required  means that documents not matching this subquery will not match
                        the query;
                     prohibited  means that documents matching this subquery will not match
                        the query;
                     optional , in which case matched documents are neither prohibited
                        from, nor required to, match the subquery. A document must match at least 1 subquery, however, to
                        match the query.
                     
         
            If optional subqueries are added to a query with required suqueries,
            both queries will have the same result set but the optional suqueries may affect the score of the matched documents.
         
            Both search methods can be used for boolean queries.
         
            Query string:
         +(word1 word2 word3) author:(word4 word5) -word6
         
                    &#39;+&#39; is used to define a required subquery.
                 
                    &#39;-&#39; is used to define a prohibited subquery.
                 
                    &#39;field:&#39; prefix is used to indicate a document field for a search.
                    If it&#39;s omitted, then all fields are searched.
                 or 
        Query construction by API:
         &lt;?php
$query = new Zend_Search_Lucene_Search_Query_Boolean();

$subquery1 = new Zend_Search_Lucene_Search_Query_MultiTerm();
$subquery1-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word1&#39;));
$subquery1-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word2&#39;));
$subquery1-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word3&#39;));

$subquery2 = new Zend_Search_Lucene_Search_Query_MultiTerm();
$subquery2-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word4&#39;, &#39;author&#39;));
$subquery2-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word5&#39;, &#39;author&#39;));

$term6 = new Zend_Search_Lucene_Index_Term(&#39;word6&#39;);
$subquery3 = new Zend_Search_Lucene_Search_Query_Term($term6);

$query-&gt;addSubquery($subquery1, true  /* required */);
$query-&gt;addSubquery($subquery2, null  /* optional */);
$query-&gt;addSubquery($subquery3, false /* prohibited */);

$hits  = $index-&gt;find($query);
         
            It&#39;s also possible to specify subqueries list within Boolean query constructor:
             &lt;?php
...
$subqueries = array($subquery1, $subquery2, $subquery3);
$signs = array(true, null, false);

$query = new Zend_Search_Lucene_Search_Query_Boolean($subqueries, $signs);

$hits  = $index-&gt;find($query);
             
         
            The  $signs  array contains information about the subquery type:
             true  is used to define required subquery.
                     false  is used to define prohibited subquery.
                     null  is used to define a subquery that is neither required nor prohibited.
                     
         
            Each query which uses boolean operators can be rewritten using signs notation and constructed using API. For example:
	         word1 AND (word2 AND word3 AND NOT word4) OR word5 
	        is equivalent to
             (+(word1) +(+word2 +word3 -word4)) (word5) 
         Starting in 1.5, Wildcard Query 
            Wildcard queries can be used to search for documents containing strings matching specified patterns.
         
            The &#39;?&#39; symbol is used as a single character wildcard.
         
            The &#39;*&#39; symbol is used as a multiple character wildcard.
         
            Query string:
             field1:test* 
         or 
            Query construction by API:
             &lt;?php
$pattern = new Zend_Search_Lucene_Index_Term(&#39;test*&#39;, &#39;field1&#39;);
$query = new Zend_Search_Lucene_Search_Query_Wildcard($pattern);
$hits  = $index-&gt;find($query);
             
         
            The term field is optional. Zend_Search_Lucene searches through all fields on each document if a field is not specified:
             &lt;?php
$pattern = new Zend_Search_Lucene_Index_Term(&#39;test*&#39;);
$query = new Zend_Search_Lucene_Search_Query_Wildcard($pattern);
$hits  = $index-&gt;find($query);
             
         Starting in 1.5, Fuzzy Query 
            Fuzzy queries can be used to search for documents containing strings matching terms similar to specified term.
         
            Query string:
             field1:test~ 
            This query matches documents containing &#39;test&#39; &#39;text&#39; &#39;best&#39; words and others.
         or 
            Query construction by API:
             &lt;?php
$term = new Zend_Search_Lucene_Index_Term(&#39;test&#39;, &#39;field1&#39;);
$query = new Zend_Search_Lucene_Search_Query_Fuzzy($term);
$hits  = $index-&gt;find($query);
             
         
            Optional similarity can be specified after &quot;~&quot; sign.
         
            Query string:
             field1:test~0.4 
         or 
            Query construction by API:
             &lt;?php
$term = new Zend_Search_Lucene_Index_Term(&#39;test&#39;, &#39;field1&#39;);
$query = new Zend_Search_Lucene_Search_Query_Fuzzy($term, 0.4);
$hits  = $index-&gt;find($query);
             
         
            The term field is optional. Zend_Search_Lucene searches through all fields on each document if a field is not specified:
             &lt;?php
$term = new Zend_Search_Lucene_Index_Term(&#39;test&#39;);
$query = new Zend_Search_Lucene_Search_Query_Fuzzy($term);
$hits  = $index-&gt;find($query);
             
         Phrase Query 
            Phrase Queries can be used to search for a phrase within documents.
         
            Phrase Queries are very flexible and allow the user or developer to search for exact phrases as well as &#39;sloppy&#39; phrases.
         
            Phrases can also contain gaps or terms in the same places; they can be generated by
            the analyzer for different purposes. For example, a term can be duplicated to increase the term
            its weight, or several synonyms can be placed into a single position.
         &lt;?php
$query1 = new Zend_Search_Lucene_Search_Query_Phrase();

// Add &#39;word1&#39; at 0 relative position.
$query1-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word1&#39;));

// Add &#39;word2&#39; at 1 relative position.
$query1-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word2&#39;));

// Add &#39;word3&#39; at 3 relative position.
$query1-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;word3&#39;), 3);

...

$query2 = new Zend_Search_Lucene_Search_Query_Phrase(
                array(&#39;word1&#39;, &#39;word2&#39;, &#39;word3&#39;), array(0,1,3));

...

// Query without a gap.
$query3 = new Zend_Search_Lucene_Search_Query_Phrase(
                array(&#39;word1&#39;, &#39;word2&#39;, &#39;word3&#39;));

...

$query4 = new Zend_Search_Lucene_Search_Query_Phrase(
                array(&#39;word1&#39;, &#39;word2&#39;), array(0,1), &#39;annotation&#39;);
         
            A phrase query can be constructed in one step with a class constructor or step by step with
             Zend_Search_Lucene_Search_Query_Phrase::addTerm()  method calls.
         
            Zend_Search_Lucene_Search_Query_Phrase class constructor takes three optional arguments:
         &lt;?php
Zend_Search_Lucene_Search_Query_Phrase([array $terms[, array $offsets[, string $field]]]);
         
            The  $terms  parameter is an array of strings that contains a set of phrase terms.
            If it&#39;s omitted or equal to null, then an empty query is constructed.
         
            The  $offsets  parameter is an array of integers that contains offsets of terms in a phrase.
            If it&#39;s omitted or equal to null, then the terms&#39; positions are assumed to be sequential with no gaps.
         
            The  $field  parameter is a string that indicates the document field to search.
            If it&#39;s omitted or equal to null, then the default field is searched.
         
            Thus:
         &lt;?php
$query = new Zend_Search_Lucene_Search_Query_Phrase(array(&#39;zend&#39;, &#39;framework&#39;));
         
            will search for the phrase &#39;zend framework&#39; in all fields.
         &lt;?php
$query = new Zend_Search_Lucene_Search_Query_Phrase(array(&#39;zend&#39;, &#39;download&#39;), array(0, 2));
         
            will search for the phrase &#39;zend ????? download&#39; and match &#39;zend platform download&#39;, &#39;zend studio
            download&#39;, &#39;zend core download&#39;, &#39;zend framework download&#39;, and so on.
         &lt;?php
$query = new Zend_Search_Lucene_Search_Query_Phrase(array(&#39;zend&#39;, &#39;framework&#39;), null, &#39;title&#39;);
         
            will search for the phrase &#39;zend framework&#39; in the &#39;title&#39; field.
         Zend_Search_Lucene_Search_Query_Phrase::addTerm()  takes two arguments, a
            required  Zend_Search_Lucene_Index_Term  object and an optional position:
         &lt;?php
Zend_Search_Lucene_Search_Query_Phrase::addTerm(Zend_Search_Lucene_Index_Term $term[, integer $position]);
         
            The  $term  parameter describes the next term in the phrase. It must indicate the same field as previous terms, or an exception will be thrown.
         
            The  $position  parameter indicates the term position in the phrase.
         
            Thus:
         &lt;?php
$query = new Zend_Search_Lucene_Search_Query_Phrase();
$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;zend&#39;));
$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;framework&#39;));
         
            will search for the phrase &#39;zend framework&#39;.
          &lt;?php
$query = new Zend_Search_Lucene_Search_Query_Phrase();
$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;zend&#39;), 0);
$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;framework&#39;), 2);
         
            will search for the phrase &#39;zend ????? download&#39; and match &#39;zend platform download&#39;, &#39;zend studio
            download&#39;, &#39;zend core download&#39;, &#39;zend framework download&#39;, and so on.
         &lt;?php
$query = new Zend_Search_Lucene_Search_Query_Phrase();
$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;zend&#39;, &#39;title&#39;));
$query-&gt;addTerm(new Zend_Search_Lucene_Index_Term(&#39;framework&#39;, &#39;title&#39;));
         
            will search for the phrase &#39;zend framework&#39; in the &#39;title&#39; field.
         
            The slop factor sets the number of other words permitted between specified words in the query phrase. If set to zero,
            then the corresponding query is an exact phrase search.  For larger values this works like the WITHIN or NEAR
            operators.
         
            The slop factor is in fact an edit distance, where the edits correspond to moving terms in the query
            phrase.  For example, to switch the order of two words requires two moves (the
            first move places the words atop one another), so to permit re-orderings of phrases, the slop factor
            must be at least two.
         
            More exact matches are scored higher than sloppier matches; thus, search results are sorted by
            exactness. The slop is zero by default, requiring exact matches.
         
            The slop factor can be assigned after query creation:
         &lt;?php
// Query without a gap.
$query = new Zend_Search_Lucene_Search_Query_Phrase(array(&#39;word1&#39;, &#39;word2&#39;));

// Search for &#39;word1 word2&#39;, &#39;word1 ... word2&#39;
$query-&gt;setSlop(1);
$hits1 = $index-&gt;find($query);

// Search for &#39;word1 word2&#39;, &#39;word1 ... word2&#39;,
// &#39;word1 ... ... word2&#39;, &#39;word2 word1&#39;
$query-&gt;setSlop(2);
$hits2 = $index-&gt;find($query);
         Starting in 1.5, Range Query Range queries  are intended for searching terms within specified interval.
         
            Query string:
             mod_date:[20020101 TO 20030101]
title:{Aida TO Carmen} 
         or 
            Query construction by API:
             &lt;?php
$from = new Zend_Search_Lucene_Index_Term(&#39;20020101&#39;, &#39;mod_date&#39;);
$to   = new Zend_Search_Lucene_Index_Term(&#39;20030101&#39;, &#39;mod_date&#39;);
$query = new Zend_Search_Lucene_Search_Query_Range($from, $to, true /* inclusive */);
$hits  = $index-&gt;find($query);
             
         
            Term fields are optional. Zend_Search_Lucene searches through all fields if the field is not specified:
             &lt;?php
$from = new Zend_Search_Lucene_Index_Term(&#39;Aida&#39;);
$to   = new Zend_Search_Lucene_Index_Term(&#39;Carmen&#39;);
$query = new Zend_Search_Lucene_Search_Query_Range($from, $to, false /* non-inclusive */);
$hits  = $index-&gt;find($query);
             
         
            Either (but not both) of the boundary terms may be set to null. Zend_Search_Lucene searches from the beginning or
            up to the end of the dictionary for the specified field(s) in this case:
             &lt;?php
$from = new Zend_Search_Lucene_Index_Term(&#39;20020101&#39;, &#39;mod_date&#39;);
$query = new Zend_Search_Lucene_Search_Query_Range($from, null, true /* inclusive */);  // searches for [&#39;20020101&#39; TO ...]
$hits  = $index-&gt;find($query);
             
         Query Language 
        Java Lucene and Zend_Search_Lucene provide quite powerful query languages.
     
        These languages are mostly the same with some minor differences, which are mentioned below.
     
        Full Java Lucene query language syntax documentation can be found
         here .
     Terms 
            A query is broken up into terms and operators. There are three types of terms: Single Terms, Phrases,
            and Subqueries.
         
            A Single Term is a single word such as &quot;test&quot; or &quot;hello&quot;.
         
            A Phrase is a group of words surrounded by double quotes such as &quot;hello dolly&quot;.
         
            A Subquery is a query surrounded by parentheses such as &quot;(hello dolly)&quot;.
         
            Multiple terms can be combined together with boolean operators to form complex queries (see below).
         Fields 
            Lucene supports fields of data. When performing a search you can either specify a field, or use
            the default field. The field names depend on indexed data and default field is defined
            by current settings.
         
            The first and most significant difference from Java Lucene is that terms are searched through
             all fields  by default.
         
            There are two static methods in the Zend_Search_Lucene class which allow the developer to configure these settings:
         &lt;?php
$defaultSearchField = Zend_Search_Lucene::getDefaultSearchField();
...
Zend_Search_Lucene::setDefaultSearchField(&#39;contents&#39;);
         
            The  null  value indicated that the search is performed across all fields. It&#39;s the default setting.
         
            You can search specific fields by typing the field name followed by a colon &quot;:&quot; followed by the term you
            are looking for.
         
            As an example, let&#39;s assume a Lucene index contains two fields- title and text- with text as the default field.
            If you want to find the document entitled &quot;The Right Way&quot; which contains the text &quot;don&#39;t go this way&quot;,
            you can enter:
         title:&quot;The Right Way&quot; AND text:go
         
            or
         title:&quot;Do it right&quot; AND go
         
            Because &quot;text&quot; is the default field, the field indicator is not required.
         
            Note: The field is only valid for the term, phrase or subquery that it directly precedes,
            so the query
             title:Do it right
             
            Will only find &quot;Do&quot; in the title field. It will find &quot;it&quot; and &quot;right&quot; in the default field (if the default field is set)
            or in all indexed fields (if the default field is set to  null ).
         Starting in 1.5, Wildcards Wildcard queries  support is available with SVN and latest snapshot versions and 
               doesn&#39;t included into current release. 
            Lucene supports single and multiple character wildcard searches within single terms (but not within phrase queries).
         
            To perform a single character wildcard search use the &quot;?&quot; symbol.
         
            To perform a multiple character wildcard search use the &quot;*&quot; symbol.
         
            The single character wildcard search looks for string that match the term with the &quot;?&quot; replaced by any single character.
            For example, to search for &quot;text&quot; or &quot;test&quot; you can use the search:
             te?t
             
         
            Multiple character wildcard searches look for 0 or more characters when matching strings against terms. For example, to search for test,
            tests or tester, you can use the search:
             test*
             
         
            You can use &quot;?&quot;, &quot;*&quot; or both at any place of the term:
             *wr?t*
             
            It searches for &quot;write&quot;, &quot;wrote&quot;, &quot;written&quot;, &quot;rewrite&quot;, &quot;rewrote&quot; and so on.
         Term Modifiers 
            Lucene supports modifying query terms to provide a wide range of searching options.
         
            &quot;~&quot; modifier can be used to specify proximity search for phrases or fuzzy search for individual terms.
             
                    Fuzzy search is availably only starting ZF 1.5
                 
         Starting in 1.5, Range Searches Range queries support is available with SVN and latest snapshot versions and 
               doesn&#39;t included into current release. 
            Range queries allow the developer or user to match documents whose field(s) values are between the lower and upper bound specified by the range query.
            Range Queries can be inclusive or exclusive of the upper and lower bounds. Sorting is performed lexicographically.
             mod_date:[20020101 TO 20030101]
             
            This will find documents whose mod_date fields have values between 20020101 and 20030101, inclusive. Note that Range Queries are not
            reserved for date fields. You could also use range queries with non-date fields:
             title:{Aida TO Carmen}
             
            This will find all documents whose titles would be sorted between Aida and Carmen, but not including Aida and Carmen.
         
            Inclusive range queries are denoted by square brackets. Exclusive range queries are denoted by curly brackets.
         
            If field is not specified then Zend_Search_Lucene searches for specified interval through all fields by default.
             {Aida TO Carmen}
             
         Starting in 1.5, Fuzzy Searches Fuzzy queries support is available with SVN and latest snapshot versions and 
               doesn&#39;t included into current release. 
            Zend_Search_Lucene as well as Java Lucene supports fuzzy searches based on the Levenshtein Distance, or Edit Distance algorithm. 
            To do a fuzzy search use the tilde, &quot;~&quot;, symbol at the end of a Single word Term. For example to search for a term similar 
            in spelling to &quot;roam&quot; use the fuzzy search:

             roam~ 

            This search will find terms like foam and roams.

            Additional (optional) parameter can specify the required similarity. The value is between 0 and 1, with a value closer to 1 only terms 
            with a higher similarity will be matched. For example:

             roam~0.8 

            The default that is used if the parameter is not given is 0.5.
         Proximity Searches 
            Lucene supports finding words from a phrase that are within a specified word distance in a string. To do a proximity search
            use the tilde, &quot;~&quot;, symbol at the end of the phrase. For example to search for a &quot;Zend&quot; and
            &quot;Framework&quot; within 10 words of each other in a document use the search:
             &quot;Zend Framework&quot;~10
             
         Boosting a Term 
            Java Lucene and Zend_Search_Lucene provide the relevance level of matching documents based
            on the terms found. To boost the relevance of a term use the caret, &quot;^&quot;, symbol with a boost factor (a number)
            at the end of the term you are searching. The higher the boost factor, the more relevant
            the term will be.
         
            Boosting allows you to control the relevance of a document by boosting individual terms. For example,
            if you are searching for
             PHP framework
             
            and you want the term &quot;PHP&quot; to be more relevant boost it using the ^ symbol along with the
            boost factor next to the term. You would type:
             PHP^4 framework
             
            This will make documents with the term PHP appear more relevant. You can also boost phrase
            terms and subqueries as in the example:
             &quot;PHP framework&quot;^4 &quot;Zend Framework&quot;
             
            By default, the boost factor is 1. Although the boost factor must be positive,
            it may be less than 1 (e.g. 0.2).
         Boolean Operators 
            Boolean operators allow terms to be combined through logic operators.
            Lucene supports AND, &quot;+&quot;, OR, NOT and &quot;-&quot; as Boolean operators.
            Java Lucene requires boolean operators to be ALL CAPS. Zend_Search_Lucene does not.
         
            AND, OR, and NOT operators and &quot;+&quot;, &quot;-&quot; defines two different styles to construct boolean queries.
            Unlike Java Lucene, Zend_Search_Lucene doesn&#39;t allow these two styles to be mixed.
         
            If the AND/OR/NOT style is used, then an AND or OR operator must be present between all query terms.
            Each term may also be preceded by NOT operator. The AND operator has higher precedence than the OR operator.
            This differs from Java Lucene behavior.
         AND 
                The AND operator means that all terms in the &quot;AND group&quot; must match some part of the searched field(s).
             
                To search for documents that contain &quot;PHP framework&quot; and &quot;Zend Framework&quot; use the query:
                 &quot;PHP framework&quot; AND &quot;Zend Framework&quot;
                 
             OR 
                The OR operator divides the query into several optional terms.
             
                To search for documents that contain &quot;PHP framework&quot; or &quot;Zend Framework&quot; use the query:
                 &quot;PHP framework&quot; OR &quot;Zend Framework&quot;
                 
             NOT 
                The NOT operator excludes documents that contain the term after NOT. But an &quot;AND group&quot; which contains
                only terms with the NOT operator gives an empty result set instead of a full set of indexed documents.
             
                To search for documents that contain &quot;PHP framework&quot; but not &quot;Zend Framework&quot; use the query:
                 &quot;PHP framework&quot; AND NOT &quot;Zend Framework&quot;
                 
             &amp;&amp;, ||, and ! operators 
                &amp;&amp;, ||, and ! may be used instead of AND, OR, and NOT notation.
             + 
                The &quot;+&quot; or required operator stipulates that the term after the &quot;+&quot; symbol must match the document.
             
                To search for documents that must contain &quot;Zend&quot; and may contain &quot;Framework&quot; use the query:
                 +Zend Framework
                 
             - 
                The &quot;-&quot; or prohibit operator excludes documents that match the term after the &quot;-&quot; symbol.
             
                To search for documents that contain &quot;PHP framework&quot; but not &quot;Zend Framework&quot; use the query:
                 &quot;PHP framework&quot; -&quot;Zend Framework&quot;
                 
             No Operator 
                If no operator is used, then the search behavior is defined by the &quot;default boolean operator&quot;.
             
                This is set to  OR  by default.
             
                That implies each term is optional by default. It may or may not be present within document, but documents with this term
                will recieve a higher score.
             
                To search for documents that requires &quot;PHP framework&quot; and may contain &quot;Zend Framework&quot; use the query:
                 +&quot;PHP framework&quot; &quot;Zend Framework&quot;
                 
             
                The default boolean operator may be set or retrieved with the
                 Zend_Search_Lucene_Search_QueryParser::setDefaultOperator($operator)  and
                 Zend_Search_Lucene_Search_QueryParser::getDefaultOperator()  methods, respectively.
             
                These methods operate with the
                 Zend_Search_Lucene_Search_QueryParser::B_AND  and
                 Zend_Search_Lucene_Search_QueryParser::B_OR  constants.
             Grouping 
            Java Lucene and Zend_Search_Lucene support using parentheses to group clauses to form sub queries. This can be
            useful if you want to control the precedence of boolean logic operators for a query or mix different boolean query styles:
             +(framework OR library) +php
             
            Zend_Search_Lucene supports subqueries nested to any level.
         Field Grouping 
            Lucene also supports using parentheses to group multiple clauses to a single field.
         
            To search for a title that contains both the word &quot;return&quot; and the phrase &quot;pink panther&quot; use the query:
             title:(+return +&quot;pink panther&quot;)
             
         Escaping Special Characters 
            Lucene supports escaping special characters that are used in query syntax. The current list of special
            characters is:
         
            + - &amp;&amp; || ! ( ) { } [ ] ^ &quot; ~ * ? : \
         
            + and - inside single terms are automatically treated as common characters.
         
            For other instances of these characters use the \ before each special character you&#39;d like to escape. For example to search for (1+1):2 use the query:
             \(1\+1\)\:2
             
         Searching an Index Building Queries 
            There are two ways to search the index. The first method uses
            query parser to construct a query from a string. The second is
            to programmatically create your own queries through the Zend_Search_Lucene API.
         
        Before choosing to use the provided query parser, please consider
        the following:

             
                        If you are programmatically creating a query string and then parsing
                        it with the query parser then you should consider building
                        your queries directly with the query API. Generally speaking, the query
                        parser is designed for human-entered text, not for program-generated text.
                     
                        Untokenized fields are best added directly to queries and not through
                        the query parser. If a field&#39;s values are generated programmatically
                        by the application, then the query clauses for this field should also
                        be constructed programmatically.
                        An analyzer, which the query parser uses, is designed to convert
                        human-entered text to terms. Program-generated values, like dates,
                        keywords, etc., should be added with the query API.
                     
                        In a query form, fields that are general text should use the query parser.
                        All others, such as date ranges, keywords, etc., are better added directly
                        through the query API. A field with a limited set of values that can be
                        specified with a pull-down menu should not be added to a query string
                        that is subsequently parsed but instead should be added as a TermQuery clause.
                     
                        Boolean queries allow the programmer to logically combine two or more queries into new one.
                        Thus it&#39;s the best way to add additional criteria to a search defined by
                        a query string.
                     

         
            Both ways use the same API method to search through the index:
         &lt;?php
require_once &#39;Zend/Search/Lucene.php&#39;;

$index = Zend_Search_Lucene::open(&#39;/data/my_index&#39;);

$index-&gt;find($query);
         
            The  Zend_Search_Lucene::find()  method determines the input type automatically and
            uses the query parser to construct an appropriate Zend_Search_Lucene_Search_Query object
            from an input of type string.
         
            It is important to note that the query parser uses the standard analyzer to tokenize separate parts of query string.
            Thus all transformations which are applied to indexed text are also applied to query strings.
         
            The standard analyzer may transform the query string to lower case for case-insensitivity, remove stop-words, and stem among other transformations.
         
            The API method doesn&#39;t transform or filter input terms in any way. It&#39;s therefore more suitable for
            computer generated or untokenized fields.
         Query Parsing Zend_Search_Lucene_Search_QueryParser::parse()  method may be used to parse query strings
                into query objects.
             
                This query object may be used in query construction API methods to combine user entered queries with
                programmatically generated queries.
             
                Actually, in some cases it&#39;s the only way to search for values within untokenized fields:

                 &lt;?php
$userQuery = Zend_Search_Lucene_Search_QueryParser::parse($queryStr);

$pathTerm  = new Zend_Search_Lucene_Index_Term(&#39;/data/doc_dir/&#39; . $filename, &#39;path&#39;);
$pathQuery = new Zend_Search_Lucene_Search_Query_Term($pathTerm);

$query = new Zend_Search_Lucene_Search_Query_Boolean();
$query-&gt;addSubquery($userQuery, true /* required */);
$query-&gt;addSubquery($pathQuery, true /* required */);

$hits = $index-&gt;find($query);
                 
             Zend_Search_Lucene_Search_QueryParser::parse()  method also takes an optional encoding parameter,
                which can specify query string encoding:
             &lt;?php
$userQuery = Zend_Search_Lucene_Search_QueryParser::parse($queryStr, &#39;iso-8859-5&#39;);
             
             
                If the encoding parameter is omitted, then current locale is used.
             
                It&#39;s also possible to specify the default query string encoding with
                 Zend_Search_Lucene_Search_QueryParser::setDefaultEncoding()  method:
                 &lt;?php
Zend_Search_Lucene_Search_QueryParser::setDefaultEncoding(&#39;iso-8859-5&#39;);
...
$userQuery = Zend_Search_Lucene_Search_QueryParser::parse($queryStr);
                 
             Zend_Search_Lucene_Search_QueryParser::getDefaultEncoding()  returns the current default query
                string encoding (the empty string means &quot;current locale&quot;).
             Search Results 
            The search result is an array of Zend_Search_Lucene_Search_QueryHit objects.  Each of these has
            two properties:  $hit-&gt;document  is a document number within
            the index and  $hit-&gt;score  is a score of the hit in
            a search result. The results are ordered by score (descending from highest score).
         
            The Zend_Search_Lucene_Search_QueryHit object also exposes each field of the Zend_Search_Lucene_Document found in the search 
            as a property of the hit.  In the following example, a hit is returned with two fields from the corresponding document: title and author.
         &lt;?php
require_once(&#39;Zend/Search/Lucene.php&#39;);

$index = Zend_Search_Lucene::open(&#39;/data/my_index&#39;);

$hits = $index-&gt;find($query);

foreach ($hits as $hit) {
    echo $hit-&gt;score;
    echo $hit-&gt;title;
    echo $hit-&gt;author;
}
         
            Stored fields are always returned in UTF-8 encoding.
         
            Optionally, the original Zend_Search_Lucene_Document object can be returned from the
            Zend_Search_Lucene_Search_QueryHit.

            You can retrieve stored parts of the document by using the  getDocument() 
            method of the index object and then get them by
             getFieldValue()  method:
         &lt;?php
require_once &#39;Zend/Search/Lucene.php&#39;;

$index = Zend_Search_Lucene::open(&#39;/data/my_index&#39;);

$hits = $index-&gt;find($query);
foreach ($hits as $hit) {
    // return Zend_Search_Lucene_Document object for this hit
    echo $document = $hit-&gt;getDocument();

    // return a Zend_Search_Lucene_Field object
    // from the Zend_Search_Lucene_Document
    echo $document-&gt;getField(&#39;title&#39;);

    // return the string value of the Zend_Search_Lucene_Field object
    echo $document-&gt;getFieldValue(&#39;title&#39;);

    // same as getFieldValue()
    echo $document-&gt;title;
}
         
        The fields available from the Zend_Search_Lucene_Document object are determined at
        the time of indexing.  The document fields are either indexed, or
        index and stored, in the document by the indexing application
        (e.g. LuceneIndexCreation.jar).
         
        Note that the document identity (&#39;path&#39; in our example) is also stored
        in the index and must be retrieved from it.
         Limiting the Result Set 
            The most computationally expensive part of searching is score calculation. It may take several seconds for large result sets (tens of thousands of hits).
         
            Zend_Search_Lucene gives the possibility to limit result set size with  getResultSetLimit()  and
             setResultSetLimit()  methods:
             &lt;?php
$currentResultSetLimit = Zend_Search_Lucene::getResultSetLimit();

Zend_Search_Lucene::setResultSetLimit($newLimit);
             
            The default value of 0 means &#39;no limit&#39;.
         
            It doesn&#39;t give the &#39;best N&#39; results, but only the &#39;first N&#39; Returned hits are still ordered by score or by the the specified order, if given. .
         Results Scoring 
            Zend_Search_Lucene uses the same scoring algorithms as Java Lucene.
            All hits in the search result are ordered by score by default. Hits with greater score come first, and
            documents having higher scores should match the query more precisely than documents having lower scores.
         
            Roughly speaking, search hits that contain the searched term or phrase more frequently
            will have a higher score.
         
            A hit&#39;s score can be retrieved by accessing the  score  property of the hit:
         &lt;?php
$hits = $index-&gt;find($query);

foreach ($hits as $hit) {
    echo $hit-&gt;id;
    echo $hit-&gt;score;
}
         
            The Zend_Search_Lucene_Search_Similarity class is used to calculate the score for each hit.
            See  Extensibility. Scoring Algorithms  section for details.
         Search Result Sorting 
            By default, the search results are ordered by score. The programmer can change this behavior by setting a sort field (or a list of fields), sort type
            and sort order parameters.
         $index-&gt;find()  call may take several optional parameters:
             &lt;?php
$index-&gt;find($query [, $sortField [, $sortType [, $sortOrder]]] [, $sortField2 [, $sortType [, $sortOrder]]] ...);
             
         
             A name of stored field by which to sort result should be passed as the  $sortField  parameter.
         $sortType  may be omitted or take the following enumerated values:
             SORT_REGULAR  (compare items normally- default value),
             SORT_NUMERIC  (compare items numerically),
             SORT_STRING  (compare items as strings).
         $sortOrder  may be omitted or take the following enumerated values:
             SORT_ASC  (sort in ascending order- default value),
             SORT_DESC  (sort in descending order).
         
            Examples:
             &lt;?php
$index-&gt;find($query, &#39;quantity&#39;, SORT_NUMERIC, SORT_DESC);
             
             &lt;?php
$index-&gt;find($query, &#39;fname&#39;, SORT_STRING, &#39;lname&#39;, SORT_STRING);
             
             &lt;?php
$index-&gt;find($query, &#39;name&#39;, SORT_STRING, &#39;quantity&#39;, SORT_NUMERIC, SORT_DESC);
             
         
            Please use caution when using a non-default search order;
            the query needs to retrieve documents completely from an index, which may dramatically reduce search performance.
         Search Results Highlighting Zend_Search_Lucene_Search_Query::highlightMatches()  method allows the developer to highlight HTML document terms
            in the context of a search query:
             &lt;?php
$query = Zend_Search_Lucene_Search_QueryParser::parse($queryStr);
$hits = $index-&gt;find($query);
...
$highlightedHTML = $query-&gt;highlightMatches($sourceHTML);
             
         highlightMatches()  method utilizes  Zend_Search_Lucene_Document_Html  class
            (see  HTML documents section  for details)
            for HTML processing, so it has the same requirements for HTML source.
         Introduction 
        The  Zend_Server  family of classes provides functionality
        for the various server classes, including
         Zend_XmlRpc_Server ,  Zend_Rest_Server ,
         Zend_Json_Server  and  Zend_Soap_Wsdl .
         Zend_Server_Interface  provides an interface that mimics PHP
        5&#39;s  SoapServer  class; all server classes should implement
        this interface in order to provide a standard server API.
     
        The  Zend_Server_Reflection  tree provides a standard
        mechanism for performing function and class introspection for use as
        callbacks with the server classes, and provides data suitable for use
        with  Zend_Server_Interface &#39;s  getFunctions() 
        and  loadFunctions()  methods.
     Zend_Server_Reflection Introduction 
            Zend_Server_Reflection provides a standard mechanism for performing
            function and class introspection for use with server classes. It is
            based on PHP 5&#39;s Reflection API, and extends it to provide methods
            for retrieving parameter and return value types and descriptions, a
            full list of function and method prototypes (i.e., all possible
            valid calling combinations), and function/method descriptions.
         
            Typically, this functionality will only be used by developers of
            server classes for the framework.
         Usage 
            Basic usage is simple:
         &lt;?php
require_once &#39;Zend/Server/Reflection.php&#39;;
$class    = Zend_Server_Reflection::reflectClass(&#39;My_Class&#39;);
$function = Zend_Server_Reflection::reflectFunction(&#39;my_function&#39;);

// Get prototypes
$prototypes = $reflection-&gt;getPrototypes();

// Loop through each prototype for the function
foreach ($prototypes as $prototype) {

    // Get prototype return type
    echo &quot;Return type: &quot;, $prototype-&gt;getReturnType(), &quot;\n&quot;;

    // Get prototype parameters
    $parameters = $prototype-&gt;getParameters();

    echo &quot;Parameters: \n&quot;;
    foreach ($parameters as $parameter) {
        // Get parameter type
        echo &quot;    &quot;, $parameter-&gt;getType(), &quot;\n&quot;;
    }
}

// Get namespace for a class, function, or method.
// Namespaces may be set at instantiation time (second argument), or using
// setNamespace()
$reflection-&gt;getNamespace();
         reflectFunction()  returns a
             Zend_Server_Reflection_Function  object;
             reflectClass  returns a
             Zend_Server_Reflection_Class  object. Please refer to
            the API documentation to know what methods are available to each.
         Introduction Zend_Service  is an abstract class which serves as a
        foundation for web service implementations, such as SOAP or REST.
     
        If you need support for generic, XML-based REST services, you may want
        to look at  Zend_Rest_Client .
     
        In addition to being able to extend the  Zend_Service  and
        use  Zend_Rest_Client  for REST-based web services, Zend also
        provides support for popular web services.  See the following sections
        for specific information on each supported web service.
     Akismet Amazon Audioscrobbler Del.icio.us Flickr Simpy SlideShare StrikeIron Yahoo! 
        Additional services are coming in the future.
     Zend_Service_Akismet Introduction Zend_Service_Akismet  provides a client for the  Akismet API .
            The Akismet service is used to determine if incoming data is
            potentially spam; it also exposes methods for submitting data as
            known spam or as false positives (ham). Originally intended to help
            categorize and identify spam for Wordpress, it can be used for any
            type of data.
         
            Akismet requires an API key for usage. You may get one for signing
            up for a  WordPress.com 
            account. You do not need to activate a blog; simply acquiring the
            account will provide you with the API key.
         
            Additionally, Akismet requires that all requests contain a URL to
            the resource for which data is being filtered, and, because of
            Akismet&#39;s origins in WordPress, this resource is called the blog
            url. This value should be passed as the second argument to the
            constructor, but may be reset at any time using the
             setBlogUrl()  accessor, or overridden by specifying a
            &#39;blog&#39; key in the various method calls.
         Verify an API key Zend_Service_Akismet::verifyKey($key)  is used to
            verify that an Akismet API key is valid. In most cases, you
            will not need to check, but if you need a sanity check, or
            to determine if a newly acquired key is active, you may do
            so with this method.
         &lt;?php
require_once &#39;Zend/Service/Akismet.php&#39;;

// Instantiate with the API key and a URL to the application or resource being
// used
$akismet = new Zend_Service_Akismet($apiKey, &#39;http://framework.zend.com/wiki/&#39;);
if ($akismet-&gt;verifyKey($apiKey) {
echo &quot;Key is valid.\n&quot;;
} else {
echo &quot;Key is not valid\n&quot;;
}
         
            If called with no arguments,  verifyKey()  uses
            the API key provided to the constructor.
         verifyKey()  implements Akismet&#39;s
             verify-key  REST method.
         Check for spam Zend_Service_Akismet::isSpam($data)  is used to
            determine if the data provided is considered spam by
            Akismet. It accepts an associative array as the sole
            argument. That array requires the following keys be set:
         user_ip , the IP address of the user
                    submitting the data (not your IP address, but that
                    of a user on your site).
                 user_agent , the reported UserAgent
                    string (browser and version) of the user submitting
                    the data.
                 
            The following keys are also recognized specifically by the
            API:
         blog , the fully qualified URL to the
                    resource or application. If not specified, the URL
                    provided to the constructor will be used.
                 referrer , the content of the
                    HTTP_REFERER header at the time of submission. (Note
                    spelling; it does not follow the header name.)
                 permalink , the permalink location, if
                    any, of the entry the data was submitted to.
                 comment_type , the type of data
                    provided. Values specifically specified in the API
                    include &#39;comment&#39;, &#39;trackback&#39;, &#39;pingback&#39;, and an
                    empty string (&#39;&#39;), but it may be any value.
                 comment_author , name of the person
                    submitting the data.
                 comment_author_email , email of the
                    person submitting the data.
                 comment_author_url , URL or home page of the
                    person submitting the data.
                 comment_content , actual data content
                    submitted.
                 
            You may also submit any other environmental variables you
            feel might be a factor in determining if data is spam.
            Akismet suggests the contents of the entire $_SERVER array.
         
            The  isSpam()  method will return either true or
            false, and throw an exception if the API key is invalid.
         isSpam() Usage &lt;?php
$data = array(
    &#39;user_ip&#39;              =&gt; &#39;111.222.111.222&#39;,
    &#39;user_agent&#39;           =&gt; &#39;Mozilla/5.0 (Windows; U; Windows NT 5.2; en-GB; rv:1.8.1) Gecko/20061010 Firefox/2.0&#39;,
    &#39;comment_type&#39;         =&gt; &#39;contact&#39;,
    &#39;comment_author&#39;       =&gt; &#39;John Doe&#39;,
    &#39;comment_author_email&#39; =&gt; &#39;nospam@myhaus.net&#39;,
    &#39;comment_content&#39;      =&gt; &quot;I&#39;m not a spammer, honest!&quot;
);
if ($akismet-&gt;isSpam($data)) {
    echo &quot;Sorry, but we think you&#39;re a spammer.&quot;;
} else {
    echo &quot;Welcome to our site!&quot;;
}
             isSpam()  implements the  comment-check 
            Akismet API method.
         Submitting known spam 
            Occasionally spam data will get through the filter. If in your
            review of incoming data you discover spam that you feel should have
            been caught, you can submit it to Akismet to help improve their
            filter.
         Zend_Service_Akismet::submitSpam()  takes the same data
            array as passed to  isSpam() , but does not return a
            value. An exception will be raised if the API key used is invalid.
         submitSpam() Usage &lt;?php
$data = array(
    &#39;user_ip&#39;              =&gt; &#39;111.222.111.222&#39;,
    &#39;user_agent&#39;           =&gt; &#39;Mozilla/5.0 (Windows; U; Windows NT 5.2; en-GB; rv:1.8.1) Gecko/20061010 Firefox/2.0&#39;,
    &#39;comment_type&#39;         =&gt; &#39;contact&#39;,
    &#39;comment_author&#39;       =&gt; &#39;John Doe&#39;,
    &#39;comment_author_email&#39; =&gt; &#39;nospam@myhaus.net&#39;,
    &#39;comment_content&#39;      =&gt; &quot;I&#39;m not a spammer, honest!&quot;
);
$akismet-&gt;submitSpam($data));
             submitSpam()  implements the  submit-spam 
            Akismet API method.
         Submitting false positives (ham) 
            Occasionally data will be trapped erroneously as spam by Akismet.
            For this reason, you should probably keep a log of all data
            trapped as spam by Akismet and review it periodically. If you find
            such occurrences, you can submit the data to Akismet as &quot;ham&quot;, or a
            false positive (ham is good, spam is not).
         Zend_Service_Akismet::submitHam()  takes the same data
            array as passed to  isSpam()  or
             submitSpam() , and, like  submitSpam() , does
            not return a value. An exception will be raised if the API key used
            is invalid.
         submitHam() Usage &lt;?php
$data = array(
    &#39;user_ip&#39;              =&gt; &#39;111.222.111.222&#39;,
    &#39;user_agent&#39;           =&gt; &#39;Mozilla/5.0 (Windows; U; Windows NT 5.2; en-GB; rv:1.8.1) Gecko/20061010 Firefox/2.0&#39;,
    &#39;comment_type&#39;         =&gt; &#39;contact&#39;,
    &#39;comment_author&#39;       =&gt; &#39;John Doe&#39;,
    &#39;comment_author_email&#39; =&gt; &#39;nospam@myhaus.net&#39;,
    &#39;comment_content&#39;      =&gt; &quot;I&#39;m not a spammer, honest!&quot;
);
$akismet-&gt;submitHam($data));
             submitHam()  implements the  submit-ham 
            Akismet API method.
         Zend-specific Accessor Methods 
            While the Akismet API only specifies four methods,
             Zend_Service_Akismet  has several additional accessors
            that may be used for modifying internal properties.
         getBlogUrl()  and  setBlogUrl() 
                    allow you to retrieve and modify the blog URL used in
                    requests.
                 getApiKey()  and  setApiKey() 
                    allow you to retrieve and modify the API key used in
                    requests.
                 getCharset()  and  setCharset() 
                    allow you to retrieve and modify the character set used to
                    make the request.
                 getPort()  and  setPort() 
                    allow you to retrieve and modify the TCP port used to make
                    the request.
                 getUserAgent()  and  setUserAgent() 
                    allow you to retrieve and modify the HTTP user agent used to
                    make the request. Note: this is not the user_agent used in
                    data submitted to the service, but rather the value provided
                    in the HTTP User-Agent header when making a request to the
                    service.
                 
                    The value used to set the user agent should be of the form
                     some user agent/version | Akismet/version . The
                    default is  Zend Framework/ZF-VERSION | Akismet/1.11 , where  ZF-VERSION  is the current Zend Framework version as stored in the  Zend_Framework::VERSION  constant.
                 Zend_Service_Amazon Introduction Zend_Service_Amazon  is a simple API for using Amazon web services.
             Zend_Service_Amazon  has two APIs: a more traditional one that follows Amazon&#39;s own API, and a
            simpler &quot;Query API&quot; for constructing even complex search queries easily.
         Zend_Service_Amazon  enables developers to retrieve information appearing throughout Amazon.com
            web sites directly through the Amazon Web Services API. Examples include:
             
                        Store item information, such as images, descriptions, pricing, and more
                     
                        Customer and editorial reviews
                     
                        Similar products and accessories
                     
                        Amazon.com offers
                     
                        ListMania lists
                     
         
            In order to use  Zend_Service_Amazon , you should already have an Amazon developer API key. To
            get a key and for more information, please visit the
             Amazon Web Services  web site.
         Attention 
                Your Amazon developer API key is linked to your Amazon identity,
                so take appropriate measures to keep your API key private.
             Search Amazon Using the Traditional API 
                In this example, we search for PHP books at Amazon and loop through the results, printing them.
             &lt;?php
require_once &#39;Zend/Service/Amazon.php&#39;;
$amazon = new Zend_Service_Amazon(&#39;AMAZON_API_KEY&#39;);
$results = $amazon-&gt;itemSearch(array(&#39;SearchIndex&#39; =&gt; &#39;Books&#39;, &#39;Keywords&#39; =&gt; &#39;php&#39;));
foreach ($results as $result) {
    echo $result-&gt;Title . &#39;&lt;br /&gt;&#39;;
}
             Search Amazon Using the Query API 
                Here, we also search for PHP books at Amazon, but we instead use the Query API, which
                resembles the Fluent Interface design pattern.
             &lt;?php
require_once &#39;Zend/Service/Amazon/Query.php&#39;;
$query = new Zend_Service_Amazon_Query(&#39;AMAZON_API_KEY&#39;);
$query-&gt;category(&#39;Books&#39;)-&gt;Keywords(&#39;PHP&#39;);
$results = $query-&gt;search();
foreach ($results as $result) {
    echo $result-&gt;Title . &#39;&lt;br /&gt;&#39;;
}
             Country Codes 
            By default,  Zend_Service_Amazon  connects to the United States (&quot; US &quot;) Amazon
            web service. To connect from a different country, simply specify the appropriate country code string
            as the second parameter to the constructor:
         Choosing an Amazon Web Service Country &lt;?php
// Connect to Amazon in Japan
require_once &#39;Zend/Service/Amazon.php&#39;;
$amazon = new Zend_Service_Amazon(&#39;AMAZON_API_KEY&#39;, &#39;JP&#39;);
             Country codes 
                Valid country codes are:  CA ,  DE ,  FR ,  JP ,
                 UK , and  US .
             Looking up a Specific Amazon Item by ASIN 
            The  itemLookup()  method provides the ability to fetch a particular Amazon item when
            the ASIN is known.
         Looking up a Specific Amazon Item by ASIN &lt;?php
require_once &#39;Zend/Service/Amazon.php&#39;;
$amazon = new Zend_Service_Amazon(&#39;AMAZON_API_KEY&#39;);
$item = $amazon-&gt;itemLookup(&#39;B0000A432X&#39;);
             
            The  itemLookup()  method also accepts an optional second parameter for handling search
            options. For full details, including a list of available options, please see the
             relevant Amazon documentation .
         Image information 
                To retrieve images information for your search results, you must set
                 ResponseGroup  option to  Medium  or  Large .
             Performing Amazon Item Searches 
            Searching for items based on any of various available criteria are made simple using the
             itemSearch()  method, as in the following example:
         Performing Amazon Item Searches &lt;?php
require_once &#39;Zend/Service/Amazon.php&#39;;
$amazon = new Zend_Service_Amazon(&#39;AMAZON_API_KEY&#39;);
$results = $amazon-&gt;itemSearch(array(&#39;SearchIndex&#39; =&gt; &#39;Books&#39;, &#39;Keywords&#39; =&gt; &#39;php&#39;));
foreach ($results as $result) {
    echo $result-&gt;Title . &#39;&lt;br /&gt;&#39;;
}
             Using the  ResponseGroup  Option 
                The  ResponseGroup  option is used to control the specific information that will be returned
                in the response.
             &lt;?php
require_once &#39;Zend/Service/Amazon.php&#39;;
$amazon = new Zend_Service_Amazon(&#39;AMAZON_API_KEY&#39;);
$results = $amazon-&gt;itemSearch(array(
    &#39;SearchIndex&#39;   =&gt; &#39;Books&#39;,
    &#39;Keywords&#39;      =&gt; &#39;php&#39;,
    &#39;ResponseGroup&#39; =&gt; &#39;Small,ItemAttributes,Images,SalesRank,Reviews,EditorialReview,Similarities,ListmaniaLists&#39;
    ));
foreach ($results as $result) {
    echo $result-&gt;Title . &#39;&lt;br /&gt;&#39;;
}
             
            The  itemSearch()  method accepts a single array parameter for handling search
            options. For full details, including a list of available options, please see the
             relevant Amazon documentation 
         
                The  Zend_Service_Amazon_Query  class
                is an easy to use wrapper around this method.
             Using the Alternative Query API Introduction Zend_Service_Amazon_Query  provides an alternative API for using the Amazon Web Service.
                The alternative API uses the Fluent Interface pattern. That is, all calls can be made using chained method
                calls. (e.g.,  $obj-&gt;method()-&gt;method2($arg) )
             
                The  Zend_Service_Amazon_Query  API uses overloading to easily set up an item search and then
                allows you to search based upon the criteria specified. Each of the options is provided as a method call,
                and each method&#39;s argument corresponds to the named option&#39;s value:
             Search Amazon Using the Alternative Query API 
                    In this example, the alternative query API is used as a fluent interface to specify options and their
                    respective values:
                 &lt;?php
require_once &#39;Zend/Service/Amazon/Query.php&#39;;
$query = new Zend_Service_Amazon_Query(&#39;MY_API_KEY&#39;);
$query-&gt;Category(&#39;Books&#39;)-&gt;Keywords(&#39;PHP&#39;);
$results = $query-&gt;search();
foreach ($results as $result) {
    echo $result-&gt;Title . &#39;&lt;br /&gt;&#39;;
}
                 
                    This sets the option  Category  to &quot;Books&quot; and  Keywords  to &quot;PHP&quot;.
                 
                    For more information on the available options, please refer to the
                     relevant Amazon documentation .
                 Zend_Service_Amazon Classes 
            The following classes are all returned by
             Zend_Service_Amazon::itemLookup() 
            and
             Zend_Service_Amazon::itemSearch() :
             Zend_Service_Amazon_Item Zend_Service_Amazon_Image Zend_Service_Amazon_ResultSet Zend_Service_Amazon_OfferSet Zend_Service_Amazon_Offer Zend_Service_Amazon_SimilarProduct Zend_Service_Amazon_Accessories Zend_Service_Amazon_CustomerReview Zend_Service_Amazon_EditorialReview Zend_Service_Amazon_ListMania 
         Zend_Service_Amazon_Item Zend_Service_Amazon_Item  is the class type used to represent an Amazon item returned by the
                web service. It encompasses all of the items attributes, including title, description, reviews, etc.
             Zend_Service_Amazon_Item::asXML() string asXML Return the original XML for the item Properties Zend_Service_Amazon_Item  has a number of properties directly related to their standard
                    Amazon API counterparts.
                 Zend_Service_Amazon_Item Properties Name Type Description ASIN string Amazon Item ID DetailPageURL string URL to the Items Details Page SalesRank int Sales Rank for the Item SmallImage Zend_Service_Amazon_Image Small Image of the Item MediumImage Zend_Service_Amazon_Image Medium Image of the Item LargeImage Zend_Service_Amazon_Image Large Image of the Item Subjects array Item Subjects Offers Zend_Service_Amazon_OfferSet Offer Summary and Offers for the Item CustomerReviews array 
                                    Customer reviews represented as an array of
                                     Zend_Service_Amazon_CustomerReview 
                                    objects
                                 EditorialReviews array 
                                    Editorial reviews represented as an array of
                                     Zend_Service_Amazon_EditorialReview 
                                    objects
                                 SimilarProducts array 
                                    Similar Products represented as an array of
                                     Zend_Service_Amazon_SimilarProduct 
                                    objects
                                 Accessories array 
                                    Accessories for the item represented as an array of
                                     Zend_Service_Amazon_Accessories 
                                    objects
                                 Tracks array An array of track numbers and names for Music CDs and DVDs ListmaniaLists array 
                                    Item related Listmania Lists as an array of
                                     Zend_Service_Amazon_ListmainList 
                                    objects
                                 PromotionalTag string Item Promotional Tag Back to Class List Zend_Service_Amazon_Image Zend_Service_Amazon_Image  represents a remote Image for a product. Properties Zend_Service_Amazon_Image Properties Name Type Description Url Zend_Uri Remote URL for the Image Height int The Height of the image in pixels Width int The Width of the image in pixels Back to Class List Zend_Service_Amazon_ResultSet Zend_Service_Amazon_ResultSet  objects are returned by
                 Zend_Service_Amazon::itemSearch() 
                and allow you to easily handle the multiple results returned.
             SeekableIterator 
                    Implements the  SeekableIterator  for easy iteration (e.g. using  foreach ), as
                    well as direct access to a specific result using  seek() .
                 Zend_Service_Amazon_ResultSet::totalResults() int totalResults Returns the total number of results returned by the search Back to Class List Zend_Service_Amazon_OfferSet 
                Each result returned by
                 Zend_Service_Amazon::itemSearch() 
                and
                 Zend_Service_Amazon::itemLookup() 
                contains a
                 Zend_Service_Amazon_OfferSet 
                object through which pricing information for the item can be retrieved.
             Properties Zend_Service_Amazon_OfferSet Properties Name Type Description LowestNewPrice int Lowest Price for the item in &quot;New&quot; condition LowestNewPriceCurrency string 
                                    The currency for the
                                     LowestNewPrice 
                                 LowestOldPrice int Lowest Price for the item in &quot;Used&quot; condition LowestOldPriceCurrency string 
                                    The currency for the
                                     LowestOldPrice 
                                 TotalNew int Total number of &quot;new&quot; condition available for the item TotalUsed int Total number of &quot;used&quot; condition available for the item TotalCollectible int Total number of &quot;collectible&quot; condition available for the item TotalRefurbished int Total number of &quot;refurbished&quot; condition available for the item Offers array 
                                    An array of
                                     Zend_Service_Amazon_Offer 
                                    objects.
                                 Back to Class List Zend_Service_Amazon_Offer 
                Each offer for an item is returned as an
                 Zend_Service_Amazon_Offer 
                object.
             Zend_Service_Amazon_Offer Properties Properties Name Type Description MerchantId string Merchants Amazon ID GlancePage string URL for a page with a summary of the Merchant Condition string Condition of the item OfferListingId string ID of the Offer Listing Price int Price for the item CurrencyCode string Currency Code for the price of the item Availability string Availability of the item IsEligibleForSuperSaverShipping boolean Whether the item is eligible for Super Saver Shipping or not Back to Class List Zend_Service_Amazon_SimilarProduct 
                When searching for items, Amazon also returns a list of similar products that the searcher may find to
                their liking. Each of these is returned as a  Zend_Service_Amazon_SimilarProduct  object.
             
                Each object contains the information to allow you to make sub-sequent requests to get the full information
                on the item.
             Properties Zend_Service_Amazon_SimilarProduct Properties Name Type Description ASIN string Products Amazon Unique ID (ASIN) Title string Products Title Back to Class List Zend_Service_Amazon_Accessories 
                Accessories for the returned item are represented as  Zend_Service_Amazon_Accessories  objects
             Properties Zend_Service_Amazon_Accessories Properties Name Type Description ASIN string Products Amazon Unique ID (ASIN) Title string Products Title Back to Class List Zend_Service_Amazon_CustomerReview 
                Each Customer Review is returned as a  Zend_Service_Amazon_CustomerReview  object.
             Properties Zend_Service_Amazon_CustomerReview Properties Name Type Description Rating string Item Rating HelpfulVotes string Votes on how helpful the review is CustomerId string Customer ID TotalVotes string Total Votes Date string Date of the Review Summary string Review Summary Content string Review Content Back to Class List Zend_Service_Amazon_EditorialReview 
                Each items Editorial Reviews are returned as a  Zend_Service_Amazon_EditorialReview  object
             Properties Zend_Service_Amazon_EditorialReview Properties Name Type Description Source string Source of the Editorial Review Content string Review Content Back to Class List Zend_Service_Amazon_Listmania 
                Each results List Mania List items are returned as  Zend_Service_Amazon_Listmania  objects.
             Properties Zend_Service_Amazon_Listmania Properties Name Type Description ListId string List ID ListName string List Name Back to Class List Zend_Service_Audioscrobbler Introduction to Searching Audioscrobbler Zend_Service_Audioscrobbler  is a simple API for using the Audioscrobbler REST Web Service. The
            Audioscrobbler Web Service provides access to its database of Users, Artists, Albums, Tracks, Tags, Groups,
            and Forums. The methods of the  Zend_Service_Audioscrobbler  class begin with one of these terms.
            The syntax and namespaces of the Audioscrobbler Web Service are mirrored in
             Zend_Service_Audioscrobbler . For more information about the Audioscrobbler REST Web Service,
            please visit the  Audioscrobbler Web Service
            site .
         Users 
            In order to retrieve information for a specific user, the  setUser()  method is first used to
            select the user for which data are to be retrieved.  Zend_Service_Audioscrobbler  provides
            several methods for retrieving data specific to a single user:
             userGetProfileInformation() : Returns a SimpleXML object containing the current
                        user&#39;s profile information.
                     userGetTopArtists() : Returns a SimpleXML object containing a list of the current
                        user&#39;s most listened to artists.
                     userGetTopAlbums() : Returns a SimpleXML object containing a list of the current
                        user&#39;s most listened to albums.
                     userGetTopTracks() : Returns a SimpleXML object containing a list of the current
                        user&#39;s most listened to tracks.
                     userGetTopTags() : Returns a SimpleXML object containing a list of tags most applied
                        by the current user.
                     userGetTopTagsForArtist() : Requires that an artist be set via
                         setArtist() . Returns a SimpleXML object containing the tags most applied to the
                        current artist by the current user.
                     userGetTopTagsForAlbum() : Requires that an album be set via
                         setAlbum() . Returns a SimpleXML object containing the tags most applied to the
                        current album by the current user.
                     userGetTopTagsForTrack() : Requires that a track be set via
                         setTrack() . Returns a SimpleXML object containing the tags most applied to the
                        current track by the current user.
                     userGetFriends() : Returns a SimpleXML object containing the user names of the
                        current user&#39;s friends.
                     userGetNeighbours() : Returns a SimpleXML object containing the user names of
                        people with similar listening habits to the current user.
                     userGetRecentTracks() : Returns a SimpleXML object containing the 10 tracks most
                        recently played by the current user.
                     userGetRecentBannedTracks() : Returns a SimpleXML object containing a list of the 10
                        tracks most recently banned by the current user.
                     userGetRecentLovedTracks() : Returns a SimpleXML object containing a list of the 10
                        tracks most recently loved by the current user.
                     userGetRecentJournals() : Returns a SimpleXML object containing a list of the
                        current user&#39;s most recent journal entries.
                     userGetWeeklyChartList() : Returns a SimpleXML object containing a list of weeks for
                        which there exist Weekly Charts for the current user.
                     userGetRecentWeeklyArtistChart() : Returns a SimpleXML object containing the most
                        recent Weekly Artist Chart for the current user.
                     userGetRecentWeeklyAlbumChart() : Returns a SimpleXML object containing the most
                        recent Weekly Album Chart for the current user.
                     userGetRecentWeeklyTrackChart() : Returns a SimpleXML object containing the most
                        recent Weekly Track Chart for the current user.
                     userGetPreviousWeeklyArtistChart($fromDate, $toDate) : Returns a SimpleXML object
                        containing the Weekly Artist Chart from  $fromDate  to  $toDate  for the
                        current user.
                     userGetPreviousWeeklyAlbumChart($fromDate, $toDate) : Returns a SimpleXML object
                        containing the Weekly Album Chart from  $fromDate  to  $toDate  for the
                        current user.
                     userGetPreviousWeeklyTrackChart($fromDate, $toDate) : Returns a SimpleXML object
                        containing the Weekly Track Chart from  $fromDate  to  $toDate  for the
                        current user.
                     
         Retrieving User Profile Information 
                In this example, we use the  setUser()  and  userGetProfileInformation()  methods
                to retrieve a specific user&#39;s profile information:
             &lt;?php
require_once &#39;Zend/Service/Audioscrobbler.php&#39;;
$as = new Zend_Service_Audioscrobbler();
$as-&gt;setUser(&#39;BigDaddy71&#39;); // Set the user whose profile information we want to retrieve
$profileInfo = $as-&gt;userGetProfileInformation(); // Retrieve BigDaddy71&#39;s profile information
print &quot;Information for $profileInfo-&gt;realname can be found at $profileInfo-&gt;url&quot;; // Display some of it
             Retrieving a User&#39;s Weekly Artist Chart &lt;?php
require_once &#39;Zend/Service/Audioscrobbler.php&#39;;
$as = new Zend_Service_Audioscrobbler();
$as-&gt;setUser(&#39;lo_fye&#39;); // Set the user whose profile weekly artist chart we want to retrieve
$weeks = $as-&gt;userGetWeeklyChartList(); // Retrieves a list of previous weeks for which there are chart data
if (count($weeks) &lt; 1) {
    echo &#39;No data available&#39;;
}
sort($weeks); // Order the list of weeks

$as-&gt;setFromDate($weeks[0]); // Set the starting date
$as-&gt;setToDate($weeks[0]); // Set the ending date

$previousWeeklyArtists = $as-&gt;userGetPreviousWeeklyArtistChart();

echo &#39;Artist Chart For Week Of &#39; . date(&#39;Y-m-d h:i:s&#39;, $as-&gt;from_date) . &#39;&lt;br /&gt;&#39;;

foreach ($previousWeeklyArtists as $artist) {
    // Display the artists&#39; names with links to their profiles
    print &#39;&lt;a href=&quot;&#39; . $artist-&gt;url . &#39;&quot;&gt;&#39; . $artist-&gt;name . &#39;&lt;/a&gt;&lt;br /&gt;&#39;;
}
             Artists Zend_Service_Audioscrobbler  provides several methods for retrieving data about a specific
            artist, specified via the  setArtist()  method:
             artistGetRelatedArtists() : Returns a SimpleXML object containing a list of
                        Artists similar to the current Artist.
                     artistGetTopFans() : Returns a SimpleXML object containing a list of Users who
                        listen most to the current Artist.
                     artistGetTopTracks() : Returns a SimpleXML object containing a list of the current
                        Artist&#39;s top-rated Tracks.
                     artistGetTopAlbums() : Returns a SimpleXML object containing a list of the current
                        Artist&#39;s top-rated Albums.
                     artistGetTopTags() : Returns a SimpleXML object containing a list of the Tags most
                        frequently applied to current Artist.
                     
         Retrieving Related Artists &lt;?php
require_once &#39;Zend/Service/Audioscrobbler.php&#39;;
$as = new Zend_Service_Audioscrobbler();
$as-&gt;setArtist(&#39;LCD Soundsystem&#39;); // Set the artist for whom you would like to retrieve related artists
$relatedArtists = $as-&gt;artistGetRelatedArtists(); // Retrieve the related artists
foreach ($relatedArtists as $artist) {
    print &#39;&lt;a href=&quot;&#39; . $artist-&gt;url . &#39;&quot;&gt;&#39; . $artist-&gt;name . &#39;&lt;/a&gt;&lt;br /&gt;&#39;; // Display the related artists
}
             Tracks Zend_Service_Audioscrobbler  provides two methods for retrieving data specific to a single
            track, specified via the  setTrack()  method:
             trackGetTopFans() : Returns a SimpleXML object containing a list of Users who
                        listen most to the current Track.
                     trackGetTopTags() : Returns a SimpleXML object containing a list of the Tags most
                        frequently applied to the current Track.
                     
         Tags Zend_Service_Audioscrobbler  provides several methods for retrieving data specific to a single
            tag, specified via the  setTag()  method:
             tagGetOverallTopTags() : Returns a SimpleXML object containing a list of Tags most
                        frequently used on Audioscrobbler.
                     tagGetTopArtists() : Returns a SimpleXML object containing a list of Artists to whom
                        the current Tag was most frequently applied.
                     tagGetTopAlbums() : Returns a SimpleXML object containing a list of Albums to which
                        the current Tag was most frequently applied.
                     tagGetTopTracks() : Returns a SimpleXML object containing a list of Tracks to which
                        the current Tag was most frequently applied.
                     
         Groups Zend_Service_Audioscrobbler  provides several methods for retrieving data specific to a single
            group, specified via the  setGroup()  method:
             groupGetRecentJournals() : Returns a SimpleXML object containing a list of recent
                        journal posts by Users in the current Group.
                     groupGetWeeklyChart() : Returns a SimpleXML object containing a list of weeks for
                        which there exist Weekly Charts for the current Group.
                     groupGetRecentWeeklyArtistChart() : Returns a SimpleXML object containing the most
                        recent Weekly Artist Chart for the current Group.
                     groupGetRecentWeeklyAlbumChart() : Returns a SimpleXML object containing the most
                        recent Weekly Album Chart for the current Group.
                     groupGetRecentWeeklyTrackChart() : Returns a SimpleXML object containing the most
                        recent Weekly Track Chart for the current Group.
                     groupGetPreviousWeeklyArtistChart($fromDate, $toDate) : Requires
                         setFromDate()  and  setToDate() . Returns a SimpleXML object containing
                        the Weekly Artist Chart from the current fromDate to the current toDate for the current Group.
                     groupGetPreviousWeeklyAlbumChart($fromDate, $toDate) : Requires
                         setFromDate()  and  setToDate() . Returns a SimpleXML object containing
                        the Weekly Album Chart from the current fromDate to the current toDate for the current Group.
                     groupGetPreviousWeeklyTrackChart($fromDate, $toDate) : Returns a SimpleXML object
                        containing the Weekly Track Chart from the current fromDate to the current toDate for the
                        current Group.
                     
         Forums Zend_Service_Audioscrobbler  provides a method for retrieving data specific to a single forum,
            specified via the  setForum()  method:
             forumGetRecentPosts() : Returns a SimpleXML object containing a list of recent posts
                        in the current forum.
                     
         Zend_Service_Delicious Introduction Zend_Service_Delicious  is simple API for using
             del.icio.us 
            XML and JSON web services. This component gives you read-write access to posts at del.icio.us
            if you provide credentials. It also allows read-only access to public data of all users.
         Get all posts &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);
$posts = $delicious-&gt;getAllPosts();

foreach ($posts as $post) {
    echo &quot;--\n&quot;;
    echo &quot;Title: {$post-&gt;getTitle()}\n&quot;;
    echo &quot;Url: {$post-&gt;getUrl()}\n&quot;;
}
             Retrieving posts Zend_Service_Delicious  provides three methods for retrieving posts:  getPosts() ,
             getRecentPosts()  and  getAllPosts() . All of these
            methods return an instance of  Zend_Service_Delicious_PostList , which
            holds all retrieved posts.
         &lt;?php
/**
 * Get posts matching the arguments. If no date or url is given, most recent date will be used.
 *
 * @param string $tag Optional filtering by tag
 * @param Zend_Date $dt Optional filtering by date
 * @param string $url Optional filtering by url
 * @return Zend_Service_Delicious_PostList
 */
public function getPosts($tag = null, $dt = null, $url = null);

/**
 * Get recent posts
 *
 * @param string $tag   Optional filtering by tag
 * @param string $count Maximal number of posts to be returned (default 15)
 * @return Zend_Service_Delicious_PostList
 */
public function getRecentPosts($tag = null, $count = 15);

/**
 * Get all posts
 *
 * @param string $tag Optional filtering by tag
 * @return Zend_Service_Delicious_PostList
 */
public function getAllPosts($tag = null);
         Zend_Service_Delicious_PostList 
            Instances of this class are returned by the  getPosts() ,  getAllPosts() ,
             getRecentPosts() , and  getUserPosts()  methods of  Zend_Service_Delicious .
         
            For easier data access this class implements the  Countable ,  Iterator , and
             ArrayAccess  interfaces.
         Accessing post lists &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);
$posts = $delicious-&gt;getAllPosts();

// count posts
echo count($posts);

// iterate over posts
foreach ($posts as $post) {
    echo &quot;--\n&quot;;
    echo &quot;Title: {$post-&gt;getTitle()}\n&quot;;
    echo &quot;Url: {$post-&gt;getUrl()}\n&quot;;
}

// get post using array access
echo $posts[0]-&gt;getTitle();
             
                The  ArrayAccess::offsetSet()  and  ArrayAccess::offsetUnset()  methods
                throw exceptions in this implementation. Thus, code like  unset($posts[0]);  and
                 $posts[0] = &#39;A&#39;;  will throw exceptions because these properties are read-only.
             
            Post list objects have two built-in filtering capabilities. Post lists may be filtered by tags and by URL.
         Filtering a Post List with Specific Tags 
                Posts may be filtered by specific tags using  withTags() . As a convenience,
                 withTag()  is also provided for when only a single tag needs to be specified.
             &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);
$posts = $delicious-&gt;getAllPosts();

// Print posts having &quot;php&quot; and &quot;zend&quot; tags
foreach ($posts-&gt;withTags(array(&#39;php&#39;, &#39;zend&#39;)) as $post) {
    echo &quot;Title: {$post-&gt;getTitle()}\n&quot;;
    echo &quot;Url: {$post-&gt;getUrl()}\n&quot;;
}
             Filtering a Post List by URL 
                Posts may be filtered by URL matching a specified regular expression using the  withUrl() 
                method:
             &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);
$posts = $delicious-&gt;getAllPosts();

// Print posts having &quot;help&quot; in the URL
foreach ($posts-&gt;withUrl(&#39;/help/&#39;) as $post) {
    echo &quot;Title: {$post-&gt;getTitle()}\n&quot;;
    echo &quot;Url: {$post-&gt;getUrl()}\n&quot;;
}
             Editing posts Post editing &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);
$posts = $delicious-&gt;getPosts();

// set title
$posts[0]-&gt;setTitle(&#39;New title&#39;);
// save changes
$posts[0]-&gt;save();
             Method call chaining 
               Every setter method returns the post object so that you can chain method calls using a fluent interface.
             &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);
$posts = $delicious-&gt;getPosts();

$posts[0]-&gt;setTitle(&#39;New title&#39;)
         -&gt;setNotes(&#39;New notes&#39;)
         -&gt;save();
             Deleting posts 
            There are two ways to delete a post, by specifying the post URL or by calling the  delete() 
            method upon a post object.
         Deleting posts &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);

// by specifying URL
$delicious-&gt;deletePost(&#39;http://framework.zend.com&#39;);

// or by calling the method upon a post object
$posts = $delicious-&gt;getPosts();
$posts[0]-&gt;delete();

// another way of using deletePost()
$delicious-&gt;deletePost($posts[0]-&gt;getUrl());
             Adding new posts 
            To add a post you first need to call the  createNewPost()  method, which returns a
             Zend_Service_Delicious_Post  object. When you edit the post, you need to save it
            to the del.icio.us database by calling the  save()  method.
         Adding a post &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);

// create a new post and save it (with method call chaining)
$delicious-&gt;createNewPost(&#39;Zend Framework&#39;, &#39;http://framework.zend.com&#39;)
          -&gt;setNotes(&#39;Zend Framework Homepage&#39;)
          -&gt;save();

// create a new post and save it  (without method call chaining)
$newPost = $delicious-&gt;createNewPost(&#39;Zend Framework&#39;, &#39;http://framework.zend.com&#39;);
$newPost-&gt;setNotes(&#39;Zend Framework Homepage&#39;);
$newPost-&gt;save();
             Tags Tags &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);

// get all tags
print_r($delicious-&gt;getTags());

// rename tag ZF to zendFramework
$delicious-&gt;renameTag(&#39;ZF&#39;, &#39;zendFramework&#39;);
             Bundles Bundles &lt;?php
$delicious = new Zend_Service_Delicious(&#39;username&#39;, &#39;password&#39;);

// get all bundles
print_r($delicious-&gt;getBundles());

// delete bundle someBundle
$delicious-&gt;deleteBundle(&#39;someBundle&#39;);

// add bundle
$delicious-&gt;addBundle(&#39;newBundle&#39;, array(&#39;tag1&#39;, &#39;tag2&#39;));
             Public data 
            The del.icio.us web API allows access to the public data of all users.
         Methods for retrieving public data Name Description Return type getUserFans() Retrieves fans of a user Array getUserNetwork() Retrieves network of a user Array getUserPosts() Retrieves posts of a user Zend_Service_Delicious_PostList getUserTags() Retrieves tags of a user Array 
                When using only these methods, a username and password combination is not required when constructing
                a new  Zend_Service_Delicious  object.
             Retrieving public data &lt;?php
// username and password are not required
$delicious = new Zend_Service_Delicious();

// get fans of user someUser
print_r($delicious-&gt;getUserFans(&#39;someUser&#39;));

// get network of user someUser
print_r($delicious-&gt;getUserNetwork(&#39;someUser&#39;));

// get tags of user someUser
print_r($delicious-&gt;getUserTags(&#39;someUser&#39;));
             Public posts 
                When retrieving public posts with the  getUserPosts()  method, a
                 Zend_Service_Delicious_PostList  object is returned, and it contains
                 Zend_Service_Delicious_SimplePost  objects, which contain basic information
                about the posts, including URL, title, notes, and tags.
             Methods of the  Zend_Service_Delicious_SimplePost  class Name Description Return type getNotes() Returns notes of a post String getTags() Returns tags of a post Array getTitle() Returns title of a post String getUrl() Returns URL of a post String HTTP client Zend_Service_Delicious  uses  Zend_Rest_Client  for making HTTP requests
            to the del.icio.us web service. To change which HTTP client  Zend_Service_Delicious 
            uses, you need to change the HTTP client of  Zend_Rest_Client .
         Changing the HTTP client of  Zend_Rest_Client &lt;?php
$myHttpClient = new My_Http_Client();
Zend_Rest_Client::setHttpClient($myHttpClient);
             
            When you are making more than one request with  Zend_Service_Delicious  to speed your
            requests, it&#39;s better to configure your HTTP client to keep connections alive.
         Configuring your HTTP client to keep connections alive &lt;?php
Zend_Rest_Client::getHttpClient()-&gt;setConfig(array(
        &#39;keepalive&#39; =&gt; true
));
             
                When a  Zend_Service_Delicious  object is constructed, the SSL transport
                of  Zend_Rest_Client  is set to  &#39;ssl&#39;  rather than the default of
                 &#39;ssl2&#39; . This is because del.icio.us has some problems with  &#39;ssl2&#39; , such
                as requests taking a long time to complete (around 2 seconds).
             Zend_Service_Flickr Introduction to Searching Flickr Zend_Service_Flickr  is a simple API for using the Flickr REST Web Service. In order to use
            the Flickr web services, you must have an API key. To obtain a key and for more information about the
            Flickr REST Web Service, please visit the
             Flickr API Documentation .
         
            In the following example, we use the  tagSearch()  method to search for photos having &quot;php&quot;
            in the tags.
         Simple Flickr Photo Search &lt;?php
require_once &#39;Zend/Service/Flickr.php&#39;;

$flickr = new Zend_Service_Flickr(&#39;MY_API_KEY&#39;);

$results = $flickr-&gt;tagSearch(&quot;php&quot;);

foreach ($results as $result) {
    echo $result-&gt;title . &#39;&lt;br /&gt;&#39;;
}
             Optional parameter tagSearch()  accepts an optional second parameter as an array of options.
             Finding Flickr Users&#39; Photos and Information Zend_Service_Flickr  provides several ways to get information about Flickr users:
         userSearch() : Accepts a string query of space-delimited tags and an optional second
                    parameter as an array of search options, and returns a set of photos as a
                     Zend_Service_Flickr_ResultSet  object.
                 getIdByUsername() : Returns a string user ID associated with the given username string.
                 getIdByEmail() : Returns a string user ID associated with the given email address
                    string.
                 Finding a Flickr User&#39;s Public Photos by E-Mail Address 
                In this example, we have a Flickr user&#39;s e-mail address, and we search for the user&#39;s public photos by
                using the  userSearch()  method:
             &lt;?php
require_once &#39;Zend/Service/Flickr.php&#39;;

$flickr = new Zend_Service_Flickr(&#39;MY_API_KEY&#39;);

$results = $flickr-&gt;userSearch($userEmail);

foreach ($results as $result) {
    echo $result-&gt;title . &#39;&lt;br /&gt;&#39;;
}
             Finding photos From a Group Pool Zend_Service_Flickr  allows to retrieve a group&#39;s pool photos based 
            on the group ID. Use the  groupPoolGetPhotos()  method:
         Retrieving a Group&#39;s Pool Photos by Group ID &lt;?php
    require_once &#39;Zend/Service/Flickr.php&#39;;

    $flickr = new Zend_Service_Flickr(&#39;MY_API_KEY&#39;);

    $results = $flickr-&gt;groupPoolGetPhotos($groupId);

    foreach ($results as $result) {
        echo $result-&gt;title . &#39;&lt;br /&gt;&#39;;
    }            
             Optional parameter groupPoolGetPhotos()  accepts an optional second parameter as an array of options. 
             Retrieving Flickr Image Details Zend_Service_Flickr  makes it quick and easy to get an image&#39;s details based on a given image
            ID. Just use the  getImageDetails()  method, as in the following example:
         Retrieving Flickr Image Details 
                Once you have a Flickr image ID, it is a simple matter to fetch information about the image:
             &lt;?php
require_once &#39;Zend/Service/Flickr.php&#39;;

$flickr = new Zend_Service_Flickr(&#39;MY_API_KEY&#39;);

$image = $flickr-&gt;getImageDetails($imageId);

echo &quot;Image ID $imageId is $image-&gt;width x $image-&gt;height pixels.&lt;br /&gt;\n&quot;;
echo &quot;&lt;a href=\&quot;$image-&gt;clickUri\&quot;&gt;Click for Image&lt;/a&gt;\n&quot;;
             Zend_Service_Flickr Result Classes 
            The following classes are all returned by  tagSearch()  and  userSearch() :
             Zend_Service_Flickr_ResultSet Zend_Service_Flickr_Result Zend_Service_Flickr_Image 
         Zend_Service_Flickr_ResultSet Represents a set of Results from a Flickr search. 
                    Implements the  SeekableIterator  interface for easy iteration (e.g., using
                     foreach ), as well as direct access to a specific result using  seek() .
                 Properties Zend_Service_Flickr_ResultSet Properties Name Type Description totalResultsAvailable int Total Number of Results available totalResultsReturned int Total Number of Results returned firstResultPosition int The offset in the total result set of this result set Zend_Service_Flickr_ResultSet::totalResults() int totalResults 
                    Returns the total number of results in this result set.
                 Back to Class List Zend_Service_Flickr_Result 
                A single Image result from a Flickr query
             Properties Zend_Service_Flickr_Result Properties Name Type Description id string Image ID owner string The photo owner&#39;s NSID. secret string A key used in url construction. server string The servername to use for URL construction. title string The photo&#39;s title. ispublic string The photo is public. isfriend string The photo is visible to you because you are a friend of the owner. isfamily string The photo is visible to you because you are family of the owner. license string The license the photo is available under. dateupload string The date the photo was uploaded. datetaken string The date the photo was taken. ownername string The screenname of the owner. iconserver string The server used in assembling icon URLs. Square Zend_Service_Flickr_Image A 75x75 thumbnail of the image. Thumbnail Zend_Service_Flickr_Image A 100 pixel thumbnail of the image. Small Zend_Service_Flickr_Image A 240 pixel version of the image. Medium Zend_Service_Flickr_Image A 500 pixel version of the image. Large Zend_Service_Flickr_Image A 640 pixel version of the image. Original Zend_Service_Flickr_Image The original image. Back to Class List Zend_Service_Flickr_Image Represents an Image returned by a Flickr search. Properties Zend_Service_Flickr_Image Properties Name Type Description uri string URI for the original image clickUri string Clickable URI (i.e. the Flickr page) for the image width int Width of the Image height int Height of the Image Back to Class List Zend_Service_Nirvanix Introduction 
            Nirvanix provides an Internet Media File System (IMFS), an
            Internet storage service that allows applications to upload, store and
            organize files and subsequently access them using a standard Web
            Services interface. An IMFS is distributed clustered file system,
            accessed over the Internet, and optimized for dealing with media files
            (audio, video, etc). The goal of an IMFS is to provide massive
            scalability to deal with the challenges of media storage growth, with
            guaranteed access and availability regardless of time and location.
            Finally, an IMFS gives applications the ability to access data
            securely, without the large fixed costs associated with acquiring and
            maintaining physical storage assets.
         Registering with Nirvanix 
            Before you can get started with  Zend_Service_Nirvanix , you must first
            register for an account.  Please see the 
             Getting Started 
            page on the Nirvanix website for more information.
         
            After registering, you will receive a Username, Password, and 
            Application Key.  All three are required to use  Zend_Service_Nirvanix .
         API Documentation 
            Access to the Nirvanix IMFS is available through both SOAP and a faster 
            REST service.   Zend_Service_Nirvanix  provides a 
            relatively thin PHP 5 wrapper around the REST service.
         Zend_Service_Nirvanix  aims to make using the Nirvanix REST service
            easier but understanding the service itself is still essential to be successful
            with Nirvanix.  
         
            The  Nirvanix API Documentation 
            provides an overview as well as detailed information using the
            service.  Please familiarize yourself with this document and refer back to it
            as you use  Zend_Service_Nirvanix .
         Features 
            Nirvanix&#39;s REST service can be used effectively with PHP using the 
             SimpleXML 
            extension and  Zend_Http_Client  alone. However, using it this way
            is somewhat inconvenient due to repetitive operations like passing the
            session token on every request and repeatedly checking the response body for
            error codes.  
         Zend_Service_Nirvanix  provides the following functionality:

             
                        A single point for configuring your Nirvanix authentication
                        credentials that can be used across the Nirvanix namespaces.
                     
                        A proxy object that is more convenient to use than an HTTP client
                        alone, mostly removing the need to manually construct HTTP POST
                        requests to access the REST service.
                     
                        A response wrapper that parses each response body and throws an
                        exception if an error occurred, alleviating the need to repeatedly 
                        check the success of many commands.
                     
                        Additional convenience methods for some of the more common operations.
                     
         Getting Started 
            Once you have registered with Nirvanix, you&#39;re ready to store your first
            file on the IMFS.  The most common operations that you will need to do 
            on the IMFS are creating a new file, downloading an existing file, and
            deleting a file.   Zend_Service_Nirvanix  provides convenience
            methods for these three operations.
         &lt;?php
require_once &#39;Zend/Service/Nirvanix.php&#39;;        

$auth = array(&#39;username&#39; =&gt; &#39;your-username&#39;,
              &#39;password&#39; =&gt; &#39;your-password&#39;,
              &#39;appKey&#39;   =&gt; &#39;your-app-key&#39;);

$nirvanix = new Zend_Service_Nirvanix($auth);
$imfs = $nirvanix-&gt;getService(&#39;IMFS&#39;);

$imfs-&gt;putContents(&#39;/foo.txt&#39;, &#39;contents to store&#39;);

echo $imfs-&gt;getContents(&#39;/foo.txt&#39;);

$imfs-&gt;unlink(&#39;/foo.txt&#39;);
         
            The first step to using  Zend_Service_Nirvanix  is always
            to authenticate against the service. This is done by passing your
            credentials to the  Zend_Service_Nirvanix  constructor
            above. The associative array is passed directly to Nirvanix as POST
            parameters.
         
            Nirvanix divides its web services into 
             namespaces .  
            Each namespace encapsulates a group of related operations. After getting
            an instance of  Zend_Service_Nirvanix , call the
             getService()  method to create a proxy for the namespace
            you want to use. Above, a proxy for the  IMFS  namespace is created.
         
            After you have a proxy for the namespace you want to use, call methods on it.
            The proxy will allow you to use any command available on the REST API.  The
            proxy may also make convenience methods available, which wrap web service
            commands.  The example above shows using the IMFS convenience methods to create a
            new file, retrieve and display that file, and finally delete the file.
         Understanding the Proxy 
            In the previous example, we used the  getService()  method to return
            a proxy object to the  IMFS  namespace.  The proxy object allows
            you to use the Nirvanix REST service in a way that&#39;s closer to making a normal
            PHP method call, as opposed to constructing your own HTTP request objects.
         
            A proxy object may provide convenience methods.  These are methods that the
             Zend_Service_Nirvanix  provides to simplify the use of 
            the Nirvanix web services.  In the previous example, the methods 
             putContents() ,  getContents() , and  unlink() 
            do not have direct equivalents in the REST API.  They are convenience methods 
            provided by  Zend_Service_Nirvanix  that abstract more complicated
            operations on the REST API.
         
            For all other method calls to the proxy object, the proxy will dynamically
            convert the method call to the equivalent HTTP POST request to the REST API.
            It does this by using the method name as the API command, and an associative
            array in the first argument as the POST parameters.  
         
            Let&#39;s say you want to call the REST API method 
             RenameFile ,
            which does not have a convenience method in  Zend_Service_Nirvanix :
         &lt;?php
require_once &#39;Zend/Service/Nirvanix.php&#39;;        

$auth = array(&#39;username&#39; =&gt; &#39;your-username&#39;,
              &#39;password&#39; =&gt; &#39;your-password&#39;,
              &#39;appKey&#39;   =&gt; &#39;your-app-key&#39;);

$nirvanix = new Zend_Service_Nirvanix($auth);
$imfs = $nirvanix-&gt;getService(&#39;IMFS&#39;);

$result = $imfs-&gt;renameFile(array(&#39;filePath&#39; =&gt; &#39;/path/to/foo.txt&#39;,
                                  &#39;newFileName&#39; =&gt; &#39;bar.txt&#39;));
         
            Above, a proxy for the  IMFS  namespace is created.  A method, 
             renameFile() , is then called on the proxy.  This method does not
            exist as a convenience method in the PHP code, so it is trapped by 
             __call()  and converted into a POST request to the REST API where
            the associative array is used as the POST parameters.
         
            Notice in the Nirvanix API documentation that  sessionToken  is required
            for this method but we did not give it to the proxy object.  It is added 
            automatically for your convenience.
         
            The result of this operation will either be a  Zend_Service_Nirvanix_Response 
            object wrapping the XML returned by Nirvanix, or a  Zend_Service_Nirvanix_Exception 
            if an error occurred.
         Examining Results 
            The Nirvanix REST API always returns its results in XML.   Zend_Service_Nirvanix 
            parses this XML with the  SimpleXML  extension and then decorates
            the resulting  SimpleXMLElement  with a  Zend_Service_Nirvanix_Response 
            object.  
         
            The simplest way to examine a result from the service is to use the
            built-in PHP functions like  print_r() :
         &lt;?php
require_once &#39;Zend/Service/Nirvanix.php&#39;;        

$auth = array(&#39;username&#39; =&gt; &#39;your-username&#39;,
              &#39;password&#39; =&gt; &#39;your-password&#39;,
              &#39;appKey&#39;   =&gt; &#39;your-app-key&#39;);

$nirvanix = new Zend_Service_Nirvanix($auth);
$imfs = $nirvanix-&gt;getService(&#39;IMFS&#39;);

$result = $imfs-&gt;putContents(&#39;/foo.txt&#39;, &#39;fourteen bytes&#39;);
print_r($result);
?&gt;


Zend_Service_Nirvanix_Response Object
(
    [_sxml:protected] =&gt; SimpleXMLElement Object
        (
            [ResponseCode] =&gt; 0
            [FilesUploaded] =&gt; 1
            [BytesUploaded] =&gt; 14
        ))
         
            You can access any property or method of the decorated  SimpleXMLElement .
            In the above example,  $result-&gt;BytesUploaded  could be used to see the
            number of bytes received.  Should you want to access the  SimpleXMLElement 
            directly, just use  $result-&gt;getSxml() .
         
            The most common response from Nirvanix is success ( ResponseCode  of zero).  
            It is not normally necessary to check  ResponseCode  because any non-zero
            result will throw a  Zend_Service_Nirvanix_Exception .  See the next
            section on handling errors.
         Handling Errors 
            When using Nirvanix, it&#39;s important to anticipate errors that can be returned 
            by the service and handle them appropriately.  
         
            All operations against the REST service result in an XML return payload that 
            contains a  ResponseCode  element, such as the following example:
         
&lt;Response&gt;
   &lt;ResponseCode&gt;0&lt;/ResponseCode&gt;
&lt;/Response&gt;
         
            When the  ResponseCode  is zero such as in the example
            above, the operation was successful. When the operation is not
            successful, the  ResponseCode  is non-zero and an
             ErrorMessage  element should be present.
         
            To alleviate the need to repeatedly check if the  ResponseCode 
            is non-zero,  Zend_Service_Nirvanix  automatically checks each response 
            returned by Nirvanix.  If the  ResponseCode  indicates an 
            error, a  Zend_Service_Nirvanix_Exception  will be thrown.
         &lt;?php
require_once &#39;Zend/Service/Nirvanix.php&#39;;        
        
$auth = array(&#39;username&#39; =&gt; &#39;your-username&#39;,
              &#39;password&#39; =&gt; &#39;your-password&#39;,
              &#39;appKey&#39;   =&gt; &#39;your-app-key&#39;);
$nirvanix = new Zend_Service_Nirvanix($auth);

try {

  $imfs = $nirvanix-&gt;getService(&#39;IMFS&#39;);
  $imfs-&gt;unlink(&#39;/a-nonexistant-path&#39;);

} catch (Zend_Service_Nirvanix_Exception $e) {
  echo $e-&gt;getMessage() . &quot;\n&quot;;
  echo $e-&gt;getCode();
}
         
            In the example above,  unlink()  is a convenience method that wraps the
             DeleteFiles  command on the REST API.  The  filePath  parameter required by the
             DeleteFiles 
            command contains a path that does not exist.  This will result in a 
             Zend_Service_Nirvanix  exception being thrown with the message
            &quot;Invalid path&quot; and code 70005.
         
            The  Nirvanix
            API Documentation  describes the errors associated with each command.  Depending
            on your needs, you may wrap each command in a  try  block or 
            wrap many commands in the same  try  block for convenience.  
         Zend_Service_Simpy Introduction Zend_Service_Simpy  is a lightweight wrapper for the free REST API available
            for the Simpy social bookmarking service.
         
            In order to use  Zend_Service_Simpy , you should already have a Simpy account.
            To get an account, visit the  Simpy web site . For more
            information on the Simpy REST API, refer to the
             Simpy REST API documentation .
         
            The Simpy REST API allows developers to interact with specific aspects of the service that
            the Simpy web site offers. The sections following will outline the use of
             Zend_Service_Simpy  for each of these areas.
             
                        Links: Create, Retrieve, Update, Delete
                     
                        Tags: Retrieve, Delete, Rename, Merge, Split
                     
                        Notes: Create, Retrieve, Update, Delete
                     
                        Watchlists: Get, Get All
                     
         Links 
            When querying links, results are returned in descending order by date added. Links can be
            searched by title, nickname, tags, note, or even the content of the web page associated
            with the link. Simpy offers searching by any or all of these fields with phrases, boolean
            operators, and wildcards. See the
             search syntax  and
             search fields 
            sections of the Simpy FAQ for more information.
         Querying Links &lt;?php
require_once &#39;Zend/Service/Simpy.php&#39;;
$simpy = new Zend_Service_Simpy(&#39;yourusername&#39;, &#39;yourpassword&#39;);

/* Search for the 10 links added most recently */
$linkQuery = new Zend_Service_Simpy_LinkQuery();
$linkQuery-&gt;setLimit(10);

/* Get and display the links */
$linkSet = $simpy-&gt;getLinks($linkQuery);
foreach ($linkSet as $link) {
    echo &#39;&lt;a href=&quot;&#39;;
    echo $link-&gt;getUrl();
    echo &#39;&quot;&gt;&#39;;
    echo $link-&gt;getTitle();
    echo &#39;&lt;/a&gt;&lt;br /&gt;&#39;;
}

/* Search for the 5 links added most recently with &#39;PHP&#39; in
the title */
$linkQuery-&gt;setQueryString(&#39;title:PHP&#39;);
$linkQuery-&gt;setLimit(5);

/* Search for all links with &#39;French&#39; in the title and
&#39;language&#39; in the tags */
$linkQuery-&gt;setQueryString(&#39;+title:French +tags:language&#39;);

/* Search for all links with &#39;French&#39; in the title and without
&#39;travel&#39; in the tags */
$linkQuery-&gt;setQueryString(&#39;+title:French -tags:travel&#39;);

/* Search for all links added on 12/9/06 */
$linkQuery-&gt;setDate(&#39;2006-12-09&#39;);

/* Search for all links added after 12/9/06 (excluding that
date) */
$linkQuery-&gt;setAfterDate(&#39;2006-12-09&#39;);

/* Search for all links added before 12/9/06 (excluding that
date) */
$linkQuery-&gt;setBeforeDate(&#39;2006-12-09&#39;);

/* Search for all links added between 12/1/06 and 12/9/06
(excluding those two dates) */
$linkQuery-&gt;setBeforeDate(&#39;2006-12-01&#39;);
$linkQuery-&gt;setAfterDate(&#39;2006-12-09&#39;);
             
            Links are represented uniquely by their URLs. In other words, if an attempt is made to save
            a link that has the same URL as an existing link, data for the existing link will be
            overwritten with the data specified in the save attempt.
         Modifying Links &lt;?php
require_once &#39;Zend/Service/Simpy.php&#39;;
$simpy = new Zend_Service_Simpy(&#39;yourusername&#39;, &#39;yourpassword&#39;);

/* Save a link */
$simpy-&gt;saveLink(
    &#39;Zend Framework&#39; // Title
    &#39;http://framework.zend.com&#39;, // URL
    Zend_Service_Simpy_Link::ACCESSTYPE_PUBLIC, // Access Type
    &#39;zend, framework, php&#39; // Tags
    &#39;Zend Framework home page&#39; // Alternative title
    &#39;This site rocks!&#39; // Note
);

/* Overwrite the existing link with new data */
$simpy-&gt;saveLink(
    &#39;Zend Framework&#39;
    &#39;http://framework.zend.com&#39;,
    Zend_Service_Simpy_Link::ACCESSTYPE_PRIVATE, // Access Type has changed
    &#39;php, zend, framework&#39; // Tags have changed order
    &#39;Zend Framework&#39; // Alternative title has changed
    &#39;This site REALLY rocks!&#39; // Note has changed
);

/* Delete the link */
$simpy-&gt;deleteLink(&#39;http://framework.zend.com&#39;);

/* A really easy way to do spring cleaning on your links ;) */
$linkSet = $this-&gt;_simpy-&gt;getLinks();
foreach ($linkSet as $link) {
    $this-&gt;_simpy-&gt;deleteLink($link-&gt;getUrl());
}
             Tags 
            When retrieved, tags are sorted in decreasing order (i.e. highest
            first) by the number of links that use the tag.
         Working With Tags &lt;?php
require_once &#39;Zend/Service/Simpy.php&#39;;
$simpy = new Zend_Service_Simpy(&#39;yourusername&#39;, &#39;yourpassword&#39;);

/* Save a link with tags */
$simpy-&gt;saveLink(
    &#39;Zend Framework&#39; // Title
    &#39;http://framework.zend.com&#39;, // URL
    Zend_Service_Simpy_Link::ACCESSTYPE_PUBLIC, // Access Type
    &#39;zend, framework, php&#39; // Tags
);

/* Get a list of all tags in use by links and notes */
$tagSet = $simpy-&gt;getTags();

/* Display each tag with the number of links using it */
foreach ($tagSet as $tag) {
    echo $tag-&gt;getTag();
    echo &#39; - &#39;;
    echo $tag-&gt;getCount();
    echo &#39;&lt;br /&gt;&#39;;
}

/* Remove the &#39;zend&#39; tag from all links using it */
$simpy-&gt;removeTag(&#39;zend&#39;);

/* Rename the &#39;framework&#39; tag to &#39;frameworks&#39; */
$simpy-&gt;renameTag(&#39;framework&#39;, &#39;frameworks&#39;);

/* Split the &#39;frameworks&#39; tag into &#39;framework&#39; and
&#39;development&#39;, which will remove the &#39;frameworks&#39; tag for
all links that use it and add the tags &#39;framework&#39; and
&#39;development&#39; to all of those links */
$simpy-&gt;splitTag(&#39;frameworks&#39;, &#39;framework&#39;, &#39;development&#39;);

/* Merge the &#39;framework&#39; and &#39;development&#39; tags back into
&#39;frameworks&#39;, basically doing the opposite of splitting them */
$simpy-&gt;mergeTags(&#39;framework&#39;, &#39;development&#39;, &#39;frameworks&#39;);
             Notes 
            Notes can be saved, retrieved, and deleted. They are uniquely
            identified by a numeric ID value.
         Working With Notes &lt;?php
require_once &#39;Zend/Service/Simpy.php&#39;;
$simpy = new Zend_Service_Simpy(&#39;yourusername&#39;, &#39;yourpassword&#39;);

/* Save a note */
$simpy-&gt;saveNote(
    &#39;Test Note&#39;, // Title
    &#39;test,note&#39;, // Tags
    &#39;This is a test note.&#39; // Description
);

/* Overwrite an existing note */
$simpy-&gt;saveNote(
    &#39;Updated Test Note&#39;, // Title
    &#39;test,note,updated&#39;, // Tags
    &#39;This is an updated test note.&#39;, // Description
    $note-&gt;getId() // Unique identifier
);

/* Search for the 10 most recently added notes */
$noteSet = $simpy-&gt;getNotes(null, 10);

/* Display the notes */
foreach ($noteSet as $note) {
    echo &#39;&lt;p&gt;&#39;;
    echo $note-&gt;getTitle();
    echo &#39;&lt;br /&gt;&#39;;
    echo $note-&gt;getDescription();
    echo &#39;&lt;br &gt;&#39;;
    echo $note-&gt;getTags();
    echo &#39;&lt;/p&gt;&#39;;
}

/* Search for all notes with &#39;PHP&#39; in the title */
$noteSet = $simpy-&gt;getNotes(&#39;title:PHP&#39;);

/* Search for all notes with &#39;PHP&#39; in the title and
without &#39;framework&#39; in the description */
$noteSet = $simpy-&gt;getNotes(&#39;+title:PHP -description:framework&#39;);

/* Delete a note */
$simpy-&gt;deleteNote($note-&gt;getId());
             Watchlists 
            Watchlists cannot be created or removed using the API, only
            retrieved. Thus, you must set up a watchlist via the Simpy web
            site prior to attempting to access it using the API.
         Retrieving Watchlists &lt;?php
require_once &#39;Zend/Service/Simpy.php&#39;;
$simpy = new Zend_Service_Simpy(&#39;yourusername&#39;, &#39;yourpassword&#39;);

/* Get a list of all watchlists */
$watchlistSet = $simpy-&gt;getWatchlists();

/* Display data for each watchlist */
foreach ($watchlistSet as $watchlist) {
    echo $watchlist-&gt;getId();
    echo &#39;&lt;br /&gt;&#39;;
    echo $watchlist-&gt;getName();
    echo &#39;&lt;br /&gt;&#39;;
    echo $watchlist-&gt;getDescription();
    echo &#39;&lt;br /&gt;&#39;;
    echo $watchlist-&gt;getAddDate();
    echo &#39;&lt;br /&gt;&#39;;
    echo $watchlist-&gt;getNewLinks();
    echo &#39;&lt;br /&gt;&#39;;

    foreach ($watchlist-&gt;getUsers() as $user) {
        echo $user;
        echo &#39;&lt;br /&gt;&#39;;
    }

    foreach ($watchlist-&gt;getFilters() as $filter) {
        echo $filter-&gt;getName();
        echo &#39;&lt;br /&gt;&#39;;
        echo $filter-&gt;getQuery();
        echo &#39;&lt;br /&gt;&#39;;
    }
}

/* Get an individual watchlist by its identifier */
$watchlist = $simpy-&gt;getWatchlist($watchlist-&gt;getId());
$watchlist = $simpy-&gt;getWatchlist(1);
             Introduction 
        The  Zend_Service_SlideShare  component is used to interact with the
         slideshare.net  web services for hosting
        slide shows online. With this component, you can embed slide shows which are hosted on this
        web site within a web site and even upload new slide shows to your account.
     Getting Started with  Zend_Service_SlideShare 
            In order to use the Zend_Service_SlideShare component you must first create an account
            on the slideshare.net servers (more information can be found
             here ) in order to receive an
            API key, username, password and shared secret value -- all of which are needed in order
            to use the  Zend_Service_SlideShare  component.
         
            Once you have setup an account, you can begin using the
             Zend_Service_SlideShare  component by creating a new instance of the
             Zend_Service_SlideShare  object and providing these values as shown below:
         &lt;?php
require_once &#39;Zend/Service/SlideShare.php&#39;;

// Create a new instance of the component
$ss = new Zend_Service_SlideShare(&#39;APIKEY&#39;, &#39;SHAREDSECRET&#39;, &#39;USERNAME&#39;, &#39;PASSWORD&#39;);
?&gt;
         The SlideShow object 
            All slide shows in the  Zend_Service_SlideShare  component are represented
            using the  Zend_Service_SlideShare_SlideShow  object (both when retrieving
            and uploading new	slide shows). For your reference a pesudo-code version of this class
            is provided below.
         &lt;?php
class Zend_Service_SlideShare_SlideShow {

    /**
     * Retrieves the location of the slide show
     */
    public function getLocation() {
        return $this-&gt;_location;
    }

    /**
     * Gets the transcript for this slide show
     */
    public function getTranscript() {
        return $this-&gt;_transcript;
    }

    /**
     * Adds a tag to the slide show
     */
    public function addTag($tag) {
        $this-&gt;_tags[] = (string)$tag;
        return $this;
    }

    /**
     * Sets the tags for the slide show
     */
    public function setTags(Array $tags) {
        $this-&gt;_tags = $tags;
        return $this;
    }

    /**
     * Gets all of the tags associated with the slide show
     */
    public function getTags() {
        return $this-&gt;_tags;
    }

    /**
     * Sets the filename on the local filesystem of the slide show
     * (for uploading a new slide show)
     */
    public function setFilename($file) {
        $this-&gt;_slideShowFilename = (string)$file;
        return $this;
    }

    /**
     * Retrieves the filename on the local filesystem of the slide show
     * which will be uploaded
     */
    public function getFilename() {
        return $this-&gt;_slideShowFilename;
    }

    /**
     * Gets the ID for the slide show
     */
    public function getId() {
        return $this-&gt;_slideShowId;
    }

    /**
     * Retrieves the HTML embed code for the slide show
     */
    public function getEmbedCode() {
        return $this-&gt;_embedCode;
    }

    /**
     * Retrieves the Thumbnail URi for the slide show
     */
    public function getThumbnailUrl() {
        return $this-&gt;_thumbnailUrl;
    }

    /**
     * Sets the title for the Slide show
     */
    public function setTitle($title) {
        $this-&gt;_title = (string)$title;
        return $this;
    }

    /**
     * Retrieves the Slide show title
     */
    public function getTitle() {
        return $this-&gt;_title;
    }

    /**
     * Sets the description for the Slide show
     */
    public function setDescription($desc) {
        $this-&gt;_description = (string)$desc;
        return $this;
    }

    /**
     * Gets the description of the slide show
     */
    public function getDescription() {
        return $this-&gt;_description;
    }

    /**
     * Gets the numeric status of the slide show on the server
     */
    public function getStatus() {
        return $this-&gt;_status;
    }

    /**
     * Gets the textual description of the status of the slide show on the server
     */
    public function getStatusDescription() {
        return $this-&gt;_statusDescription;
    }

    /**
     * Gets the permanent link of the slide show
     */
    public function getPermaLink() {
        return $this-&gt;_permalink;
    }

    /**
     * Gets the number of views the slide show has received
     */
    public function getNumViews() {
        return $this-&gt;_numViews;
    }
}
         
                The above pseudo-class only shows those methods which should be used by end-user
                developers. Other available methods are internal to the component.
             
            When using the  Zend_Service_SlideShare  component, this data class will be
            used frequently to browse or add new slide shows to or from the web service.
         Retrieving a single slide show 
            The simplest usage of the  Zend_Service_SlideShare  component is the
            retrieval of a single slide show by slide show ID provided by the slideshare.net
            application and is done by calling the  getSlideShow()  method of a
             Zend_Service_SlideShare  object and using the resulting
             Zend_Service_SlideShare_SlideShow  object as shown.
         &lt;?php
require_once &#39;Zend/Service/SlideShare.php&#39;;

// Create a new instance of the component
$ss = new Zend_Service_SlideShare(&#39;APIKEY&#39;, &#39;SHAREDSECRET&#39;, &#39;USERNAME&#39;, &#39;PASSWORD&#39;);

$slideshow = $ss-&gt;getSlideShow(123456);

print &quot;Slide Show Title: {$slideshow-&gt;getTitle()}&lt;br/&gt;\n&quot;;
print &quot;Number of views: {$slideshow-&gt;getNumViews()}&lt;br/&gt;\n&quot;;
?&gt;
         Retrieving Groups of Slide Shows 
            If you do not know the specific ID of a slide show you are interested in retrieving,
            you can retrieving groups of slide shows by using one of three methods:
         Slide shows from a specific account 
                    You can retrieve slide shows from a specific account by using the
                     getSlideShowsByUsername()  method and providing the username from
                    which the slide shows should be retrieved
                 Slide shows which contain specific tags 
                    You can retrieve slide shows which contain one or more specific tags by using
                    the  getSlideShowsByTag  method and providing one or more tags which
                    the slide show must have assigned to it in order to be retrieved
                 Slide shows by group 
                    You can retrieve slide shows which are a member of a specific group using the
                     getSlideShowsByGroup  method and providng the name of the group
                    which the slide show must belong to in order to be retrieved
                 
            Each of the above methods of retrieving multiple slide shows a similar approach is
            used. An example of using each method is shown below:
         &lt;?php
require_once &#39;Zend/Service/SlideShare.php&#39;;

// Create a new instance of the component
$ss = new Zend_Service_SlideShare(&#39;APIKEY&#39;, &#39;SHAREDSECRET&#39;, &#39;USERNAME&#39;, &#39;PASSWORD&#39;);

$starting_offset = 0;
$limit = 10;

// Retrieve the first 10 of each type
$ss_user = $ss-&gt;getSlideShowsByUser(&#39;username&#39;, $starting_offset, $limit);
$ss_tags = $ss-&gt;getSlideShowsByTag(&#39;zend&#39;, $starting_offset, $limit);
$ss_group = $ss-&gt;getSlideShowsByGroup(&#39;mygroup&#39;, $starting_offset, $limit);

// Iterate over the slide shows
foreach($ss_user as $slideshow) {
   print &quot;Slide Show Title: {$slideshow-&gt;getTitle}&lt;br/&gt;\n&quot;;
}
?&gt;
         Zend_Service_SlideShare  Caching policies 
            By default,  Zend_Service_SlideShare  will cache any request against the web
            service automatically to the filesystem (default path  /tmp ) for 12 hours.
            If you desire to change this behavior, you must provide your own
              object using the  setCacheObject  method as
            shown:
         &lt;?php
require_once &#39;Zend/Cache.php&#39;;
require_once &#39;Zend/Service/SlideShare.php&#39;;

$frontendOptions = array(
                        &#39;lifetime&#39; =&gt; 7200,
                        &#39;automatic_serialization&#39; =&gt; true);
$backendOptions  = array(
                        &#39;cache_dir&#39; =&gt; &#39;/webtmp/&#39;);

$cache = Zend_Cache::factory(&#39;Core&#39;, &#39;File&#39;, $frontendOptions, $backendOptions);

$ss = new Zend_Service_SlideShare(&#39;APIKEY&#39;, &#39;SHAREDSECRET&#39;, &#39;USERNAME&#39;, &#39;PASSWORD&#39;);
$ss-&gt;setCacheObject($cache);

$ss_user = $ss-&gt;getSlideShowsByUser(&#39;username&#39;, $starting_offset, $limit);
?&gt;
         Changing the behavior of the HTTP Client 
            If for whatever reason you would like to change the behavior of the HTTP client when
            making the web service request, you can do so by creating your own instance of the
             Zend_Http_Client  object (see  ). This is useful
            for instance when it is desirable to set the timeout for the connection to something
            other then default as shown:
         &lt;?php
require_once &#39;Zend/Http/Client.php&#39;;

$client = new Zend_Http_Client();
$client-&gt;setConfig(array(&#39;timeout&#39; =&gt; 5));

$ss = new Zend_Service_SlideShare(&#39;APIKEY&#39;, &#39;SHAREDSECRET&#39;, &#39;USERNAME&#39;, &#39;PASSWORD&#39;);
$ss-&gt;setHttpClient($client);
$ss_user = $ss-&gt;getSlideShowsByUser(&#39;username&#39;, $starting_offset, $limit);
?&gt;
         Zend_Service_StrikeIron: Advanced Uses 
      This section describes the more advanced uses of Zend_Service_StrikeIron.
     Using Services by WSDL 
        Some StrikeIron services may have a PHP wrapper class available,
        such as those described in
         Bundled Services .
        However, StrikeIron offers hundreds of services and many of these
        may be usable even without creating a special wrapper class.
       
        To try a StrikeIron service that does not have a wrapper class available,
        give the  wsdl  option to  getService() 
        instead of the  class  option:

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

// Get a generic client to the Reverse Phone Lookup service
$phone = $strikeIron-&gt;getService(array(&#39;wsdl&#39; =&gt; &#39;http://ws.strikeiron.com/ReversePhoneLookup?WSDL&#39;));

$result = $phone-&gt;lookup(array(&#39;Number&#39; =&gt; &#39;(408) 253-8800&#39;));
echo $result-&gt;listingName;

// Zend Technologies USA Inc
         
       
        Using StrikeIron services from the WSDL will require at least some understanding
        of the WSDL files.  StrikeIron has many resources on its site to help with this.
        Also,
         Jan Schneider  from the
         Horde project  has written a
         small PHP routine  that
        will format a WSDL file into more readable HTML.
       
        Please note that only the services
        described in the  Bundled Services 
        section are officially supported.
       Viewing SOAP Transactions 
        All communication with StrikeIron is done using the SOAP extension.  It
        is sometimes useful to view the XML exchanged with StrikeIron for debug
        purposes.
       
        Every StrikeIron client (subclass of  Zend_Service_StrikeIron_Base )
        contains a  getSoapClient()  method to return the underlying instance of
         SOAPClient  used to communicate with StrikeIron.
       
        PHP&#39;s
         SOAPClient 
        has a  trace  option that causes it to remember the XML exchanged during the last transaction.
        Zend_Service_StrikeIron does not enable the  trace  option by default but this
        can easily by changed by specifying the options that will be passed to the  SOAPClient  constructor.
       
        To view a SOAP transaction, call the  getSoapClient()  method
        to get the  SOAPClient  instance and then call the appropriate
        methods like
         __getLastRequest() 
        and
         __getLastRequest() :

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;,
                                                &#39;options&#39;  =&gt; array(&#39;trace&#39; =&gt; true)));

// Get a client for the Sales &amp; Use Tax Basic service
$taxBasic = $strikeIron-&gt;getService(array(&#39;class&#39; =&gt; &#39;SalesUseTaxBasic&#39;));

// Perform a method call
$taxBasic-&gt;getTaxRateCanada(array(&#39;province&#39; =&gt; &#39;ontario&#39;));

// Get SOAPClient instance and view XML
$soapClient = $taxBasic-&gt;getSoapClient();
echo $soapClient-&gt;__getLastRequest();
echo $soapClient-&gt;__getLastResponse();
         
       Zend_Service_StrikeIron: Bundled Services 
      Zend_Service_StrikeIron comes with wrapper classes for three popular StrikeIron services.
     ZIP Code Information Zend_Service_StrikeIron_ZipCodeInfo  provides a client for StrikeIron&#39;s
        Zip Code Information Service.  For more information on this service, visit these
        StrikeIron resources:

         Zip Code Information Service Page Zip Code Information Service WSDL 

        The service contains a  getZipCode()  method that will retrieve information
        about a United States ZIP code or Canadian postal code:

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

// Get a client for the Zip Code Information service
$zipInfo = $strikeIron-&gt;getService(array(&#39;class&#39; =&gt; &#39;ZipCodeInfo&#39;));

// Get the Zip information for 95014
$response = $zipInfo-&gt;getZipCode(array(&#39;ZipCode&#39; =&gt; 95014));
$zips = $response-&gt;serviceResult;

// Display the results
if ($zips-&gt;count == 0) {
    echo &#39;No results found&#39;;
} else {
    // a result with one single zip code is returned as an object,
    // not an array with one element as one might expect.
    if (! is_array($zips-&gt;zipCodes)) {
        $zips-&gt;zipCodes = array($zips-&gt;zipCodes);
    }

    // print all of the possible results
    foreach ($zips-&gt;zipCodes as $z) {
        $info = $z-&gt;zipCodeInfo;

        // show all properties
        print_r($info);

        // or just the city name
        echo $info-&gt;preferredCityName;
    }
}

// Detailed status information
// http://www.strikeiron.com/exampledata/StrikeIronZipCodeInformation_v3.pdf
$status = $response-&gt;serviceStatus;
         
       U.S. Address Verification Zend_Service_StrikeIron_USAddressVerification  provides a client for
        StrikeIron&#39;s U.S. Address Verification Service.  For more information on this
        service, visit these StrikeIron resources:

         U.S. Address Verification Service Page U.S. Address Verification Service WSDL 
       
        The service contains a  verifyAddressUSA()  method that will verify
        an address in the United States:

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

// Get a client for the Zip Code Information service
$verifier = $strikeIron-&gt;getService(array(&#39;class&#39; =&gt; &#39;USAddressVerification&#39;));

// Address to verify.  Not all fields are required but
// supply as many as possible for the best results.
$address = array(&#39;firm&#39;           =&gt; &#39;Zend Technologies&#39;,
                 &#39;addressLine1&#39;   =&gt; &#39;19200 Stevens Creek Blvd&#39;,
                 &#39;addressLine2&#39;   =&gt; &#39;&#39;,
                 &#39;city_state_zip&#39; =&gt; &#39;Cupertino CA 95014&#39;);

// Verify the address
$result = $verifier-&gt;verifyAddressUSA($address);

// Display the results
if ($result-&gt;addressErrorNumber != 0) {
    echo $result-&gt;addressErrorNumber;
    echo $result-&gt;addressErrorMessage;
} else {
    // show all properties
    print_r($result);

    // or just the firm name
    echo $result-&gt;firm;

    // valid address?
    $valid = ($result-&gt;valid == &#39;VALID&#39;);
}
         
       Sales &amp; Use Tax Basic Zend_Service_StrikeIron_SalesUseTaxBasic  provides a client for
        StrikeIron&#39;s Sales &amp; Use Tax Basic service.  For more information on this
        service, visit these StrikeIron resources:

         Sales &amp; Use Tax Basic Service Page Sales &amp; Use Tax Basic Service WSDL 
       
        The service contains two methods,  getTaxRateUSA()  and  getTaxRateCanada() ,
        that will retrieve sales and use tax data for the United States and Canada, respectively.

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

// Get a client for the Sales &amp; Use Tax Basic service
$taxBasic = $strikeIron-&gt;getService(array(&#39;class&#39; =&gt; &#39;SalesUseTaxBasic&#39;));

// Query tax rate for Ontario, Canada
$rateInfo = $taxBasic-&gt;getTaxRateCanada(array(&#39;province&#39; =&gt; &#39;foo&#39;));
print_r($rateInfo);               // show all properties
echo $rateInfo-&gt;GST;              // or just the GST (Goods &amp; Services Tax)

// Query tax rate for Cupertino, CA USA
$rateInfo = $taxBasic-&gt;getTaxRateUS(array(&#39;zip_code&#39; =&gt; 95014));
print_r($rateInfo);               // show all properties
echo $rateInfo-&gt;state_sales_tax;  // or just the state sales tax
         
       Zend_Service_StrikeIron 
        Zend_Service_StrikeIron provides a PHP 5 client to StrikeIron
        web services.  See the following sections:
     Overview StrikeIron 
          offers hundreds of commercial data services (&quot;Data as a Service&quot;)
          such as Online Sales Tax, Currency Rates, Stock Quotes, Geocodes, Global
          Address Verification, Yellow/White Pages, MapQuest Driving Directions,
          Dun &amp; Bradstreet Business Credit Checks, and much, much more.
         
          Each StrikeIron web service service shares a standard SOAP (and REST)
          API, making it easy to integrate and manage multiple services.
          StrikeIron also manages customer billing for all services in a single
          account, making it perfect for solution providers. Get
          started with free web services at
           http://www.strikeiron.com/sdp .
         
          StrikeIron&#39;s services may be used through the
           PHP 5 SOAP extension  alone.
          However, using StrikeIron this way does not give an ideal PHP-like interface.
          The Zend_Service_StrikeIron component provides a lightweight layer on
          top of the SOAP extension for working with StrikeIron services in a
          more convenient, PHP-like manner.
         
            The PHP 5 SOAP extension must be installed and enabled to use
            Zend_Service_StrikeIron.
           
          The Zend_Service_StrikeIron component provides:

           
                A single point for configuring your StrikeIron authentication credentials
                that can be used across many StrikeIron services.
               
                A standard way of retrieving your StrikeIron subscription information
                such as license status and the number of hits remaining to a service.
               
                The ability to use any StrikeIron service from its WSDL without
                creating a PHP wrapper class, and the option of creating a wrapper for
                a more convenient interface.
               
                Wrappers for three popular StrikeIron services.
               
         Registering with StrikeIron 
        Before you can get started with Zend_Service_StrikeIron, you must first
         register  for a
        StrikeIron developer account.
       
        After registering, you will receive a StrikeIron username and password.
        These will be used when connecting to StrikeIron using Zend_Service_StrikeIron.
       
        You will also need to  sign up 
        for StrikeIron&#39;s Super Data Pack Web Service.
       
        Both registration steps are free and can be done relatively quickly through
        the StrikeIron website.
       Getting Started 
        Once you have  registered 
        for a StrikeIron account and signed up for the
         Super Data Pack ,
        you&#39;re ready to start using Zend_Service_StrikeIron.
       
        StrikeIron consists of hundreds of different web services.
        Zend_Service_StrikeIron can be used with many of these services but provides supported
        wrappers for three of them:
       ZIP Code Information US Address Verification Sales &amp; Use Tax Basic 
        The class  Zend_Service_StrikeIron  provides a simple way
        of specifying your StrikeIron account information and other options in
        its constructor. It also has a factory method that will return clients
        for StrikeIron services:

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

$taxBasic = $strikeIron-&gt;getService(array(&#39;class&#39; =&gt; &#39;SalesUseTaxBasic&#39;));
         
       
        The  getService()  method will return a client for any
        StrikeIron service by the name of its PHP wrapper class. In this case,
        the name  SalesUseTaxBasic  refers to the wrapper class
         Zend_Service_StrikeIron_SalesUseTaxBasic . Wrappers are
        included for three services and described in
         Bundled Services .
       
        The  getService()  method can also return a client for
        a StrikeIron service that does not yet have a PHP wrapper.  This is
        explained in
         Using Services by WSDL .
       Making Your First Query 
        Once you have used the  getService()  method to get a client
        for a particular StrikeIron service, you can utilize that client
        by calling methods on it just like any other PHP object.

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

// Get a client for the Sales &amp; Use Tax Basic service
$taxBasic = $strikeIron-&gt;getService(array(&#39;class&#39; =&gt; &#39;SalesUseTaxBasic&#39;));

// Query tax rate for Ontario, Canada
$rateInfo = $taxBasic-&gt;getTaxRateCanada(array(&#39;province&#39; =&gt; &#39;ontario&#39;));
echo $rateInfo-&gt;province;
echo $rateInfo-&gt;abbreviation;
echo $rateInfo-&gt;GST;
         

        In the example above, the  getService()  method is used
        to return a client to the
         Sales &amp; Use Tax Basic  service.
        The client object is stored in  $taxBasic .
       
        The  getTaxRateCanada()  method is then called on the
        service. An associative array is used to supply keyword parameters to
        the method. This is the way that all StrikeIron methods are called.
       
        The result from  getTaxRateCanada()  is stored in
         $rateInfo  and has properties like  province 
        and  GST .
       
        Many of the StrikeIron services are as simple to use as the example above.  See
         Bundled Services 
        for detailed information on three StrikeIron services.
       Examining Results 
        When learning or debugging the StrikeIron services, it&#39;s often useful to dump the
        result returned from a method call.  The result will always be an object that is an
        instance of  Zend_Service_StrikeIron_Decorator .  This is a
        small  decorator 
        object that wraps the results from the method call.
       
        The simplest way to examine a result from the service is to use the built-in
        PHP functions like  print_r() :

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

$taxBasic = $strikeIron-&gt;getService(array(&#39;class&#39; =&gt; &#39;SalesUseTaxBasic&#39;));

$rateInfo = $taxBasic-&gt;getTaxRateCanada(array(&#39;province&#39; =&gt; &#39;ontario&#39;));
print_r($rateInfo);
?&gt;


Zend_Service_StrikeIron_Decorator Object
(
    [_name:protected] =&gt; GetTaxRateCanadaResult
    [_object:protected] =&gt; stdClass Object
        (
            [abbreviation] =&gt; ON
            [province] =&gt; ONTARIO
            [GST] =&gt; 0.06
            [PST] =&gt; 0.08
            [total] =&gt; 0.14
            [HST] =&gt; Y
        )
)
         
       
        In the output above, we see that the decorator ( $rateInfo ) wraps an object
        named  GetTaxRateCanadaResult , the result of the call to  getTaxRateCanada() .
       
        This means that  $rateInfo  has public properties like  abbreviation ,
         province , and  GST .  These are accessed like  $rateInfo-&gt;province .
       
          StrikeIron result properties sometimes start with an uppercase
          letter such as  Foo  or  Bar  where most PHP object
          properties normally start with a lowercase letter as in  foo  or
           bar . The decorator will automatically do this inflection so you
          may read a property  Foo  as  foo .
         
        If you ever need to get the original object or its name out of the decorator, use the
        respective methods  getDecoratedObject()  and  getDecoratedObjectName() .
       Handling Errors 
        The previous examples are naive, i.e. no error handling was shown.
        It&#39;s possible that StrikeIron will return a fault during a method
        call. Events like bad account credentials or an expired subscription
        can cause StrikeIron to raise a fault.
       
        An exception will be thrown when such a fault occurs. You should
        anticipate and catch these exceptions when making method calls to the
        service:

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

$taxBasic = $strikeIron-&gt;getService(array(&#39;class&#39; =&gt; &#39;SalesUseTaxBasic&#39;));

try {

  $taxBasic-&gt;getTaxRateCanada(array(&#39;province&#39; =&gt; &#39;ontario&#39;));

} catch (Zend_Service_StrikeIron_Exception $e) {

  // error handling for events like connection
  // problems or subscription errors

}
         
        The exceptions thrown will always be  Zend_Service_StrikeIron_Exception .
       
        It&#39;s important to understand the difference between exceptions and
        normal failed method calls. Exceptions occur for
         exceptional  conditions, such as
        the network going down or your subscription expiring.
        Failed method calls that are a common occurrence,
        such as  getTaxRateCanada()  not finding the
         province  you supplied, will not result an in exception.
       
          Every time you make a method call to a StrikeIron service, you
          should check the response object for validity and also be
          prepared to catch an exception.
         Checking Your Subscription 
        StrikeIron provides many different services.  Some of these are
        free, some are available on a trial basis, and some are pay subscription only.
        When using StrikeIron, it&#39;s important to be aware of your subscription
        status for the services you are using and check it regularly.
       
        Each StrikeIron client returned by the  getService  method
        has the ability to check the subscription status for that service using
        the  getSubscriptionInfo()  method of the client:

         &lt;?php
require_once &#39;Zend/Service/StrikeIron.php&#39;;

// Get a client for the Sales &amp; Use Tax Basic service
$strikeIron = new Zend_Service_StrikeIron(array(&#39;username&#39; =&gt; &#39;your-username&#39;,
                                                &#39;password&#39; =&gt; &#39;your-password&#39;));

$taxBasic = $strikeIron-&gt;getService(array(&#39;class =&gt; &#39;SalesUseTaxBasic&#39;));

// Check remaining hits for the Sales &amp; Use Tax Basic service
$subscription = $taxBasic-&gt;getSubscriptionInfo();
echo $subscription-&gt;remainingHits;
         
       
        The  getSubscriptionInfo()  method will return an object
        that typically has a  remainingHits  property.  It&#39;s
        important to check the status on each service that you are using.  If
        a method call is made to StrikeIron after the remaining hits have been
        used up, an exception will occur.
       
        Checking your subscription to a service does not use any remaining
        hits to the service.  Each time any method call to the service is made,
        the number of hits remaining will be cached and this cached value will
        be returned by  getSubscriptionInfo()  without connecting
        to the service again.  To force  getSubscriptionInfo() 
        to override its cache and query the subscription information again, use
         getSubscriptionInfo(true) .
       Zend_Service_Technorati Introduction Zend_Service_Technorati  provides an easy, intuitive and object-oriented interface for using
            the Technorati API. It provides access to all available
             Technorati API queries 
            and returns the original XML response as a friendly PHP object.
         Technorati  is one of the most popular blog search engines.
            The API interface enables developers to retrieve information about a specific blog, search blogs matching a
            single tag or phrase and get information about a specific author (blogger). For a full list of available
            queries please see the
             Technorati API documentation 
            or the  Available Technorati queries  section of this
            document.
         Getting Started 
            Technorati requires a valid API key for usage. To get your own API Key you first need to
             create a new Technorati account , then visit the
             API Key section .
         API Key limits 
                You can make up to 500 Technorati API calls per day, at no charge.
                Other usage limitations may apply, depending on the current Technorati API license.
             
            Once you have a valid API key, you&#39;re ready to start using  Zend_Service_Technorati .
         Making Your First Query 
            In order to run a query, first you need a  Zend_Service_Technorati  instance with a valid API
            key. Then choose one of the available query methods, and call it providing required arguments.
         Sending your first query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

// create a new Zend_Service_Technorati
// with a valid API_KEY
$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);

// search Technorati for PHP keyword
$resultSet = $technorati-&gt;search(&#39;PHP&#39;);

             
            Each query method accepts an array of optional parameters that can be used to refine your query.
         Refining your query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

// create a new Zend_Service_Technorati
// with a valid API_KEY
$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);

// filter your query including only results
// with some authority (Results from blogs with a handful of links)
$options = array(&#39;authority&#39; =&gt; &#39;a4&#39;);

// search Technorati for PHP keyword
$resultSet = $technorati-&gt;search(&#39;PHP&#39;, $options);

             
            A  Zend_Service_Technorati  instance is not a single-use object. That is, you don&#39;t need to
            create a new instance for each query call; simply use your current  Zend_Service_Technorati 
            object as long as you need it.
         Sending multiple queries with the same  Zend_Service_Technorati  instance &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

// create a new Zend_Service_Technorati
// with a valid API_KEY
$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);

// search Technorati for PHP keyword
$search = $technorati-&gt;search(&#39;PHP&#39;);

// get top tags indexed by Technorati
$topTags = $technorati-&gt;topTags();

             Consuming Results 
            You can get one of two types of result object in response to a query.
         
            The first group is represented by  Zend_Service_Technorati_*ResultSet  objects. A result set
            object is basically a collection of result objects. It extends the basic
             Zend_Service_Technorati_ResultSet  class and implements the  SeekableIterator  PHP
            interface. The best way to consume a result set object is to loop over it with the PHP  foreach 
            statement.
         Consuming a result set object &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

// create a new Zend_Service_Technorati
// with a valid API_KEY
$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);

// search Technorati for PHP keyword
// $resultSet is an instance of Zend_Service_Technorati_SearchResultSet
$resultSet = $technorati-&gt;search(&#39;PHP&#39;);

// loop over all result objects
foreach ($resultSet as $result) {
    // $result is an instance of Zend_Service_Technorati_SearchResult
} 
             
            Because  Zend_Service_Technorati_ResultSet  implements the  SeekableIterator 
            interface, you can seek a specific result object using its position in the result collection.
         Seeking a specific result set object &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

// create a new Zend_Service_Technorati
// with a valid API_KEY
$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);

// search Technorati for PHP keyword
// $resultSet is an instance of Zend_Service_Technorati_SearchResultSet
$resultSet = $technorati-&gt;search(&#39;PHP&#39;);

// $result is an instance of Zend_Service_Technorati_SearchResult
$resultSet-&gt;seek(1);
$result = $resultSet-&gt;current();

             SeekableIterator  works as an array and counts positions starting from index 0. Fetching
                position number 1 means getting the second result in the collection.
             
            The second group is represented by special standalone result objects.
             Zend_Service_Technorati_GetInfoResult ,  Zend_Service_Technorati_BlogInfoResult  and
             Zend_Service_Technorati_KeyInfoResult  act as wrappers for additional objects, such as
             Zend_Service_Technorati_Author  and  Zend_Service_Technorati_Weblog .
         Consuming a standalone result object &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

// create a new Zend_Service_Technorati
// with a valid API_KEY
$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);

// get info about weppos author
$result = $technorati-&gt;getInfo(&#39;weppos&#39;);

$author = $result-&gt;getAuthor();
echo &quot;&lt;h2&gt;Blogs authored by &quot; . $author-&gt;getFirstName() . &quot; &quot; . $author-&gt;getLastName() . &quot;&lt;/h2&gt;&quot;;
echo &quot;&lt;ol&gt;&quot;;
foreach ($result-&gt;getWeblogs() as $weblog) {
    echo &quot;&lt;li&gt;&quot; . $weblog-&gt;getName() . &quot;&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ol&gt;&quot;;

             
            Please read the  Zend_Service_Technorati Classes 
            section for further details about response classes.
         Handling Errors 
            Each  Zend_Service_Technorati  query method throws a
             Zend_Service_Technorati_Exception  exception on failure with a meaningful error message.
         
            There are several reasons that may cause a  Zend_Service_Technorati  query to fail.
             Zend_Service_Technorati  validates all parameters for any query request. If a parameter is
            invalid or it contains an invalid value, a new  Zend_Service_Technorati_Exception  exception is
            thrown. Additionally, the Technorati API interface could be temporally unavailable, or it could return a
            response that is not well formed.
         
            You should always wrap a Technorati query with a  try ... catch  block.
         Handling a Query Exception &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
try {
    $resultSet = $technorati-&gt;search(&#39;PHP&#39;);
} catch(Zend_Service_Technorati_Exception $e) {
    echo &quot;An error occurred: &quot; $e-&gt;getMessage();
} 
             Checking Your API Key Daily Usage 
            From time to time you probably will want to check your API key daily usage. By default Technorati limits
            your API usage to 500 calls per day, and an exception is returned by  Zend_Service_Technorati 
            if you try to use it beyond this limit. You can get information about your API key usage using the
             Zend_Service_Technorati::keyInfo()  method.
         Zend_Service_Technorati::keyInfo()  returns a
             Zend_Service_Technorati_KeyInfoResult  object. For full details please see the
             API reference guide .
         Getting API key daily usage information &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$key = $technorati-&gt;keyInfo();

echo &quot;API Key: &quot; . $key-&gt;getApiKey() . &quot;&lt;br /&gt;&quot;;
echo &quot;Daily Usage: &quot; . $key-&gt;getApiQueries() . &quot;/&quot; . $key-&gt;getMaxQueries() . &quot;&lt;br /&gt;&quot;;

             Available Technorati Queries Zend_Service_Technorati  provides support for the following queries:
             Cosmos Search Tag DailyCounts TopTags BlogInfo BlogPostTags GetInfo 
         Technorati Cosmos Cosmos  query lets you see what
                blogs are linking to a given URL. It returns a
                 Zend_Service_Technorati_CosmosResultSet 
                object. For full details please see  Zend_Service_Technorati::cosmos()  in the
                 API reference guide .
             Cosmos Query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$resultSet = $technorati-&gt;cosmos(&#39;http://devzone.zend.com/&#39;);

echo &quot;&lt;p&gt;Reading &quot; . $resultSet-&gt;totalResults() .
     &quot; of &quot; . $resultSet-&gt;totalResultsAvailable() . &quot; available results&lt;/p&gt;&quot;;
echo &quot;&lt;ol&gt;&quot;;
foreach ($resultSet as $result) {
    echo &quot;&lt;li&gt;&quot; . $result-&gt;getWeblog()-&gt;getName() . &quot;&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ol&gt;&quot;;

                 Technorati Search 
                The  Search  query lets you see
                what blogs contain a given search string. It returns a
                 Zend_Service_Technorati_SearchResultSet 
                object. For full details please see  Zend_Service_Technorati::search()  in the
                 API reference guide .
             Search Query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$resultSet = $technorati-&gt;search(&#39;zend framework&#39;);

echo &quot;&lt;p&gt;Reading &quot; . $resultSet-&gt;totalResults() .
     &quot; of &quot; . $resultSet-&gt;totalResultsAvailable() . &quot; available results&lt;/p&gt;&quot;;
echo &quot;&lt;ol&gt;&quot;;
foreach ($resultSet as $result) {
    echo &quot;&lt;li&gt;&quot; . $result-&gt;getWeblog()-&gt;getName() . &quot;&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ol&gt;&quot;;

                 Technorati Tag 
                The  Tag  query lets you see what
                posts are associated with a given tag. It returns a
                 Zend_Service_Technorati_TagResultSet 
                object. For full details please see  Zend_Service_Technorati::tag()  in the
                 API reference guide .
             Tag Query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$resultSet = $technorati-&gt;tag(&#39;php&#39;);

echo &quot;&lt;p&gt;Reading &quot; . $resultSet-&gt;totalResults() .
     &quot; of &quot; . $resultSet-&gt;totalResultsAvailable() . &quot; available results&lt;/p&gt;&quot;;
echo &quot;&lt;ol&gt;&quot;;
foreach ($resultSet as $result) {
    echo &quot;&lt;li&gt;&quot; . $result-&gt;getWeblog()-&gt;getName() . &quot;&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ol&gt;&quot;;

                 Technorati DailyCounts 
                The  DailyCounts  query
                provides daily counts of posts containing the queried keyword. It returns a
                 Zend_Service_Technorati_DailyCountsResultSet 
                object. For full details please see  Zend_Service_Technorati::dailyCounts()  in the
                 API reference guide .
             DailyCounts Query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$resultSet = $technorati-&gt;dailyCounts(&#39;php&#39;);

foreach ($resultSet as $result) {
    echo &quot;&lt;li&gt;&quot; . $result-&gt;getDate() . &quot;(&quot; . $result-&gt;getCount() . &quot;)&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ol&gt;&quot;;

                 Technorati TopTags 
                The  TopTags  query provides
                information on top tags indexed by Technorati. It returns a
                 Zend_Service_Technorati_TagsResultSet 
                object. For full details please see  Zend_Service_Technorati::topTags()  in the
                 API reference guide .
             TopTags Query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$resultSet = $technorati-&gt;topTags();

echo &quot;&lt;p&gt;Reading &quot; . $resultSet-&gt;totalResults() .
     &quot; of &quot; . $resultSet-&gt;totalResultsAvailable() . &quot; available results&lt;/p&gt;&quot;;
echo &quot;&lt;ol&gt;&quot;;
foreach ($resultSet as $result) {
    echo &quot;&lt;li&gt;&quot; . $result-&gt;getTag() . &quot;&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ol&gt;&quot;;

                 Technorati BlogInfo 
                The  BlogInfo  query provides
                information on what blog, if any, is associated with a given URL. It returns a
                 Zend_Service_Technorati_BlogInfoResult 
                object. For full details please see  Zend_Service_Technorati::blogInfo()  in the
                 API reference guide .
             BlogInfo Query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$result = $technorati-&gt;blogInfo(&#39;http://devzone.zend.com/&#39;);

echo &#39;&lt;h2&gt;&lt;a href=&quot;&#39; . (string) $result-&gt;getWeblog()-&gt;getUrl() . &#39;&quot;&gt;&#39; .
     $result-&gt;getWeblog()-&gt;getName() . &#39;&lt;/a&gt;&lt;/h2&gt;&#39;;

                 Technorati BlogPostTags 
                The  BlogPostTags  query
                provides information on the top tags used by a specific blog. It returns a
                 Zend_Service_Technorati_TagsResultSet 
                object. For full details please see  Zend_Service_Technorati::blogPostTags()  in the
                 API reference guide .
             BlogPostTags Query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$resultSet = $technorati-&gt;blogPostTags(&#39;http://devzone.zend.com/&#39;);

echo &quot;&lt;p&gt;Reading &quot; . $resultSet-&gt;totalResults() .
     &quot; of &quot; . $resultSet-&gt;totalResultsAvailable() . &quot; available results&lt;/p&gt;&quot;;
echo &quot;&lt;ol&gt;&quot;;
foreach ($resultSet as $result) {
    echo &quot;&lt;li&gt;&quot; . $result-&gt;getTag() . &quot;&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ol&gt;&quot;;

                 Technorati GetInfo 
                The  GetInfo  query tells you
                things that Technorati knows about a member. It returns a
                 Zend_Service_Technorati_GetInfoResult 
                object. For full details please see  Zend_Service_Technorati::getInfo()  in the
                 API reference guide .
             GetInfo Query &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$result = $technorati-&gt;getInfo(&#39;weppos&#39;);

$author = $result-&gt;getAuthor();
echo &quot;&lt;h2&gt;Blogs authored by &quot; . $author-&gt;getFirstName() . &quot; &quot; . $author-&gt;getLastName() . &quot;&lt;/h2&gt;&quot;;
echo &quot;&lt;ol&gt;&quot;;
foreach ($result-&gt;getWeblogs() as $weblog) {
    echo &quot;&lt;li&gt;&quot; . $weblog-&gt;getName() . &quot;&lt;/li&gt;&quot;;
}
echo &quot;&lt;/ol&gt;&quot;;

                 Technorati KeyInfo 
                The KeyInfo query provides information on daily usage of an API key. It returns a
                Zend_Service_Technorati_KeyInfoResult 
               object. For full details please see  Zend_Service_Technorati::keyInfo()  in the
                API reference guide .
             Zend_Service_Technorati Classes 
            The following classes are returned by the various Technorati queries. Each
             Zend_Service_Technorati_*ResultSet  class holds a type-specific result set which can be easily
            iterated, with each result being contained in a type result object. All result set classes extend
             Zend_Service_Technorati_ResultSet  class and implement the  SeekableIterator 
            interface, allowing for easy iteration and seeking to a specific result.
             Zend_Service_Technorati_ResultSet Zend_Service_Technorati_CosmosResultSet Zend_Service_Technorati_SearchResultSet Zend_Service_Technorati_TagResultSet Zend_Service_Technorati_DailyCountsResultSet Zend_Service_Technorati_TagsResultSet Zend_Service_Technorati_Result Zend_Service_Technorati_CosmosResult Zend_Service_Technorati_SearchResult Zend_Service_Technorati_TagResult Zend_Service_Technorati_DailyCountsResult Zend_Service_Technorati_TagsResult Zend_Service_Technorati_GetInfoResult Zend_Service_Technorati_BlogInfoResult Zend_Service_Technorati_KeyInfoResult 
         Zend_Service_Technorati_GetInfoResult ,  Zend_Service_Technorati_BlogInfoResult 
                and  Zend_Service_Technorati_KeyInfoResult  represent exceptions to the above because they
                don&#39;t belong to a result set and they don&#39;t implement any interface. They represent a single response
                object and they act as a wrapper for additional  Zend_Service_Technorati  objects, such as
                 Zend_Service_Technorati_Author  and  Zend_Service_Technorati_Weblog .
             
            The  Zend_Service_Technorati  library includes additional convenient classes representing
            specific response objects.  Zend_Service_Technorati_Author  represents a single Technorati
            account, also known as a blog author or blogger.  Zend_Service_Technorati_Weblog  represents a
            single weblog object, along with all specific weblog properties such as feed URLs or blog name. For full
            details please see  Zend_Service_Technorati  in the
             API reference guide .
         Zend_Service_Technorati_ResultSet Zend_Service_Technorati_ResultSet  is the most essential result set. The scope of this
                class is to be extended by a query-specific child result set class, and it should never be used to
                initialize a standalone object. Each of the specific result sets represents a collection of
                query-specific
                 Zend_Service_Technorati_Result 
                objects.
             Zend_Service_Technorati_ResultSet  implements the PHP  SeekableIterator 
                interface, and you can iterate all result objects via the PHP  foreach  statement.
             Iterating result objects from a resultset collection &lt;?php
require_once &#39;Zend/Service/Technorati.php&#39;;

// run a simple query
$technorati = new Zend_Service_Technorati(&#39;VALID_API_KEY&#39;);
$resultSet = $technorati-&gt;search(&#39;php&#39;);

// $resultSet is now an instance of Zend_Service_Technorati_SearchResultSet
// it extends Zend_Service_Technorati_ResultSet
foreach ($resultSet as $result) {
    // do something with your
    // Zend_Service_Technorati_SearchResult object
} 
                 Zend_Service_Technorati_CosmosResultSet Zend_Service_Technorati_CosmosResultSet  represents a Technorati Cosmos query result set.
             Zend_Service_Technorati_CosmosResultSet  extends
                     Zend_Service_Technorati_ResultSet .
                 Zend_Service_Technorati_SearchResultSet Zend_Service_Technorati_SearchResultSet  represents a Technorati Search query result set.
             Zend_Service_Technorati_SearchResultSet  extends
                     Zend_Service_Technorati_ResultSet .
                 Zend_Service_Technorati_TagResultSet Zend_Service_Technorati_TagResultSet  represents a Technorati Tag query result set.
             Zend_Service_Technorati_TagResultSet  extends
                     Zend_Service_Technorati_ResultSet .
                 Zend_Service_Technorati_DailyCountsResultSet Zend_Service_Technorati_DailyCountsResultSet  represents a Technorati DailyCounts query result set.
             Zend_Service_Technorati_DailyCountsResultSet  extends
                     Zend_Service_Technorati_ResultSet .
                 Zend_Service_Technorati_TagsResultSet Zend_Service_Technorati_TagsResultSet  represents a Technorati TopTags or BlogPostTags queries result set.
             Zend_Service_Technorati_TagsResultSet  extends
                     Zend_Service_Technorati_ResultSet .
                 Zend_Service_Technorati_Result Zend_Service_Technorati_Result  is the most essential result object. The scope of this
                class is to be extended by a query specific child result class, and it should never be used to
                initialize a standalone object.
             Zend_Service_Technorati_CosmosResult Zend_Service_Technorati_CosmosResult  represents a single Technorati Cosmos query result
                object. It is never returned as a standalone object, but it always belongs to a valid
                 Zend_Service_Technorati_CosmosResultSet 
                object.
             Zend_Service_Technorati_CosmosResult  extends
                     Zend_Service_Technorati_Result .
                 Zend_Service_Technorati_SearchResult Zend_Service_Technorati_SearchResult  represents a single Technorati Search query result
                object. It is never returned as a standalone object, but it always belongs to a valid
                 Zend_Service_Technorati_SearchResultSet 
                object.
             Zend_Service_Technorati_SearchResult  extends
                     Zend_Service_Technorati_Result .
                 Zend_Service_Technorati_TagResult Zend_Service_Technorati_TagResult  represents a single Technorati Tag query result object.
                It is never returned as a standalone object, but it always belongs to a valid
                 Zend_Service_Technorati_TagResultSet 
                object.
             Zend_Service_Technorati_TagResult  extends
                     Zend_Service_Technorati_Result .
                 Zend_Service_Technorati_DailyCountsResult Zend_Service_Technorati_DailyCountsResult  represents a single Technorati DailyCounts query
                result object. It is never returned as a standalone object, but it always belongs to a valid
                 Zend_Service_Technorati_DailyCountsResultSet 
                object.
             Zend_Service_Technorati_DailyCountsResult  extends
                     Zend_Service_Technorati_Result .
                 Zend_Service_Technorati_TagsResult Zend_Service_Technorati_TagsResult  represents a single Technorati TopTags or BlogPostTags
                query result object. It is never returned as a standalone object, but it always belongs to a valid
                 Zend_Service_Technorati_TagsResultSet  
                object.
             Zend_Service_Technorati_TagsResult  extends
                     Zend_Service_Technorati_Result .
                 Zend_Service_Technorati_GetInfoResult Zend_Service_Technorati_GetInfoResult  represents a single Technorati GetInfo query result
                object.
             Zend_Service_Technorati_BlogInfoResult Zend_Service_Technorati_BlogInfoResult  represents a single Technorati BlogInfo query
                result object.
             Zend_Service_Technorati_KeyInfoResult Zend_Service_Technorati_KeyInfoResult  represents a single Technorati KeyInfo query result
                object. It provides information about your
                 Technorati API Key daily usage .
             Zend_Service_Yahoo Introduction Zend_Service_Yahoo  is a simple API for using many of the Yahoo! REST APIs.
             Zend_Service_Yahoo  allows you to search Yahoo! Web search, Yahoo! News, Yahoo! Local, Yahoo!
            Images. In order to use the Yahoo! REST API, you must have a Yahoo! Application ID. To obtain an Application ID, please complete and submit the
             Application ID Request Form .
         Searching the Web with Yahoo! Zend_Service_Yahoo  enables you to search the Web with Yahoo! using the
             webSearch()  method, which accepts a string query parameter and an optional second parameter
            as an array of search options. For full details and an option list, please visit the
             Yahoo! Web Search
            Documentation . The  webSearch()  method returns a
             Zend_Service_Yahoo_WebResultSet  object.
         Searching the Web with Yahoo! &lt;?php
require_once &#39;Zend/Service/Yahoo.php&#39;;
$yahoo = new Zend_Service_Yahoo(&quot;YAHOO_APPLICATION_ID&quot;);
$results = $yahoo-&gt;webSearch(&#39;PHP&#39;);
foreach ($results as $result) {
    echo $result-&gt;Title .&#39;&lt;br /&gt;&#39;;
}
             Finding Images with Yahoo! 
            You can search for Images with Yahoo using  Zend_Service_Yahoo &#39;s  imageSearch() 
            method. This method accepts a string query parameter and an optional array of search options, as for the
             webSearch()  method . For full details
            and an option list, please visit the
             Yahoo! Image Search
            Documentation .
         Finding Images with Yahoo! &lt;?php
require_once &#39;Zend/Service/Yahoo.php&#39;;
$yahoo = new Zend_Service_Yahoo(&quot;YAHOO_APPLICATION_ID&quot;);
$results = $yahoo-&gt;imageSearch(&#39;PHP&#39;);
foreach ($results as $result) {
    echo $result-&gt;Title .&#39;&lt;br /&gt;&#39;;
}
             Finding videos with Yahoo! 
            You can search for videos with Yahoo using  Zend_Service_Yahoo &#39;s  videoSearch() 
            method. For full details and an option list, please visit the
             Yahoo! Video Search
            Documentation .
         Finding videos with Yahoo! &lt;?php
require_once &#39;Zend/Service/Yahoo.php&#39;;
$yahoo = new Zend_Service_Yahoo(&quot;YAHOO_APPLICATION_ID&quot;);
$results = $yahoo-&gt;videoSearch(&#39;PHP&#39;);
foreach ($results as $result) {
    echo $result-&gt;Title .&#39;&lt;br /&gt;&#39;;
}
             Finding Local Businesses and Services with Yahoo! 
            You can search for local businesses and services with Yahoo! by using the  localSearch()  method.
            For full details, please see the
             Yahoo! Local Search
            Documentation .
         Finding Local Businesses and Services with Yahoo! &lt;?php
require_once &#39;Zend/Service/Yahoo.php&#39;;
$yahoo = new Zend_Service_Yahoo(&quot;YAHOO_APPLICATION_ID&quot;);
$results = $yahoo-&gt;localSearch(&#39;Apple Computers&#39;, array(&#39;zip&#39; =&gt; &#39;95014&#39;));
foreach ($results as $result) {
    echo $result-&gt;Title .&#39;&lt;br /&gt;&#39;;
}
             Searching Yahoo! News 
            Searching Yahoo! News is simple; just use the  newsSearch()  method, as in the following
            example. For full details, please see the
             Yahoo! News Search
            Documentation .
         Searching Yahoo! News &lt;?php
require_once &#39;Zend/Service/Yahoo.php&#39;;
$yahoo = new Zend_Service_Yahoo(&quot;YAHOO_APPLICATION_ID&quot;);
$results = $yahoo-&gt;newsSearch(&#39;PHP&#39;);
foreach ($results as $result) {
    echo $result-&gt;Title .&#39;&lt;br /&gt;&#39;;
}
             Searching Yahoo! Site Explorer Inbound Links 
            Searching Yahoo! Site Explorer Inbound Links is simple; just use the  inlinkDataSearch() 
            method, as in the following example. For full details, please see the
             Yahoo!
            Site Explorer Inbound Links Documentation .
         Searching Yahoo! Site Explorer Inbound Links &lt;?php
require_once &#39;Zend/Service/Yahoo.php&#39;;
$yahoo = new Zend_Service_Yahoo(&quot;YAHOO_APPLICATION_ID&quot;);
$results = $yahoo-&gt;inlinkDataSearch(&#39;http://framework.zend.com/&#39;);
foreach ($results as $result) {
    echo $result-&gt;Title .&#39;&lt;br /&gt;&#39;;
}
             Searching Yahoo! Site Explorer&#39;s PageData 
            Searching Yahoo! Site Explorer&#39;s PageData is simple; just use the  pageDataSearch() 
            method, as in the following example. For full details, please see the
             Yahoo!
            Site Explorer PageData Documentation .
         Searching Yahoo! Site Explorer&#39;s PageData &lt;?php
require_once &#39;Zend/Service/Yahoo.php&#39;;
$yahoo = new Zend_Service_Yahoo(&quot;YAHOO_APPLICATION_ID&quot;);
$results = $yahoo-&gt;pageDataSearch(&#39;http://framework.zend.com/&#39;);
foreach ($results as $result) {
    echo $result-&gt;Title .&#39;&lt;br /&gt;&#39;;
}
             Zend_Service_Yahoo Classes 
            The following classes are all returned by the various Yahoo! searches. Each search type returns a
            type-specific result set which can be easily iterated, with each result being contained in a type result
            object. All result set classes implement the  SeekableIterator  interface, allowing for easy
            iteration and seeking to a specific result.
             Zend_Service_Yahoo_ResultSet Zend_Service_Yahoo_WebResultSet Zend_Service_Yahoo_ImageResultSet Zend_Service_Yahoo_VideoResultSet Zend_Service_Yahoo_LocalResultSet Zend_Service_Yahoo_NewsResultSet Zend_Service_Yahoo_InlinkDataResultSet Zend_Service_Yahoo_PageDataResultSet Zend_Service_Yahoo_Result Zend_Service_Yahoo_WebResult Zend_Service_Yahoo_ImageResult Zend_Service_Yahoo_VideoResult Zend_Service_Yahoo_LocalResult Zend_Service_Yahoo_NewsResult Zend_Service_Yahoo_InlinkDataResult Zend_Service_Yahoo_PageDataResult Zend_Service_Yahoo_Image 
         Zend_Service_Yahoo_ResultSet 
                Each of the search specific result sets is extended from this base class.
             
                Each of the specific result sets returns a search specific
                 Zend_Service_Yahoo_Result  objects.
             Zend_Service_Yahoo_ResultSet::totalResults() int totalResults 
                    Returns the number of results returned for the search.
                 Properties Zend_Service_Yahoo_ResultSet Name Type Description totalResultsAvailable int 
                                    Total number of results found.
                                 totalResultsReturned int Number of results in the current result set firstResultPosition int Position of the first result in this set relative to the total number of results. Back to Class List Zend_Service_Yahoo_WebResultSet Zend_Service_Yahoo_WebResultSet  represents a Yahoo! Web Search result set.
             Zend_Service_Yahoo_WebResultSet  extends  Zend_Service_Yahoo_ResultSet 
                 Back to Class List Zend_Service_Yahoo_ImageResultSet Zend_Service_Yahoo_ImageResultSet  represents a Yahoo! Image Search result set.
             Zend_Service_Yahoo_ImageResultSet  extends  Zend_Service_Yahoo_ResultSet 
                 Back to Class List Zend_Service_Yahoo_VideoResultSet Zend_Service_Yahoo_VideoResultSet  represents a Yahoo! Video Search result set.
             Zend_Service_Yahoo_VideoResultSet  extends  Zend_Service_Yahoo_ResultSet 
                 Back to Class List Zend_Service_Yahoo_LocalResultSet Zend_Service_Yahoo_LocalResultSet  represents a Yahoo! Local Search result set.
             Zend_Service_Yahoo_LocalResultSet Properties Name Type Description resultSetMapURL string The URL of a webpage containing a map graphic with all returned results plotted on it. Zend_Service_Yahoo_LocalResultSet  extends  Zend_Service_Yahoo_ResultSet 
                 Back to Class List Zend_Service_Yahoo_NewsResultSet Zend_Service_Yahoo_NewsResultSet  represents a Yahoo! News Search result set.
             Zend_Service_Yahoo_NewsResultSet  extends  Zend_Service_Yahoo_ResultSet 
                 Back to Class List Zend_Service_Yahoo_InlinkDataResultSet Zend_Service_Yahoo_InlinkDataResultSet  represents a Yahoo! Inbound Link Search result set.
             Zend_Service_Yahoo_InlinkDataResultSet  extends  Zend_Service_Yahoo_ResultSet 
                 Back to Class List Zend_Service_Yahoo_PageDataResultSet Zend_Service_Yahoo_PageDataResultSet  represents a Yahoo! PageData Search result set.
             Zend_Service_Yahoo_PageDataResultSet  extends  Zend_Service_Yahoo_ResultSet 
                 Back to Class List Zend_Service_Yahoo_Result 
                Each of the search specific results is extended from this base class.
             Properties Zend_Service_Yahoo_Result Properties Name Type Description Title string Title of the Result item Url string The URL of the result item ClickUrl string The URL for linking to the result item Back to Class List Zend_Service_Yahoo_WebResult 
                Each Web Search result is returned as a  Zend_Service_Yahoo_WebResult  object.
             Properties Zend_Service_Yahoo_WebResult Properties Name Type Description Summary string Result summary MimeType string Result mimetype ModificationDate string The last modification date of the result as a UNIX timestamp. CacheUrl string Yahoo! web cache URL for the result, if it exists. CacheSize int The size of the Cache entry Back to Class List Zend_Service_Yahoo_ImageResult 
                Each Image Search result is returned as a  Zend_Service_Yahoo_ImageResult  object.
             Properties Zend_Service_Yahoo_ImageResult Properties Name Type Description Summary string Result summary RefererUrl string The URL of the page which contains the image FileSize int The size of the image file in bytes FileFormat string The format of the image (bmp, gif, jpeg, png, etc.) Height int The height of the image Width int The width of the image Thumbnail Zend_Service_Yahoo_Image Image thumbnail Back to Class List Zend_Service_Yahoo_VideoResult 
                Each Video Search result is returned as a  Zend_Service_Yahoo_VideoResult  object.
             Properties Zend_Service_Yahoo_VideoResult Properties Name Type Description Summary string Result summary RefererUrl string The URL of the page which contains the video FileSize int The size of the video file in bytes FileFormat string The format of the video (avi, flash, mpeg, msmedia, quicktime, realmedia, etc.) Height int The height of the video in pixels Width int The width of the video in pixels Duration int The length of the video in seconds Channels int Number of audio channels in the video Streaming boolean Whether the video is streaming or not Thumbnail Zend_Service_Yahoo_Image Image thumbnail Back to Class List Zend_Service_Yahoo_LocalResult 
                Each Local Search result is returned as a  Zend_Service_Yahoo_LocalResult  object.
             Properties Zend_Service_Yahoo_LocalResult Properties Name Type Description Address string Street Address of the result City string City in which the result resides in State string State in which the result resides in Phone string Phone number for the result Rating int User submitted rating for the result Distance float The distance to the result from your specified location MapUrl string A URL of a map for the result BusinessUrl string The URL for the business website, if known BusinessClickUrl string The URL for linking to the business website, if known Back to Class List Zend_Service_Yahoo_NewsResult 
                Each News Search result is returned as a  Zend_Service_Yahoo_NewsResult  object.
             Properties Zend_Service_Yahoo_NewsResult Properties Name Type Description Summary string Result summary NewsSource string The company who distributed the article NewsSourceUrl string The URL for the company who distributed the article Language string The language the article is in PublishDate string The date the article was published as a UNIX timestamp ModificationDate string The date the article was last modified as a UNIX timestamp Thumbnail Zend_Service_Yahoo_Image Image Thumbnail for the article, if it exists Back to Class List Zend_Service_Yahoo_InlinkDataResult 
                Each Inbound Link Search result is returned as a
                 Zend_Service_Yahoo_InlinkDatabResult  object.
             Back to Class List Zend_Service_Yahoo_PageDataResult 
                Each Page Data Search result is returned as a
                 Zend_Service_Yahoo_PageDatabResult  object.
             Back to Class List Zend_Service_Yahoo_Image 
                All images returned either by the Yahoo! Image Search or the Yahoo! News Search
                are represented by  Zend_Service_Yahoo_Image  objects
             Properties Zend_Service_Yahoo_Image Properties Name Type Description Url string Image URL Width int Image Width Height int Image Height Back to Class List Advanced Usage 
        While the basic usage examples are a perfectly acceptable way to utilize Zend Framework sessions, there are some
        best practices to consider. This section discusses the finer details of session handling and illustrates more
        advanced usage of the Zend_Session component.
     Starting a Session 
            If you want all requests to have a session facilitated by Zend_Session, then start the session in the
            bootstrap file:
         Starting the Global Session &lt;?php
require_once &#39;Zend/Session.php&#39;;

Zend_Session::start();
             
            By starting the session in the bootstrap file, you avoid the possibility that your session might be started
            after headers have been sent to the browser, which results in an exception, and possibly a broken page for
            website viewers. Various advanced features require  Zend_Session::start()  first. (More on
            advanced features later.)
         
            There are four ways to start a session, when using Zend_Session. Two are wrong.
         
                    Wrong: Do not enable PHP&#39;s
                                         session.auto_start 
                    setting . If you do not have the ability to disable this setting in
                    php.ini, you are using mod_php (or equivalent), and the setting is already enabled in
                     php.ini , then add the following to your  .htaccess  file (usually in your
                    HTML document root directory):
                     php_value session.auto_start 0
                     
                 
                    Wrong: Do not use PHP&#39;s
                     session_start()  function
                    directly. If you use  session_start()  directly, and then start using
                     Zend_Session_Namespace , an exception will be thrown by
                     Zend_Session::start()  (&quot;session has already been started&quot;). If you call
                     session_start()  after using  Zend_Session_Namespace  or calling
                     Zend_Session::start() , an error of level  E_NOTICE  will be generated, and
                    the call will be ignored.
                 
                    Correct: Use  Zend_Session::start() . If you want all requests to have and use
                    sessions, then place this function call early and unconditionally in your bootstrap code.
                    Sessions have some overhead. If some requests need sessions, but other requests will not need to use
                    sessions, then:
                 
                            Unconditionally set the  strict  option to  true  using
                             Zend_Session::setOptions()  in your bootstrap.
                         
                            Call  Zend_Session::start()  only for requests that need to use sessions and
                            before any  Zend_Session_Namespace  objects are instantiated.
                         
                            Use &quot; new Zend_Session_Namespace() &quot; normally, where needed, but make sure
                             Zend_Session::start()  has been called previously.
                         
                    The  strict  option prevents  new Zend_Session_Namespace()  from automatically
                    starting the session using  Zend_Session::start() . Thus, this option helps application
                    developers enforce a design decision to avoid using sessions for certain requests, since it causes
                    an exception to be thrown when  Zend_Session_Namespace  is instantiated before
                     Zend_Session::start()  is called. Developers should carefully consider the impact of
                    using  Zend_Session::setOptions() , since these options have global effect, owing to
                    their correspondence to the underlying options for ext/session.
                 
                    Correct: Just instantiate  Zend_Session_Namespace  whenever needed, and the underlying
                    PHP session will be automatically started. This offers extremely simple usage that works well in
                    most situations. However, you then become responsible for ensuring that the first
                     new Zend_Session_Namespace()  happens  before  any
                    output (e.g.,  HTTP headers ) has been sent by
                    PHP to the client, if you are using the default, cookie-based sessions (strongly recommended). See
                      for more information.
                 Locking Session Namespaces 
            Session namespaces can be locked, to prevent further alterations to the data in that namespace. Use
             lock()  to make a specific namespace read-only,  unLock()  to make a read-only
            namespace read-write, and  isLocked()  to test if a namespace has been previously locked. Locks
            are transient and do not persist from one request to the next. Locking the namespace has no effect on setter
            methods of objects stored in the namespace, but does prevent the use of the namespace&#39;s setter method to
            remove or replace objects stored directly in the namespace. Similarly, locking
             Zend_Session_Namespace  instances does not prevent the use of symbol table aliases to the same
            data (see  PHP references ).
         Locking Session Namespaces &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;

$userProfileNamespace = new Zend_Session_Namespace(&#39;userProfileNamespace&#39;);

// marking session as read only locked
$userProfileNamespace-&gt;lock();

// unlocking read-only lock
if ($userProfileNamespace-&gt;isLocked()) {
    $userProfileNamespace-&gt;unLock();
}
             Namespace Expiration 
            Limits can be placed on the longevity of both namespaces and individual keys in namespaces. Common use cases
            include passing temporary information between requests, and reducing exposure to certain security risks by
            removing access to potentially sensitive information some time after authentication occurred. Expiration can
            be based on either elapsed seconds or the number of &quot;hops&quot;, where a hop occurs for each successive request
            that instantiates the namespace at least once.
         Expiration Examples &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;

$s = new Zend_Session_Namespace(&#39;expireAll&#39;);
$s-&gt;a = &#39;apple&#39;;
$s-&gt;p = &#39;pear&#39;;
$s-&gt;o = &#39;orange&#39;;

$s-&gt;setExpirationSeconds(5, &#39;a&#39;); // expire only the key &quot;a&quot; in 5 seconds

// expire entire namespace in 5 &quot;hops&quot;
$s-&gt;setExpirationHops(5);

$s-&gt;setExpirationSeconds(60);
// The &quot;expireAll&quot; namespace will be marked &quot;expired&quot; on
// the first request received after 60 seconds have elapsed,
// or in 5 hops, whichever happens first.
             
            When working with data expiring from the session in the current request, care should be used when retrieving
            them. Although the data are returned by reference, modifying the data will not make expiring data persist
            past the current request. In order to &quot;reset&quot; the expiration time, fetch the data into temporary variables,
            use the namespace to unset them, and then set the appropriate keys again.
         Session Encapsulation and Controllers 
            Namespaces can also be used to separate session access by controllers to protect variables from
            contamination. For example, an authentication controller might keep its session state data separate from all
            other controllers for meeting security requirements.
         Namespaced Sessions for Controllers with Automatic Expiration 
                The following code, as part of a controller that displays a test question, initiates a boolean variable
                to represent whether or not a submitted answer to the test question should be accepted. In this case,
                the application user is given 300 seconds to answer the displayed question.
             &lt;?php
// ...
// in the question view controller
require_once &#39;Zend/Session/Namespace.php&#39;;
$testSpace = new Zend_Session_Namespace(&#39;testSpace&#39;);
$testSpace-&gt;setExpirationSeconds(300, &#39;accept_answer&#39;); // expire only this variable
$testSpace-&gt;accept_answer = true;
//...
             
                Below, the controller that processes the answers to test questions determines whether or not to accept
                an answer based on whether the user submitted the answer within the allotted time:
             &lt;?php
// ...
// in the answer processing controller
require_once &#39;Zend/Session/Namespace.php&#39;;
$testSpace = new Zend_Session_Namespace(&#39;testSpace&#39;);
if ($testSpace-&gt;accept_answer === true) {
    // within time
}
else {
    // not within time
}
// ...
             Preventing Multiple Instances per Namespace 
            Although  session locking  provides a good degree
            of protection against unintended use of namespaced session data,  Zend_Session_Namespace  also
            features the ability to prevent the creation of multiple instances corresponding to a single namespace.
         
            To enable this behavior, pass  true  to the second constructor argument when creating the last
            allowed instance of  Zend_Session_Namespace . Any subsequent attempt to instantiate the same
            namespace would result in a thrown exception.
         Limiting Session Namespace Access to a Single Instance &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;

// create an instance of a namespace
$authSpaceAccessor1 = new Zend_Session_Namespace(&#39;Zend_Auth&#39;);

// create another instance of the same namespace, but disallow any new instances
$authSpaceAccessor2 = new Zend_Session_Namespace(&#39;Zend_Auth&#39;, true);

// making a reference is still possible
$authSpaceAccessor3 = $authSpaceAccessor2;

$authSpaceAccessor1-&gt;foo = &#39;bar&#39;;

assert($authSpaceAccessor2-&gt;foo, &#39;bar&#39;);

try {
    $aNamespaceObject = new Zend_Session_Namespace(&#39;Zend_Auth&#39;);
} catch (Zend_Session_Exception $e) {
    echo &quot;Cannot instantiate this namespace since \$authSpaceAccessor2 was created\n&quot;;
}
             
            The second parameter in the constructor above tells  Zend_Session_Namespace  that any future
            instances with the &quot; Zend_Auth &quot; namespace are not allowed. Attempting to create such an instance
            causes an exception to be thrown by the constructor. The developer therefore becomes responsible for storing
            a reference to an instance object ( $authSpaceAccessor1 ,  $authSpaceAccessor2 , or
             $authSpaceAccessor3  in the example above) somewhere, if access to the session namespace is
            needed at a later time during the same request. For example, a developer may store the reference in a static
            variable, add the reference to a
             registry  (see
             ), or otherwise make it available to other methods that may need access to
            the session namespace.
         Working with Arrays 
            Due to the implementation history of PHP magic methods, modifying an array inside a namespace may not work
            under PHP versions before 5.2.1. If you will only be working with PHP 5.2.1 or later, then you may  skip to the next section .
         Modifying Array Data with a Session Namespace 
                The following illustrates how the problem may be reproduced:
             &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;
$sessionNamespace = new Zend_Session_Namespace();
$sessionNamespace-&gt;array = array();
$sessionNamespace-&gt;array[&#39;testKey&#39;] = 1; // may not work as expected before PHP 5.2.1
echo $sessionNamespace-&gt;array[&#39;testKey&#39;];
             Building Arrays Prior to Session Storage 
                If possible, avoid the problem altogether by storing arrays into a session namespace only after all
                desired array values have been set.
             &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;
$sessionNamespace = new Zend_Session_Namespace(&#39;Foo&#39;);
$sessionNamespace-&gt;array = array(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
             
            If you are using an affected version of PHP and need to modify the array after assigning it to a session
            namespace key, you may use either or both of the following workarounds.
         Workaround: Reassign a Modified Array 
                In the code that follows, a copy of the stored array is created, modified, and reassigned to the
                location from which the copy was created, overwriting the original array.
             &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;
$sessionNamespace = new Zend_Session_Namespace();

// assign the initial array
$sessionNamespace-&gt;array = array(&#39;tree&#39; =&gt; &#39;apple&#39;);

// make a copy of the array
$tmp = $sessionNamespace-&gt;array;

// modfiy the array copy
$tmp[&#39;fruit&#39;] = &#39;peach&#39;;

// assign a copy of the array back to the session namespace
$sessionNamespace-&gt;array = $tmp;

echo $sessionNamespace-&gt;array[&#39;fruit&#39;]; // prints &quot;peach&quot;
             Workaround: store array containing reference 
                Alternatively, store an array containing a reference to the desired array, and then access it
                indirectly.
             &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;
$myNamespace = new Zend_Session_Namespace(&#39;myNamespace&#39;);
$a = array(1, 2, 3);
$myNamespace-&gt;someArray = array( &amp;$a );
$a[&#39;foo&#39;] = &#39;bar&#39;;
echo $myNamespace-&gt;someArray[&#39;foo&#39;]; // prints &quot;bar&quot;
             Using Sessions with Objects 
            If you plan to persist objects in the PHP session, know that they will be
             serialized  for storage.
            Thus, any object persisted with the PHP session must be unserialized upon retrieval from storage. The
            implication is that the developer must ensure that the classes for the persisted objects must have been
            defined before the object is unserialized from session storage. If an unserialized object&#39;s class is not
            defined, then it becomes an instance of  stdClass .
         Using Sessions with Unit Tests 
            The Zend Framework relies on PHPUnit to facilitate testing of itself. Many developers extend the existing
            suite of unit tests to cover the code in their applications. The exception
            &quot; Zend_Session is currently marked as read-only &quot; is thrown while
            performing unit tests, if any write-related methods are used after ending the session. However, unit tests
            using Zend_Session require extra attention, because closing ( Zend_Session::writeClose() ), or
            destroying a session ( Zend_Session::destroy() ) prevents any further setting or unsetting of
            keys in any instance of  Zend_Session_Namespace . This behavior is a direct result of the
            underlying ext/session mechanism and PHP&#39;s  session_destroy()  and
             session_write_close() , which have no &quot;undo&quot; mechanism to facilitate setup/teardown with unit
            tests.
         
            To work around this, see the unit test  testSetExpirationSeconds()  in
             SessionTest.php  and  SessionTestHelper.php , both located in
             tests/Zend/Session , which make use of PHP&#39;s  exec()  to launch a separate process.
            The new process more accurately simulates a second, successive request from a browser. The separate process
            begins with a &quot;clean&quot; session, just like any PHP script execution for a web request. Also, any changes to
             $_SESSION  made in the calling process become available to the child process, provided the
            parent closed the session before using  exec() .
         PHPUnit Testing Code Dependent on Zend_Session &lt;?php
// testing setExpirationSeconds()
require_once &#39;tests/Zend/Session/SessionTestHelper.php&#39;; // also see SessionTest.php
$script = &#39;SessionTestHelper.php&#39;;
$s = new Zend_Session_Namespace(&#39;space&#39;);
$s-&gt;a = &#39;apple&#39;;
$s-&gt;o = &#39;orange&#39;;
$s-&gt;setExpirationSeconds(5);

Zend_Session::regenerateId();
$id = Zend_Session::getId();
session_write_close(); // release session so process below can use it
sleep(4); // not long enough for things to expire
exec($script . &quot;expireAll $id expireAll&quot;, $result);
$result = $this-&gt;sortResult($result);
$expect = &#39;;a === apple;o === orange;p === pear&#39;;
$this-&gt;assertTrue($result === $expect,
    &quot;iteration over default Zend_Session namespace failed; expecting result === &#39;$expect&#39;, but got &#39;$result&#39;&quot;);

sleep(2); // long enough for things to expire (total of 6 seconds waiting, but expires in 5)
exec($script . &quot;expireAll $id expireAll&quot;, $result);
$result = array_pop($result);
$this-&gt;assertTrue($result === &#39;&#39;,
    &quot;iteration over default Zend_Session namespace failed; expecting result === &#39;&#39;, but got &#39;$result&#39;)&quot;);
session_start(); // resume artificially suspended session

// We could split this into a separate test, but actually, if anything leftover from above
// contaminates the tests below, that is also a bug that we want to know about.
$s = new Zend_Session_Namespace(&#39;expireGuava&#39;);
$s-&gt;setExpirationSeconds(5, &#39;g&#39;); // now try to expire only 1 of the keys in the namespace
$s-&gt;g = &#39;guava&#39;;
$s-&gt;p = &#39;peach&#39;;
$s-&gt;p = &#39;plum&#39;;

session_write_close(); // release session so process below can use it
sleep(6); // not long enough for things to expire
exec($script . &quot;expireAll $id expireGuava&quot;, $result);
$result = $this-&gt;sortResult($result);
session_start(); // resume artificially suspended session
$this-&gt;assertTrue($result === &#39;;p === plum&#39;,
    &quot;iteration over named Zend_Session namespace failed (result=$result)&quot;);
             Basic Usage Zend_Session_Namespace  instances provide the primary API for manipulating session data in the Zend
        Framework. Namespaces are used to segregate all session data, although a default namespace exists for those who
        only want one namespace for all their session data.  Zend_Session  utilizes ext/session and its
        special  $_SESSION  superglobal as the storage mechanism for session state data. While
         $_SESSION  is still available in PHP&#39;s global namespace, developers should refrain from directly
        accessing it, so that  Zend_Session  and  Zend_Session_Namespace  can most effectively and
        securely provide its suite of session related functionality.
     
        Each instance of  Zend_Session_Namespace  corresponds to an entry of the  $_SESSION 
        superglobal array, where the namespace is used as the key.

         &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;

$myNamespace = new Zend_Session_Namespace(&#39;myNamespace&#39;);

// $myNamespace corresponds to $_SESSION[&#39;myNamespace&#39;]
         

        It is possible to use Zend_Session in conjunction with other code that uses  $_SESSION  directly. To
        avoid problems, however, it is highly recommended that such code only uses parts of  $_SESSION  that
        do not correspond to instances of  Zend_Session_Namespace .
     Tutorial Examples 
            If no namespace is specified when instantiating  Zend_Session_Namespace , all data will be
            transparently stored in a namespace called &quot; Default &quot;.  Zend_Session  is not intended
            to work directly on the contents of session namespace containers. Instead, we use
             Zend_Session_Namespace . The example below demonstrates use of this default namespace, showing
            how to count the number of client requests during a session:
         Counting Page Views &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;

$defaultNamespace = new Zend_Session_Namespace(&#39;Default&#39;);

if (isset($defaultNamespace-&gt;numberOfPageRequests)) {
    $defaultNamespace-&gt;numberOfPageRequests++; // this will increment for each page load.
} else {
    $defaultNamespace-&gt;numberOfPageRequests = 1; // first time
}

echo &quot;Page requests this session: &quot;, $defaultNamespace-&gt;numberOfPageRequests;
             
            When multiple modules use instances of  Zend_Session_Namespace  having different namespaces, each
            module obtains data encapsulation for its session data. The  Zend_Session_Namespace  constructor
            can be passed an optional  $namespace  argument, which allows developers to partition session
            data into separate namespaces. Namespacing provides an effective and popular way to secure session state
            data against changes due to accidental naming collisions.
         
            Namespace names are restricted to character sequences represented as non-empty PHP strings that do not begin
            with an underscore (&quot; _ &quot;) character. Only core components included in the Zend Framework should
            use namespace names starting with &quot; Zend &quot;.
         New Way: Namespaces Avoid Collisions &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;

// in the Zend_Auth component
$authNamespace = new Zend_Session_Namespace(&#39;Zend_Auth&#39;);
$authNamespace-&gt;user = &quot;myusername&quot;;

// in a web services component
$webServiceNamespace = new Zend_Session_Namespace(&#39;Some_Web_Service&#39;);
$webServiceNamespace-&gt;user = &quot;mywebusername&quot;;
             
            The example above achieves the same effect as the code below, except that the session objects above preserve
            encapsulation of session data within their respective namespaces.
         Old Way: PHP Session Access &lt;?php
$_SESSION[&#39;Zend_Auth&#39;][&#39;user&#39;] = &quot;myusername&quot;;
$_SESSION[&#39;Some_Web_Service&#39;][&#39;user&#39;] = &quot;mywebusername&quot;;
             Iterating Over Session Namespaces Zend_Session_Namespace  provides the full
             IteratorAggregate
            interface , including support for the  foreach  statement:
         Session Iteration &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;

$aNamespace = new Zend_Session_Namespace(&#39;some_namespace_with_data_present&#39;);

foreach ($aNamespace as $index =&gt; $value) {
    echo &quot;aNamespace-&gt;$index = &#39;$value&#39;;\n&quot;;
}
             Accessors for Session Namespaces Zend_Session_Namespace  implements the  __get() ,  __set() ,
             __isset() , and  __unset() 
             magic methods , which should
            not be invoked directly, except from within a subclass. Instead, the normal operators automatically invoke
            these methods, such as in the following example:
         Accessing Session Data &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;

$namespace = new Zend_Session_Namespace(); // default namespace

$namespace-&gt;foo = 100;

echo &quot;\$namespace-&gt;foo = $namespace-&gt;foo\n&quot;;

if (!isset($namespace-&gt;bar)) {
    echo &quot;\$namespace-&gt;bar not set\n&quot;;
}

unset($namespace-&gt;foo);
             Global Session Management 
        The default behavior of sessions can be modified using the static methods of Zend_Session. All management and
        manipulation of global session management occurs using Zend_Session, including configuration of the
         usual options provided by ext/session ,
        using  Zend_Session::setOptions() . For example, failure to insure the use of a safe
         save_path  or a unique cookie name by ext/session using  Zend_Session::setOptions()  may
        result in security issues.
     Configuration Options 
            When the first session namespace is requested, Zend_Session will automatically start the PHP session, unless
            already started with
             Zend_Session::start() .
            The underlying PHP session will use defaults from Zend_Session, unless modified first by
             Zend_Session::setOptions() .
         
            To set a session configuration option, include the basename (the part of the name after
            &quot; session. &quot;) as a key of an array passed to  Zend_Session::setOptions() . The
            corresponding value in the array is used to set the session option value. If no options are set by the
            developer, Zend_Session will utilize recommended default options first, then the default php.ini settings.
            Community feedback about best practices for these options should be sent to
             fw-auth@lists.zend.com .
         Using Zend_Config to Configure Zend_Session 
                To configure this component using
                 Zend_Config_Ini , first add the
                configuration options to the INI file:
             ; Accept defaults for production
[production]
; bug_compat_42
; bug_compat_warn
; cache_expire
; cache_limiter
; cookie_domain
; cookie_lifetime
; cookie_path
; cookie_secure
; entropy_file
; entropy_length
; gc_divisor
; gc_maxlifetime
; gc_probability
; hash_bits_per_character
; hash_function
; name should be unique for each PHP application sharing the same domain name
name = UNIQUE_NAME
; referer_check
; save_handler
; save_path
; serialize_handler
; use_cookies
; use_only_cookies
; use_trans_sid

; remember_me_seconds = &lt;integer seconds&gt;
; strict = on|off


; Development inherits configuration from production, but overrides several values
[development : production]
; Don&#39;t forget to create this directory and make it rwx (readable and modifiable) by PHP.
save_path = /home/myaccount/zend_sessions/myapp
use_only_cookies = on
; When persisting session id cookies, request a TTL of 10 days
remember_me_seconds = 864000
             
                Next, load the configuration file and pass its array representation to
                 Zend_Session::setOptions() :
             &lt;?php
require_once &#39;Zend/Config/Ini.php&#39;;
$config = new Zend_Config_Ini(&#39;myapp.ini&#39;, &#39;development&#39;);

require_once &#39;Zend/Session.php&#39;;
Zend_Session::setOptions($config-&gt;toArray());
             
            Most options shown above need no explanation beyond that found in the standard PHP documentation, but those
            of particular interest are noted below.
             
                        boolean  strict  - disables automatic starting of  Zend_Session  when
                        using  new Zend_Session_Namespace() .
                     
                        integer  remember_me_seconds  - how long should session id cookie persist, after user
                        agent has ended (e.g., browser application terminated).
                     
                        string  save_path  - The correct value is system dependent, and should be provided by
                        the developer using an  absolute path  to a directory readable
                        and writable by the PHP process.  If a writable path is not supplied, then
                         Zend_Session  will throw an exception when started (i.e., when  start() 
                        is called).
                     Security Risk 
                            If the path is readable by other applications, then session hijacking might be possible. If
                            the path is writable by other applications, then
                             session poisoning 
                            might be possible. If this path is shared with other users or other PHP applications,
                            various security issues might occur, including theft of session content, hijacking of
                            sessions, and collision of garbage collection (e.g., another user&#39;s application might cause
                            PHP to delete your application&#39;s session files).
                         
                            For example, an attacker can visit the victim&#39;s website to obtain a session cookie. Then, he
                            edits the cookie path to his own domain on the same server, before visiting his own website
                            to execute  var_dump($_SESSION) . Armed with detailed knowledge of the victim&#39;s
                            use of data in their sessions, the attacker can then modify the session state (poisoning the
                            session), alter the cookie path back to the victim&#39;s website, and then make requests from
                            the victim&#39;s website using the poisoned session. Even if two applications on the same server
                            do not have read/write access to the other application&#39;s  save_path , if the
                             save_path  is guessable, and the attacker has control over one of these two
                            websites, the attacker could alter their website&#39;s  save_path  to use the other&#39;s
                            save_path, and thus accomplish session poisoning, under some common configurations of PHP.
                            Thus, the value for  save_path  should not be made public knowledge and should be
                            altered to a secure location unique to each application.
                         
                        string  name  - The correct value is system dependent and should be provided by the
                        developer using a value  unique  to the application.
                     Security Risk 
                            If the  php.ini  setting for  session.name  is the same (e.g., the
                            default &quot;PHPSESSID&quot;), and there are two or more PHP applications accessible through the same
                            domain name then they will share the same session data for visitors to both websites.
                            Additionally, possible corruption of session data may result.
                         
                        boolean  use_only_cookies  - In order to avoid introducing additional security risks,
                        do not alter the default value of this option.
                         Security Risk 
                                If this setting is not enabled, an attacker can easily fix victim&#39;s session ids, using
                                links on the attacker&#39;s website, such as
                                 http://www.example.com/index.php?PHPSESSID=fixed_session_id . The fixation
                                works, if the victim does not already have a session id cookie for example.com. Once a
                                victim is using a known session id, the attacker can then attempt to hijack the session
                                by pretending to be the victim, and emulating the victim&#39;s user agent.
                             
                     
         Error: Headers Already Sent 
            If you see the error message, &quot;Cannot modify header information - headers already sent&quot;, or, &quot;You must call
            ... before any output has been sent to the browser; output started in ...&quot;, then carefully examine the
            immediate cause (function or method) associated with the message. Any actions that require sending HTTP
            headers, such as sending a cookie, must be done before sending normal output (unbuffered output), except
            when using PHP&#39;s output buffering.
         
                    Using  output buffering  often is sufficient to prevent
                    this issue, and may help improve performance. For example, in  php.ini ,
                    &quot; output_buffering = 65535 &quot; enables output buffering with a 64K buffer. Even though
                    output buffering might be a good tactic on production servers to increase performance, relying only
                    on buffering to resolve the &quot;headers already sent&quot; problem is not sufficient. The application must
                    not exceed the buffer size, or the problem will occur whenever the output sent (prior to the HTTP
                    headers) exceeds the buffer size.
                 
                    Alternatively, try rearranging the application logic so that actions manipulating headers are
                    performed prior to sending any output whatsoever.
                 
                    If a Zend_Session method is involved in causing the error message, examine the method carefully, and
                    make sure its use really is needed in the application. For example, the default usage of
                     destroy()  also sends an HTTP header to expire the client-side session cookie. If this
                    is not needed, then use  destroy(false) , since the instructions to set cookies are sent
                    with HTTP headers.
                 
                    Alternatively, try rearranging the application logic so that all actions manipulating headers are
                    performed prior to sending any output whatsoever.
                 
                    Remove any closing &quot; ?&gt; &quot; tags, if they occur at the end of a PHP source file. They
                    are not needed, and newlines and other nearly invisible whitespace following the closing tag can
                    trigger output to the client.
                 Session Identifiers 
            Introduction: Best practice in relation to using sessions with ZF calls for using a browser cookie (i.e.
            a normal cookie stored in your web browser), instead of embedding a unique session identifier in URLs as
            a means to track individual users. By default this component uses only cookies to maintain session
            identifiers. The cookie&#39;s value is the unique identifier of your browser&#39;s session. PHP&#39;s ext/session
            uses this identifier to maintain a unique one-to-one relationship between website visitors, and
            persistent session data storage unique to each visitor. Zend_Session* wraps this storage mechanism
            ( $_SESSION ) with an object-oriented interface. Unfortunately, if an attacker gains access
            to the value of the cookie (the session id), an attacker might be able to hijack a visitor&#39;s session.
            This problem is not unique to PHP, or the Zend Framework. The  regenerateId()  method allows
            an application to change the session id (stored in the visitor&#39;s cookie) to a new, random, unpredictable
            value. Note: Although not the same, to make this section easier to read, we use the terms &quot;user agent&quot;
            and &quot;web browser&quot; interchangeably.
         
            Why?: If an attacker obtains a valid session identifier, an attacker might be able to impersonate a
            valid user (the victim), and then obtain access to confidential information or otherwise manipulate the
            victim&#39;s data managed by your application. Changing session ids helps protect against session hijacking.
            If the session id is changed, and an attacker does not know the new value, the attacker can not use the
            new session id in their attempts to hijack the visitor&#39;s session. Even if an attacker gains access to an
            old session id,  regenerateId()  also moves the session data from the old session id &quot;handle&quot;
            to the new one, so no data remains accessible via the old session id.
         
            When to use regenerateId(): Adding  Zend_Session::regenerateId()  to your Zend Framework
            bootstrap yields one of the safest and most secure ways to regenerate session id&#39;s in user agent
            cookies. If there is no conditional logic to determine when to regenerate the session id, then there are
            no flaws in that logic. Although regenerating on every request prevents several possible avenues of
            attack, not everyone wants the associated small performance and bandwidth cost. Thus, applications
            commonly try to dynamically determine situations of greater risk, and only regenerate the session ids in
            those situations. Whenever a website visitor&#39;s session&#39;s privileges are &quot;escalated&quot; (e.g. a visitor
            re-authenticates their identity before editing their personal &quot;profile&quot;), or whenever a security
            &quot;sensitive&quot; session parameter change occurs, consider using  regenerateId()  to create a new
            session id. If you call the  rememberMe()  function, then don&#39;t use
             regenerateId() , since the former calls the latter. If a user has successfully logged into
            your website, use  rememberMe()  instead of  regenerateId() .
         Session Hijacking and Fixation 
                Avoiding  cross-site script (XSS)
                vulnerabilities  helps preventing session hijacking. According to
                 Secunia&#39;s  statistics XSS problems occur frequently, regardless
                of the languages used to create web applications. Rather than expecting to never have a XSS problem with
                an application, plan for it by following best practices to help minimize damage, if it occurs. With XSS,
                an attacker does not need direct access to a victim&#39;s network traffic. If the victim already has a
                session cookie, Javascript XSS might allow an attacker to read the cookie and steal the session. For
                victims with no session cookies, using XSS to inject Javascript, an attacker could create a session id
                cookie on the victim&#39;s browser with a known value, then set an identical cookie on the attacker&#39;s
                system, in order to hijack the victim&#39;s session. If the victim visited an attacker&#39;s website, then the
                attacker can also emulate most other identifiable characteristics of the victim&#39;s user agent. If your
                website has an XSS vulnerability, the attacker might be able to insert an AJAX Javascript that secretly
                &quot;visits&quot; the attacker&#39;s website, so that the attacker knows the victim&#39;s browser characteristics and
                becomes aware of a compromised session at the victim website. However, the attacker can not arbitrarily
                alter the server-side state of PHP sessions, provided the developer has correctly set the value for the
                 save_path  option.
             
                By itself, calling  Zend_Session::regenerateId()  when the user&#39;s session is first used, does
                not prevent session fixation attacks, unless you can distinguish between a session originated by an
                attacker emulating the victim. At first, this might sound contradictory to the previous statement above,
                until we consider an attacker who first initiates a real session on your website. The session is &quot;first
                used&quot; by the attacker, who then knows the result of the initialization ( regenerateId() ).
                The attacker then uses the new session id in combination with an XSS vulnerability, or injects the
                session id via a link on the attacker&#39;s website (works if  use_only_cookies = off ).
             
                If you can distinguish between an attacker and victim using the same session id, then session hijacking
                can be dealt with directly. However, such distinctions usually involve some form of usability tradeoffs,
                because the methods of distinction are often imprecise. For example, if a request is received from an IP
                in a different country than the IP of the request when the session was created, then the new request
                probably belongs to an attacker. Under the following conditions, there might not be any way for a
                website application to distinguish between a victim and an attacker:
                 
                            - attacker first initiates a session on your website to obtain a valid session id
                         
                            - attacker uses XSS vulnerability on your website to create a cookie on the victim&#39;s browser
                            with the same, valid session id (i.e. session fixation)
                         
                            - both the victim and attacker originate from the same proxy farm (e.g. both are behind the
                            same firewall at a large company, like AOL)
                         
                The sample code below makes it much harder for an attacker to know the current victim&#39;s session id,
                unless the attacker has already performed the first two steps above.
             Session Fixation &lt;?php
require_once &#39;Zend/Session/Namespace.php&#39;;
$defaultNamespace = new Zend_Session_Namespace();

if (!isset($defaultNamespace-&gt;initialized)) {
    Zend_Session::regenerateId();
    $defaultNamespace-&gt;initialized = true;
}
                 rememberMe(integer $seconds) 
            Ordinarily, sessions end when the user agent terminates, such as when an end user exits a web browser
            program. However, your application may provide the ability to extend user sessions beyond the lifetime of
            the client program through the use of persistent cookies. Use  Zend_Session::rememberMe()  before
            a session is started to control the length of time before a persisted session cookie expires. If you do not
            specify a number of seconds, then the session cookie lifetime defaults to  remember_me_seconds ,
            which may be set using  Zend_Session::setOptions() . To help thwart session fixation/hijacking,
            use this function when a user successfully authenticates with your application (e.g., from a &quot;login&quot; form).
         forgetMe() 
            This function complements  rememberMe()  by writing a session cookie that has a lifetime ending
            when the user agent terminates.
         sessionExists() 
            Use this method to determine if a session already exists for the current user agent/request. It may be used
            before starting a session, and independently of all other  Zend_Session  and
             Zend_Session_Namespace  methods.
         destroy(bool $remove_cookie = true, bool $readonly = true) Zend_Session::destroy()  destroys all of the persistent data associated with the current
            session. However, no variables in PHP are affected, so your namespaced sessions (instances of
             Zend_Session_Namespace ) remain readable. To complete a &quot;logout&quot;, set the optional parameter to
             true  (the default) to also delete the user agent&#39;s session id cookie. The optional
             $readonly  parameter removes the ability to create new  Zend_Session_Namespace 
            instances and for  Zend_Session  methods to write to the session data store.
         
            If you see the error message, &quot;Cannot modify header information - headers already sent&quot;, then either avoid
            using  true  as the value for the first argument (requesting removal of the session cookie), or
            see  . Thus,
             Zend_Session::destroy(true)  must either be called before PHP has sent HTTP headers, or output
            buffering must be enabled. Also, the total output sent must not exceed the set buffer size, in order to
            prevent triggering sending the output before the call to  destroy() .
         Throws 
                By default,  $readonly  is enabled and further actions involving writing to the session data
                store will throw an exception.
             stop() 
            This method does absolutely nothing more than toggle a flag in Zend_Session to prevent further writing to
            the session data store. We are specifically requesting feedback on this feature. Potential uses/abuses might
            include temporarily disabling the use of  Zend_Session_Namespace  instances or
             Zend_Session  methods to write to the session data store, while execution is transfered to view-
            related code. Attempts to perform actions involving writes via these instances or methods will throw an
            exception.
         writeClose($readonly = true) 
            Shutdown the session, close writing and detach  $_SESSION  from the back-end storage mechanism.
            This will complete the internal data transformation on this request. The optional  $readonly 
            boolean parameter can remove write access by throwing an exception upon any attempt to write to the session
            via  Zend_Session  or  Zend_Session_Namespace .
         Throws 
                By default,  $readonly  is enabled and further actions involving writing to the session data
                store will throw an exception. However, some legacy application might expect  $_SESSION  to
                remain writable after ending the session via  session_write_close() . Although not considered
                &quot;best practice&quot;, the  $readonly  option is available for those who need it.
             expireSessionCookie() 
            This method sends an expired session id cookie, causing the client to delete the session cookie. Sometimes
            this technique is used to perform a client-side logout.
         setSaveHandler(Zend_Session_SaveHandler_Interface $interface) 
            Most developers will find the default save handler sufficient. This method provides an object-oriented
            wrapper for
             session_set_save_handler() .
         namespaceIsset($namespace) 
            Use this method to determine if a session namespace exists, or if a particular index exists in a particular
            namespace.
         Throws 
                An exception will be thrown if  Zend_Session  is not marked as readable (e.g., before  
                Zend_Session  has been started).
             namespaceUnset($namespace) 
            Use  Zend_Session::namespaceUnset($namespace)  to efficiently remove an entire namespace and its
            contents. As with all arrays in PHP, if a variable containing an array is unset, and the array contains
            other objects, those objects will remain available, if they were also stored by reference in other
            array/objects that remain accessible via other variables. So  namespaceUnset()  does not perform
            a &quot;deep&quot; unsetting/deleting of the contents of the entries in the namespace. For a more detailed
            explanation, please see  References Explained  in the PHP
            manual.
         Throws 
                An exception will be thrown if the namespace is not writable (e.g., after  destroy() ).
             namespaceGet($namespace) 
            DEPRECATED: Use  getIterator()  in  Zend_Session_Namespace . This method returns an
            array of the contents of  $namespace . If you have logical reasons to keep this method publicly
            accessible, please provide feedback to the
             fw-auth@lists.zend.com  mail list. Actually, all
            participation on any relevant topic is welcome :)
         Throws 
                An exception will be thrown if  Zend_Session  is not marked as readable (e.g., before
                 Zend_Session  has been started).
             getIterator() 
            Use  getIterator()  to obtain an array containing the names of all namespaces.
         Throws 
                An exception will be thrown if  Zend_Session  is not marked as readable (e.g., before
                 Zend_Session  has been started).
             Introduction 
        The Zend Framework Auth team greatly appreciates your feedback and contributions on our email list:
         fw-auth@lists.zend.com 
     
        With web applications written using PHP, a  session  represents a logical,
        one-to-one connection between server-side, persistent state data and a particular user agent client (e.g., web
        browser).  Zend_Session  helps manage and preserve session data, a logical complement of cookie
        data, across multiple page requests by the same client. Unlike cookie data, session data are not stored on the
        client side and are only shared with the client when server-side source code voluntarily makes the data
        available in response to a client request. For the purposes of this component and documentation, the term
        &quot;session data&quot; refers to the server-side data stored in
         $_SESSION ,
        managed by  Zend_Session , and individually manipulated by  Zend_Session_Namespace 
        accessor objects.  Session namespaces  provide access to session data using
        classic  namespaces 
        implemented logically as named groups of associative arrays, keyed by strings (similar to normal PHP arrays).
     Zend_Session_Namespace  instances are accessor objects for namespaced slices of
         $_SESSION . The  Zend_Session  component wraps the existing PHP ext/session with an
        administration and management interface, as well as providing an API for  Zend_Session_Namespace  to
        persist session namespaces.  Zend_Session_Namespace  provides a standardized, object-oriented
        interface for working with namespaces persisted inside PHP&#39;s standard session mechanism. Support exists for
        both anonymous and authenticated (e.g., &quot;login&quot;) session namespaces.  Zend_Auth , the authentication
        component of the Zend Framework, uses  Zend_Session_Namespace  to store some information associated
        with authenticated users. Since  Zend_Session  uses the normal PHP ext/session functions internally,
        all the familiar configuration options and settings apply (see
         http://www.php.net/session ), with such bonuses as the
        convenience of an object-oriented interface and default behavior that provides both best practices and smooth
        integration with the Zend Framework. Thus, a standard PHP session identifier, whether conveyed by cookie or
        within URLs, maintains the association between a client and session state data.
     
        The default
         ext/session save
        handler  does not maintain this association for server clusters under certain conditions because session
        data are stored to the filesystem of the server that responded to the request. If a request may be processed by
        a different server than the one where the session data are located, then the responding server has no access to
        the session data (if they are not available from a networked filesystem). A list of additional, appropriate
        save handlers will be provided, when available. Community members are encouraged to suggest and submit save
        handlers to the  fw-auth@lists.zend.com  list. A Zend_Db
        compatible save handler has been posted to the list.
     Working with Zend_TimeSync Zend_TimeSync  can return the actual time from any given
         NTP  or  SNTP  timeserver.
        It can automatically handle multiple servers and provides a simple interface.
     
            In all examples within this chapter we are using one of the available public generic timeservers.
            In our case  0.europe.pool.ntp.org . For your environment
            it is recommended that you are using a public generic timeserver which is nearly to the location
            of your server. See  http://www.pool.ntp.org  for
            details.
         Generic timeserver request 
            Requesting the time from a timeserver is quite simple. All you have to give is the timeserver
            from which you want to have the time.
         &lt;?php
require_once &#39;Zend/TimeSync.php&#39;;

$server = new Zend_TimeSync(&#39;0.pool.ntp.org&#39;);

print $server-&gt;getDate()-&gt;getIso();
         
            So what is happening in the background of  Zend_TimeSync ? First the syntax of the
            given server is checked. So in our example &#39; 0.pool.ntp.org &#39; is checked and
            recognised as possible correct adress for a timeserver. Then when calling
             getDate()  the actual set timeserver is requested and it will return it&#39;s own
            time.  Zend_TimeSync  then calculates the difference to the actual time of the
            server running the script and returns a  Zend_Date  object with the actual,
            corrected time.
         
            For details about  Zend_Date  and it&#39;s methods you can refer to
             Zend_Date .
         Multiple timeservers 
            Not all timeservers are always available and will return their time. Servers will have a time
            where they can not be reached, for example when having a maintenance. In such cases, when the
            time can not be requested from the timeserver, you would get an exception.
         
            As simple solution  Zend_TimeSync  can handle multiple timeservers and supports a
            automatic fallback machanism. There are two supported ways. You can either give an array
            of timeservers when creating the instance. Or you can add additionally timeservers afterwards
            with the  addServer()  method.
         &lt;?php
require_once &#39;Zend/TimeSync.php&#39;;

$server = new Zend_TimeSync(array(&#39;0.pool.ntp.org&#39;,
                                  &#39;1.pool.ntp.org&#39;,
                                  &#39;2.pool.ntp.org&#39;));
$server-&gt;addServer(&#39;3.pool.ntp.org&#39;);

print $server-&gt;getDate()-&gt;getIso();
         
            There is no limitation in the ammount of timeservers you can add. When a timeserver can not
            be reached  Zend_TimeSync  will fallback and try to connect to the next given timeserver.
         
            When you give more than one timeserver, which should be your default behaviour, you should name
            your servers. You can either name your servers with the array key, but also with the second
            parameter at initiation or addition of an other timeserver.
         &lt;?php
require_once &#39;Zend/TimeSync.php&#39;;

$server = new Zend_TimeSync(array(&#39;generic&#39;  =&gt; &#39;0.pool.ntp.org&#39;,
                                  &#39;fallback&#39; =&gt; &#39;1.pool.ntp.org&#39;,
                                  &#39;reserve&#39;  =&gt; &#39;2.pool.ntp.org&#39;));
$server-&gt;addServer(&#39;3.pool.ntp.org&#39;, &#39;additional&#39;);

print $server-&gt;getDate()-&gt;getIso();
         
            Naming the timeservers gives you the ability to request a specific timeserver as we will see
            later in this chapter.
         Protocols of timeservers 
            There are different types of timeservers. The most public timeservers are using
             NTP  as protocol. But there are different other
            protocols available.
         
            You can set the proper protocol within the address of the timeserver. Actual there are two
            protocols which are supported by  Zend_TimeSync . The default protocol is
             NTP . If you are only using NTP you can ommit the protocol
            within the address as show in the previous examples.
         &lt;?php
require_once &#39;Zend/TimeSync.php&#39;;

$server = new Zend_TimeSync(array(&#39;generic&#39;  =&gt; &#39;ntp:\\0.pool.ntp.org&#39;,
                                  &#39;fallback&#39; =&gt; &#39;ntp:\\1.pool.ntp.org&#39;,
                                  &#39;reserve&#39;  =&gt; &#39;ntp:\\2.pool.ntp.org&#39;));
$server-&gt;addServer(&#39;sntp:\\internal.myserver.com&#39;, &#39;additional&#39;);

print $server-&gt;getDate()-&gt;getIso();
         Zend_TimeSync  is able to handle mixed timeservers. So you are not restricted to
            only one protocol, but you can add any server independently from it&#39;s protocol.
         Using ports for timeservers 
            As every protocol within the world wide web, the  NTP  and
             SNTP  protocols are using standard ports. NTP uses port
             123  and SNTP uses  37 .
         
            But sometimes the used port differ from the standard one. You can define the port which
            has to be used for each server within the address. Just add the number of the port behind the
            address. If no port is defined, then  Zend_TimeSync  will use the standard port.
         &lt;?php
require_once &#39;Zend/TimeSync.php&#39;;

$server = new Zend_TimeSync(array(&#39;generic&#39;  =&gt; &#39;ntp:\\0.pool.ntp.org:200&#39;,
                                  &#39;fallback&#39; =&gt; &#39;ntp:\\1.pool.ntp.org&#39;));
$server-&gt;addServer(&#39;sntp:\\internal.myserver.com:399&#39;, &#39;additional&#39;);

print $server-&gt;getDate()-&gt;getIso();
         Options for timeservers 
            Actually there is only one option within  Zend_TimeSync  which will be used internally.
            But you can set any self defined option you are in need for and request it.
         
            The option  timeout  defines the number of seconds after which
            a connection is detected as broken when there was no response. The default value is
             1 , which means that  Zend_TimeSync  will
            fallback to the next timeserver is the actual requested timeserver does not respond in one second.
         
            With the  setOptions()  method, you can set any option. It accepts an array where the
            key is the option to set and the value is the value of that option. Any previous set option will
            be overwritten by the new value. If you want to know which options are set, use the
             getOptions()  method. It accepts either a key which returns the given option if set
            or, if no key is set, it will return all set options.
         &lt;?php
require_once &#39;Zend/TimeSync.php&#39;;

Zend_TimeSync::setOptions(array(&#39;timeout&#39; =&gt; 3, &#39;myoption&#39; =&gt; &#39;timesync&#39;));
$server = new Zend_TimeSync(array(&#39;generic&#39;  =&gt; &#39;ntp:\\0.pool.ntp.org&#39;,
                                  &#39;fallback&#39; =&gt; &#39;ntp:\\1.pool.ntp.org&#39;));
$server-&gt;addServer(&#39;sntp:\\internal.myserver.com&#39;, &#39;additional&#39;);

print $server-&gt;getDate()-&gt;getIso();
print_r(Zend_TimeSync::getOptions();
print &quot;Timeout = &quot; . Zend_TimeSync::getOptions(&#39;timeout&#39;);
         
            As you can see the options for  Zend_TimeSync  are static, which means that each
            instance of  Zend_TimeSync  will act with the same options.
         Using different timeservers 
            The default behaviour for requesting a time is to request it from the first given server.
            But sometimes it is useful to set a different timeserver from which to request the time.
            This can be done with the  setServer()  method. To define the used timeserver
            just set the alias as parameter within the method. And to get the actual used timeserver
            just call the  getServer()  method. It accepts an alias as parameter which
            defined the timeserver to be returned. If no parameter is given, the current timeserver will
            be returned.
         &lt;?php
require_once &#39;Zend/TimeSync.php&#39;;

$server = new Zend_TimeSync(array(&#39;generic&#39;  =&gt; &#39;ntp:\\0.pool.ntp.org&#39;,
                                  &#39;fallback&#39; =&gt; &#39;ntp:\\1.pool.ntp.org&#39;));
$server-&gt;addServer(&#39;sntp:\\internal.myserver.com&#39;, &#39;additional&#39;);

$actual = $server-&gt;getServer();
$server = $server-&gt;setServer(&#39;additional&#39;);
         Informations from timeservers 
            Timeservers offer not only the time itself but also additionally informations. You can
            get these informations with the  getInfo()  method.
         &lt;?php
require_once &#39;Zend/TimeSync.php&#39;;

$server = new Zend_TimeSync(array(&#39;generic&#39;  =&gt; &#39;ntp:\\0.pool.ntp.org&#39;,
                                  &#39;fallback&#39; =&gt; &#39;ntp:\\1.pool.ntp.org&#39;));

print_r ($server-&gt;getInfo());
         
            The returned informations differ with the used protocols and they can also differ with the used
            servers.
         Taking care of exceptions 
            Exceptions are collected for all timeserver and will be returned as array. So you are able
            to iterate through all throwed exceptions like shown in the following example:
         &lt;?php
$serverlist = array(
        // invalid servers
        &#39;invalid_a&#39;  =&gt; &#39;ntp://a.foo.bar.org&#39;,
        &#39;invalid_b&#39;  =&gt; &#39;sntp://b.foo.bar.org&#39;,
);

$server = new Zend_TimeSync($serverlist);

try {
    $result = $server-&gt;getDate();
    echo $result-&gt;getIso();
} catch (Zend_TimeSync_Exception $e) {

    $exceptions = $e-&gt;get();

    foreach ($exceptions as $key =&gt; $myException) {
        echo $myException-&gt;getMessage();
        echo &#39;&lt;br /&gt;&#39;;
    }
}
         Introduction Zend_TimeSync  is able to receive internet or network time from a timeserver using
        the  NTP  or  SNTP  protocol.
        With  Zend_TimeSync  the Zend Framework is able to act indepentendly from the
        timesettings of the server where it is running.
     
        To be independent from the actual time of the server,  Zend_TimeSync  does internally
        work just with the difference of the real time which is send through NTP or SNTP and the internal
        servers time.
     Background Zend_TimeSync  is not able to change the server&#39;s time, but it will return a
             Zend_Date  instance from which the difference
            to the servers time can be worked with.
         Why  Zend_TimeSync  ? 
            So why would someone use  Zend_TimeSync  ?
         
            Normally every server within a multiserver farm will have a service running which syncronises
            the own time with a timeserver. So within a standard environment it should not be necessary to
            use  Zend_TimeSync . But it can become handy if there is no service available and if
            you don&#39;t have the right to install such a service.
         
            Here are some example usecases, where  Zend_TimeSync  is perfect suited for:
         Server without timeservice 
                    If your application is running on a server and this server does not have any timeservice
                    running it can be good to implement  Zend_TimeSync  within the own application.
                 Seperated database server 
                    If your database is running on a seperated server and the other server is not connected
                    with  NTP  or  SNTP 
                    to the application server you would expect problems with data stored into the database
                    where timestamps are used.
                 Multiple servers 
                    If your application is running on more than one server and the timebase of this servers
                    are not coupled together you can expect problems within your application when part of
                    the application are coming from one server and others from other servers.
                 Batch processing 
                    If your want to include or work with a timeservice within a batch file or within a
                    command line application.
                 
            In all this cases  Zend_TimeSync  is a perfect solution and can be used if you are
            not able to run any service on your server.
         What is NTP ? 
            The  Network Time Protocol  ( NTP ) is a protocol
            for synchronizing the clocks of computer systems over packet-switched, variable-latency data
            networks. NTP uses UDP port 123 as it&#39;s transport layer. See
             this wikipedia article 
            for details about this protocol.
         What is SNTP? 
            The  Simple Network Time Protocol  ( SNTP ) is a
            protocol for syncronising with clocks of computer systems over packet-switched, variable-latency
            data networks. SNTP uses UDP port 37 as it&#39;s transport layer. It is nearly related to the
             NTP  Protocol but simpler.
         Problematic usage 
            Be warned that when you are using  Zend_TimeSync  you will have to think about some
            details related to the structure of timesync and the web itself. How problems can be avoided
            and best practice will be described here. Read carefully before using  Zend_TimeSync .
         Decide which server to use 
            You have to select the timeserver which you want to use very carefully. This has several reasons
            which are described here:
         
                    Distance
                 
                    The distance from the server where your application is running to the timeserver you are
                    requesting. If your server is in europe it would make no sense to use a timeserver in
                    tahiti. Select always a server which is not far away. This reduces the time for the
                    request and reduced network load.
                 
                    Speed
                 
                    How long it takes to receive the request is also relevant. Try some servers to get the
                    best result. If you are requesting a server which is never accessible you will always
                    have a unnecessary delay.
                 
                    Splitting
                 
                    Do not use always the same server. All timeservers will lock request from servers which
                    are flooding the server. If your application makes excessive use of timeservers you
                    should not use a single timeserver but one of the pools described later.
                 
            So where can you find a timeserver ? Generally you can use any timeserver you know. This can be
            a timeserver within you LAN or any public timeserver you know. If you decide to use a public
            timeserver you should use a server pool. Serverpools are public addresses where you will get
            a random timeserver from the pool if you request the time. This way you will not have to split your
            requests. There are public serverpools available for different regions so you will not have any of the
            problems mentioned above.
         
            Take a look at  pool.ntp.org  to get your nearest
            serverpool. So if your server is located within germany for example you can connect to
             0.europe.pool.ntp.org  and so on.
         Adapters for Zend_Translate 
        Zend_Translate can handle different adapters for translation.
        Each adapter has its own advantages and disadvantages.
        Below is a comprehensive list of all supported adapters for
        translation source files.
     Adapters for Zend_Translate Adapter Description Usage Array Use php arrays Small pages; simplest usage; only for programmers Csv Use comma seperated (*.csv/*.txt) files Simple text file format; very fast; possible problems with unicode characters Gettext Use binary gettext (*.mo) files GNU standard for linux; very fast; thread-safe; needs tools for translation Tbx Use termbase exchange (*.tbx/*.xml) files Industry standard for inter application terminology strings; XML format Tmx Use tmx (*.tmx/*.xml) files Industry standard for inter application translation; XML format; human readable Qt Use qt linguist (*.ts) files Cross platform application framework; XML format; human readable Xliff Use xliff (*.xliff/*.xml) files A simpler format as TMX but related to it; XML format; human readable XmlTm Use xmltm (*.xml) files Industry standard for XML document translation memory; XML format; human readable Others *.sql Different other adapters may be implemented in the future How to decide which translation adapter to use 
            You should decide which Adapter you want to use for Zend_Translate.
            Frequently, external criteria such as a project requirement or
            a customer requirement determines this for you, but if you are in
            the position to do this yourself, the following hints may simplify
            your decision.
         Zend_Translate_Adapter_Array 
                The Array Adapter is the Adapter which is simplest to use for
                programmers.
                But when you have numerous translation strings or many
                languages you should think about another Adapter.
                For example, if you have 5000 translation strings,
                the Array Adapter is possibly not the best choice for you.
             
                You should only use this Adapter for small sites with a handful
                of languages, and if you or your programmer team creates the
                translations yourselves.
             Zend_Translate_Adapter_Csv 
                The Csv Adapter is the Adapter which is simplest to use for
                customers.
                CSV files are readable by standard text editors, but
                text editors often do not support utf8 character sets.
             
                You should only use this Adapter if your customer wants to do
                translations himself.
             Zend_Translate_Adapter_Gettext 
                The Gettext Adapter is the Adapter which is used most
                frequently.  Gettext is a translation source format which was
                introduced by GNU, and is now used worldwide.
                It is not human readable, but there are several freeware tools
                (for instance,  POEdit ), which are very helpful.
                The Zend_Translate Gettext Adapter is not implemented using
                PHP&#39;s gettext extension.
                You can use the Gettext Adapter even if you do not have
                the PHP gettext extension installed.
                Also the Adapter is thread-safe and the PHP gettext extension
                is currently not thread-safe.
             
                Most people will use this adapter.
                With the available tools, professional translation is
                very simple.  But gettext data are is stored in a
                machine-readable format, which is not readable without tools.
             Zend_Translate_Adapter_Tbx 
                The Tbx Adapter is an Adapter which will be used by customers
                which already use the TBX format for their internal translation
                system. Tbx is no standard translation format but more a collection
                of already translated and pre translated source strings. When you
                use this adapter you have to be sure that all your needed source
                string are translated.
                TBX is a XML file based format and a completly new format.
                XML files are human-readable, but the parsing is not as fast
                as with gettext files.
             
                This adapter is perfect for companies when pre translated
                source files already exist.
                The files are human readable and system-independent.
             Zend_Translate_Adapter_Tmx 
                The Tmx Adapter is the Adapter which will be used by most
                customers which have multiple systems which use the same
                translation source, or when the translation source must be
                system-independent.
                TMX is a XML file based format, which is announced to be the
                next industry standard.
                XML files are human-readable, but the parsing is not as fast
                as with gettext files.
             
                Most medium to large companies use this adapter.
                The files are human readable and system-independent.
             Zend_Translate_Adapter_Qt 
                The Qt Adapter is for all customers which have TS files as their
                translation source which are made by QtLinguist.
                QT is a XML file based format.
                XML files are human-readable, but the parsing is not as fast
                as with gettext files.
             
                Several big players have build software upon the QT framework.
                The files are human readable and system-independent.
             Zend_Translate_Adapter_Xliff 
                The Xliff Adapter is the Adapter which will be used by most
                customers which want to have XML files but do not have tools
                for TMX.
                XLIFF is a XML file based format, which is related to TMX but
                simpler as it does not support all possibilities of it.
                XML files are human-readable, but the parsing is not as fast
                as with gettext files.
             
                Most medium companies use this adapter.
                The files are human readable and system-independent.
             Zend_Translate_Adapter_XmlTm 
                The XmlTm Adapter is the Adapter which will be used by customers
                which do their layout themself. XmlTm is a format which allows the
                complete html source to be included in the translation source, so
                the translation is coupled with the layout.
                XLIFF is a XML file based format, which is related to XLIFF but
                its not as simple to read.
             
                This adapter sould only be used when source files already exist.
                The files are human readable and system-independent.
             Integrate self written Adapters 
            Zend_Translate allows you to integrate and use self written Adapter
            classes. They can be used like the standard Adapter classes which
            are already included within Zend_Translate.
         
            Any adapter class you want to use with Zend_Translate must be a subclass
            of Zend_Translate_Adapter. Zend_Translate_Adapter is an abstract class
            which already defines all what is needed for translation. What has to be
            done by you, is the definition of the reader for translation datas.
         
            The usage of the prefix &quot;Zend&quot; should be limited to the Zend_Framework.
            If you extend Zend_Translate with your own adapter, you should name it
            like &quot;Company_Translate_Adapter_MyFormat&quot;. The following code shows an
            example of how a self written adapter class could be implemented:
         &lt;?php
require_once &#39;Zend/Translate.php&#39;;

try {
    $translate = new Zend_Translate(&#39;Company_Translate_Adapter_MyFormat&#39;, &#39;/path/to/translate.xx&#39;, &#39;en&#39;, array(&#39;myoption&#39; =&gt; &#39;myvalue&#39;));
} catch (Exception $e) {
    // File not found, no adapter class...
    // General failure
}
         Speedup all Adapters Zend_Translate  allows you use internally  Zend_Cache  to
            fasten the loading of translation sources. This comes very handy if you use many
            translation sources or extensive source formats like XML based files.
         
            To use caching you will just have to give a cache object to the
             Zend_Translate::setCache()  method. It takes a instance of
             Zend_Cache  as only parameter. Also if you use any adapter direct you
            can use the  setCache()  method.
         &lt;?php
require_once &#39;Zend/Translate.php&#39;;

$cache = Zend_Cache::factory(&#39;Page&#39;, &#39;File&#39;, $frontendOptions, $backendOptions);
Zend_Translate::setCache($cache);
$translate = new Zend_Translate(&#39;gettext&#39;, &#39;/path/to/translate.mo&#39;, &#39;en&#39;);
         
                You must set the cache  before  you use or initiate
                any adapter or instance of  Zend_Translate . Otherwise your translation
                source will not be cached until you add a new source with the
                 addTranslation()  method.
             Introduction 
        Zend_Translate is the Zend Framework&#39;s solution for multilingual
        applications.
     
        In multilingual applications, the content must be translated into
        several languages and display content depending on the user&#39;s language.
        PHP offers already several ways to handle such problems, however
        the PHP solution has some problems:
     Inconsistent API: 
                There is no single API for the different source formats.
                The usage of gettext for example is very complicated.
             PHP supports only gettext and native array: 
                PHP itself offers only support for array or gettext.
                All other source formats have to be coded manually,
                because there is no native support.
             No detection of the default language: 
                The default language of the user cannot be detected without
                deeper knowledge of the backgrounds for
                the different web browsers.
             Gettext is not thread-safe: 
                PHP&#39;s gettext library is not thread safe, and it
                should not be used in a multithreaded environment.
                This is due to problems with gettext itself, not PHP,
                but it is an existing problem.
             
        Zend_Translate does not have the above problems. This is why we
        recommend using Zend_Translate instead of PHP&#39;s native functions.
        The benefits of Zend_Translate are:
     Supports multiple source formats: 
                Zend_Translate supports several source formats, including
                those supported by PHP, and other formats including TMX
                and CSV files.
             Thread-safe gettext: 
                The gettext reader of Zend_Translate is thread-safe.
                There are no problems using it in multi-threaded environments.
             Easy and generic API: 
                The API of Zend_Translate is very simple and requires only a
                handful of functions.
                So it&#39;s easy to learn and easy to maintain.
                All source formats are handled the same way, so if the format
                of your source files change from Gettext to TMX,
                you only need to change one line of code to specify the
                storage adapter.
             Detection of the user&#39;s standard language: 
                The preferred language of the user accessing the site can be
                detected and used by Zend_Translate.
             Automatic source detection: 
                Zend_Translate is captable of detecting and integrating multiple source files
                and additionally detect the locale to be used depending on directory or filenames.
             Starting multi-lingual 
            So let&#39;s get started with multi-lingual business.
            What we want to do is translate our string
            output so the view produces the translated output.
            Otherwise we would have to write one view
            for each language, and no one would like to do this.
            Generally, multi-lingual sites are very simple in their design.
            There are only four steps you would have to do:
         
                    Decide which adapter you want to use;
                 
                    Create your view and integrate Zend_Translate in your code;
                 
                    Create the source file from your code;
                 
                    Translate your source file to the desired language.
                 
            The following sections guide you through all four steps.
            Read through the next few pages to create your own
            multi-lingual web application.
         Using Translation Adapters 
        The next step is to use the adapter within your code.
     Example of single-language PHP code &lt;?php
print &quot;Example\n&quot;;
print &quot;=======\n&quot;;
print &quot;Here is line one\n&quot;;
print &quot;Today is the &quot; . date(&quot;d.m.Y&quot;) . &quot;\n&quot;;
print &quot;\n&quot;;
print &quot;Fix language here is line two\n&quot;;
         
        The example above shows some output with no support for translation.
        You probably write your code in your native language.
        Generally you need to translate not only the output,
        but also error messages and log messages.
     
        The next step is to include Zend Translate in your existing code.
        Of course it is much easier if you are writing your code using
        Zend_Translate instead of changing your code afterwards.
     Example of multi-lingual PHP code &lt;?php
require_once(&quot;Zend/Translate.php&quot;);

$translate = new Zend_Translate(&#39;gettext&#39;, &#39;/my/path/source-de.mo&#39;, &#39;de&#39;);
$translate-&gt;addTranslation(&#39;//my/path/fr-source.mo&#39;, &#39;fr&#39;);

print $translate-&gt;_(&quot;Example&quot;).&quot;\n&quot;;
print &quot;=======\n&quot;;
print $translate-&gt;_(&quot;Here is line one&quot;).&quot;\n&quot;;
printf($translate-&gt;_(&quot;Today is the %1\$s&quot;) . &quot;\n&quot;, date(&quot;d.m.Y&quot;));
print &quot;\n&quot;;

$translate-&gt;setLocale(&#39;fr&#39;);
print $translate-&gt;_(&quot;Fix language here is line two&quot;) . &quot;\n&quot;;
         
        Now let&#39;s get a deeper look into what has been done and how to
        integrate Zend_Translate into your code.
     
        Create a new Translation object and define the base adapter:

         &lt;?php
require_once(&quot;Zend/Translate.php&quot;);

$translate = new Zend_Translate(&#39;gettext&#39;, &#39;/my/path/source-de.mo&#39;, &#39;de&#39;);
         

        In this example we decided the
         Gettext Adapter .
        We place our file  source-de.mo 
        into the directory  /my/path .
        The gettext file will have German translation included.
        And we also added another language source for French.
     
        The next step is to wrap all strings which are to be translated.
        The simplest approach is to have only simple strings or sentences
        like this:

         &lt;?php
print $translate-&gt;_(&quot;Example&quot;).&quot;\n&quot;;
print &quot;=======\n&quot;;
print $translate-&gt;_(&quot;Here is line one&quot;).&quot;\n&quot;;
         

        Some strings do not needed to be translated.
        The seperating line is always a seperating line,
        even in other languages.
     
        Having data values integrated into a translation string is also
        supported through the use of embedded parameters.

         &lt;?php
printf($translate-&gt;_(&quot;Today is the %1\$s&quot;) . &quot;\n&quot;, date(&quot;d.m.Y&quot;));
         

        Instead of  print() , use the  printf() 
        function and replace all parameters with  %1\$s  parts.
        The first is  %1\$s , the second  %2\$s ,
        and so on. This way a translation can be done without knowing
        the exact value. In our example, the date is always the actual day,
        but the string can be translated without the knowledge of the actual
        day.
     
        Each string is identified in the translation storage by a message id.
        You can use message id&#39;s instead of strings in your code, like this:

         &lt;?php
print $translate-&gt;_(1).&quot;\n&quot;;
print &quot;=======\n&quot;;
print $translate-&gt;_(2).&quot;\n&quot;;
         

        But doing this has several disadvantages:
     
        You can not see what your code should output just by viewing your code.
     
        Also you will get problems if some strings are not translated.
        You always must imagine how translation works.
        First Zend_Translate looks if the set language has a translation
        for the given message id or string.
        If no translation string has been found it refers to the next lower
        language as defined within Zend_Locale.
        So &quot; de_AT &quot; becomes
        &quot; de &quot; only.
        If there is no translation found for
        &quot; de &quot; either,
        then the original message is returned.
        This way you always have an output, in case the message translation
        does not exist in your message storage.
        Zend_Translate never throws an error or exception when translating
        strings.
     Translation Source Structures 
            Your next step is to create the translation sources for the several
            languages to which you translate.
            Every adapter is created its own way as described here.
            But there are some general features that are relevant for all adapters.
         
            You should know where to store your translation source files.
            With Zend_Translate you are not bound to any restriction.
            The following structures are preferable:
         
                    Single structured source
                 
/application
/languages
  lang.en
  lang.de
/library
                 
                    Positive: All source files for every languages can be
                    found in one directory.  No splitting of related files.
                 
                    Language structured source
                 
/application
/languages
  /en
    lang.en
    other.en
  /de
    lang.de
    other.de
/library
                 
                    Positive: Every language is based in one directory.
                    Easy translation as only one directory has to be
                    translated by a language team.
                    Also the usage of multiple files is transparent.
                 
                    Application structured source
                 
/application
  /languages
    lang.en
    lang.de
    other.en
    other.de
                 
                    Positive: All source files for every languages can be
                    found in one directory.  No splitting of related files.
                 
                    Negative: Having multiple files for the same language is
                    problematic.
                 
                    Gettext structured source
                 
/languages
  /de
    /LC_MESSAGES
      lang.mo
      other.mo
  /en
    /LC_MESSAGES
      lang.mo
      other.mo
                 
                    Positive: Old gettext sources can be used without changing
                    structure.
                 
                    Negative: Having sub-sub directories may be confusing
                    for people who have not used gettext before.
                 
                   File structured source
                 
/application
  /models
    mymodel.php
    mymodel.de
    mymodel.en
  /views
  /controllers
    mycontroller.de
/document_root
  /images
  /styles
  .htaccess
  index.php
  index.de
/library
  /Zend
                 
                    Positive: Every file is related to its own translation
                    source.
                 
                    Negative: Multiple small translation source files make
                    it harder to translate.
                    Also every file has to be added as translation source.
                 
            Single structured and language structured source files are most
            usable for Zend_Translate.
         
            So now, that we know which structure we want to have,
            we should create our translation source files.
         Creating array source files 
            Array source files are just arrays.  But you have to define them
            manually because there is no tool for this.
            But because they are so simple, it&#39;s the fastest way to look up
            messages if your code works as expected.  It&#39;s generally the best
            adapter to get started with translation business.
         
$english = array(&#39;message1&#39; =&gt; &#39;message1&#39;,
                 &#39;message2&#39; =&gt; &#39;message2&#39;,
                 &#39;message3&#39; =&gt; &#39;message3&#39;);
$german = array(&#39;message1&#39; =&gt; &#39;Nachricht1&#39;,
                &#39;message2&#39; =&gt; &#39;Nachricht2&#39;,
                &#39;message3&#39; =&gt; &#39;Nachricht3&#39;);

$translate = new Zend_Translate(&#39;array&#39;, $english, &#39;en&#39;);
$translate-&gt;addTranslation($deutsch, &#39;de&#39;);
         
            Since Release 1.5 it is also supported to have arrays included within a external file.
            You just have to give the filename and  Zend_Translate  will automatically
            include it and look for the array. See the following example for details:
         
// myarray.php
&lt;?php
return array(
    &#39;message1&#39; =&gt; &#39;Nachricht1&#39;,
    &#39;message2&#39; =&gt; &#39;Nachricht2&#39;,
    &#39;message3&#39; =&gt; &#39;Nachricht3&#39;);

// controller
$translate = new Zend_Translate(&#39;array&#39;, &#39;path/to/myarray.php&#39;, &#39;de&#39;);
         
                Files which do not return an array will fail to be included.
                Also any output within this file will be ignored and suppressed.
             Creating Gettext Source Files 
            Gettext source files are created by GNU&#39;s gettext library.
            There are several free tools available that can parse your
            code files and create the needed gettext source files.
            These files have the ending  *.mo 
            and they are binary files.
            One freeware tool for creating the files is
             poEdit .
            This tool also supports you for the translation process itself.
         
// We expect that we have created the mo files and translated them
$translate = new Zend_Translate(&#39;gettext&#39;, &#39;path/to/english.mo&#39;, &#39;en&#39;);
$translate-&gt;addTranslation(&#39;path/to/german.mo&#39;, &#39;de&#39;);
         
            As you can see the adapters are used exactly the same way,
            with only just one small difference.
            Change &#39;array&#39; to &#39;gettext&#39;.  All other usages are exactly
            the same as with all other adapters.
            With the gettext adapter you no longer have to be aware of
            gettext&#39;s standard directory structure,
            bindtextdomain and textdomain.
            Just give the path and filename to the adapter.
         
                 You should always use UTF-8 as source encoding.
                 Otherwise you will have problems if you are using two
                 different source encodings.
                 For example, if one of your source files is encoded
                 with ISO-8815-11 and another file is encoded with CP815.
                 You can set only one encoding for your source file,
                 so one of your languages probably will not display correctly.
             
                 UTF-8 is a portable format which supports all languages.
                 If you use UTF-8 encoding for all languages, you eliminate
                 the problem of incompatible encodings.
             Creating TMX Source Files 
            TMX source files are a new industry standard.
            They have the advantage of being XML files and so they are
            readable by every editor and of course they are human-readable.
            You can either create TMX files manually with a text editor,
            or you can use a tool. But most tools currently available for
            developing TMX source files are not freeware.
         Example TMX file 
&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE tmx SYSTEM &quot;tmx14.dtd&quot;&gt;
&lt;tmx version=&quot;1.4&quot;&gt;
 &lt;header creationtoolversion=&quot;1.0.0&quot; datatype=&quot;winres&quot; segtype=&quot;sentence&quot; adminlang=&quot;en-us&quot; srclang=&quot;de-at&quot; o-tmf=&quot;abc&quot; creationtool=&quot;XYZTool&quot; &gt;
 &lt;/header&gt;
 &lt;body&gt;
  &lt;tu tuid=&#39;message1&#39;&gt;
   &lt;tuv xml:lang=&quot;de&quot;&gt;&lt;seg&gt;Nachricht1&lt;/seg&gt;&lt;/tuv&gt;
   &lt;tuv xml:lang=&quot;en&quot;&gt;&lt;seg&gt;message1&lt;/seg&gt;&lt;/tuv&gt;
  &lt;/tu&gt;
  &lt;tu tuid=&#39;message2&#39;&gt;
   &lt;tuv xml:lang=&quot;en&quot;&gt;&lt;seg&gt;message2&lt;/seg&gt;&lt;/tuv&gt;
   &lt;tuv xml:lang=&quot;de&quot;&gt;&lt;seg&gt;Nachricht2&lt;/seg&gt;&lt;/tuv&gt;
  &lt;/tu&gt;
             
$translate = new Zend_Translate(&#39;tmx&#39;, &#39;path/to/mytranslation.tmx&#39;, &#39;en&#39;);
// TMX can have several languages within one TMX file.
             
            TMX files can have several languages within the same file.
            All other included languages are added automatically,
            so you do not have to call  addLanguage() .
         
            If you want to have only spezified languages from the source translated
            you can set the option  defined_language  to  true .
            With this option you can add the wished languages explicit with
             addLanguage() . The default value for this option is to add all
            languages.
         Creating CSV Source Files 
            CSV source files are small and human readable.
            If your customers want to translate their own,
            you will probably use the CSV adapter.
         Example CSV file 
ï»¿#Example csv file
message1;Nachricht1
message2;Nachricht2
             
$translate = new Zend_Translate(&#39;csv&#39;, &#39;path/to/mytranslation.csv&#39;, &#39;de&#39;);
$translate-&gt;addTranslation(&#39;path/to/other.csv&#39;, &#39;fr&#39;);
             
            The standard separator for CSV string is the &#39; ; &#39; sign.
            But it has not to be that sign. With the option &#39; separator &#39;
            you can decide to use another separator sign.
         
            If you have to have the separator sign within your translation string you
            just have to double it to be included within the translation. One separator
            sign will separate the origin and translation strings and two separator signs
            will write the separator signs within the string. See the following example
            for details
         Example CSV file two 
ï»¿#Example csv file
# original &#39;message,1&#39;
message,,1,Nachricht1
# translation &#39;Nachricht,2&#39;
message2,Nachricht,,2
# original &#39;message3,&#39;
message3,,,Nachricht3
             
$translate = new Zend_Translate(&#39;csv&#39;, &#39;path/to/mytranslation.csv&#39;, &#39;de&#39;, array(&#39;separator&#39; =&gt; &#39;,&#39;));
$translate-&gt;addTranslation(&#39;path/to/other.csv&#39;, &#39;fr&#39;);
             Options for adapters 
            Options can be used with all adapters. Of course the options are different for all adapters.
            You can set options when you create the adapter. Actually there is one option which is available
            to all adapters. &#39; clear &#39; decides if translation data shold be added to existing
            one or not. Standard behaviour is to add new translation data to existing one. But the
            translation data is only cleared for the selected language. So all other languages will not be
            touched.
         
            You can set options temporary when using  addTranslation($data, $locale, array $options = array()) .
            as third and optional parameter. And you can use the  setOptions()  function to
            set the options fix.
         Using translation options 
// define &#39;:&#39; as separator for the translation source files
$options = array(&#39;separator&#39; =&gt; &#39;:&#39;);
$translate = new Zend_Translate(&#39;csv&#39;, &#39;path/to/mytranslation.csv&#39;, &#39;de&#39;, $options);

...

// clear the defined language and use new translation data
$options = array(&#39;clear&#39; =&gt; true);
$translate-&gt;addTranslation(&#39;path/to/new.csv&#39;, &#39;fr&#39;, $options);
             
            Here you can find all available options for the different adapters with a description of their usage:
         Options for Translation Adapters Adapter Option Standard value Description all clear false If set to true, the already read translations will be cleared. This can be used
                        instead of creating a new instance when reading new translation data all scan null If set to null, no scanning of the directory structure will be done.
                        If set to Zend_Translate::LOCALE_DIRECTORY the locale will be detected within the
                        directory. It set to Zend_Translate::LOCALE_FILENAME the locale will be detected
                        within the filename. See  
                        for details Csv separator ; Defines which sign is used for seperating source and translation 
            When you want to have self defined options, you are also able to use them within all adapters.
            The  setOptions()  method can be used to define your option.  setOptions() 
            needs an array with the options you want to set. If an given option exists it will be signed over.
            You can define as much options as needed as they will not be checked by the adapter. Just get sure
            that you do not sign over any existing option which is used by an adapter.
         
            To return the set option you can use the  getOptions()  method. When  getOptions() 
            is called without an parameter it will return all set options. When the optional parameter is given
            you will only get the particular option returned.
         Handling languages 
            When working with different languages there are a few methods which will be useful.
         
            The  getLocale()  method can be used to get the actual set language. It can eigther hold
            an instance of  Zend_Locale  or the identifier of a locale.
         
            The  setLocale()  method sets a new standard language for translation. This prevents the
            need of setting the optional language parameter more than once to the  translate()  method.
            If the given language does not exist, or no translation data is available for the language,
             setLocale()  tries to downgrade to the language without the region if any was given.
            A language of  en_US  would be downgraded to  en . When also the downgraded
            language can not be found an exception will be thrown.
         
            The  isAvailable()  method checks if a given language is already available. It returns
             true  if data for the given language exist.
         
            And finally the  getList()  method can be used to get all actual set languages for an adapter
            returned as array.
         Handling languages with adapters 
...
// returns the actual set language
$actual = $translate-&gt;getLocale();

...
// you can use the optional parameter while translating
echo $translate-&gt;_(&quot;my_text&quot;, &quot;fr&quot;);
// or set a new standard language
$translate-&gt;setLocale(&quot;fr&quot;);
echo $translate-&gt;_(&quot;my_text&quot;);
// refer to the base language... fr_CH will be downgraded to fr and be used
$translate-&gt;setLocale(&quot;fr_CH&quot;);
echo $translate-&gt;_(&quot;my_text&quot;);

...
// check if this language exist
if ($translate-&gt;isAvailable(&quot;fr&quot;)) {
    // language exists
}
             Automatically handling of languages 
                Note that as long as you only add new translation sources with the  addTranslation() 
                method  Zend_Translate  will automatically set the best fitting language for your
                environment. So normally you will not need to call  setLocale() .
             
                The algorithmus will search for the best fitting locale depending on the users browser and
                your environment. See the following example for details:
             How automatically language detection works 
// Let&#39;s expect the browser returns this language settings
HTTP_ACCEPT_LANGUAGE = &quot;de_AT=1;fr=1;en_US=0.8&quot;;

// Example 1:
$translate = new Zend_Translate(&quot;gettext&quot;, &quot;\my_it.mo&quot;, &quot;it_IT&quot;);
$translate-&gt;addTranslation(&quot;\my_es.mo&quot;,&quot;es_UG&quot;);
// no fitting language found, return the messageid

// Example 2:
$translate = new Zend_Translate(&quot;gettext&quot;, &quot;\my_en.mo&quot;, &quot;en_US&quot;);
$translate-&gt;addTranslation(&quot;\my_it.mo&quot;,&quot;it_IT&quot;);
// best found fitting language is &quot;en_US&quot;

// Example 3:
$translate = new Zend_Translate(&quot;gettext&quot;, &quot;\my_it.mo&quot;, &quot;it_IT&quot;);
$translate-&gt;addTranslation(&quot;\my_de.mo&quot;,&quot;de&quot;);
// best found fitting language is &quot;de&quot; because &quot;de_AT&quot; will be degraded to &quot;de&quot;

// Example 4:
$translate = new Zend_Translate(&quot;gettext&quot;, &quot;\my_it.mo&quot;, &quot;it_IT&quot;);
$translate-&gt;addTranslation(&quot;\my_ru.mo&quot;,&quot;ru&quot;);
$translate-&gt;setLocale(&quot;it_IT&quot;);
$translate-&gt;addTranslation(&quot;\my_de.mo&quot;,&quot;de&quot;);
// returns &quot;it_IT&quot; as translation source
                 
                After setting a language manually with the  setLocale()  method the automatically
                detection will be switched off and overridden.
             
                If you want to use the automatic again, you can set the language
                 auto  with  setLocale()  which will reactivate
                the automatically detection for  Zend_Translate .
             Automatic source detection 
            Zend_Translate can detect translation sources automatically. So you don&#39;t have
            to declare each source file manually. You can let Zend_Translate do this job and
            scan the complete directory structure for source files. 
         
                Automatic source detection is available since Zend Framework version 1.5 .
             
            The usage is quite the same as initiating a single translation source with one difference.
            You must give a directory which has to be scanned instead a file.
         Scanning a directory structure for sources 
// expect we have the following structure
//  /language
//  /language/login/login.tmx
//  /language/logout/logout.tmx
//  /language/error/loginerror.tmx
//  /language/error/logouterror.tmx

$translate = new Zend_Translate(&#39;tmx&#39;, &#39;/language&#39;);
             
            So Zend_Translate does not only search the given directory, but also all subdirectories for
            translation source files. This makes the usage quite simple. But Zend_Translate will ignore all
            files which are not sources or which produce failures while reading the translation data. So you
            have to make sure that all of your translation sources are correct and readable because you will
            not get any failure if a file is bogus or can not be read.
         
                Depending on how deep your directory structure is and how much files are within this structure
                it can take a long time for Zend_Translate to complete.
             
            In our example we have used the TMX format which includes the language to be used within the
            source. But many of the other source formats are not able to include the language within the
            file. Even this sources can be used with automatic scanning if you do some pre-requisits as
            described below:
            scanned. 
         Language through naming directories 
                One way to include automatic language detection is to name the directories related to the
                language which is used for the sources within this directory. This is the easiest way and
                is used for example within standard gettext implementations.
             
                Zend_Translate needs the &#39;scan&#39; option to know that it should search the names of all
                directories for languages. See the following example for details:
             Directory scanning for languages 
// expect we have the following structure
//  /language
//  /language/de/login/login.tmx
//  /language/de/error/loginerror.tmx
//  /language/en/login/login.tmx
//  /language/en/error/loginerror.tmx

$translate = new Zend_Translate(&#39;gettext&#39;, &#39;/language&#39;, null, array(&#39;scan&#39; =&gt; Zend_Translate::LOCALE_DIRECTORY));
                 
                    This works only for adapters which do not include the language within the source file.
                    Using this option for example with TMX will be ignored. Also language definitions within
                    the filename will be ignored when using this option.
                 
                    You should be aware if you have several subdirectories under the same
                    structure. Expect we have a structure like
                     /language/module/de/en/file.mo . The path contains in this case
                    multiple strings which would be detected as locale. It could be eigther
                     de  or  en . As the behaviour is, in this case,
                    not declared it is recommended that you use file detection in such situations.
                 Language through filenames 
                Another way to detect the langage automatically is to use special filenames. You can either
                name the complete file or parts of a file with the used language. To use this way of detection
                you will have to set the &#39;scan&#39; option at initiation. There are several ways of naming the
                sourcefiles which are described below:
             Filename scanning for languages 
// expect we have the following structure
//  /language
//  /language/login/login_en.tmx
//  /language/login/login_de.tmx
//  /language/error/loginerror_en.tmx
//  /language/error/loginerror_de.tmx

$translate = new Zend_Translate(&#39;gettext&#39;, &#39;/language&#39;, null, array(&#39;scan&#39; =&gt; Zend_Translate::LOCALE_FILENAME));
                 Complete Filename 
                    Having the whole file named after the language is the simplest way but only usable
                    if you have only one file per directory.
                 
/languages
  en.mo
  de.mo
  es.mo
                 Extension of the file 
                    Another very simple way if to use the extension of the file for the language detection.
                    But this may be confusing because you will no longer know which file extension the file
                    originally was.
                 
/languages
  view.en
  view.de
  view.es
                 Filename tokens 
                    Zend_Translate is also captable of detecting the language if it is included within the
                    filename. But if you use this way you will have to seperate the language with a token.
                    There are three supported tokens which can be used: A point &#39;.&#39;, a underline &#39;_&#39;, or
                    a hyphen &#39;-&#39;.
                 
/languages
  view_en.mo  -&gt; detects english
  view_de.mo  -&gt; detects german
  view_it.mo  -&gt; detects italian
                 
                    The first found token which can be detected as locale will be used. See the following
                    example for details.
                 
/languages
  view_en_de.mo  -&gt; detects english
  view_en_es.mo  -&gt; detects english and overwrites the first file because the same messageids are used
  view_it_it.mo  -&gt; detects italian
                 
                    All three tokens are used to detect the locale. The first one is the point &#39;.&#39;, the second
                    is the underline &#39;_&#39; and the third the hyphen &#39;-&#39;. If you have several tokens within the
                    filename the first found depending on the order of the tokens will be used. See the following
                    example for details.
                 
/languages
  view_en-it.mo  -&gt; detects english because &#39;_&#39; will be used before &#39;-&#39;
  view-en_it.mo  -&gt; detects italian because &#39;_&#39; will be used before &#39;-&#39;
  view_en.it.mo  -&gt; detects italian because &#39;.&#39; will be used before &#39;_&#39;
                 Checking for translations 
            Normally text will be translated without any computations. But sometimes it is necessary to
            know if a text is translated or not within the source. Therefor the  isTranslated() 
            method can be used.
         isTranslated($messageId, $original = false, $locale = null)  takes as first parameter
            the text from which you want to know if it can be translated. And as optional third parameter the locale
            for which you want to know the translation. The optional second parameter declares if translation
            is fixed to the declared language or a lower set of translations can be used. If you have a text which
            can be translated by &#39;en&#39; but not for &#39;en_US&#39; you will normally get the translation returned, but by
            setting  $original  to true, the  isTranslated()  method will return false in
            such cases.
         Checking if a text is translatable 
$english = array(&#39;message1&#39; =&gt; &#39;Nachricht 1&#39;,
                 &#39;message2&#39; =&gt; &#39;Nachricht 2&#39;,
                 &#39;message3&#39; =&gt; &#39;Nachricht 3&#39;);
$translate = new Zend_Translate(&#39;array&#39;, $english, &#39;de_AT&#39;);

if ($translate-&gt;isTranslated(&#39;message1&#39;)) {
    print &quot;&#39;message1&#39; can be translated&quot;;
}
if (!($translate-&gt;isTranslated(&#39;message1&#39;, true, &#39;de&#39;))) {
    print &quot;&#39;message1&#39; can not be translated in &#39;de&#39; as it&#39;s only available in &#39;de_AT&#39;&quot;;
}
if ($translate-&gt;isTranslated(&#39;message1&#39;, false, &#39;de&#39;)) {
    print &quot;&#39;message1&#39; can be translated in &#39;de_AT&#39; falls back to &#39;de&#39;&quot;;
}
             Access to the source data 
            Of course sometimes it is useful to have access to the translation source data. Therefor two
            functions exist.
         
            The  getMessageIds($locale = null)  method returns all known message ids as array.
         
            And the  getMessages($locale = null)  method returns the complete translation source as
            array. The message id is used as key and the translation data as value.
         
            Both methods accept an optional parameter  $locale  which, when set, returns the
            translation data for the specified language. If this parameter is not given, the actual set
            language will be used. Keep in mind that normally all translations should be available in all
            languages. Which means that in a normal situation you will not have to set this parameter.
         
            Additionally the  getMessages()  method is able to return the complete
            translation dictionary with the pseudo-locale &#39;all&#39;. This will return all available
            translation data for each added locale.
         
                Attention: The returned array can be  very big ,
                depending on the count of added locales and the amount of translation data.
             Handling languages with adapters 
...
// returns all known message ids
$messageids = $translate-&gt;getMessageIds();
print_r($messageids);

...
// or just for the specified language
$messageids = $translate-&gt;getMessageIds(&#39;en_US&#39;);
print_r($messageids);

...
// returns all the complete translation data
$source = $translate-&gt;getMessages();
print_r($source);
             Zend_Uri Overview Zend_Uri  is a component that aids in manipulating and
      validating  Uniform Resource
      Identifiers  (URIs).  Zend_Uri  exists primarily to
      service other components such as  Zend_Http_Client  but is
      also useful as a standalone utility.
     
      URIs always begin with a scheme, followed by a colon. The construction
      of the many different schemes varies significantly.  The
       Zend_Uri  class provides a factory that returns a subclass of
      itself which specializes in each scheme.  The subclass
      will be named  Zend_Uri_&lt;scheme&gt; , where
       &lt;scheme&gt;  is the scheme lowercased with the first
      letter capitalized. An exception to this rule is HTTPS, which is also
      handled by  Zend_Uri_Http .
     Creating a New URI Zend_Uri  will build a new URI from scratch if only a scheme
      is passed to  Zend_Uri::factory() .
     Creating a New URI with  Zend_Uri::factory() &lt;?php
require_once &#39;Zend/Uri.php&#39;;

// To create a new URI from scratch, pass only the scheme.
$uri = Zend_Uri::factory(&#39;http&#39;);

// $uri instanceof Zend_Uri_Http
       
      To create a new URI from scratch, pass only the scheme to
       Zend_Uri::factory() At the time of writing,
      Zend_Uri only supports the HTTP and HTTPS schemes.  .
      If an unsupported scheme is passed, a  Zend_Uri_Exception 
      will be thrown.
     
      If the scheme or URI passed is supported,
       Zend_Uri::factory()  will return a subclass of itself that
      specializes in the scheme to be created.
     Manipulating an Existing URI 
      To manipulate an existing URI, pass the entire URI to
       Zend_Uri::factory() .
     Manipulating an Existing URI with  Zend_Uri::factory() &lt;?php
require_once &#39;Zend/Uri.php&#39;;

// To manipulate an existing URI, pass it in.
$uri = Zend_Uri::factory(&#39;http://www.zend.com&#39;);

// $uri instanceof Zend_Uri_Http
       
      The URI will be parsed and validated. If it is found to be invalid, a
       Zend_Uri_Exception  will be thrown immediately. Otherwise,
       Zend_Uri::factory()  will return a subclass of itself that
      specializes in the scheme to be manipulated.
     URI Validation 
      The  Zend_Uri::check()  function can be used if only
      validation of an existing URI is needed.
     URI Validation with  Zend_Uri::check() &lt;?php
require_once &#39;Zend/Uri.php&#39;;

// Validate whether a given URI is well formed
$valid = Zend_Uri::check(&#39;http://uri.in.question&#39;);

// $valid is TRUE for a valid URI, or FALSE otherwise.
       Zend_Uri::check()  returns a boolean,
      which is more convenient than using  Zend_Uri::factory() 
      and catching the exception.
     Common Instance Methods 
      Every instance of a  Zend_Uri  subclass (e.g.
       Zend_Uri_Http ) has several instance methods that are useful
      for working with any kind of URI.
     Getting the Scheme of the URI 
        The scheme of the URI is the part of the URI that precedes the colon.  For example,
        the scheme of  http://www.zend.com  is  http .
       Getting the Scheme from a  Zend_Uri_*  Object &lt;?php
require_once &#39;Zend/Uri.php&#39;;

$uri = Zend_Uri::factory(&#39;http://www.zend.com&#39;);

$scheme = $uri-&gt;getScheme();  // &quot;http&quot;
         
        The  getScheme()  instance method returns only the scheme part of
        the URI object.
       Getting the Entire URI Getting the Entire URI from a  Zend_Uri_*  Object &lt;?php
require_once &#39;Zend/Uri.php&#39;;

$uri = Zend_Uri::factory(&#39;http://www.zend.com&#39;);

echo $uri-&gt;getUri();  // &quot;http://www.zend.com&quot;
         
        The  getUri()  method returns the string representation
        of the entire URI.
       Validating the URI Zend_Uri::factory()  will always validate any URI passed
        to it and will not instantiate a new  Zend_Uri  subclass
        if the given URI is found to be invalid. However, after the
         Zend_Uri  subclass is instantiated for a new URI or a
        valid existing one, it is possible that the URI can then later become
        invalid after it is manipulated.
       Validating a  Zend_Uri_*  Object &lt;?php
require_once &#39;Zend/Uri.php&#39;;

$uri = Zend_Uri::factory(&#39;http://www.zend.com&#39;);

$isValid = $uri-&gt;valid();  // TRUE
         
        The  valid()  instance method provides a means to check that the
        URI object is still valid.
       EmailAddress Zend_Validate_EmailAddress  allows you to validate an email address. The validator first splits
        the email address on local-part @ hostname and attempts to match these against known specifications for email
        addresses and hostnames.
     Basic usage 
        A basic example of usage is below:

         &lt;?php
require_once &#39;Zend/Validate/EmailAddress.php&#39;;
$validator = new Zend_Validate_EmailAddress();
if ($validator-&gt;isValid($email)) {
    // email appears to be valid
} else {
    // email is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo &quot;$message\n&quot;;
    }
}
         

        This will match the email address  $email  and on failure populate
         $validator-&gt;getMessages()  with useful error messages.
     Complex local parts Zend_Validate_EmailAddress  will match any valid email address according to RFC2822. For example,
        valid emails include  bob@domain.com ,  bob+jones@domain.us ,
         &quot;bob@jones&quot;@domain.com  and  &quot;bob jones&quot;@domain.com 
     
        Some obsolete email formats will not currently validate (e.g. carriage returns or a
        &quot;\&quot; character in an email address).
     Validating different types of hostnames 
        The hostname part of an email address is validated against
         Zend_Validate_Hostname . By default
        only DNS hostnames of the form  domain.com  are accepted, though if you wish you
        can accept IP addresses and Local hostnames too.
     
        To do this you need to instantiate  Zend_Validate_EmailAddress  passing a parameter to indicate
        the type of hostnames you want to accept. More details are included in  Zend_Validate_Hostname ,
        though an example of how to accept both DNS and Local hostnames appears below:

         &lt;?php
require_once &#39;Zend/Validate/EmailAddress.php&#39;;
$validator = new Zend_Validate_EmailAddress(Zend_Validate_Hostname::ALLOW_DNS | Zend_Validate_Hostname::ALLOW_LOCAL);
if ($validator-&gt;isValid($email)) {
    // email appears to be valid
} else {
    // email is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo &quot;$message\n&quot;;
    }
}
         
     Checking if the hostname actually accepts email 
        Just because an email address is in the correct format, it doesn&#39;t necessarily mean that
        email address actually exists. To help solve this problem, you can use MX validation to
        check whether an MX (email) entry exists in the DNS record for the email&#39;s hostname.
        This tells you that the hostname accepts email, but doesn&#39;t tell you the exact email
        address itself is valid.
     
        MX checking is not enabled by default and at this time is only supported by UNIX platforms.
        To enable MX checking you can pass a second parameter to the  Zend_Validate_EmailAddress 
        constructor.

         &lt;?php
$validator = new Zend_Validate_EmailAddress(Zend_Validate_Hostname::ALLOW_DNS, true);
         

        Alternatively you can either pass  true  or  false  to
         $validator-&gt;setValidateMx()  to enable or disable MX validation.
     
        By enabling this setting network functions will be used to check for the presence of an
        MX record on the hostname of the email address you wish to validate. Please be aware
        this will likely slow your script down.
     Validating International Domains Names Zend_Validate_EmailAddress  will also match international characters that exist in some domains.
        This is known as International Domain Name (IDN) support. This is enabled by default, though
        you can disable this by changing the setting via the internal  Zend_Validate_Hostname  object
        that exists within  Zend_Validate_EmailAddress .

         &lt;?php
$validator-&gt;hostnameValidator-&gt;setValidateIdn(false);
         

        More information on the usage of  setValidateIdn()  appears in the
         Zend_Validate_Hostname  documentation.
     
        Please note IDNs are only validated if you allow DNS hostnames to be validated.
     Validating Top Level Domains 
        By default a hostname will be checked against a list of known TLDs. This is enabled by
        default, though you can disable this by changing the setting via the internal
         Zend_Validate_Hostname  object that exists within  Zend_Validate_EmailAddress .

         &lt;?php
$validator-&gt;hostnameValidator-&gt;setValidateTld(false);
         

        More information on the usage of  setValidateTld()  appears in the
         Zend_Validate_Hostname  documentation.
     
        Please note TLDs are only validated if you allow DNS hostnames to be validated.
     Hostname 
        Zend_Validate_Hostname allows you to validate a hostname against a set of known specifications.
        It is possible to check for three different types of hostnames: a DNS Hostname (i.e.
        domain.com), IP address (i.e. 1.2.3.4), and Local hostnames (i.e. localhost). By default only
        DNS hostnames are matched.
     Basic usage 
        A basic example of usage is below:

         &lt;?php
require_once &#39;Zend/Validate/Hostname.php&#39;;
$validator = new Zend_Validate_Hostname();
if ($validator-&gt;isValid($hostname)) {
    // hostname appears to be valid
} else {
    // hostname is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo &quot;$message\n&quot;;
    }
}
         

        This will match the hostname  $hostname  and on failure populate
         $validator-&gt;getMessages()  with useful error messages.

     Validating different types of hostnames 
        You may find you also want to match IP addresses, Local hostnames, or a combination of all
        allowed types. This can be done by passing a parameter to Zend_Validate_Hostname when you
        instantiate it. The paramter should be an integer which determines what types of hostnames
        are allowed. You are encouraged to use the Zend_Validate_Hostname constants to do this.
     
        The Zend_Validate_Hostname constants are:  ALLOW_DNS  to allow only DNS hostnames,
         ALLOW_IP  to allow IP addresses,  ALLOW_LOCAL  to allow local network
        names, and  ALLOW_ALL  to allow all three types. To just check for IP addresses
        you can use the example below:
         &lt;?php
require_once &#39;Zend/Validate/Hostname.php&#39;;
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_IP);
if ($validator-&gt;isValid($hostname)) {
    // hostname appears to be valid
} else {
    // hostname is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $message) {
        echo &quot;$message\n&quot;;
    }
}
         
     
        As well as using  ALLOW_ALL  to accept all hostnames types you can combine
        these types to allow for combinations. For example, to accept DNS and Local hostnames
        instantiate your Zend_Validate_Hostname object as so:
         &lt;?php
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS | Zend_Validate_Hostname::ALLOW_IP);
         

     Validating International Domains Names 
        Some Country Code Top Level Domains (ccTLDs), such as &#39;de&#39; (Germany), support international
        characters in domain names. These are known as International Domain Names (IDN). These domains
        can be matched by Zend_Validate_Hostname via extended characters that are used in the validation
        process.
     
        At present the list of supported ccTLDs include:
   
         at (Austria) ch (Switzerland) li (Liechtenstein) de (Germany) fi (Finland) hu (Hungary) no (Norway) se (Sweden) 
    
     
        To match an IDN domain it&#39;s as simple as just using the standard Hostname validator since IDN
        matching is enabled by default. If you wish to disable IDN validation this can be done by
        by either passing a parameter to the Zend_Validate_Hostname constructor or via the
         $validator-&gt;setValidateIdn()  method.
     
        You can disable IDN validation by passing a second parameter to the Zend_Validate_Hostname
        constructor in the following way.

         &lt;?php
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS, false);
         

        Alternatively you can either pass TRUE or FALSE to
         $validator-&gt;setValidateIdn()  to enable or disable IDN validation.

        If you are trying to match an IDN hostname which isn&#39;t currently supported it is likely
        it will fail validation if it has any international characters in it. Where a ccTLD file
        doesn&#39;t exist in Zend/Validate/Hostname specifying the additional characters a normal
        hostname validation is performed.
     
        Please note IDNs are only validated if you allow DNS hostnames to be validated.
     Validating Top Level Domains 
        By default a hostname will be checked against a list of known TLDs. If this functionality
        is not required it can be disabled in much the same way as disabling IDN support.
        You can disable TLD validation by passing a third parameter to the Zend_Validate_Hostname constructor.
        In the example below we are supporting IDN validation via the second parameter.

         &lt;?php
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS, true, false);
         

        Alternatively you can either pass TRUE or FALSE to
         $validator-&gt;setValidateTld()  to enable or disable TLD validation.
     
        Please note TLDs are only validated if you allow DNS hostnames to be validated.
     Standard Validation Classes 
        The Zend Framework comes with a standard set of validation classes, which are ready for you to use.
     Alnum 
            Returns  true  if and only if  $value  contains only alphabetic and digit characters.
            This validator includes an option to also consider white space characters as valid.
         Alpha 
            Returns  true  if and only if  $value  contains only alphabetic characters. This
            validator includes an option to also consider white space characters as valid.
         Barcode 
            This validator is instantiated with a barcode type against which you wish to validate a barcode value.
            It currently supports &quot; UPC-A &quot; (Universal Product Code) and &quot; EAN-13 &quot; (European
            Article Number) barcode types, and the  isValid()  method returns true if and only if the input
            successfully validates against the barcode validation algorithm. You should remove all characters other
            than the digits zero through nine (0-9) from the input value before passing it on to the validator.
         Between 
            Returns  true  if and only if  $value  is between the minimum and maximum boundary
            values. The comparison is inclusive by default ( $value  may equal a boundary value), though
            this may be overridden in order to do a strict comparison, where  $value  must be strictly
            greater than the minimum and strictly less than the maximum.
         Ccnum 
            Returns  true  if and only if  $value  follows the Luhn algorithm (mod-10 checksum)
            for credit card numbers.
         Date 
            Returns  true  if  $value  is a valid date of the format  YYYY-MM-DD .
            If the optional  locale  option is set then the date will be validated according to the
            set locale. And if the optional  format  option is set this format is used for the
            validation. For details about the optional parameters see
             Zend_Date::isDate() .
         Digits 
            Returns  true  if and only if  $value  only contains digit characters.
         Float 
            Returns  true  if and only if  $value  is a floating-point value.
         GreaterThan 
            Returns  true  if and only if  $value  is greater than the minimum boundary.
         Hex 
            Returns  true  if and only if  $value  contains only hexadecimal digit characters.
         InArray 
            Returns  true  if and only if a &quot;needle&quot;  $value  is contained in a &quot;haystack&quot;
            array. If the strict option is  true , then the type of  $value  is also checked.
         Int 
            Returns  true  if and only if  $value  is a valid integer.
         Ip 
            Returns  true  if and only if  $value  is a valid IP address.
         LessThan 
            Returns  true  if and only if  $value  is less than the maximum boundary.
         NotEmpty 
            Returns  true  if and only if  $value  is not an empty value.
         Regex 
            Returns  true  if and only if  $value  matches against a regular expression
            pattern.
         StringLength 
            Returns  true  if and only if the string length of  $value  is at least a minimum
            and no greater than a maximum (when the max option is not  null ). Since version 1.5.0, the
             setMin()  method throws an exception if the minimum length is set to a value greater than the
            set maximum length, and the  setMax()  method throws an exception if the maximum length is set
            to a value less than than the set minimum length. Since version 1.0.2, this class supports UTF-8 and other
            character encodings, based on the current value of
             iconv.internal_encoding .
         Validator Chains 
        Often multiple validations should be applied to some value in a particular order. The following code
        demonstrates a way to solve the example from the
         introduction , where a username must be between 6 and
        12 alphanumeric characters:

         &lt;?php
// Provides validator chaining capability
require_once &#39;Zend/Validate.php&#39;;

// Validators needed for the example
require_once &#39;Zend/Validate/StringLength.php&#39;;
require_once &#39;Zend/Validate/Alnum.php&#39;;

// Create a validator chain and add validators to it
$validatorChain = new Zend_Validate();
$validatorChain-&gt;addValidator(new Zend_Validate_StringLength(6, 12))
               -&gt;addValidator(new Zend_Validate_Alnum());

// Validate the username
if ($validatorChain-&gt;isValid($username)) {
    // username passed validation
} else {
    // username failed validation; print reasons
    foreach ($validatorChain-&gt;getMessages() as $message) {
        echo &quot;$message\n&quot;;
    }
}
         

        Validators are run in the order they were added to  Zend_Validate . In the above example,
        the username is first checked to ensure that its length is between 6 and 12 characters, and then it is
        checked to ensure that it contains only alphanumeric characters. The second validation, for
        alphanumeric characters, is performed regardless of whether the first validation, for length between 6
        and 12 characters, succeeds. This means that if both validations fail,  getMessages()  will
        return failure messages from both validators.
     
        In some cases it makes sense to have a validator break the chain if its validation process
        fails.  Zend_Validate  supports such use cases with the second parameter to the
         addValidator()  method. By setting  $breakChainOnFailure  to  true ,
        the added validator will break the chain execution upon failure, which avoids running any other
        validations that are determined to be unnecessary or inappropriate for the situation. If the above
        example were written as follows, then the alphanumeric validation would not occur if the string length
        validation fails:

         &lt;?php
$validatorChain-&gt;addValidator(new Zend_Validate_StringLength(6, 12), true)
        -&gt;addValidator(new Zend_Validate_Alnum());
         

     
        Any object that implements  Zend_Validate_Interface  may be used in a validator chain.
     Writing Validators 
        Zend_Validate supplies a set of commonly needed validators, but inevitably, developers will wish to
        write custom validators for their particular needs. The task of writing a custom validator is
        described in this section.
     Zend_Validate_Interface  defines three methods,  isValid() ,
         getMessages() , and  getErrors() , that may be implemented by user classes in order to
        create custom validation objects. An object that implements  Zend_Validate_Interface  interface
        may be added to a validator chain with  Zend_Validate::addValidator() . Such objects may also be
        used with  Zend_Filter_Input .
     
        As you may already have inferred from the above description of  Zend_Validate_Interface ,
        validation classes provided with Zend Framework return a boolean value for whether or not a value validates
        successfully. They also provide information about  why  a value failed
        validation. The availability of the reasons for validation failures may be valuable to an application for
        various purposes, such as providing statistics for usability analysis.
     
        Basic validation failure message functionality is implemented in  Zend_Validate_Abstract . To
        include this functionality when creating a validation class, simply extend
         Zend_Validate_Abstract . In the extending class you would implement the
         isValid()  method logic and define the message variables and message templates that correspond to
        the types of validation failures that can occur. If a value fails your validation tests, then
         isValid()  should return  false . If the value passes your validation tests, then
         isValid()  should return  true .
     
        In general, the  isValid()  method should not throw any exceptions, except where it is impossible
        to determine whether or not the input value is valid. A few examples of reasonable cases for throwing an
        exception might be if a file cannot be opened, an LDAP server could not be contacted, or a database
        connection is unavailable, where such a thing may be required for validation success or failure to be
        determined.
     Creating a Simple Validation Class 
            The following example demonstrates how a very simple custom validator might be written. In this case the
            validation rules are simply that the input value must be a floating point value.

             &lt;?php
require_once &#39;Zend/Validate/Abstract.php&#39;;

class MyValid_Float extends Zend_Validate_Abstract
{
    const FLOAT = &#39;float&#39;;

    protected $_messageTemplates = array(
        self::FLOAT =&gt; &quot;&#39;%value%&#39; is not a floating point value&quot;
    );

    public function isValid($value)
    {
        $this-&gt;_setValue($value);

        if (!is_float($value)) {
            $this-&gt;_error();
            return false;
        }

        return true;
    }
}
             

            The class defines a template for its single validation failure message, which includes the built-in magic
            parameter,  %value% . The call to  _setValue()  prepares the object to insert the
            tested value into the failure message automatically, should the value fail validation. The call to
             _error()  tracks a reason for validation failure. Since this class only defines one failure
            message, it is not necessary to provide  _error()  with the name of the failure message
            template.
         Writing a Validation Class having Dependent Conditions 
            The following example demonstrates a more complex set of validation rules, where it is required that the
            input value be numeric and within the range of minimum and maximum boundary values. An input value would
            fail validation for exactly one of the following reasons:

             The input value is not numeric. The input value is less than the minimum allowed value. The input value is more than the maximum allowed value. 
         
            These validation failure reasons are then translated to definitions in the class:

             &lt;?php
require_once &#39;Zend/Validate/Abstract.php&#39;;

class MyValid_NumericBetween extends Zend_Validate_Abstract
{
    const MSG_NUMERIC = &#39;msgNumeric&#39;;
    const MSG_MINIMUM = &#39;msgMinimum&#39;;
    const MSG_MAXIMUM = &#39;msgMaximum&#39;;

    public $minimum = 0;
    public $maximum = 100;

    protected $_messageVariables = array(
        &#39;min&#39; =&gt; &#39;minimum&#39;,
        &#39;max&#39; =&gt; &#39;maximum&#39;
    );

    protected $_messageTemplates = array(
        self::MSG_NUMERIC =&gt; &quot;&#39;%value%&#39; is not numeric&quot;,
        self::MSG_MINIMUM =&gt; &quot;&#39;%value%&#39; must be at least &#39;%min%&#39;&quot;,
        self::MSG_MAXIMUM =&gt; &quot;&#39;%value%&#39; must be no more than &#39;%max%&#39;&quot;
    );

    public function isValid($value)
    {
        $this-&gt;_setValue($value);

        if (!is_numeric($value)) {
            $this-&gt;_error(self::MSG_NUMERIC);
            return false;
        }

        if ($value &lt; $this-&gt;minimum) {
            $this-&gt;_error(self::MSG_MINIMUM);
            return false;
        }

        if ($value &gt; $this-&gt;maximum) {
            $this-&gt;_error(self::MSG_MAXIMUM);
            return false;
        }

        return true;
    }
}
             

            The public properties  $minimum  and  $maximum  have been established to provide
            the minimum and maximum boundaries, respectively, for a value to successfully validate. The class also
            defines two message variables that correspond to the public properties and allow  min  and
             max  to be used in message templates as magic parameters, just as with  value .
         
            Note that if any one of the validation checks in  isValid()  fails, an appropriate failure
            message is prepared, and the method immediately returns  false . These validation rules are
            therefore sequentially dependent. That is, if one test should fail, there is no need to test any
            subsequent validation rules. This need not be the case, however. The following example illustrates how to
            write a class having independent validation rules, where the validation object may return multiple
            reasons why a particular validation attempt failed.
         Validation with Independent Conditions, Multiple Reasons for Failure 
            Consider writing a validation class for password strength enforcement - when a user is required to choose
            a password that meets certain criteria for helping secure user accounts. Let us assume that the password
            security criteria enforce that the password:

             is at least 8 characters in length, contains at least one uppercase letter, contains at least one lowercase letter, and contains at least one digit character. 
         
            The following class implements these validation criteria:

             &lt;?php
require_once &#39;Zend/Validate/Abstract.php&#39;;

class MyValid_PasswordStrength extends Zend_Validate_Abstract
{
    const LENGTH = &#39;length&#39;;
    const UPPER  = &#39;upper&#39;;
    const LOWER  = &#39;lower&#39;;
    const DIGIT  = &#39;digit&#39;;

    protected $_messageTemplates = array(
        self::LENGTH =&gt; &quot;&#39;%value%&#39; must be at least 8 characters in length&quot;,
        self::UPPER  =&gt; &quot;&#39;%value%&#39; must contain at least one uppercase letter&quot;,
        self::LOWER  =&gt; &quot;&#39;%value%&#39; must contain at least one lowercase letter&quot;,
        self::DIGIT  =&gt; &quot;&#39;%value%&#39; must contain at least one digit character&quot;
    );

    public function isValid($value)
    {
        $this-&gt;_setValue($value);

        $isValid = true;

        if (strlen($value) &lt; 8) {
            $this-&gt;_error(self::LENGTH);
            $isValid = false;
        }

        if (!preg_match(&#39;/[A-Z]/&#39;, $value)) {
            $this-&gt;_error(self::UPPER);
            $isValid = false;
        }

        if (!preg_match(&#39;/[a-z]/&#39;, $value)) {
            $this-&gt;_error(self::LOWER);
            $isValid = false;
        }

        if (!preg_match(&#39;/\d/&#39;, $value)) {
            $this-&gt;_error(self::DIGIT);
            $isValid = false;
        }

        return $isValid;
    }
}
             

            Note that the four criteria tests in  isValid()  do not immediately return  false .
            This allows the validation class to provide  all  of the reasons that the
            input password failed to meet the validation requirements. If, for example, a user were to input the
            string &quot; #$% &quot; as a password,  isValid()  would cause all four validation failure
            messages to be returned by a subsequent call to  getMessages() .
         Introduction 
        The Zend_Validate component provides a set of commonly needed
        validators. It also provides a simple validator chaining mechanism by
        which multiple validators may be applied to a single datum in a
        user-defined order.
     What is a validator? 
            A validator examines its input with respect to some requirements
            and produces a boolean result - whether the input successfully
            validates against the requirements. If the input does not meet the
            requirements, a validator may additionally provide information
            about which requirement(s) the input does not meet.
         
            For example, a web application might require that a username be
            between six and twelve characters in length and may only contain
            alphanumeric characters. A validator can be used for ensuring that
            usernames meet these requirements. If a chosen username does not
            meet one or both of the requirements, it would be useful to know
            which of the requirements the username fails to meet.
         Basic usage of validators 
            Having defined validation in this way provides the foundation for
             Zend_Validate_Interface , which defines two methods,
             isValid()  and  getMessages() . The
             isValid()  method performs validation upon the provided
            value, returning  true  if and only if the value passes
            against the validation criteria.
         
            If  isValid()  returns  false , the
             getMessages()  returns an array of messages explaining
            the reason(s) for validation failure. The array keys are short
            strings that identify the reasons for validation failure, and the
            array values are the corresponding human-readable string messages.
            The keys and values are class-dependent; each validation class
            defines its own set of validation failure messages and the unique
            keys that identify them. Each class also has a  const 
            definition that matches each identifier for a validation failure
            cause.
         
                The  getMessages()  methods return validation
                failure information only for the most recent
                 isValid()  call.  Each call to
                 isValid()  clears any messages and errors caused by
                a previous  isValid()  call, because it&#39;s likely
                that each call to  isValid()  is made for a
                different input value.
             
            The following example illustrates validation of an e-mail address:

             &lt;?php
require_once &#39;Zend/Validate/EmailAddress.php&#39;;

$validator = new Zend_Validate_EmailAddress();

if ($validator-&gt;isValid($email)) {
    // email appears to be valid
} else {
    // email is invalid; print the reasons
    foreach ($validator-&gt;getMessages() as $messageId =&gt; $message) {
        echo &quot;Validation failure &#39;$messageId&#39;: $message\n&quot;;
    }
}
             

         Customizing messages 
            Validate classes provide a  setMessage()  method with
            which you can specify the format of a message returned by
             getMessages()  in case of validation failure.  The
            first argument of this method is a string containing the error
            message.  You can include tokens in this string which will be
            substituted with data relevant to the validator.  The token
             %value%  is supported by all validators; this is
            substituted with the value you passed to  isValid() .
            Other tokens may be supported on a case-by-case basis in each
            validation class.  For example,  %max%  is a token
            supported by  Zend_Validate_LessThan .
            The  getMessageVariables()  method returns an array
            of variable tokens supported by the validator.
         
            The second optional argument is a string that identifies the
            validation failure message template to be set, which is useful when
            a validation class defines more than one cause for failure. If you
            omit the second argument,  setMessage()  assumes the
            message you specify should be used for the first message template
            declared in the validation class. Many validation classes only have
            one error message template defined, so there is no need to specify
            which message template you are changing.
         &lt;?php
require_once &#39;Zend/Validate/StringLength.php&#39;;

$validator = new Zend_Validate_StringLength(8);

$validator-&gt;setMessage(
    &#39;The string \&#39;%value%\&#39; is too short; it must be at least %min% characters&#39;,
    Zend_Validate_StringLength::TOO_SHORT);

if (!$validator-&gt;isValid(&#39;word&#39;)) {
    $messages = $validator-&gt;getMessages();
    echo current($messages);

    // echoes &quot;The string &#39;word&#39; is too short; it must be at least 8 characters&quot;
}
             
            You can set multiple messages using the  setMessages() 
            method.  Its argument is an array containing key/message pairs.

             &lt;?php
require_once &#39;Zend/Validate/StringLength.php&#39;;

$validator = new Zend_Validate_StringLength(8, 12);

$validator-&gt;setMessages( array(
    Zend_Validate_StringLength::TOO_SHORT =&gt; &#39;The string \&#39;%value%\&#39; is too short&#39;,
    Zend_Validate_StringLength::TOO_LONG  =&gt; &#39;The string \&#39;%value%\&#39; is too long&#39;
));
             

         
            If your application requires even greater flexibility with which it
            reports validation failures, you can access properties by the same
            name as the message tokens supported by a given validation class.
            The  value  property is always available in a validator;
            it is the value you specified as the argument of
             isValid() .  Other properties may be supported on a
            case-by-case basis in each validation class.

             &lt;?php
require_once &#39;Zend/Validate/StringLength.php&#39;;

$validator = new Zend_Validate_StringLength(8, 12);

if (!validator-&gt;isValid(&#39;word&#39;)) {
    echo &#39;Word failed: &#39;
        . $validator-&gt;value
        . &#39;; its length is not between &#39;
        . $validator-&gt;min
        . &#39; and &#39;
        . $validator-&gt;max
        . &quot;\n&quot;;
}
             
         Using the static  is()  method 
            If it&#39;s inconvenient to load a given validation class and create an
            instance of the validator, you can use the static method
             Zend_Validate::is()  as an alternative invocation
            style.  The first argument of this method is a data input value,
            that you would pass to the  isValid()  method.  The
            second argument is a string, which corresponds to the basename of
            the validation class, relative to the  Zend_Validate 
            namespace.  The  is()  method automatically loads the
            class, creates an instance, and applies the  isValid() 
            method to the data input.

             &lt;?php
require_once &#39;Zend/Validate.php&#39;;

if (Zend_Validate::is($email, &#39;EmailAddress&#39;)) {
    // Yes, email appears to be valid
}
             

         
            You can also pass an array of constructor arguments, if they
            are needed for the validator.

             &lt;?php
require_once &#39;Zend/Validate.php&#39;;

if (Zend_Validate::is($value, &#39;Between&#39;, array(1, 12))) {
    // Yes, $value is between 1 and 12
}
             

         
            The  is()  method returns a boolean value, the same as
            the  isValid()  method.  When using the static
             is()  method, validation failure messages are not
            available.
         
            The static usage can be convenient for invoking a validator ad hoc,
            but if you have the need to run a validator for multiple inputs,
            it&#39;s more efficient to use the non-static usage, creating an
            instance of the validator object and calling its
             isValid()  method.
         
            Also, the  Zend_Filter_Input  class allows you to
            instantiate and run multiple filter and validator classes on demand
            to process sets of input data. See
             .
         Reading the Zend Framework Version 
        The class constant  Zend_Version::VERSION 
        contains a string that identifies the current version
        number of Zend Framework.  For example, &quot;0.9.0beta&quot;.
     
        The static method  Zend_Version::compareVersion($version) 
        is based on the PHP function
         version_compare() .
        The method returns -1 if the specified  $version 
        is older than the Zend Framework version, 0 if they are the same,
        and +1 if the specified  $version  is newer than the
        Zend Framework version.
     Example of compareVersion() method &lt;?php
// returns -1, 0 or 1
$cmp = Zend_Version::compareVersion(&#39;1.0.0&#39;);
         Zend_View_Abstract Zend_View_Abstract  is the base class on which
         Zend_View  is built;  Zend_View  itself simply
        extends it and declares a concrete implementation of the
         _run()  method (which is invoked by  render() ).
     
        Many developers find that they want to extend
         Zend_View_Abstract  to add custom functionality, and
        inevitably run into issues with its design, which includes a number of
        private members. This document aims to explain the decision behind the
        design.
     Zend_View  is something of an anti-templating engine in that
        it uses PHP natively for its templating. As a result, all of PHP is
        available, and view scripts inherit the scope of their calling object.
     
        It is this latter point that is salient to the design decisions.
        Internally,  Zend_View::_run()  does the following:
     &lt;?php
protected function _run()
{
    include func_get_arg(0);
}
?&gt; 
        As such, the view scripts have access to the current object
        ( $this ),  and any methods or members of that
            object . Since many operations depend on members with
        limited visibility, this poses a problem: the view scripts could
        potentially make calls to such methods or modify critical properties
        directly. Imagine a script overwriting  $_path  or
         $_file  inadvertently -- any further calls to
         render()  or view helpers would break!
     
        Fortunately, PHP 5 has an answer to this with its visibility
        declarations: private members are not accessible by objects extending a
        given class. This led to the current design: since
         Zend_View   extends 
         Zend_View_Abstract , view scripts are thus limited to only
        protected or public methods and members of
         Zend_View_Abstract  -- effectively limiting the actions it
        can perform, and allowing us to secure critical areas from abuse by view
        scripts.
     Controller Scripts 
        The controller is where you instantiate and configure Zend_View.
        You then assign variables to the view, and tell the view to
        render output using a particular script.
     Assigning Variables 
            Your controller script should assign necessary variables to the view
            before it hands over control to the view script.  Normally, you
            can do assignments one at a time by assigning to property names
            of the view instance:
         &lt;?php
$view = new Zend_View();
$view-&gt;a = &quot;Hay&quot;;
$view-&gt;b = &quot;Bee&quot;;
$view-&gt;c = &quot;Sea&quot;;
         
            However, this can be tedious when you have already collected the
            values to be assigned into an array or object.
         
            The assign() method lets you assign from an array or object &quot;in
            bulk.&quot;  The following examples have the same effect as the above
            one-by-one property assignments.
         &lt;?php
$view = new Zend_View();

// assign an array of key-value pairs, where the
// key is the variable name, and the value is
// the assigned value.
$array = array(
    &#39;a&#39; =&gt; &quot;Hay&quot;,
    &#39;b&#39; =&gt; &quot;Bee&quot;,
    &#39;c&#39; =&gt; &quot;Sea&quot;,
);
$view-&gt;assign($array);

// do the same with an object&#39;s public properties;
// note how we cast it to an array when assigning.
$obj = new StdClass;
$obj-&gt;a = &quot;Hay&quot;;
$obj-&gt;b = &quot;Bee&quot;;
$obj-&gt;c = &quot;Sea&quot;;
$view-&gt;assign((array) $obj);
         
            Alternatively, you can use the assign method to assign
            one-by-one by passing a string variable name, and then the
            variable value.
         &lt;?php
$view = new Zend_View();
$view-&gt;assign(&#39;a&#39;, &quot;Hay&quot;);
$view-&gt;assign(&#39;b&#39;, &quot;Bee&quot;);
$view-&gt;assign(&#39;c&#39;, &quot;Sea&quot;);
         Rendering a View Script 
            Once you have assigned all needed variables, the controller
            should tell Zend_View to render a particular view script.
            Do so by calling the render() method.  Note that the method will
            return the rendered view, not print it, so you need to print or
            echo it yourself at the appropriate time.
         &lt;?php
$view = new Zend_View();
$view-&gt;a = &quot;Hay&quot;;
$view-&gt;b = &quot;Bee&quot;;
$view-&gt;c = &quot;Sea&quot;;
echo $view-&gt;render(&#39;someView.php&#39;);
         View Script Paths 
            By default, Zend_View expects your view scripts to be relative to
            your calling script.  For example, if your controller script is at
            &quot;/path/to/app/controllers&quot; and it calls
            $view-&gt;render(&#39;someView.php&#39;), Zend_View will look for
            &quot;/path/to/app/controllers/someView.php&quot;.
         
            Obviously, your view scripts are probably located elsewhere.  To
            tell Zend_View where it should look for view scripts, use the
            setScriptPath() method.
         &lt;?php
$view = new Zend_View();
$view-&gt;setScriptPath(&#39;/path/to/app/views&#39;);
         
            Now when you call $view-&gt;render(&#39;someView.php&#39;), it will look
            for &quot;/path/to/app/views/someView.php&quot;.
         
            In fact, you can &quot;stack&quot; paths using the addScriptPath()
            method. As you add paths to the stack, Zend_View will look
            at the most-recently-added path for the requested view
            script.  This allows you override default views with custom
            views so that you may create custom &quot;themes&quot; or &quot;skins&quot; for
            some views, while leaving others alone.
         &lt;?php
$view = new Zend_View();
$view-&gt;addScriptPath(&#39;/path/to/app/views&#39;);
$view-&gt;addScriptPath(&#39;/path/to/custom/&#39;);

// now when you call $view-&gt;render(&#39;booklist.php&#39;), Zend_View will
// look first for &quot;/path/to/custom/booklist.php&quot;, then for
// &quot;/path/to/app/views/booklist.php&quot;, and finally in the current
// directory for &quot;booklist.php&quot;.
         Action View Helper 
        The  Action  view helper enables view scripts to dispatch a
        given controller action; the result of the response object following the
        dispatch is then returned. These can be used when a particular action
        could generate re-usable content or &quot;widget-ized&quot; content.
     
        Actions that result in a  _forward()  or redirect are
        considered invalid, and will return an empty string.
     
        The API for the  Action  view helper follows that of most MVC
        components that invoke controller actions:  action($action,
            $controller, $module = null, array $params = array()) .
         $action  and  $controller  are required; if no
        module is specified, the default module is assumed.
     Basic Usage of Action View Helper 
            As an example, you may have a  CommentController  with a
             listAction()  method you wish to invoke in order to pull
            a list of comments for the current request:
         
&lt;div id=&quot;sidebar right&quot;&gt; 
    &lt;div class=&quot;item&quot;&gt;
        &lt;?= $this-&gt;action(&#39;list&#39;, &#39;comment&#39;, null, array(&#39;count&#39; =&gt; 10)); ?&gt; 
    &lt;/div&gt;
&lt;/div&gt;
 Doctype Helper 
        Valid HTML and XHTML documents should include a  DOCTYPE 
        declaration. Besides being difficult to remember, these can also affect
        how certain elements in your document should be rendered (for instance,
        CDATA escaping in  &lt;script&gt;  and
         &lt;style&gt;  elements.
     
        The  Doctype  helper allows you to specify one of the
        following types:
     XHTML11 XHTML1_STRICT XHTML1_TRANSITIONAL XHTML1_FRAMESET XHTML_BASIC1 HTML4_STRICT HTML4_LOOSE HTML4_FRAMESET 
        You can also specify a custom doctype as long as it is well-formed.
     
        The  Doctype  helper is a concrete implementation of the 
         Placeholder
            helper .
     Doctype Helper Basic Usage 
            You may specify the doctype at any time. However, probably the
            simplest use case is to specify it and output it at the same time,
            at the top of your layout script:
         
&lt;?= $this-&gt;doctype(&#39;XHTML1_STRICT&#39;) ?&gt;
 
            From this point forward, any helpers that depend on the doctype for
            their output will be doctype aware -- and the doctype will be
            present in your document.
         Retrieving the Doctype 
            If you need to know the doctype later, you can do so by calling
             getDoctype()  on the object, which is returned by
            invoking the helper.
         &lt;?php
$doctype = $view-&gt;doctype()-&gt;getDoctype();
?&gt; 
            Typically, you&#39;ll simply want to know if the doctype is XHTML or
            not; for this, the  isXhtml()  method will suffice:
         &lt;?php
if ($view-&gt;doctype()-&gt;isXhtml()) {
    // do something differently
}
?&gt; HeadLink Helper 
        The HTML  &lt;link&gt;  element is increasingly used for
        linking a variety of resources for your site: stylesheets, feeds,
        favicons, trackbacks, and more. The  HeadTitle  helper
        provides a simple interface for creating and aggregating these elements
        for later retrieval and output in your layout script.
     
        The  HeadLink  helper has special methods for adding
        stylesheet links to its stack:
     appendStylesheet($href, $media,
                    $conditionalStylesheet) offsetSetStylesheet($index, $href, $media,
                    $conditionalStylesheet) prependStylesheet($href, $media,
                    $conditionalStylesheet) setStylesheet($href, $media,
                    $conditionalStylesheet) 
        The  $media  value defaults to &#39;screen&#39;, but may be any valid
        media value.  $conditionalStylesheet  is a boolean, and will
        be used at rendering time to determine if special comments should be
        included to prevent loading of the stylesheet on certain platforms.
     
        Additionally, the  HeadLink  helper has special methods for
        adding &#39;alternate&#39; links to its stack:
     appendAlternate($href, $type,
                    $title) offsetSetAlternate($index, $href, $type,
                    $title) prependAlternate($href, $type,
                    $title) setAlternate($href, $type,
                    $title) 
        The  headLink()  helper method allows specifying all
        attributes necessary for a  &lt;link&gt;  element, and allows
        you to also specify placement -- whether the new element replaces all
        others, prepends (top of stack), or appends (end of stack).
     
        The  HeadLink  helper is a concrete implementation of the 
         Placeholder
            helper .
     HeadLink Helper Basic Usage 
            You may specify a  headLink  at any time. Typically, you
            will specify global links in your layout script, and application
            specific links in your application view scripts. In your layout
            script, in the &lt;head&gt; section, you will then echo the helper
            to output it.
         
&lt;?php // setting links in a view script:
$this-&gt;headLink()-&gt;appendStylesheet(&#39;/styles/basic.css&#39;)
                 -&gt;headLink(array(&#39;rel&#39; =&gt; &#39;favicon&#39;, &#39;href&#39; =&gt; &#39;/img/favicon.ico&#39;), &#39;PREPEND&#39;)
                 -&gt;prependStylesheet(&#39;/styles/moz.css&#39;, &#39;screen&#39;, true);
?&gt;
&lt;?php // rendering the links: ?&gt;
&lt;?= $this-&gt;headLink() ?&gt;
 HeadMeta Helper 
        The HTML  &lt;meta&gt;  element is used to provide meta
        information about your HTML document -- typically keywords, document
        character set, caching pragmas, etc. Meta tags may be either of the
        &#39;http-equiv&#39; or &#39;name&#39; types, must contain a &#39;content&#39; attribute, and
        can also have either of the &#39;lang&#39; or &#39;scheme&#39; modifier attributes.
     
        The  HeadMeta  helper supports the following methods for
        setting and adding meta tags:
     appendName($keyValue, $content,
                    $conditionalName) offsetSetName($index, $keyValue, $content,
                    $conditionalName) prependName($keyValue, $content,
                    $conditionalName) setName($keyValue, $content,
                    $modifiers) appendHttpEquiv($keyValue, $content,
                    $conditionalHttpEquiv) offsetSetHttpEquiv($index, $keyValue, $content,
                    $conditionalHttpEquiv) prependHttpEquiv($keyValue, $content,
                    $conditionalHttpEquiv) setHttpEquiv($keyValue, $content,
                    $modifiers) 
        The  $keyValue  item is used to define a value for the &#39;name&#39;
        or &#39;http-equiv&#39; key;  $content  is the value for the
        &#39;content&#39; key, and  $modifiers  is an optional associative
        array that can contain keys for &#39;lang&#39; and/or &#39;scheme&#39;.
     
        You may also set meta tags using the  headMeta()  helper
        method, which has the following signature:  headMeta($content,
            $keyValue, $keyType = &#39;name&#39;, $modifiers = array(), $placement =
            &#39;APPEND&#39;) .  $keyValue  is the content for the key
        specified in  $keyType , which should be either &#39;name&#39; or
        &#39;http-equiv&#39;.  $placement  can be either &#39;SET&#39; (overwrites
        all previously stored values), &#39;APPEND&#39; (added to end of stack), or
        &#39;PREPEND&#39; (added to top of stack).
     HeadMeta  overrides each of  append() ,
         offsetSet() ,  prepend() , and  set() 
        to enforce usage of the special methods as listed above. Internally, it
        stores each item as a  stdClass  token, which it later
        serializes using the  itemToString()  method. This allows you
        to perform checks on the items in the stack, and optionally modify these
        items by simply modifying the object returned.
     
        The  HeadMeta  helper is a concrete implementation of the 
         Placeholder
            helper .
     HeadMeta Helper Basic Usage 
            You may specify a new meta tag at any time. Typically, you
            will specify client-side caching rules or SEO keywords.
         
            For instance, if you wish to specify SEO keywords, you&#39;d be creating
            a meta name tag with the name &#39;keywords&#39; and the content the
            keywords you wish to associate with your page:
         
&lt;?php // setting meta keywords
$this-&gt;headMeta()-&gt;appendName(&#39;keywords&#39;, &#39;framework php productivity&#39;);
?&gt;
 
            If you wishedto set some client-side caching rules, you&#39;d set
            http-equiv tags with the rules you wish to enforce:
         
&lt;?php // disabling client-side cache
$this-&gt;headMeta()-&gt;appendHttpEquiv(&#39;expires&#39;, &#39;Wed, 26 Feb 1997 08:21:57 GMT&#39;)
                 -&gt;appendHttpEquiv(&#39;pragma&#39;, &#39;no-cache&#39;)
                 -&gt;appendHttpEquiv(&#39;Cache-Control&#39;, &#39;no-cache&#39;);
?&gt;
 
            Another popular use for meta tags is setting the content type,
            character set, and language:
         
&lt;?php // setting content type and character set
$this-&gt;headMeta()-&gt;appendHttpEquiv(&#39;Content-Type&#39;, &#39;text/html; charset=UTF-8&#39;)
                 -&gt;appendHttpEquiv(&#39;Content-Language&#39;, &#39;en-US&#39;);
?&gt;
 
            As a final example, an easy way to display a transitional message
            before a redirect is using a &quot;meta refresh&quot;:
         
&lt;?php // setting a meta refresh for 3 seconds to a new url:
$this-&gt;headMeta()-&gt;appendHttpEquiv(&#39;Refresh&#39;, &#39;3;URL=http://www.some.org/some.html&#39;);
?&gt;
 
            When you&#39;re ready to place your meta tags in the layout, simply echo
            the helper:
         
&lt;?= $this-&gt;headMeta() ?&gt;
 HeadScript Helper 
        The HTML  &lt;script&gt;  element is used to either provide
        inline client-side scripting elements or link to a remote resource
        containing client-side scripting code. The  HeadScript 
        helper allows you to manage both.
     
        The  HeadScript  helper supports the following methods for
        setting and adding scripts:
     appendFile($src, $type = &#39;text/javascript&#39;,
                    $attrs = array()) offsetSetFile($index, $src, $type = &#39;text/javascript&#39;,
                    $attrs = array()) prependFile($src, $type = &#39;text/javascript&#39;,
                    $attrs = array()) setFile($src, $type = &#39;text/javascript&#39;,
                    $attrs = array()) appendScript($script, $type = &#39;text/javascript&#39;,
                    $attrs = array()) offsetSetScript($index, $script, $type = &#39;text/javascript&#39;,
                    $attrs = array()) prependScript($script, $type = &#39;text/javascript&#39;,
                    $attrs = array()) setScript($script, $type = &#39;text/javascript&#39;,
                    $attrs = array()) 
        In the case of the  *File()  methods,  $src  is
        the remote location of the script to load; this is usually in the form
        of a URL or a path. For the  *Script()  methods,
         $script  is the client-side scripting directives you wish to
        use in the element.
     HeadScript  also allows capturing scripts; this can be
        useful if you want to create the client-side script programmatically,
        and then place it elsewhere. The usage for this will be showed in an
        example below.
     
        Finally, you can also use the  headScript()  method to
        quickly add script elements; the signature for this is
         headScript($mode = &#39;FILE&#39;, $spec, $placement = &#39;APPEND&#39;) .
        The  $mode  is either &#39;FILE&#39; or &#39;SCRIPT&#39;, depending on if
        you&#39;re linking a script or defining one.  $spec  is either
        the script file to link or the script source itself.
         $placement  should be either &#39;APPEND&#39;, &#39;PREPEND&#39;, or &#39;SET&#39;.
     HeadScript  overrides each of  append() ,
         offsetSet() ,  prepend() , and  set() 
        to enforce usage of the special methods as listed above. Internally, it
        stores each item as a  stdClass  token, which it later
        serializes using the  itemToString()  method. This allows you
        to perform checks on the items in the stack, and optionally modify these
        items by simply modifying the object returned.
     
        The  HeadScript  helper is a concrete implementation of the 
         Placeholder
            helper .
     Use InlineScript for HTML Body Scripts HeadScript &#39;s sibling helper,  InlineScript , 
            should be used when you wish to include scripts inline in the HTML
             body . Placing scripts at the end of your document is a
            good practice for speeding up delivery of your page, particularly
            when using 3rd party analytics scripts.
         Arbitrary Attributes are Disabled by Default 
            By default,  HeadScript  only will render
             &lt;script&gt;  attributes that are blessed by the W3C.
            These include &#39;type&#39;, &#39;charset&#39;, &#39;defer&#39;, &#39;language&#39;, and &#39;src.&#39;
            However, some javascript frameworks, notably  Dojo , utilize custom
            attributes in order to modify behavior. To allow such attributes,
            you can enable them via the
             setAllowArbitraryAttributes()  method:
         &lt;?php
$this-&gt;headScript()-&gt;setAllowArbitraryAttributes(true);
?&gt; HeadScript Helper Basic Usage 
            You may specify a new script tag at any time. As noted above, these
            may be links to outside resource files or scripts theselves.
         
&lt;?php // adding scripts
$this-&gt;headScript()-&gt;appendFile(&#39;/js/prototype.js&#39;)
                   -&gt;appendScript($onloadScript);
?&gt;
 
            Order is often important with client-side scripting; you may need to
            ensure that libraries are loaded in a specific order due to
            dependencies each have; use the various append, prepend, and
            offsetSet directives to aid in this task:
         
&lt;?php // Putting scripts in order

// place at a particular offset to ensure loaded last
$this-&gt;headScript()-&gt;offsetSetScript(100, &#39;/js/myfuncs.js&#39;);

// use scriptaculous effects (append uses next index, 101)
$this-&gt;headScript()-&gt;appendScript(&#39;/js/scriptaculous.js&#39;);

// but always have base prototype script load first:
$this-&gt;headScript()-&gt;prependScript(&#39;/js/prototype.js&#39;);
?&gt;
 
            When you&#39;re finally ready to output all scripts in your layout
            script, simply echo the helper:
         
&lt;?= $this-&gt;headScript() ?&gt;
 Capturing Scripts Using the HeadScript Helper 
            Sometimes you need to generate client-side scripts programmatically.
            While you could use string concatenation, heredocs, and the like,
            often it&#39;s easier just to do so by creating the script and
            sprinkling in PHP tags.  HeadScript  lets you do just
            that, capturing it to the stack:
         
&lt;?php $this-&gt;headScript()-&gt;captureStart() ?&gt;
var action = &#39;&lt;?= $this-&gt;baseUrl ?&gt;&#39;;
$(&#39;foo_form&#39;).action = action;
&lt;?php $this-&gt;headScript()-&gt;captureEnd() ?&gt;
 
            The following assumptions are made:
         
                    The script will be appended to the stack. If you wish for it
                    to replace the stack or be added to the top, you will need
                    to pass &#39;SET&#39; or &#39;PREPEND&#39;, respectively, as the first
                    argument to  captureStart() .
             
                    The script MIME type is assumed to be &#39;text/javascript&#39;; if you
                    wish to specify a different type, you will need to pass it
                    as the second argument to  captureStart() .
             
                    If you wish to specify any additional attributes for the
                     &lt;script&gt;  tag, pass them in an array as
                    the third argument to  captureStart() .
             HeadStyle Helper 
        The HTML  &lt;style&gt;  element is used to include
        CSS stylesheets inline in the HTML  &lt;head&gt;  element. 
     Use HeadLink to link CSS files HeadLink 
            should be used to create  &lt;link&gt;  elements for
            including external stylesheets.  HeadScript  is used when
            you wish to define your stylesheets inline.
         
        The  HeadStyle  helper supports the following methods for
        setting and adding stylesheet declarations:
     appendStyle($content, $attributes =
                    array()) offsetSetStyle($index, $content, $attributes =
                    array()) prependStyle($content, $attributes =
                    array()) setStyle($content, $attributes =
                    array()) 
        In all cases,  $content  is the actual CSS declarations.
         $attributes  are any additional attributes you wish to provide to the
         style  tag: lang, title, media, or dir are all permissable.
     HeadStyle  also allows capturing style declarations; this
        can be useful if you want to create the declarations programmatically,
        and then place them elsewhere. The usage for this will be showed in an
        example below.
     
        Finally, you can also use the  headStyle()  method to
        quickly add declarations elements; the signature for this is
         headStyle($content$placement = &#39;APPEND&#39;, $attributes = array()) .
         $placement  should be either &#39;APPEND&#39;, &#39;PREPEND&#39;, or &#39;SET&#39;.
     HeadStyle  overrides each of  append() ,
         offsetSet() ,  prepend() , and  set() 
        to enforce usage of the special methods as listed above. Internally, it
        stores each item as a  stdClass  token, which it later
        serializes using the  itemToString()  method. This allows you
        to perform checks on the items in the stack, and optionally modify these
        items by simply modifying the object returned.
     
        The  HeadStyle  helper is a concrete implementation of the 
         Placeholder
            helper .
     HeadStyle Helper Basic Usage 
            You may specify a new style tag at any time:
         
&lt;?php // adding styles
$this-&gt;headStyle()-&gt;appendStyle($styles);
?&gt;
 
            Order is very important with CSS; you may need to ensure that
            declarations are loaded in a specific order due to the order of the
            cascade; use the various append, prepend, and offsetSet directives
            to aid in this task:
         
&lt;?php // Putting styles in order

// place at a particular offset:
$this-&gt;headStyle()-&gt;offsetSetStyle(100, $customStyles);

// place at end:
$this-&gt;headStyle()-&gt;appendStyle($finalStyles);

// place at beginning
$this-&gt;headStyle()-&gt;prependStyle($firstStyles);
?&gt;
 
            When you&#39;re finally ready to output all style declarations in your
            layout script, simply echo the helper:
         
&lt;?= $this-&gt;headStyle() ?&gt;
 Capturing Style Declarations Using the HeadStyle Helper 
            Sometimes you need to generate CSS style declarations
            programmatically.  While you could use string concatenation,
            heredocs, and the like, often it&#39;s easier just to do so by creating
            the styles and sprinkling in PHP tags.  HeadStyle  lets
            you do just that, capturing it to the stack:
         
&lt;?php $this-&gt;headStyle()-&gt;captureStart() ?&gt;
body {
    background-color: &lt;?= $this-&gt;bgColor ?&gt;;
}
&lt;?php $this-&gt;headStyle()-&gt;captureEnd() ?&gt;
 
            The following assumptions are made:
         
                    The style declarations will be appended to the stack. If you
                    wish for them to replace the stack or be added to the top,
                    you will need to pass &#39;SET&#39; or &#39;PREPEND&#39;, respectively, as
                    the first argument to  captureStart() .
             
                    If you wish to specify any additional attributes for the
                     &lt;style&gt;  tag, pass them in an array as
                    the second argument to  captureStart() .
             HeadTitle Helper 
        The HTML  &lt;title&gt;  element is used to provide a title
        for an HTML document. The  HeadTitle  helper allows you to
        programmatically create and store the title for later retrieval and
        output.
     
        The  HeadTitle  helper is a concrete implementation of the 
         Placeholder
            helper . It overrides the  toString()  method to
        enforce generating a  &lt;title&gt;  element, and adds a
         headTitle()  method for quick and easy setting and
        aggregation of title elements. The signature for that method is
         headTitle($title, $setType = &#39;APPEND&#39;) ; by default, the
        value is appended to the stack (aggregating title segments), but you may
        also specify either &#39;PREPEND&#39; (place at top of stack) or &#39;SET&#39;
        (overwrite stack).
     HeadTitle Helper Basic Usage 
            You may specify a title tag at any time. A typical usage would have
            you setting title segments for each level of depth in your
            application: site, controller, action, and potentially resource.
         &lt;?php 
// setting the controller and action name as title segments:
$request = Zend_Controller_Front::getInstance()-&gt;getRequest();
$this-&gt;headTitle($request-&gt;getActionName())
     -&gt;headTitle($request-&gt;getControllerName());

// setting the site in the title; possibly in the layout script:
$this-&gt;headTitle(&#39;Zend Framework&#39;);

// setting a separator string for segments:
$this-&gt;headTitle()-&gt;setSeparator(&#39; / &#39;);
?&gt;
 
            When you&#39;re finally ready to render the title in your layout
            script, simply echo the helper:
         
&lt;!-- renders &lt;action&gt; / &lt;controller&gt; / Zend Framework --&gt;
&lt;?= $this-&gt;headTitle() ?&gt;
 InlineScript Helper 
        The HTML  &lt;script&gt;  element is used to either provide
        inline client-side scripting elements or link to a remote resource
        containing client-side scripting code. The  InlineScript 
        helper allows you to manage both. It is derived from  HeadScript ,
        and any method of that helper is available; however, use the
         inlineScript()  method in place of
         headScript() .
     Use InlineScript for HTML Body Scripts InlineScript , should be used when you wish to include
            scripts inline in the HTML  body . Placing scripts at the
            end of your document is a good practice for speeding up delivery of
            your page, particularly when using 3rd party analytics scripts.
         
            Some JS libraries need to be included in the HTML  head ;
            use  HeadScript 
            for those scripts.
         JSON Helper 
        When creating views that return JSON, it&#39;s important to also set the
        appropriate response header. The JSON view helper does exactly that. In
        addition, by default, it disables layouts (if currently enabled), as
        layouts generally aren&#39;t used with JSON responses.
     
        The JSON helper sets the following header:
     
Content-Type: application/json
 
        Most AJAX libraries look for this header when parsing responses to
        determine how to handle the content.
     
        Usage of the JSON helper is very straightforward:
     &lt;?php
&lt;?= $this-&gt;json($this-&gt;data) ?&gt;
?&gt; Partial Helper 
        The  Partial  view helper is used to render a specified
        template within its own variable scope. The primary use is for reusable
        template fragments with which you do not need to worry about variable
        name clashes. Additionally, they allow you to specify partial view
        scripts from specific modules.
     
        A sibling to the  Partial , the  PartialLoop  view
        helper allows you to pass iterable data, and render a partial for each
        item.
     Basic Usage of Partials 
            Basic usage of partials is to render a template fragment in its own
            view scope. Consider the following partial script:
         
&lt;?php // partial.phtml ?&gt;
&lt;ul&gt;
    &lt;li&gt;From: &lt;?= $this-&gt;escape($this-&gt;from) &gt;?&lt;/li&gt;
    &lt;li&gt;Subject: &lt;?= $this-&gt;escape($this-&gt;subject) &gt;?&lt;/li&gt;
&lt;/ul&gt;
 
            You would then call it from your view script using the following:
         
&lt;?= $this-&gt;partial(&#39;partial.phtml&#39;, array(
    &#39;from&#39; =&gt; &#39;Team Framework&#39;, 
    &#39;subject&#39; =&gt; &#39;view partials&#39;)); ?&gt;
 
            Which would then render:
         
&lt;ul&gt;
    &lt;li&gt;From: Team Framework&lt;/li&gt;
    &lt;li&gt;Subject: view partials&lt;/li&gt;
&lt;/ul&gt;
 What is a model? 
                A model used with the  Partial  view helper can be
                one of the following:
             Array . If an array is passed, it
                        should be associative, as its key/value pairs are
                        assigned to the view with keys as view variables.
                 Object implementing toArray()
                            method . If an object is passed an has a
                         toArray()  method, the results of
                         toArray()  will be assigned to the view
                        object as view variables.
                 Standard object . Any other object
                        will assign the results of
                         object_get_vars()  (essentially all public
                        properties of the object) to the view object.
                 Using PartialLoop to Render Iterable Models 
            Typically, you&#39;ll want to use partials in a loop, to render the same
            content fragment many times; this way you can put large blocks of
            repeated content or complex display logic into a single location.
            However this has a performance impact, as the partial helper needs
            to be invoked once for each iteration.
         
            The  PartialLoop  view helper helps solve this issue. It
            allows you to pass an iterable item (array or object implementing
             Iterator ) as the model. It then iterates over this,
            passing, the items to the partial script as the model. Items in the
            iterator may be any model the  Partial  view helper
            allows.
         
            Let&#39;s assume the following partial view script:
         
&lt;? // partialLoop.phtml ?&gt;
    &lt;dt&gt;&lt;?= $this-&gt;key ?&gt;&lt;/dt&gt;
    &lt;dd&gt;&lt;?= $this-&gt;value ?&gt;&lt;/dd&gt;

 
            And the following &quot;model&quot;:
         &lt;?php
$model = array(
    array(&#39;key&#39; =&gt; &#39;Mammal&#39;, &#39;value&#39; =&gt; &#39;Camel&#39;),
    array(&#39;key&#39; =&gt; &#39;Bird&#39;, &#39;value&#39; =&gt; &#39;Penguin&#39;),
    array(&#39;key&#39; =&gt; &#39;Reptile&#39;, &#39;value&#39; =&gt; &#39;Asp&#39;),
    array(&#39;key&#39; =&gt; &#39;Fish&#39;, &#39;value&#39; =&gt; &#39;Flounder&#39;),
);
?&gt; 
            In your view script, you could then invoke the
             PartialLoop  helper:
         
&lt;dl&gt;
&lt;?= $this-&gt;partialLoop(&#39;partialLoop.phtml&#39;, $model) ?&gt;
&lt;/dl&gt;
 
&lt;dl&gt;&lt;/dl&gt;
    &lt;dt&gt;Mammal&lt;/dt&gt;
    &lt;dd&gt;Camel&lt;/dd&gt;

    &lt;dt&gt;Bird&lt;/dt&gt;
    &lt;dd&gt;Penguin&lt;/dd&gt;

    &lt;dt&gt;Reptile&lt;/dt&gt;
    &lt;dd&gt;Asp&lt;/dd&gt;

    &lt;dt&gt;Fish&lt;/dt&gt;
    &lt;dd&gt;Flounder&lt;/dd&gt;

&lt;/dl&gt;
 Rendering Partials in Other Modules 
            Sometime a partial will exist in a different module. If you know the
            name of the module, you can pass it as the second argument to either
             partial()  or  partialLoop() , moving the
             $model  argument to third position.
         
            For instance, if there&#39;s a pager partial you wish to use that&#39;s in
            the &#39;list&#39; module, you could grab it as follows:
         
&lt;?= $this-&gt;partial(&#39;pager.phtml&#39;, &#39;list&#39;, $pagerData) ?&gt;
 
            In this way, you can re-use partials created specifically for other
            modules. That said, it&#39;s likely a better practice to put re-usable
            partials in shared view script paths.
         Placeholder Helper 
        The  Placeholder  view helper is used to persist content
        between view scripts and view instances. It also offers some useful
        features such as aggregating content, capturing view script content
        for later use, and adding pre- and post-text to content (and custom
        separators for aggregated content).
     Basic Usage of Placeholders 
            Basic usage of placeholders is to persist view data. Each invocation
            of the  Placeholder  helper expects a placeholder name;
            the helper then returns a placeholder container object that you can
            either manipulate or simply echo out.
         
&lt;?php $this-&gt;placeholder(&#39;foo&#39;)-&gt;set(&quot;Some text for later&quot;) ?&gt;

&lt;?php 
    echo $this-&gt;placeholder(&#39;foo&#39;); 
    // outputs &quot;Some text for later&quot;
?&gt;
 Using Placeholders to Aggregate Content 
            Aggregating content via placeholders can be useful at times as well.
            For instance, your view script may have a variable array from which
            you wish to retrieve messages to display later; a later view script
            can then determine how those will be rendered.
         
            The  Placeholder  view helper uses containers that extend
             ArrayObject , providing a rich featureset for
            manipulating arrays. In addition, it offers a variety of methods for
            formatting the content stored in the container:
         setPrefix($prefix)  sets text with which to
                    prefix the content. Use  getPrefix()  at any time
                    to determine what the current setting is.
             setPostfix($prefix)  sets text with which to
                    append the content. Use  getPostfix()  at any time
                    to determine what the current setting is.
             setSeparator($prefix)  sets text with which to
                    separate aggregated content. Use  getSeparator() 
                    at any time to determine what the current setting is.
             setIndent($prefix)  can be used to set an
                    indentation value for content. If an integer is passed,
                    that number of spaces will be used; if a string is passed,
                    the string will be used.  Use  getIndent() 
                    at any time to determine what the current setting is.
             
&lt;!-- first view script --&gt;
&lt;?php $this-&gt;placeholder(&#39;foo&#39;)-&gt;exchangeArray($this-&gt;data) ?&gt;
 
&lt;!-- later view script --&gt;
&lt;?php 
$this-&gt;placeholder(&#39;foo&#39;)-&gt;setPrefix(&quot;&lt;ul&gt;\n    &lt;li&gt;&quot;)
                         -&gt;setSeparator(&quot;&lt;/li&gt;&lt;li&gt;\n&quot;) 
                         -&gt;setIndent(4)
                         -&gt;setPostfix(&quot;&lt;/li&gt;&lt;/ul&gt;\n&quot;);
?&gt;

&lt;?php 
    echo $this-&gt;placeholder(&#39;foo&#39;); 
    // outputs as unordered list with pretty indentation
?&gt;
 
            Because the  Placeholder  container objects extend
             ArrayObject , you can also assign content to a specific
            key in the container easily, instead of simply pushing it into the
            container. Keys may be accessed either as object properties or as
            array keys.
         
&lt;?php $this-&gt;placeholder(&#39;foo&#39;)-&gt;bar = $this-&gt;data ?&gt;
&lt;?php echo $this-&gt;placeholder(&#39;foo&#39;)-&gt;bar ?&gt;

&lt;?php
$foo = $this-&gt;placeholder(&#39;foo&#39;);
echo $foo[&#39;bar&#39;];
?&gt;
 Using Placeholders to Capture Content 
            Occasionally you may have content for a placeholder in a view script
            that is easiest to template; the  Placeholder  view
            helper allows you to capture arbitrary content for later rendering
            using the following API.
         captureStart($type, $key)  begins capturing
                    content. 
                 $type  should be one of the
                     Placeholder  constants  APPEND  or
                     SET . If  APPEND , captured content
                    is appended to the list of current content in the
                    placeholder; if  SET , captured content is used
                    as the sole value of the placeholder (potentially replacing
                    any previous content). By default,  $type  is
                     APPEND .
                 $key  can be used to specify a specific key in
                    the placeholder container to which you want content
                    captured.
                 captureStart()  locks capturing until
                     captureEnd()  is called; you cannot nest
                    capturing with the same placholder container. Doing so will
                    raise an exception.
                 captureEnd()  stops capturing content, and
                    places it in the container object according to how
                     captureStart()  was called.
             
&lt;!-- Default capture: append --&gt;
&lt;?php $this-&gt;placeholder(&#39;foo&#39;)-&gt;captureStart() 
foreach ($this-&gt;data as $datum): ?&gt;
&lt;div class=&quot;foo&quot;&gt;
    &lt;h2&gt;&lt;?= $datum-&gt;title ?&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;?= $datum-&gt;content ?&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;?php $this-&gt;placeholder(&#39;foo&#39;)-&gt;captureEnd() ?&gt;

&lt;?php echo $this-&gt;placeholder(&#39;foo&#39;) ?&gt;
 
&lt;!-- Capture to key --&gt;
&lt;?php $this-&gt;placeholder(&#39;foo&#39;)-&gt;captureStart(&#39;SET&#39;, &#39;data&#39;) 
foreach ($this-&gt;data as $datum): ?&gt;
&lt;div class=&quot;foo&quot;&gt;
    &lt;h2&gt;&lt;?= $datum-&gt;title ?&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;?= $datum-&gt;content ?&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;?php $this-&gt;placeholder(&#39;foo&#39;)-&gt;captureEnd() ?&gt;

&lt;?php echo $this-&gt;placeholder(&#39;foo&#39;)-&gt;data ?&gt;
 Concrete Placeholder Implementations 
            Zend Framework ships with a number of &quot;concrete&quot; placeholder
            implementations. These are for commonly used placeholders: doctype,
            page title, and various &lt;head&gt; elements. In all cases, calling
            the placeholder with no arguments returns the element itself. 
         
            Documentation for each element is covered separately, as linked
            below:
         Doctype HeadLink HeadMeta HeadScript HeadStyle HeadTitle InlineScript Translate Helper 
        Often web sites are available in several languages. To translate the
        content of a site you should simply use  Zend Translate  and to
        integrate  Zend Translate  within your view you should use
        the  Translate  View Helper.
     
        In all following examples we are using the simple Array Translation
        Adapter. Of course you can also use any instance of
         Zend_Translate  and also any subclasses of
         Zend_Translate_Adapter . There are several ways to initiate
        the  Translate  View Helper:
     
                Registered, through a previously registered instance in
                 Zend_Registry 
             
                Afterwards, through the fluent interface
             
                Directly, through initiating the class
             
        A registered instance of  Zend_Translate  is the preferred
        usage for this helper.  You can also select the locale to be used simply
        before you add the adapter to the registry.
     
            We are speaking of locales instead of languages because a language
            also may contain a region.  For example English is spoken in
            different dialects. There may be a translation for British and one
            for American English. Therefore, we say &quot;locale&quot; instead of
            &quot;language.&quot;
         Registered instance 
            To use a registered instance just create an instance of
             Zend_Translate  or  Zend_Translate_Adapter 
            and register it within  Zend_Registry  using
             Zend_Translate  as its key.
         &lt;?php
// our example adapter
$adapter = new Zend_Translate(&#39;array&#39;, array(&#39;simple&#39; =&gt; &#39;einfach&#39;), &#39;de&#39;);
Zend_Registry::set(&#39;Zend_Translate&#39;, $adapter);

// within your view
echo $this-&gt;translate(&#39;simple&#39;);
// this returns &#39;einfach&#39;
?&gt; 
        If you are more familiar with the fluent interface, then you can also
        create an instace within your view and initiate the helper afterwards.
     Within the view 
            To use the fluent interface, create an instance of
             Zend_Translate  or  Zend_Translate_Adapter ,
            call the helper without a parameter, and call the
             setTranslator()  method.
         &lt;?php
// within your view
$adapter = new Zend_Translate(&#39;array&#39;, array(&#39;simple&#39; =&gt; &#39;einfach&#39;), &#39;de&#39;);
$this-&gt;translate()-&gt;setTranslator($adapter)-&gt;translate(&#39;simple&#39;);
// this returns &#39;einfach&#39;
?&gt; 
        If you are using the helper without  Zend_View  then you can
        also use it directly.
     Direct usage &lt;?php
// our example adapter
$adapter = new Zend_Translate(&#39;array&#39;, array(&#39;simple&#39; =&gt; &#39;einfach&#39;), &#39;de&#39;);

// initiate the adapter
$translate = new Zend_View_Helper_Translate($adapter);
print $translate-&gt;translate(&#39;simple&#39;); // this returns &#39;einfach&#39;
?&gt; 
            You would use this way if you are not working with
             Zend_View  and need to create translated output.
         
        As already seen, the  translate()  method is used to return
        the translation. Just call it with the needed messageid of your
        translation adapter. But it can also replace parameters within the
        translation string. Therefore, it accepts variable parameters in two ways:
        either as a list of parameters, or as an array of parameters. As examples:
     Single parameter 
            To use a single parameter just add it to the method.
         &lt;?php
// within your view
$date = &quot;Monday&quot;;
$this-&gt;translate(&#39;Today is %1\$s&#39;, $date);
// could return &#39;Heute ist Monday&#39;
?&gt; 
            Keep in mind that if you are using parameters which are also text,
            you may also need to translate these parameters.
         List of parameters 
            Or use a list of parameters and add it to the method.
         &lt;?php
// within your view
$date = &quot;Monday&quot;;
$month = &quot;April&quot;;
$time = &quot;11:20:55&quot;;
$this-&gt;translate(&#39;Today is %1\$s in %2\$s. Actual time: %3\$s&#39;, $date, $month, $time);
// Could return &#39;Heute ist Monday in April. Aktuelle Zeit: 11:20:55&#39;
?&gt; Array of parameters 
            Or use an array of parameters and add it to the method.
         &lt;?php
// within your view
$date = array(&quot;Monday&quot;, &quot;April&quot;, &quot;11:20:55&quot;);
$this-&gt;translate(&#39;Today is %1\$s in %2\$s. Actual time: %3\$s&#39;, $date);
// Could return &#39;Heute ist Monday in April. Aktuelle Zeit: 11:20:55&#39;
?&gt; 
        Sometimes it is necessary to change the locale of the translation. This
        can be done either dynamically per translation or statically for all
        following translations. And you can use it with both a parameter list
        and an array of parameters. In both cases the locale must be given as
        the last single parameter.
     Change locale dynamically &lt;?php
// within your view
$date = array(&quot;Monday&quot;, &quot;April&quot;, &quot;11:20:55&quot;);
$this-&gt;translate(&#39;Today is %1\$s in %2\$s. Actual time: %3\$s&#39;, $date, &#39;it&#39;);
?&gt; 
        This example returns the Italian translation for the messageid. But it
        will only be used once. The next translation will use the locale from
        the adapter. Normally you will set the desired locale within the
        translation adapter before you add it to the registry. But you can also
        set the locale from within the helper:
     Change locale statically &lt;?php
// within your view
$date = array(&quot;Monday&quot;, &quot;April&quot;, &quot;11:20:55&quot;);
$this-&gt;setLocale(&#39;it&#39;)-&gt;translate(&#39;Today is %1\$s in %2\$s. Actual time: %3\$s&#39;, $date);
?&gt; 
        The above example sets  &#39;it&#39;  as the new default locale which
        will be used for all further translations.
     
        Of course there is also a  getLocale()  method to get the
        currently set locale. 
     Get the currently set locale &lt;?php
// within your view
$date = array(&quot;Monday&quot;, &quot;April&quot;, &quot;11:20:55&quot;);

// returns &#39;de&#39; as set default locale from our above examples
$this-&gt;getLocale();

$this-&gt;setLocale(&#39;it&#39;)-&gt;translate(&#39;Today is %1\$s in %2\$s. Actual time: %3\$s&#39;, $date);

// returns &#39;it&#39; as new set default locale
$this-&gt;getLocale();
?&gt; View Helpers 
        In your view scripts, often it is necessary to perform certain
        complex functions over and over: e.g., formatting a date,
        generating form elements, or displaying action links.  You can
        use helper classes to perform these behaviors for you.
     
        A helper is simply a class. Let&#39;s say we want a helper named &#39;fooBar&#39;.
        By default, the class is prefixed with  &#39;Zend_View_Helper_&#39; 
        (you can specify a custom prefix when setting a helper path), and the
        last segment of the class name is the helper name; this segment should
        be TitleCapped; the full class name is then:
         Zend_View_Helper_FooBar . This class should contain at the
        minimum a single method, named after the helper, and camelCased:
         fooBar() .
     Watch the Case 
            Helper names are always camelCased, i.e., they never begin with an
            uppercase character. The class name itself is MixedCased, but the
            method that is actually executed is camelCased.
         Default Helper Path 
            The default helper path always points to the Zend Framework view
            helpers, i.e., &#39;Zend/View/Helper/&#39;. Even if you call
             setHelperPath()  to overwrite the existing paths, this
            path will be set to ensure the default helpers work.
         
        To use a helper in your view script, call it using
         $this-&gt;helperName() . Behind the scenes,
         Zend_View  will load the
         Zend_View_Helper_HelperName  class, create an object
        instance of it, and call its  helperName()  method.  The
        object instance is persistent within the  Zend_View 
        instance, and is reused for all future calls to
         $this-&gt;helperName() .
     Initial Helpers Zend_View  comes with an initial set of helper classes,
            most of which relate to form element generation and perform
            the appropriate output escaping automatically. In addition, there
            are helpers for creating route-based URLs and HTML lists, as well as
            declaring variables. The currently shipped helpers include:
         declareVars():  Primarily for use when using
                 strictVars() , this helper can be used to declare
                template variables that may or may not already be set in the
                view object, as well as to set default values.  Arrays passed as
                arguments to the method will be used to set default values;
                otherwise, if the variable does not exist, it is set to an empty
                string.
             fieldset($name, $content, $attribs):  Creates an
                XHTML fieldset. If  $attribs  contains a &#39;legend&#39;
                key, that value will be used for the fieldset legend. The
                fieldset will surround the  $content  as provided to
                the helper.
             form($name, $attribs, $content):  Generates an XHTML
                form. All  $attribs  are escaped and rendered as
                XHTML attributes of the form tag. If  $content  is
                present and not a boolean false, then that content is rendered
                within the start and close form tags; if  $content 
                is a boolean false (the default), only the opening form tag is
                generated.
             formButton($name, $value, $attribs):  Creates an
                &lt;input type=&quot;button&quot; /&gt; element.
             formCheckbox($name, $value, $attribs,
                        $options):  Creates an &lt;input type=&quot;checkbox&quot;
                    /&gt; element.  
                 
                    By default, when no $value is provided and no $options are
                    present, &#39;0&#39; is assumed to be the unchecked value, and &#39;1&#39;
                    the checked value. If a $value is passed, but no $options
                    are present, the checked value is assumed to be the value
                    passed.
                 
                    $options should be an array. If the array is indexed, the
                    first value is the checked value, and the second the
                    unchecked value; all other values are ignored. You may also
                    pass an associative array with the keys &#39;checked&#39; and
                    &#39;unChecked&#39;.
                 
                    If $options has been passed, if $value matches the checked
                    value, then the element will be marked as checked. You may
                    also mark the element as checked or unchecked by passing a
                    boolean value for the attribute &#39;checked&#39;.
                 
                    The above is probably best summed up with some examples:
                 &lt;?php
// &#39;1&#39; and &#39;0&#39; as checked/unchecked options; not checked
echo $this-&gt;formCheckbox(&#39;foo&#39;);

// &#39;1&#39; and &#39;0&#39; as checked/unchecked options; checked
echo $this-&gt;formCheckbox(&#39;foo&#39;, null, array(&#39;checked&#39; =&gt; true));

// &#39;bar&#39; and &#39;0&#39; as checked/unchecked options; not checked 
echo $this-&gt;formCheckbox(&#39;foo&#39;, &#39;bar&#39;);

// &#39;bar&#39; and &#39;0&#39; as checked/unchecked options; checked 
echo $this-&gt;formCheckbox(&#39;foo&#39;, &#39;bar&#39;, array(&#39;checked&#39; =&gt; true));

// &#39;bar&#39; and &#39;baz&#39; as checked/unchecked options; unchecked 
echo $this-&gt;formCheckbox(&#39;foo&#39;, null, null, array(&#39;bar&#39;, &#39;baz&#39;);

// &#39;bar&#39; and &#39;baz&#39; as checked/unchecked options; unchecked 
echo $this-&gt;formCheckbox(&#39;foo&#39;, null, null, array(
    &#39;checked&#39; =&gt; &#39;bar&#39;, 
    &#39;unChecked&#39; =&gt; &#39;baz&#39;
));

// &#39;bar&#39; and &#39;baz&#39; as checked/unchecked options; checked 
echo $this-&gt;formCheckbox(&#39;foo&#39;, &#39;bar&#39;, null, array(&#39;bar&#39;, &#39;baz&#39;);
echo $this-&gt;formCheckbox(&#39;foo&#39;, null, array(&#39;checked&#39; =&gt; true), array(&#39;bar&#39;, &#39;baz&#39;);

// &#39;bar&#39; and &#39;baz&#39; as checked/unchecked options; unchecked 
echo $this-&gt;formCheckbox(&#39;foo&#39;, &#39;baz&#39;, null, array(&#39;bar&#39;, &#39;baz&#39;);
echo $this-&gt;formCheckbox(&#39;foo&#39;, null, array(&#39;checked&#39; =&gt; false), array(&#39;bar&#39;, &#39;baz&#39;);
 
                    In all cases, the markup prepends a hidden element with the
                    unchecked value; this way, if the value is unchecked, you
                    will still get a valid value returned to your form.
                 formErrors($errors, $options):  Generates an
                    XHTML unordered list to show errors.  $errors 
                    should be a string or an array of strings;
                     $options  should be any attributes you want
                    placed in the opening list tag.
                 
                    You can specify alternate opening, closing, and separator
                    content when rendering the errors by calling several methods
                    on the helper:
                 setElementStart($string) ; default is
                            &#39;&lt;ul class=&quot;errors&quot;%s&quot;&gt;&lt;li&gt;&#39;, where %s
                            is replaced with the attributes as specified in
                             $options .
                     setElementSeparator($string) ; default
                            is &#39;&lt;/li&gt;&lt;li&gt;&#39;.
                     setElementEnd($string) ; default is
                            &#39;&lt;/li&gt;&lt;/ul&gt;&#39;.
                     formFile($name, $value, $attribs):  Creates an
                &lt;input type=&quot;file&quot; /&gt; element.
             formHidden($name, $value, $attribs):  Creates an
                &lt;input type=&quot;hidden&quot; /&gt; element.
             formLabel($name, $value, $attribs):  Creates a
                &lt;label&gt; element, setting the  for  attribute to
                 $name , and the actual label text to
                 $value . If  disable  is passed in
                 attribs , nothing will be returned.
             formMultiCheckbox($name, $value, $attribs, $options,
                    $listsep):  Creates a list of checkboxes.
                 $options  should be an associative array, and may be
                arbitrarily deep.  $value  may be a single value or
                an array of selected values that match the keys in the
                 $options  array.  $listsep  is an HTML
                break (&quot;&lt;br /&gt;&quot;) by default. By default, this element is
                treated as an array; all checkboxes share the same name, and are
                submitted as an array.
             formPassword($name, $value, $attribs):  Creates an
                &lt;input type=&quot;password&quot; /&gt; element.
             formRadio($name, $value, $attribs, $options): 
                Creates a series of &lt;input type=&quot;radio&quot; /&gt; elements, one
                for each of the $options elements.  In the $options array, the
                element key is the radio value, and the element value is the
                radio label.  The $value radio will be preselected for you.
             formReset($name, $value, $attribs):  Creates an
                &lt;input type=&quot;reset&quot; /&gt; element.
             formSelect($name, $value, $attribs, $options): 
                Creates a &lt;select&gt;...&lt;/select&gt; block, with one
                &lt;option&gt;one for each of the $options elements.  In the
                $options array, the element key is the option value, and the
                element value is the option label.  The $value option(s) will be
                preselected for you.
             formSubmit($name, $value, $attribs):  Creates an
                &lt;input type=&quot;submit&quot; /&gt; element.
             formText($name, $value, $attribs):  Creates an
                &lt;input type=&quot;text&quot; /&gt; element.
             formTextarea($name, $value, $attribs):  Creates a
                &lt;textarea&gt;...&lt;/textarea&gt; block.
             url($urlOptions, $name, $reset):  Creates a URL
                string based on a named route.  $urlOptions  should
                be an associative array of key/value pairs used by the
                particular route.
             htmlList($items, $ordered, $attribs, $escape):  generates
                unordered and ordered lists based on the  $items 
                passed to it. If  $items  is a multidimensional
                array, a nested list will be built. If the  $escape 
                flag is true (default), individual items will be escaped using
                the view objects registered escaping mechanisms; pass a false
                value if you want to allow markup in your lists.
             
            Using these in your view scripts is very easy, here is an example.
            Note that you all you need to do is call them; they will load
            and instantiate themselves as they are needed.
         &lt;?php
// inside your view script, $this refers to the Zend_View instance.
//
// say that you have already assigned a series of select options under
// the name $countries as array(&#39;us&#39; =&gt; &#39;United States&#39;, &#39;il&#39; =&gt;
// &#39;Israel&#39;, &#39;de&#39; =&gt; &#39;Germany&#39;).
?&gt;
&lt;form action=&quot;action.php&quot; method=&quot;post&quot;&gt;
    &lt;p&gt;&lt;label&gt;Your Email:
        &lt;?php echo $this-&gt;formText(&#39;email&#39;, &#39;you@example.com&#39;, array(&#39;size&#39; =&gt; 32)) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Your Country:
        &lt;?php echo $this-&gt;formSelect(&#39;country&#39;, &#39;us&#39;, null, $this-&gt;countries) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Would you like to opt in?
        &lt;?php echo $this-&gt;formCheckbox(&#39;opt_in&#39;, &#39;yes&#39;, null, array(&#39;yes&#39;, &#39;no&#39;)) ?&gt;
    &lt;/label&gt;&lt;/p&gt;
&lt;/form&gt;
         
            The resulting output from the view script will look something like this:
         &lt;form action=&quot;action.php&quot; method=&quot;post&quot;&gt;
    &lt;p&gt;&lt;label&gt;Your Email:
        &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;you@example.com&quot; size=&quot;32&quot; /&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Your Country:
        &lt;select name=&quot;country&quot;&gt;
            &lt;option value=&quot;us&quot; selected=&quot;selected&quot;&gt;United States&lt;/option&gt;
            &lt;option value=&quot;il&quot;&gt;Israel&lt;/option&gt;
            &lt;option value=&quot;de&quot;&gt;Germany&lt;/option&gt;
        &lt;/select&gt;
    &lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;label&gt;Would you like to opt in?
        &lt;input type=&quot;hidden&quot; name=&quot;opt_in&quot; value=&quot;no&quot; /&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;opt_in&quot; value=&quot;yes&quot; checked=&quot;checked&quot; /&gt;
    &lt;/label&gt;&lt;/p&gt;
&lt;/form&gt;
         Helper Paths 
            As with view scripts, your controller can specify a stack of paths
            for  Zend_View  to search for helper classes. By default,
             Zend_View  looks in &quot;Zend/View/Helper/*&quot; for helper
            classes. You can tell  Zend_View  to look in other
            locations using the  setHelperPath()  and
             addHelperPath()  methods.  Additionally, you can
            indicate a class prefix to use for helpers in the path provided, to
            allow namespacing your helper classes. By default, if no class
            prefix is provided, &#39;Zend_View_Helper_&#39; is assumed.
         &lt;?php
$view = new Zend_View();

// Set path to /path/to/more/helpers, with prefix &#39;My_View_Helper&#39;
$view-&gt;setHelperPath(&#39;/path/to/more/helpers&#39;, &#39;My_View_Helper&#39;);
         
            In fact, you can &quot;stack&quot; paths using the
             addHelperPath()  method. As you add paths to the stack,
             Zend_View  will look at the most-recently-added path for
            the requested helper class.  This allows you to add to (or even
            override) the initial distribution of helpers with your own custom
            helpers.
         &lt;?php
$view = new Zend_View();
// Add /path/to/some/helpers with class prefix &#39;My_View_Helper&#39;
$view-&gt;addHelperPath(&#39;/path/to/some/helpers&#39;, &#39;My_View_Helper&#39;);
// Add /other/path/to/helpers with class prefix &#39;Your_View_Helper&#39;
$view-&gt;addHelperPath(&#39;/other/path/to/helpers&#39;, &#39;Your_View_Helper&#39;);

// now when you call $this-&gt;helperName(), Zend_View will look first for
// &quot;/other/path/to/helpers/HelperName.php&quot; using class name &quot;My_View_Helper_HelperName&quot;,
// then for &quot;/path/to/some/helpers/HelperName&quot; using class name &quot;Your_View_Helper_HelperName&quot;,
// and finally for &quot;Zend/View/Helper/HelperName.php&quot; using class name &quot;Zend_View_Helper_HelperName&quot;.
         Writing Custom Helpers 
            Writing custom helpers is easy; just follow these rules:
         
                The class name must, at the very minimum, end with the helper
                name itself, using MixedCaps.  E.g., if you were writing a
                helper called &quot;specialPurpose&quot;, the class name would minimally
                need to be &quot;SpecialPurpose&quot;. You may, and should, give the class
                name a prefix, and it is recommended that you use &#39;View_Helper&#39;
                as part of that prefix: &quot;My_View_Helper_SpecialPurpose&quot;. (You
                will need to pass in the prefix, with or without the trailing
                underscore, to  addHelperPath()  or
                 setHelperPath() ).
             
                The class must have a public method that matches the
                helper name; this is the method that will be called when
                your template calls &quot;$this-&gt;specialPurpose()&quot;.  In our
                &quot;specialPurpose&quot; helper example, the required method
                declaration would be &quot;public function specialPurpose()&quot;.
             
                In general, the class should not echo or print or otherwise
                generate output.  Instead, it should return values to be
                printed or echoed.  The returned values should be escaped
                appropriately.
             
                The class must be in a file named after the helper class.  Again
                using our &quot;specialPurpose&quot; helper example, the file has to be
                named &quot;SpecialPurpose.php&quot;.
             
            Place the helper class file somewhere in your helper path stack, and
             Zend_View  will automatically load, instantiate,
            persist, and execute it for you.
         
            Here is an example of our  SpecialPurpose  helper code:
         &lt;?php
class My_View_Helper_SpecialPurpose
{
    protected $_count = 0;
    public function specialPurpose()
    {
        $this-&gt;_count++;
        $output = &quot;I have seen &#39;The Jerk&#39; {$this-&gt;_count} time(s).&quot;;
        return htmlspecialchars($output);
    }
}
         
            Then in a view script, you can call the  SpecialPurpose 
            helper as many times as you like; it will be instantiated once, and
            then it persists for the life of that  Zend_View 
            instance.
         &lt;?php
// remember, in a view script, $this refers to the Zend_View instance.
echo $this-&gt;specialPurpose();
echo $this-&gt;specialPurpose();
echo $this-&gt;specialPurpose();
         
            The output would look something like this:
         I have seen &#39;The Jerk&#39; 1 time(s).
I have seen &#39;The Jerk&#39; 2 time(s).
I have seen &#39;The Jerk&#39; 3 time(s).
         
            Sometimes you will need access to the calling  Zend_View 
            object -- for instance, if you need to use the registered encoding,
            or want to render another view script as part of your helper. To get
            access to the view object, your helper class should have a
             setView($view)  method, like the following:
         &lt;?php
class My_View_Helper_ScriptPath
{
    public $view;

    public function setView(Zend_View_Interface $view)
    {
        $this-&gt;view = $view;
    }

    public function scriptPath($script)
    {
        return $this-&gt;view-&gt;getScriptPath($script);
    }
}
         
            If your helper class has a  setView()  method, it will be
            called when the helper class is first instantiated, and passed the
            current view object. It is up to you to persist the object in your
            class, as well as determine how it should be accessed.
         Introduction Zend_View  is a class for working with the &quot;view&quot; portion of
        the model-view-controller pattern.  That is, it exists to
        help keep the view script separate from the model and
        controller scripts.  It provides a system of helpers, output
        filters, and variable escaping.
     Zend_View  is template system agnostic; you may use PHP as
        your template language, or create instances of other
        template systems and manipulate them within your view
        script.
     
        Essentially, using  Zend_View  happens in two major steps:

        1.  Your controller script creates an instance of
        Zend_View and assigns variables to that instance.

        2. The controller tells the  Zend_View  to render a particular
        view, thereby handing control over the view script, which
        generates the view output.
     Controller Script 
            As a simple example, let us say your controller has a list
            of book data that it wants to have rendered by a view.  The
            controller script might look something like this:
         &lt;?php
// use a model to get the data for book authors and titles.
$data = array(
    array(
        &#39;author&#39; =&gt; &#39;Hernando de Soto&#39;,
        &#39;title&#39; =&gt; &#39;The Mystery of Capitalism&#39;
    ),
    array(
        &#39;author&#39; =&gt; &#39;Henry Hazlitt&#39;,
        &#39;title&#39; =&gt; &#39;Economics in One Lesson&#39;
    ),
    array(
        &#39;author&#39; =&gt; &#39;Milton Friedman&#39;,
        &#39;title&#39; =&gt; &#39;Free to Choose&#39;
    )
);

// now assign the book data to a Zend_View instance
Zend_Loader::loadClass(&#39;Zend_View&#39;);
$view = new Zend_View();
$view-&gt;books = $data;

// and render a view script called &quot;booklist.php&quot;
echo $view-&gt;render(&#39;booklist.php&#39;);
         View Script 
            Now we need the associated view script, &quot;booklist.php&quot;.
            This is a PHP script like any other, with one exception:  it
            executes inside the scope of the  Zend_View  instance, which
            means that references to $this point to the Zend_View
            instance properties and methods.  (Variables assigned to the
            instance by the controller are public properties of the
            Zend_View instance.)  Thus, a very basic view script could
            look like this:
         &lt;?php if ($this-&gt;books): ?&gt;

    &lt;!-- A table of some books. --&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;Author&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
        &lt;/tr&gt;

        &lt;?php foreach ($this-&gt;books as $key =&gt; $val): ?&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;?php echo $this-&gt;escape($val[&#39;author&#39;]) ?&gt;&lt;/td&gt;
            &lt;td&gt;&lt;?php echo $this-&gt;escape($val[&#39;title&#39;]) ?&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;?php endforeach; ?&gt;

    &lt;/table&gt;

&lt;?php else: ?&gt;

    &lt;p&gt;There are no books to display.&lt;/p&gt;

&lt;?php endif;
         
            Note how we use the &quot;escape()&quot; method to apply output
            escaping to variables.
         Options Zend_View  has several options that may be set to
            configure the behaviour of your view scripts.
         basePath : indicate a base path from which to set
                    the script, helper, and filter path. It assumes a directory
                    structure of:
                 
base/path/
    helpers/
    filters/
    scripts/
                 
                    This may be set via  setBasePath() ,
                     addBasePath() , or the  basePath 
                    option to the constructor.
                 encoding : indicate the character encoding to use
                with  htmlentities() ,
                 htmlspecialchars() , and other operations. Defaults
                to ISO-8859-1 (latin1). May be set via
                 setEncoding()  or the  encoding  option
                to the constructor.
             escape : indicate a callback to be used by
                 escape() . May be set via  setEscape() 
                or the  escape  option to the constructor.
             filter : indicate a filter to use after rendering
                a view script. May be set via  setFilter() ,
                 addFilter() , or the  filter  option to
                the constructor.
             strictVars:  force  Zend_View  to emit
                notices and warnings when uninitialized view variables are
                accessed. This may be set by calling
                 strictVars(true)  or passing the
                 strictVars  option to the constructor.
             Utility Accessors 
            Typically, you&#39;ll only ever need to call on  assign() ,
             render() , or one of the methods for setting/adding
            filter, helper, and script paths. However, if you wish to extend
             Zend_View  yourself, or need access to some of its
            internals, a number of accessors exist:
         getVars()  will return all assigned variables.
                 clearVars()  will clear all assigned variables;
                    useful when you wish to re-use a view object, but want to
                    control what variables are available.
                 getScriptPath($script)  will retrieve the
                    resolved path to a given view script.
                 getScriptPaths()  will retrieve all registered
                    script paths.
                 getHelperPath($helper)  will retrieve the
                    resolved path to the named helper class.
                 getHelperPaths()  will retrieve all registered
                    helper paths.
                 getFilterPath($filter)  will retrieve the
                    resolved path to the named filter class.
                 getFilterPaths()  will retrieve all registered
                    filter paths.
                 View Scripts 
        Once your controller has assigned variables and called render(),
        Zend_View then includes the requested view script and executes
        it &quot;inside&quot; the scope of the Zend_View instance.  Therefore,
        in your view scripts, references to $this actually point to the
        Zend_View instance itself.
     
        Variables assigned to the view from the controller are referred
        to as instance properties.  For example, if the controller were
        to assign a variable &#39;something&#39;, you would refer to it as
        $this-&gt;something in the view script.  (This allows you to keep
        track of which values were assigned to the script, and which are
        internal to the script itself.)
     
        By way of reminder, here is the example view script from the
        Zend_View introduction.
     &lt;?php if ($this-&gt;books): ?&gt;

    &lt;!-- A table of some books. --&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;th&gt;Author&lt;/th&gt;
            &lt;th&gt;Title&lt;/th&gt;
        &lt;/tr&gt;

        &lt;?php foreach ($this-&gt;books as $key =&gt; $val): ?&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;?php echo $this-&gt;escape($val[&#39;author&#39;]) ?&gt;&lt;/td&gt;
            &lt;td&gt;&lt;?php echo $this-&gt;escape($val[&#39;title&#39;]) ?&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;?php endforeach; ?&gt;

    &lt;/table&gt;

&lt;?php else: ?&gt;

    &lt;p&gt;There are no books to display.&lt;/p&gt;

&lt;?php endif;
     Escaping Output 
            One of the most important tasks to perform in a view script
            is to make sure that output is escaped properly; among other
            things, this helps to avoid cross-site scripting attacks.
            Unless you are using a function, method, or helper that does
            escaping on its own, you should always escape variables when
            you output them.
         
            Zend_View comes with a method called escape() that does such
            escaping for you.
         &lt;?php
// bad view-script practice:
echo $this-&gt;variable;

// good view-script practice:
echo $this-&gt;escape($this-&gt;variable);
         
            By default, the escape() method uses the PHP htmlspecialchars()
            function for escaping.  However, depending on your environment,
            you may wish for escaping to occur in a different way.  Use the
            setEscape() method at the controller level to tell Zend_View
            what escaping callback to use.
         &lt;?php
// create a Zend_View instance
$view = new Zend_View();

// tell it to use htmlentities as the escaping callback
$view-&gt;setEscape(&#39;htmlentities&#39;);

// or tell it to use a static class method as the callback
$view-&gt;setEscape(array(&#39;SomeClass&#39;, &#39;methodName&#39;));

// or even an instance method
$obj = new SomeClass();
$view-&gt;setEscape(array($obj, &#39;methodName&#39;));

// and then render your view
echo $view-&gt;render(...);
         
            The callback function or method should take the value to be
            escaped as its first parameter, and all other parameters should
            be optional.
         Using Alternate Template Systems 
            Although PHP is itself a powerful template system, many developers
            feel it is too powerful or complex for their template designers and
            will want to use an alternate template engine. Zend_View provides
            two mechanisms for doing so, the first through view scripts, the
            second by implementing Zend_View_Interface.
         Template Systems Using View Scripts 
                A view script may be used to instantiate and manipulate a
                separate template object, such as a PHPLIB-style template.  The
                view script for that kind of activity might look something like
                this:
             &lt;?php
include_once &#39;template.inc&#39;;
$tpl = new Template();

if ($this-&gt;books) {
    $tpl-&gt;setFile(array(
        &quot;booklist&quot; =&gt; &quot;booklist.tpl&quot;,
        &quot;eachbook&quot; =&gt; &quot;eachbook.tpl&quot;,
    ));

    foreach ($this-&gt;books as $key =&gt; $val) {
        $tpl-&gt;set_var(&#39;author&#39;, $this-&gt;escape($val[&#39;author&#39;]);
        $tpl-&gt;set_var(&#39;title&#39;, $this-&gt;escape($val[&#39;title&#39;]);
        $tpl-&gt;parse(&quot;books&quot;, &quot;eachbook&quot;, true);
    }

    $tpl-&gt;pparse(&quot;output&quot;, &quot;booklist&quot;);
} else {
    $tpl-&gt;setFile(&quot;nobooks&quot;, &quot;nobooks.tpl&quot;)
    $tpl-&gt;pparse(&quot;output&quot;, &quot;nobooks&quot;);
}Â´
             
                These would be the related template files:
             
&lt;!-- booklist.tpl --&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Author&lt;/th&gt;
        &lt;th&gt;Title&lt;/th&gt;
    &lt;/tr&gt;
    {books}
&lt;/table&gt;

&lt;!-- eachbook.tpl --&gt;
    &lt;tr&gt;
        &lt;td&gt;{author}&lt;/td&gt;
        &lt;td&gt;{title}&lt;/td&gt;
    &lt;/tr&gt;

&lt;!-- nobooks.tpl --&gt;
&lt;p&gt;There are no books to display.&lt;/p&gt;
             Template Systems Using Zend_View_Interface 
                Some may find it easier to simply provide a Zend_View-compatible
                template engine.  Zend_View_Interface  defines the
                minimum interface needed for compatability:
             
/**
 * Return the actual template engine object
 */
public function getEngine();

/**
 * Set the path to view scripts/templates
 */
public function setScriptPath($path);

/**
 * Set a base path to all view resources
 */
public function setBasePath($path, $prefix = &#39;Zend_View&#39;);

/**
 * Add an additional base path to view resources
 */
public function addBasePath($path, $prefix = &#39;Zend_View&#39;);

/**
 * Retrieve the current script paths
 */
public function getScriptPaths();

/**
 * Overloading methods for assigning template variables as object properties
 */
public function __set($key, $value);
public function __get($key);
public function __isset($key);
public function __unset($key);

/**
 * Manual assignment of template variables, or ability to assign multiple
 * variables en masse.
 */
public function assign($spec, $value = null);

/**
 * Unset all assigned template variables
 */
public function clearVars();

/**
 * Render the template named $name
 */
public function render($name);
             
                Using this interface, it becomes relatively easy to wrap a
                third-party template engine as a Zend_View-compatible class. As
                an example, the following is one potential wrapper for Smarty:
             
require_once &#39;Zend/View/Interface.php&#39;;
require_once &#39;Smarty.class.php&#39;;

class Zend_View_Smarty implements Zend_View_Interface
{
    /**
     * Smarty object
     * @var Smarty
     */
    protected $_smarty;

    /**
     * Constructor
     *
     * @param string $tmplPath
     * @param array $extraParams
     * @return void
     */
    public function __construct($tmplPath = null, $extraParams = array())
    {
        $this-&gt;_smarty = new Smarty;

        if (null !== $tmplPath) {
            $this-&gt;setScriptPath($tmplPath);
        }

        foreach ($extraParams as $key =&gt; $value) {
            $this-&gt;_smarty-&gt;$key = $value;
        }
    }

    /**
     * Return the template engine object
     *
     * @return Smarty
     */
    public function getEngine()
    {
        return $this-&gt;_smarty;
    }

    /**
     * Set the path to the templates
     *
     * @param string $path The directory to set as the path.
     * @return void
     */
    public function setScriptPath($path)
    {
        if (is_readable($path)) {
            $this-&gt;_smarty-&gt;template_dir = $path;
            return;
        }

        throw new Exception(&#39;Invalid path provided&#39;);
    }

    /**
     * Retrieve the current template directory
     *
     * @return string
     */
    public function getScriptPaths()
    {
        return array($this-&gt;_smarty-&gt;template_dir);
    }

    /**
     * Alias for setScriptPath
     *
     * @param string $path
     * @param string $prefix Unused
     * @return void
     */
    public function setBasePath($path, $prefix = &#39;Zend_View&#39;)
    {
        return $this-&gt;setScriptPath($path);
    }

    /**
     * Alias for setScriptPath
     *
     * @param string $path
     * @param string $prefix Unused
     * @return void
     */
    public function addBasePath($path, $prefix = &#39;Zend_View&#39;)
    {
        return $this-&gt;setScriptPath($path);
    }

    /**
     * Assign a variable to the template
     *
     * @param string $key The variable name.
     * @param mixed $val The variable value.
     * @return void
     */
    public function __set($key, $val)
    {
        $this-&gt;_smarty-&gt;assign($key, $val);
    }

    /**
     * Retrieve an assigned variable
     *
     * @param string $key The variable name.
     * @return mixed The variable value.
     */
    public function __get($key)
    {
        return $this-&gt;_smarty-&gt;get_template_vars($key);
    }

    /**
     * Allows testing with empty() and isset() to work
     *
     * @param string $key
     * @return boolean
     */
    public function __isset($key)
    {
        return (null !== $this-&gt;_smarty-&gt;get_template_vars($key));
    }

    /**
     * Allows unset() on object properties to work
     *
     * @param string $key
     * @return void
     */
    public function __unset($key)
    {
        $this-&gt;_smarty-&gt;clear_assign($key);
    }

    /**
     * Assign variables to the template
     *
     * Allows setting a specific key to the specified value, OR passing an array
     * of key =&gt; value pairs to set en masse.
     *
     * @see __set()
     * @param string|array $spec The assignment strategy to use (key or array of key
     * =&gt; value pairs)
     * @param mixed $value (Optional) If assigning a named variable, use this
     * as the value.
     * @return void
     */
    public function assign($spec, $value = null)
    {
        if (is_array($spec)) {
            $this-&gt;_smarty-&gt;assign($spec);
            return;
        }

        $this-&gt;_smarty-&gt;assign($spec, $value);
    }

    /**
     * Clear all assigned variables
     *
     * Clears all variables assigned to Zend_View either via {@link assign()} or
     * property overloading ({@link __get()}/{@link __set()}).
     *
     * @return void
     */
    public function clearVars()
    {
        $this-&gt;_smarty-&gt;clear_all_assign();
    }

    /**
     * Processes a template and returns the output.
     *
     * @param string $name The template to process.
     * @return string The output.
     */
    public function render($name)
    {
        return $this-&gt;_smarty-&gt;fetch($name);
    }
}
             
                In this example, you would instantiate the
                 Zend_View_Smarty  class instead of
                 Zend_View , and then use it in roughly the same
                fashion as  Zend_View :
             
$view = new Zend_View_Smarty();
$view-&gt;setScriptPath(&#39;/path/to/templates&#39;);
$view-&gt;book = &#39;Zend PHP 5 Certification Study Guide&#39;;
$view-&gt;author = &#39;Davey Shafik and Ben Ramsey&#39;
$rendered = $view-&gt;render(&#39;bookinfo.tpl&#39;);
             Introduction 
        From its  home page ,
        XML-RPC is described as a &quot;...remote procedure calling using HTTP as the
        transport and XML as the encoding. XML-RPC is designed to be as simple
        as possible, while allowing complex data structures to be transmitted,
        processed and returned.&quot;
     
        The Zend Framework provides support for both consuming remote XML-RPC
        services and building new XML-RPC servers.
     Zend_XmlRpc_Client Introduction 
            The Zend Framework provides support for consuming remote XML-RPC
            services as a client in the  Zend_XmlRpc_Client 
            package. Its major features include automatic type conversion
            between PHP and XML-RPC, a server proxy object, and access to
            server introspection capabilities.
         Method Calls 
            The constructor of  Zend_XmlRpc_Client  receives the
            URL of the remote XML-RPC server endpoint as its first parameter.
            The new instance returned may be used to call any number of
            remote methods at that endpoint.
         
            To call a remote method with the XML-RPC client, instantiate it
            and use the  call()  instance method. The code sample
            below uses a demonstration XML-RPC server on the Zend Framework
            website. You can use it for testing or exploring the
             Zend_XmlRpc  components.
         XML-RPC Method Call &lt;?php
require_once &#39;Zend/XmlRpc/Client.php&#39;;

$client = new Zend_XmlRpc_Client(&#39;http://framework.zend.com/xmlrpc&#39;);

echo $client-&gt;call(&#39;test.sayHello&#39;);

// hello
             
            The XML-RPC value returned from the remote method call will be
            automatically unmarshaled and cast to the equivalent PHP native
            type. In the example above, a PHP  string  is returned
            and is immediately ready to be used.
         
            The first parameter of the  call()  method receives the
            name of the remote method to call. If the remote method requires
            any parameters, these can be sent by supplying a second, optional
            parameter to  call()  with an  array  of
            values to pass to the remote method:
         XML-RPC Method Call with Parameters &lt;?php
require_once &#39;Zend/XmlRpc/Client.php&#39;;

$client = new Zend_XmlRpc_Client(&#39;http://framework.zend.com/xmlrpc&#39;);

$arg1 = 1.1;
$arg2 = &#39;foo&#39;;

$result = $client-&gt;call(&#39;test.sayHello&#39;, array($arg1, $arg2));

// $result is a native PHP type
             
            If the remote method doesn&#39;t require parameters, this optional
            parameter may either be left out or an empty  array() 
            passed to it. The array of parameters for the remote method can
            contain native PHP types,  Zend_XmlRpc_Value 
            objects, or a mix of each.
         
            The  call()  method will automatically convert the
            XML-RPC response and return its equivalent PHP native type. A
             Zend_XmlRpc_Response  object for the return value will
            also be available by calling the  getLastResponse() 
            method after the call.
         Types and Conversions 
            Some remote method calls require parameters.  These are given to
            the  call()  method of  Zend_XmlRpc_Client 
            as an array in the second parameter.  Each parameter may be
            given as either a native PHP type which will be automatically
            converted, or as an object representing a specific XML-RPC type
            (one of the  Zend_XmlRpc_Value  objects).
         PHP Native Types as Parameters 
                Parameters may be passed to  call()  as native PHP
                variables, meaning as a  string ,
                 integer ,  float ,
                 boolean ,  array , or an
                 object . In this case, each PHP native type will
                be auto-detected and converted into one of the XML-RPC types
                according to this table:
             PHP and XML-RPC Type Conversions PHP Native Type XML-RPC Type integer int double double boolean boolean string string array array associative array struct object array Zend_XmlRpc_Value  Objects as Parameters 
                Parameters may also be created as  Zend_XmlRpc_Value 
                instances to specify an exact XML-RPC type.  The primary reasons
                for doing this are:

                 
                            When you want to make sure the correct parameter
                            type is passed to the procedure (i.e. the
                            procedure requires an integer and you may get it
                            from a database as a string)
                         
                            When the procedure requires  base64  or
                             dateTime.iso8601  type (which doesn&#39;t exists as a
                            PHP native type)
                         
                            When auto-conversion may fail (i.e. you want to
                            pass an empty XML-RPC struct as a parameter. Empty
                            structs are represented as empty arrays in PHP
                            but, if you give an empty array as a parameter it
                            will be auto-converted to an XML-RPC array since
                            it&#39;s not an associative array)
                         
             
                There are two ways to create a  Zend_XmlRpc_Value 
                object: instantiate one of the  Zend_XmlRpc_Value 
                subclasses directly, or use the static factory method
                 Zend_XmlRpc_Value::getXmlRpcValue() .
             Zend_XmlRpc_Value  Objects for XML-RPC Types XML-RPC Type Zend_XmlRpc_Value  Constant Zend_XmlRpc_Value  Object int Zend_XmlRpc_Value::XMLRPC_TYPE_INTEGER Zend_XmlRpc_Value_Integer double Zend_XmlRpc_Value::XMLRPC_TYPE_DOUBLE Zend_XmlRpc_Value_Double boolean Zend_XmlRpc_Value::XMLRPC_TYPE_BOOLEAN Zend_XmlRpc_Value_Boolean string Zend_XmlRpc_Value::XMLRPC_TYPE_STRING Zend_XmlRpc_Value_String base64 Zend_XmlRpc_Value::XMLRPC_TYPE_BASE64 Zend_XmlRpc_Value_Base64 dateTime.iso8601 Zend_XmlRpc_Value::XMLRPC_TYPE_DATETIME Zend_XmlRpc_Value_DateTime array Zend_XmlRpc_Value::XMLRPC_TYPE_ARRAY Zend_XmlRpc_Value_Array struct Zend_XmlRpc_Value::XMLRPC_TYPE_STRUCT Zend_XmlRpc_Value_Struct Automatic Conversion 
                        When building a new  Zend_XmlRpc_Value 
                        object, its value is set by a PHP type. The PHP type
                        will be converted to the specified type using
                        PHP casting. For example, if a string is given as a
                        value to the  Zend_XmlRpc_Value_Integer 
                        object, it will be converted using
                         (int)$value .
                     Server Proxy Object 
            Another way to call remote methods with the XML-RPC client is to
            use the server proxy.  This is a PHP object that proxies a remote
            XML-RPC namespace, making it work as close to a native PHP object
            as possible.
         
            To instantiate a server proxy, call the  getProxy() 
            instance method of  Zend_XmlRpc_Client . This will
            return an instance of  Zend_XmlRpc_Client_ServerProxy .
            Any method call on the server proxy object will be forwarded to
            the remote, and parameters may be passed like any other PHP
            method.
         Proxy the Default Namespace &lt;?php
require_once &#39;Zend/XmlRpc/Client.php&#39;;

$client = new Zend_XmlRpc_Client(&#39;http://framework.zend.com/xmlrpc&#39;);

$server = $client-&gt;getProxy();           // Proxy the default namespace

$hello = $server-&gt;test-&gt;sayHello(1, 2);  // test.Hello(1, 2) returns &quot;hello&quot;
             
            The  getProxy()  method receives an optional argument
            specifying which namespace of the remote server to proxy. If it
            does not receive a namespace, the default namespace will be
            proxied.  In the next example, the  test  namespace
            will be proxied:
         Proxy Any Namespace &lt;?php
require_once &#39;Zend/XmlRpc/Client.php&#39;;

$client = new Zend_XmlRpc_Client(&#39;http://framework.zend.com/xmlrpc&#39;);

$test  = $client-&gt;getProxy(&#39;test&#39;);     // Proxy the &quot;test&quot; namespace

$hello = $test-&gt;sayHello(1, 2);         // test.Hello(1,2) returns &quot;hello&quot;
             
            If the remote server supports nested namespaces of any depth,
            these can also be used through the server proxy. For example, if
            the server in the example above had a method
             test.foo.bar() , it could be called as
             $test-&gt;foo-&gt;bar() .
         Error Handling 
            Two kinds of errors can occur during an XML-RPC method call: HTTP
            errors and XML-RPC faults. The  Zend_XmlRpc_Client 
            recognizes each and provides the ability to detect and trap them
            independently.
         HTTP Errors 
                If any HTTP error occurs, such as the remote HTTP server
                returns a  404 Not Found , a
                 Zend_XmlRpc_Client_HttpException  will be thrown.
             Handling HTTP Errors &lt;?php
require_once &#39;Zend/XmlRpc/Client.php&#39;;

$client = new Zend_XmlRpc_Client(&#39;http://foo/404&#39;);

try {

    $client-&gt;call(&#39;bar&#39;, array($arg1, $arg2));

} catch (Zend_XmlRpc_Client_HttpException $e) {

    // $e-&gt;getCode() returns 404
    // $e-&gt;getMessage() returns &quot;Not Found&quot;

}
                 
                Regardless of how the XML-RPC client is used, the
                 Zend_XmlRpc_Client_HttpException  will be thrown
                whenever an HTTP error occurs.
             XML-RPC Faults 
                An XML-RPC fault is analogous to a PHP exception. It is a
                special type returned from an XML-RPC method call that has
                both an error code and an error message. XML-RPC faults are
                handled differently depending on the context of how the
                 Zend_XmlRpc_Client  is used.
             
                When the  call()  method or the server
                proxy object is used, an XML-RPC fault will result in a
                 Zend_XmlRpc_Client_FaultException  being thrown.
                The code and message of the exception will map directly to
                their respective values in the original XML-RPC fault
                response.
             Handling XML-RPC Faults &lt;?php
require_once &#39;Zend/XmlRpc/Client.php&#39;;

$client = new Zend_XmlRpc_Client(&#39;http://framework.zend.com/xmlrpc&#39;);

try {

    $client-&gt;call(&#39;badMethod&#39;);

} catch (Zend_XmlRpc_Client_FaultException $e) {

    // $e-&gt;getCode() returns 1
    // $e-&gt;getMessage() returns &quot;Unknown method&quot;

}
                 
                When the  call()  method is used to make the
                request, the  Zend_XmlRpc_Client_FaultException  will be
                thrown on fault. A  Zend_XmlRpc_Response  object
                containing the fault will also be available by calling
                 getLastResponse() .
             
                When the  doRequest()  method is used to make the
                request, it will not throw the exception. Instead, it will
                return a  Zend_XmlRpc_Response  object returned
                will containing the fault. This can be checked with
                 isFault()  instance method of
                 Zend_XmlRpc_Response .
             Server Introspection 
            Some XML-RPC servers support the de facto introspection methods under the XML-RPC
             system.  namespace.   Zend_XmlRpc_Client  provides special
            support for servers with these capabilities.
         
            A  Zend_XmlRpc_Client_ServerIntrospection  instance may be retrieved by calling
            the  getIntrospector()  method of  Zend_XmlRpcClient .  It can
            then be used to perform introspection operations on the server.
         From Request to Response 
            Under the hood, the  call()  instance method of  Zend_XmlRpc_Client 
            builds a request object ( Zend_XmlRpc_Request ) and sends it to another method,
             doRequest() , that returns a response object ( Zend_XmlRpc_Response ).
         
            The  doRequest()  method is also available for use directly:
         Processing Request to Response &lt;?php
require_once &#39;Zend/XmlRpc/Client.php&#39;;

$client = new Zend_XmlRpc_Client(&#39;http://framework.zend.com/xmlrpc&#39;);

$request = new Zend_XmlRpc_Request();
$request-&gt;setMethod(&#39;test.sayHello&#39;);
$request-&gt;setParams(array(&#39;foo&#39;, &#39;bar&#39;));

$client-&gt;doRequest($request);

// $server-&gt;getLastRequest() returns instanceof Zend_XmlRpc_Request
// $server-&gt;getLastResponse() returns instanceof Zend_XmlRpc_Response
             
            Whenever an XML-RPC method call is made by the client through any
            means, either the  call()  method,
             doRequest()  method, or server proxy, the last request
            object and its resultant response object will always be available
            through the methods  getLastRequest()  and
             getLastResponse()  respectively.
         HTTP Client and Testing 
            In all of the prior examples, an HTTP client was never specified.
            When this is the case, a new instance of
             Zend_Http_Client  will be created with its default
            options and used by  Zend_XmlRpc_Client  automatically.
         
            The HTTP client can be retrieved at any time with the
             getHttpClient()  method. For most cases, the default
            HTTP client will be sufficient. However, the
             setHttpClient()  method allows for a different HTTP
            client instance to be injected.
         
            The  setHttpClient()  is particularly useful for unit testing.  When combined
            with the  Zend_Http_Client_Adapter_Test , remote services can be mocked
            out for testing.  See the unit tests for  Zend_XmlRpc_Client  for examples
            of how to do this.
         Zend_XmlRpc_Server Introduction Zend_XmlRpc_Server is intended as a fully-featured XML-RPC server,
            following  the specifications
            outlined at www.xmlrpc.com . Additionally, it implements the
            system.multicall() method, allowing boxcarring of requests.
         Basic Usage 
            An example of the most basic use case:
         &lt;?php
require_once &#39;Zend/XmlRpc/Server.php&#39;;
require_once &#39;My/Service/Class.php&#39;;

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass(&#39;My_Service_Class&#39;);
echo $server-&gt;handle();
         Server Structure 
            Zend_XmlRpc_Server is composed of a variety of components, ranging
            from the server itself to request, response, and fault objects.
         
            To bootstrap Zend_XmlRpc_Server, the developer must attach one or
            more classes or functions to the server, via the
             setClass()  and  addFunction()  methods.
         
            Once done, you may either pass a  Zend_XmlRpc_Request 
            object to  Zend_XmlRpc_Server::handle() , or it will
            instantiate a  Zend_XmlRpc_Request_Http  object if none
            is provided -- thus grabbing the request from
             php://input .
         Zend_XmlRpc_Server::handle()  then attempts to
            dispatch to the appropriate handler based on the method
            requested. It then returns either a
             Zend_XmlRpc_Response -based object or a
             Zend_XmlRpc_Server_Fault object. These objects both have
             __toString()  methods that create valid XML-RPC XML
            responses, allowing them to be directly echoed.
         Conventions 
            Zend_XmlRpc_Server allows the developer to attach functions and
            class method calls as dispatchable XML-RPC methods. Via
            Zend_Server_Reflection, it does introspection on all attached
            methods, using the function and method docblocks to determine the
            method help text and method signatures.
         
            XML-RPC types do not necessarily map one-to-one to PHP types.
            However, the code will do its best to guess the appropriate type
            based on the values listed in @param and @return lines. Some XML-RPC
            types have no immediate PHP equivalent, however, and should be
            hinted using the XML-RPC type in the phpdoc. These include:
         dateTime.iso8601, a string formatted as
                    YYYYMMDDTHH:mm:ss base64, base64 encoded data struct, any associative array 
            An example of how to hint follows:
         &lt;?php
/**
* This is a sample function
*
* @param base64 $val1 Base64-encoded data
* @param dateTime.iso8601 $val2 An ISO date
* @param struct $val3 An associative array
* @return struct
*/
function myFunc($val1, $val2, $val3)
{
}
         
            PhpDocumentor does no validation of the types specified for params
            or return values, so this will have no impact on your API
            documentation. Providing the hinting is necessary, however, when the
            server is validating the parameters provided to the method call.
         
            It is perfectly valid to specify multiple types for both params and
            return values; the XML-RPC specification even suggests that
            system.methodSignature should return an array of all possible method
            signatures (i.e., all possible combinations of param and return
            values). You may do so just as you normally would with
            PhpDocumentor, using the &#39;|&#39; operator:
         &lt;?php
/**
* This is a sample function
*
* @param string|base64 $val1 String or base64-encoded data
* @param string|dateTime.iso8601 $val2 String or an ISO date
* @param array|struct $val3 Normal indexed array or an associative array
* @return boolean|struct
*/
function myFunc($val1, $val2, $val3)
{
}
         
            One note, however: allowing multiple signatures can lead to
            confusion for developers using the services; generally speaking, an
            XML-RPC method should only have a single signature.
         Utilizing Namespaces 
            XML-RPC has a concept of namespacing; basically, it allows grouping
            XML-RPC methods by dot-delimited namespaces. This helps prevent
            naming collisions between methods served by different classes. As an
            example, the XML-RPC server is expected to server several methods in
            the &#39;system&#39; namespace:
         system.listMethods system.methodHelp system.methodSignature 
            Internally, these map to the methods of the same name in
            Zend_XmlRpc_Server.
         
            If you want to add namespaces to the methods you serve, simply
            provide a namespace to the appropriate method when attaching a
            function or class:
         &lt;?php
// All public methods in My_Service_Class will be accessible as
// myservice.METHODNAME
$server-&gt;setClass(&#39;My_Service_Class&#39;, &#39;myservice&#39;);

// Function &#39;somefunc&#39; will be accessible as funcs.somefunc
$server-&gt;addFunction(&#39;somefunc&#39;, &#39;funcs&#39;);
         Custom Request Objects 
            Most of the time, you&#39;ll simply use the default request type
            included with Zend_XmlRpc_Server, Zend_XmlRpc_Request_Http. However,
            there may be times when you need XML-RPC to be available via the CLI,
            a GUI, or other environment, or want to log incoming requests. To do
            so, you may create a custom request object that extends
            Zend_XmlRpc_Request. The most important thing to remember is to
            ensure that the getMethod() and getParams() methods are implemented
            so that the XML-RPC server can retrieve that information in order to
            dispatch the request.
         Custom Responses 
            Similar to request objects, Zend_XmlRpc_Server can return custom
            response objects; by default, a Zend_XmlRpc_Response_Http object is
            returned, which sends an appropriate Content-Type HTTP header for
            use with XML-RPC. Possible uses of a custom object would be to log
            responses, or to send responses back to STDOUT.
         
            To use a custom response class, use
            Zend_XmlRpc_Server::setResponseClass() prior to calling handle().
         Handling Exceptions via Faults 
            Zend_XmlRpc_Server catches Exceptions generated by a dispatched
            method, and generates an XML-RPC fault response when such an
            exception is caught. By default, however, the exception messages and
            codes are not used in a fault response. This is an intentional
            decision to protect your code; many exceptions expose more
            information about the code or environment than a developer would
            necessarily intend (a prime example includes database abstraction or
            access layer exceptions).
         
            Exception classes can be whitelisted to be used as fault responses,
            however. To do so, simply utilize
            Zend_XmlRpc_Server_Fault::attachFaultException() to pass an
            exception class to whitelist:
         &lt;?php
Zend_XmlRpc_Server_Fault::attachFaultException(&#39;My_Project_Exception&#39;);
         
            If you utilize an exception class that your other project exceptions
            inherit, you can then whitelist a whole family of exceptions at a
            time. Zend_XmlRpc_Server_Exceptions are always whitelisted, to
            allow reporting specific internal errors (undefined methods, etc.).
         
            Any exception not specifically whitelisted will generate a fault
            response with a code of &#39;404&#39; and a message of &#39;Unknown error&#39;.
         Caching Server Definitions Between Requests 
            Attaching many classes to an XML-RPC server instance can utilize a
            lot of resources; each class must introspect using the Reflection
            API (via Zend_Server_Reflection), which in turn generates a list of
            all possible method signatures to provide to the server class.
         
            To reduce this performance hit somewhat, Zend_XmlRpc_Server_Cache
            can be used to cache the server definition between requests. When
            combined with __autoload(), this can greatly increase performance.
         
            An sample usage follows:
         &lt;?php
require_once &#39;Zend/Loader.php&#39;;
require_once &#39;Zend/XmlRpc/Server.php&#39;;
require_once &#39;Zend/XmlRpc/Server/Cache.php&#39;;

function __autoload($class)
{
    Zend_Loader::loadClass($class);
}

$cacheFile = dirname(__FILE__) . &#39;/xmlrpc.cache&#39;;
$server = new Zend_XmlRpc_Server();

if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    require_once &#39;My/Services/Glue.php&#39;;
    require_once &#39;My/Services/Paste.php&#39;;
    require_once &#39;My/Services/Tape.php&#39;;

    $server-&gt;setClass(&#39;My_Services_Glue&#39;, &#39;glue&#39;);   // glue. namespace
    $server-&gt;setClass(&#39;My_Services_Paste&#39;, &#39;paste&#39;); // paste. namespace
    $server-&gt;setClass(&#39;My_Services_Tape&#39;, &#39;tape&#39;);   // tape. namespace

    Zend_XmlRpc_Server_Cache::save($cacheFile, $server);
}

echo $server-&gt;handle();
         
            The above example attempts to retrieve a server definition from
            xmlrpc.cache in the same directory as the script. If unsuccessful,
            it loads the service classes it needs, attaches them to the server
            instance, and then attempts to create a new cache file with the
            server definition.
         Usage Examples 
            Below are several usage examples, showing the full spectrum of
            options available to developers. Usage examples will each build
            on the previous example provided.
         Basic Usage 
                The example below attaches a function as a dispatchable XML-RPC
                method and handles incoming calls.
             &lt;?php
require_once &#39;Zend/XmlRpc/Server.php&#39;;

/**
 * Return the MD5 sum of a value
 *
 * @param string $value Value to md5sum
 * @return string MD5 sum of value
 */
function md5Value($value)
{
    return md5($value);
}

$server = new Zend_XmlRpc_Server();
$server-&gt;addFunction(&#39;md5Value&#39;);
echo $server-&gt;handle();
             Attaching a class 
                The example below illustrates attaching a class&#39; public methods
                as dispatchable XML-RPC methods.
             &lt;?php
require_once &#39;Zend/XmlRpc/Server.php&#39;;
require_once &#39;Services/Comb.php&#39;;

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass(&#39;Services_Comb&#39;);
echo $server-&gt;handle();
             Attaching several classes using namespaces 
                The example below illustrates attaching several classes, each
                with their own namespace.
             &lt;?php
require_once &#39;Zend/XmlRpc/Server.php&#39;;
require_once &#39;Services/Comb.php&#39;;
require_once &#39;Services/Brush.php&#39;;
require_once &#39;Services/Pick.php&#39;;

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass(&#39;Services_Comb&#39;, &#39;comb&#39;);   // methods called as comb.*
$server-&gt;setClass(&#39;Services_Brush&#39;, &#39;brush&#39;); // methods called as brush.*
$server-&gt;setClass(&#39;Services_Pick&#39;, &#39;pick&#39;);   // methods called as pick.*
echo $server-&gt;handle();
             Specifying exceptions to use as valid fault responses 
                The example below allows any Services_Exception-derived class to
                report its code and message in the fault response.
             &lt;?php
require_once &#39;Zend/XmlRpc/Server.php&#39;;
require_once &#39;Zend/XmlRpc/Server/Fault.php&#39;;
require_once &#39;Services/Exception.php&#39;;
require_once &#39;Services/Comb.php&#39;;
require_once &#39;Services/Brush.php&#39;;
require_once &#39;Services/Pick.php&#39;;

// Allow Services_Exceptions to report as fault responses
Zend_XmlRpc_Server_Fault::attachFaultException(&#39;Services_Exception&#39;);

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass(&#39;Services_Comb&#39;, &#39;comb&#39;);   // methods called as comb.*
$server-&gt;setClass(&#39;Services_Brush&#39;, &#39;brush&#39;); // methods called as brush.*
$server-&gt;setClass(&#39;Services_Pick&#39;, &#39;pick&#39;);   // methods called as pick.*
echo $server-&gt;handle();
             Utilizing a custom request object 
                The example below instantiates a custom request object and
                passes it to the server to handle.
             &lt;?php
require_once &#39;Zend/XmlRpc/Server.php&#39;;
require_once &#39;Zend/XmlRpc/Server/Fault.php&#39;;
require_once &#39;Services/Request.php&#39;;
require_once &#39;Services/Exception.php&#39;;
require_once &#39;Services/Comb.php&#39;;
require_once &#39;Services/Brush.php&#39;;
require_once &#39;Services/Pick.php&#39;;

// Allow Services_Exceptions to report as fault responses
Zend_XmlRpc_Server_Fault::attachFaultException(&#39;Services_Exception&#39;);

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass(&#39;Services_Comb&#39;, &#39;comb&#39;);   // methods called as comb.*
$server-&gt;setClass(&#39;Services_Brush&#39;, &#39;brush&#39;); // methods called as brush.*
$server-&gt;setClass(&#39;Services_Pick&#39;, &#39;pick&#39;);   // methods called as pick.*

// Create a request object
$request = new Services_Request();

echo $server-&gt;handle($request);
             Utilizing a custom response object 
                The example below illustrates specifying a custom response class
                for the returned response.
             &lt;?php
require_once &#39;Zend/XmlRpc/Server.php&#39;;
require_once &#39;Zend/XmlRpc/Server/Fault.php&#39;;
require_once &#39;Services/Request.php&#39;;
require_once &#39;Services/Response.php&#39;;
require_once &#39;Services/Exception.php&#39;;
require_once &#39;Services/Comb.php&#39;;
require_once &#39;Services/Brush.php&#39;;
require_once &#39;Services/Pick.php&#39;;

// Allow Services_Exceptions to report as fault responses
Zend_XmlRpc_Server_Fault::attachFaultException(&#39;Services_Exception&#39;);

$server = new Zend_XmlRpc_Server();
$server-&gt;setClass(&#39;Services_Comb&#39;, &#39;comb&#39;);   // methods called as comb.*
$server-&gt;setClass(&#39;Services_Brush&#39;, &#39;brush&#39;); // methods called as brush.*
$server-&gt;setClass(&#39;Services_Pick&#39;, &#39;pick&#39;);   // methods called as pick.*

// Create a request object
$request = new Services_Request();

// Utilize a custom response
$server-&gt;setResponseClass(&#39;Services_Response&#39;);

echo $server-&gt;handle($request);
             Cache server definitions between requests 
                The example below illustrates caching server definitions
                between requests.
             &lt;?php
require_once &#39;Zend/XmlRpc/Server.php&#39;;
require_once &#39;Zend/XmlRpc/Server/Fault.php&#39;;
require_once &#39;Zend/XmlRpc/Server/Cache.php&#39;;
require_once &#39;Services/Request.php&#39;;
require_once &#39;Services/Response.php&#39;;
require_once &#39;Services/Exception.php&#39;;
require_once &#39;Services/Comb.php&#39;;
require_once &#39;Services/Brush.php&#39;;
require_once &#39;Services/Pick.php&#39;;

// Specify a cache file
$cacheFile = dirname(__FILE__) . &#39;/xmlrpc.cache&#39;;

// Allow Services_Exceptions to report as fault responses
Zend_XmlRpc_Server_Fault::attachFaultException(&#39;Services_Exception&#39;);

$server = new Zend_XmlRpc_Server();

// Attempt to retrieve server definition from cache
if (!Zend_XmlRpc_Server_Cache::get($cacheFile, $server)) {
    $server-&gt;setClass(&#39;Services_Comb&#39;, &#39;comb&#39;);   // methods called as comb.*
    $server-&gt;setClass(&#39;Services_Brush&#39;, &#39;brush&#39;); // methods called as brush.*
    $server-&gt;setClass(&#39;Services_Pick&#39;, &#39;pick&#39;);   // methods called as pick.*

    // Save cache
    Zend_XmlRpc_Server_Cache::save($cacheFile, $server));
}

// Create a request object
$request = new Services_Request();

// Utilize a custom response
$server-&gt;setResponseClass(&#39;Services_Response&#39;);

echo $server-&gt;handle($request);
            

</plainxml>
